var cle=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var cht=cle((ea,ta)=>{function $j(n,e){for(var t=0;t<e.length;t++){const i=e[t];if(typeof i!="string"&&!Array.isArray(i)){for(const r in i)if(r!=="default"&&!(r in n)){const s=Object.getOwnPropertyDescriptor(i,r);s&&Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:()=>i[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}})();function Zy(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Wj={exports:{}},EA={},Hj={exports:{}},Sn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var T1=Symbol.for("react.element"),hle=Symbol.for("react.portal"),dle=Symbol.for("react.fragment"),ple=Symbol.for("react.strict_mode"),fle=Symbol.for("react.profiler"),mle=Symbol.for("react.provider"),gle=Symbol.for("react.context"),yle=Symbol.for("react.forward_ref"),ble=Symbol.for("react.suspense"),xle=Symbol.for("react.memo"),vle=Symbol.for("react.lazy"),hH=Symbol.iterator;function wle(n){return n===null||typeof n!="object"?null:(n=hH&&n[hH]||n["@@iterator"],typeof n=="function"?n:null)}var Xj={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Kj=Object.assign,Zj={};function jy(n,e,t){this.props=n,this.context=e,this.refs=Zj,this.updater=t||Xj}jy.prototype.isReactComponent={};jy.prototype.setState=function(n,e){if(typeof n!="object"&&typeof n!="function"&&n!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")};jy.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")};function jj(){}jj.prototype=jy.prototype;function KF(n,e,t){this.props=n,this.context=e,this.refs=Zj,this.updater=t||Xj}var ZF=KF.prototype=new jj;ZF.constructor=KF;Kj(ZF,jy.prototype);ZF.isPureReactComponent=!0;var dH=Array.isArray,Yj=Object.prototype.hasOwnProperty,jF={current:null},Jj={key:!0,ref:!0,__self:!0,__source:!0};function Qj(n,e,t){var i,r={},s=null,o=null;if(e!=null)for(i in e.ref!==void 0&&(o=e.ref),e.key!==void 0&&(s=""+e.key),e)Yj.call(e,i)&&!Jj.hasOwnProperty(i)&&(r[i]=e[i]);var a=arguments.length-2;if(a===1)r.children=t;else if(1<a){for(var l=Array(a),u=0;u<a;u++)l[u]=arguments[u+2];r.children=l}if(n&&n.defaultProps)for(i in a=n.defaultProps,a)r[i]===void 0&&(r[i]=a[i]);return{$$typeof:T1,type:n,key:s,ref:o,props:r,_owner:jF.current}}function Sle(n,e){return{$$typeof:T1,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}function YF(n){return typeof n=="object"&&n!==null&&n.$$typeof===T1}function Tle(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,function(t){return e[t]})}var pH=/\/+/g;function NR(n,e){return typeof n=="object"&&n!==null&&n.key!=null?Tle(""+n.key):e.toString(36)}function x_(n,e,t,i,r){var s=typeof n;(s==="undefined"||s==="boolean")&&(n=null);var o=!1;if(n===null)o=!0;else switch(s){case"string":case"number":o=!0;break;case"object":switch(n.$$typeof){case T1:case hle:o=!0}}if(o)return o=n,r=r(o),n=i===""?"."+NR(o,0):i,dH(r)?(t="",n!=null&&(t=n.replace(pH,"$&/")+"/"),x_(r,e,t,"",function(u){return u})):r!=null&&(YF(r)&&(r=Sle(r,t+(!r.key||o&&o.key===r.key?"":(""+r.key).replace(pH,"$&/")+"/")+n)),e.push(r)),1;if(o=0,i=i===""?".":i+":",dH(n))for(var a=0;a<n.length;a++){s=n[a];var l=i+NR(s,a);o+=x_(s,e,t,l,r)}else if(l=wle(n),typeof l=="function")for(n=l.call(n),a=0;!(s=n.next()).done;)s=s.value,l=i+NR(s,a++),o+=x_(s,e,t,l,r);else if(s==="object")throw e=String(n),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return o}function PT(n,e,t){if(n==null)return n;var i=[],r=0;return x_(n,i,"","",function(s){return e.call(t,s,r++)}),i}function Cle(n){if(n._status===-1){var e=n._result;e=e(),e.then(function(t){(n._status===0||n._status===-1)&&(n._status=1,n._result=t)},function(t){(n._status===0||n._status===-1)&&(n._status=2,n._result=t)}),n._status===-1&&(n._status=0,n._result=e)}if(n._status===1)return n._result.default;throw n._result}var io={current:null},v_={transition:null},_le={ReactCurrentDispatcher:io,ReactCurrentBatchConfig:v_,ReactCurrentOwner:jF};Sn.Children={map:PT,forEach:function(n,e,t){PT(n,function(){e.apply(this,arguments)},t)},count:function(n){var e=0;return PT(n,function(){e++}),e},toArray:function(n){return PT(n,function(e){return e})||[]},only:function(n){if(!YF(n))throw Error("React.Children.only expected to receive a single React element child.");return n}};Sn.Component=jy;Sn.Fragment=dle;Sn.Profiler=fle;Sn.PureComponent=KF;Sn.StrictMode=ple;Sn.Suspense=ble;Sn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=_le;Sn.cloneElement=function(n,e,t){if(n==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var i=Kj({},n.props),r=n.key,s=n.ref,o=n._owner;if(e!=null){if(e.ref!==void 0&&(s=e.ref,o=jF.current),e.key!==void 0&&(r=""+e.key),n.type&&n.type.defaultProps)var a=n.type.defaultProps;for(l in e)Yj.call(e,l)&&!Jj.hasOwnProperty(l)&&(i[l]=e[l]===void 0&&a!==void 0?a[l]:e[l])}var l=arguments.length-2;if(l===1)i.children=t;else if(1<l){a=Array(l);for(var u=0;u<l;u++)a[u]=arguments[u+2];i.children=a}return{$$typeof:T1,type:n.type,key:r,ref:s,props:i,_owner:o}};Sn.createContext=function(n){return n={$$typeof:gle,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},n.Provider={$$typeof:mle,_context:n},n.Consumer=n};Sn.createElement=Qj;Sn.createFactory=function(n){var e=Qj.bind(null,n);return e.type=n,e};Sn.createRef=function(){return{current:null}};Sn.forwardRef=function(n){return{$$typeof:yle,render:n}};Sn.isValidElement=YF;Sn.lazy=function(n){return{$$typeof:vle,_payload:{_status:-1,_result:n},_init:Cle}};Sn.memo=function(n,e){return{$$typeof:xle,type:n,compare:e===void 0?null:e}};Sn.startTransition=function(n){var e=v_.transition;v_.transition={};try{n()}finally{v_.transition=e}};Sn.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Sn.useCallback=function(n,e){return io.current.useCallback(n,e)};Sn.useContext=function(n){return io.current.useContext(n)};Sn.useDebugValue=function(){};Sn.useDeferredValue=function(n){return io.current.useDeferredValue(n)};Sn.useEffect=function(n,e){return io.current.useEffect(n,e)};Sn.useId=function(){return io.current.useId()};Sn.useImperativeHandle=function(n,e,t){return io.current.useImperativeHandle(n,e,t)};Sn.useInsertionEffect=function(n,e){return io.current.useInsertionEffect(n,e)};Sn.useLayoutEffect=function(n,e){return io.current.useLayoutEffect(n,e)};Sn.useMemo=function(n,e){return io.current.useMemo(n,e)};Sn.useReducer=function(n,e,t){return io.current.useReducer(n,e,t)};Sn.useRef=function(n){return io.current.useRef(n)};Sn.useState=function(n){return io.current.useState(n)};Sn.useSyncExternalStore=function(n,e,t){return io.current.useSyncExternalStore(n,e,t)};Sn.useTransition=function(){return io.current.useTransition()};Sn.version="18.2.0";Hj.exports=Sn;var K=Hj.exports;const Is=Zy(K),Mle=$j({__proto__:null,default:Is},[K]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ale=K,Ele=Symbol.for("react.element"),Ile=Symbol.for("react.fragment"),kle=Object.prototype.hasOwnProperty,Rle=Ale.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Nle={key:!0,ref:!0,__self:!0,__source:!0};function qj(n,e,t){var i,r={},s=null,o=null;t!==void 0&&(s=""+t),e.key!==void 0&&(s=""+e.key),e.ref!==void 0&&(o=e.ref);for(i in e)kle.call(e,i)&&!Nle.hasOwnProperty(i)&&(r[i]=e[i]);if(n&&n.defaultProps)for(i in e=n.defaultProps,e)r[i]===void 0&&(r[i]=e[i]);return{$$typeof:Ele,type:n,key:s,ref:o,props:r,_owner:Rle.current}}EA.Fragment=Ile;EA.jsx=qj;EA.jsxs=qj;Wj.exports=EA;var se=Wj.exports,_P={},e8={exports:{}},fa={},t8={exports:{}},n8={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(n){function e(O,X){var j=O.length;O.push(X);e:for(;0<j;){var z=j-1>>>1,Z=O[z];if(0<r(Z,X))O[z]=X,O[j]=Z,j=z;else break e}}function t(O){return O.length===0?null:O[0]}function i(O){if(O.length===0)return null;var X=O[0],j=O.pop();if(j!==X){O[0]=j;e:for(var z=0,Z=O.length,ce=Z>>>1;z<ce;){var fe=2*(z+1)-1,ge=O[fe],Ne=fe+1,Fe=O[Ne];if(0>r(ge,j))Ne<Z&&0>r(Fe,ge)?(O[z]=Fe,O[Ne]=j,z=Ne):(O[z]=ge,O[fe]=j,z=fe);else if(Ne<Z&&0>r(Fe,j))O[z]=Fe,O[Ne]=j,z=Ne;else break e}}return X}function r(O,X){var j=O.sortIndex-X.sortIndex;return j!==0?j:O.id-X.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;n.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,d=3,p=!1,f=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,m=typeof clearTimeout=="function"?clearTimeout:null,v=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(O){for(var X=t(u);X!==null;){if(X.callback===null)i(u);else if(X.startTime<=O)i(u),X.sortIndex=X.expirationTime,e(l,X);else break;X=t(u)}}function S(O){if(g=!1,w(O),!f)if(t(l)!==null)f=!0,J(C);else{var X=t(u);X!==null&&q(S,X.startTime-O)}}function C(O,X){f=!1,g&&(g=!1,m(I),I=-1),p=!0;var j=d;try{for(w(X),h=t(l);h!==null&&(!(h.expirationTime>X)||O&&!P());){var z=h.callback;if(typeof z=="function"){h.callback=null,d=h.priorityLevel;var Z=z(h.expirationTime<=X);X=n.unstable_now(),typeof Z=="function"?h.callback=Z:h===t(l)&&i(l),w(X)}else i(l);h=t(l)}if(h!==null)var ce=!0;else{var fe=t(u);fe!==null&&q(S,fe.startTime-X),ce=!1}return ce}finally{h=null,d=j,p=!1}}var _=!1,A=null,I=-1,E=5,k=-1;function P(){return!(n.unstable_now()-k<E)}function V(){if(A!==null){var O=n.unstable_now();k=O;var X=!0;try{X=A(!0,O)}finally{X?U():(_=!1,A=null)}}else _=!1}var U;if(typeof v=="function")U=function(){v(V)};else if(typeof MessageChannel<"u"){var F=new MessageChannel,$=F.port2;F.port1.onmessage=V,U=function(){$.postMessage(null)}}else U=function(){y(V,0)};function J(O){A=O,_||(_=!0,U())}function q(O,X){I=y(function(){O(n.unstable_now())},X)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(O){O.callback=null},n.unstable_continueExecution=function(){f||p||(f=!0,J(C))},n.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<O?Math.floor(1e3/O):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(O){switch(d){case 1:case 2:case 3:var X=3;break;default:X=d}var j=d;d=X;try{return O()}finally{d=j}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(O,X){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var j=d;d=O;try{return X()}finally{d=j}},n.unstable_scheduleCallback=function(O,X,j){var z=n.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?z+j:z):j=z,O){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=j+Z,O={id:c++,callback:X,priorityLevel:O,startTime:j,expirationTime:Z,sortIndex:-1},j>z?(O.sortIndex=j,e(u,O),t(l)===null&&O===t(u)&&(g?(m(I),I=-1):g=!0,q(S,j-z))):(O.sortIndex=Z,e(l,O),f||p||(f=!0,J(C))),O},n.unstable_shouldYield=P,n.unstable_wrapCallback=function(O){var X=d;return function(){var j=d;d=X;try{return O.apply(this,arguments)}finally{d=j}}}})(n8);t8.exports=n8;var Lle=t8.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var i8=K,ua=Lle;function et(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r8=new Set,mv={};function Zf(n,e){dy(n,e),dy(n+"Capture",e)}function dy(n,e){for(mv[n]=e,n=0;n<e.length;n++)r8.add(e[n])}var kc=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),MP=Object.prototype.hasOwnProperty,Ple=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,fH={},mH={};function Dle(n){return MP.call(mH,n)?!0:MP.call(fH,n)?!1:Ple.test(n)?mH[n]=!0:(fH[n]=!0,!1)}function Fle(n,e,t,i){if(t!==null&&t.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return i?!1:t!==null?!t.acceptsBooleans:(n=n.toLowerCase().slice(0,5),n!=="data-"&&n!=="aria-");default:return!1}}function Ole(n,e,t,i){if(e===null||typeof e>"u"||Fle(n,e,t,i))return!0;if(i)return!1;if(t!==null)switch(t.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function ro(n,e,t,i,r,s,o){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=i,this.attributeNamespace=r,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var cs={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n){cs[n]=new ro(n,0,!1,n,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(n){var e=n[0];cs[e]=new ro(e,1,!1,n[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(n){cs[n]=new ro(n,2,!1,n.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(n){cs[n]=new ro(n,2,!1,n,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n){cs[n]=new ro(n,3,!1,n.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(n){cs[n]=new ro(n,3,!0,n,null,!1,!1)});["capture","download"].forEach(function(n){cs[n]=new ro(n,4,!1,n,null,!1,!1)});["cols","rows","size","span"].forEach(function(n){cs[n]=new ro(n,6,!1,n,null,!1,!1)});["rowSpan","start"].forEach(function(n){cs[n]=new ro(n,5,!1,n.toLowerCase(),null,!1,!1)});var JF=/[\-:]([a-z])/g;function QF(n){return n[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n){var e=n.replace(JF,QF);cs[e]=new ro(e,1,!1,n,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n){var e=n.replace(JF,QF);cs[e]=new ro(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(n){var e=n.replace(JF,QF);cs[e]=new ro(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(n){cs[n]=new ro(n,1,!1,n.toLowerCase(),null,!1,!1)});cs.xlinkHref=new ro("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(n){cs[n]=new ro(n,1,!1,n.toLowerCase(),null,!0,!0)});function qF(n,e,t,i){var r=cs.hasOwnProperty(e)?cs[e]:null;(r!==null?r.type!==0:i||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(Ole(e,t,r,i)&&(t=null),i||r===null?Dle(e)&&(t===null?n.removeAttribute(e):n.setAttribute(e,""+t)):r.mustUseProperty?n[r.propertyName]=t===null?r.type===3?!1:"":t:(e=r.attributeName,i=r.attributeNamespace,t===null?n.removeAttribute(e):(r=r.type,t=r===3||r===4&&t===!0?"":""+t,i?n.setAttributeNS(i,e,t):n.setAttribute(e,t))))}var Xc=i8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,DT=Symbol.for("react.element"),Tg=Symbol.for("react.portal"),Cg=Symbol.for("react.fragment"),eO=Symbol.for("react.strict_mode"),AP=Symbol.for("react.profiler"),s8=Symbol.for("react.provider"),o8=Symbol.for("react.context"),tO=Symbol.for("react.forward_ref"),EP=Symbol.for("react.suspense"),IP=Symbol.for("react.suspense_list"),nO=Symbol.for("react.memo"),Ah=Symbol.for("react.lazy"),a8=Symbol.for("react.offscreen"),gH=Symbol.iterator;function Hb(n){return n===null||typeof n!="object"?null:(n=gH&&n[gH]||n["@@iterator"],typeof n=="function"?n:null)}var Di=Object.assign,LR;function Ix(n){if(LR===void 0)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);LR=e&&e[1]||""}return`
`+LR+n}var PR=!1;function DR(n,e){if(!n||PR)return"";PR=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(u){var i=u}Reflect.construct(n,[],e)}else{try{e.call()}catch(u){i=u}n.call(e.prototype)}else{try{throw Error()}catch(u){i=u}n()}}catch(u){if(u&&i&&typeof u.stack=="string"){for(var r=u.stack.split(`
`),s=i.stack.split(`
`),o=r.length-1,a=s.length-1;1<=o&&0<=a&&r[o]!==s[a];)a--;for(;1<=o&&0<=a;o--,a--)if(r[o]!==s[a]){if(o!==1||a!==1)do if(o--,a--,0>a||r[o]!==s[a]){var l=`
`+r[o].replace(" at new "," at ");return n.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",n.displayName)),l}while(1<=o&&0<=a);break}}}finally{PR=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?Ix(n):""}function Ble(n){switch(n.tag){case 5:return Ix(n.type);case 16:return Ix("Lazy");case 13:return Ix("Suspense");case 19:return Ix("SuspenseList");case 0:case 2:case 15:return n=DR(n.type,!1),n;case 11:return n=DR(n.type.render,!1),n;case 1:return n=DR(n.type,!0),n;default:return""}}function kP(n){if(n==null)return null;if(typeof n=="function")return n.displayName||n.name||null;if(typeof n=="string")return n;switch(n){case Cg:return"Fragment";case Tg:return"Portal";case AP:return"Profiler";case eO:return"StrictMode";case EP:return"Suspense";case IP:return"SuspenseList"}if(typeof n=="object")switch(n.$$typeof){case o8:return(n.displayName||"Context")+".Consumer";case s8:return(n._context.displayName||"Context")+".Provider";case tO:var e=n.render;return n=n.displayName,n||(n=e.displayName||e.name||"",n=n!==""?"ForwardRef("+n+")":"ForwardRef"),n;case nO:return e=n.displayName||null,e!==null?e:kP(n.type)||"Memo";case Ah:e=n._payload,n=n._init;try{return kP(n(e))}catch{}}return null}function zle(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=e.render,n=n.displayName||n.name||"",e.displayName||(n!==""?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return kP(e);case 8:return e===eO?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function ud(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":return n;case"object":return n;default:return""}}function l8(n){var e=n.type;return(n=n.nodeName)&&n.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Gle(n){var e=l8(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),i=""+n[e];if(!n.hasOwnProperty(e)&&typeof t<"u"&&typeof t.get=="function"&&typeof t.set=="function"){var r=t.get,s=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return r.call(this)},set:function(o){i=""+o,s.call(this,o)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return i},setValue:function(o){i=""+o},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}function FT(n){n._valueTracker||(n._valueTracker=Gle(n))}function u8(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),i="";return n&&(i=l8(n)?n.checked?"true":"false":n.value),n=i,n!==t?(e.setValue(n),!0):!1}function Y_(n){if(n=n||(typeof document<"u"?document:void 0),typeof n>"u")return null;try{return n.activeElement||n.body}catch{return n.body}}function RP(n,e){var t=e.checked;return Di({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:t??n._wrapperState.initialChecked})}function yH(n,e){var t=e.defaultValue==null?"":e.defaultValue,i=e.checked!=null?e.checked:e.defaultChecked;t=ud(e.value!=null?e.value:t),n._wrapperState={initialChecked:i,initialValue:t,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function c8(n,e){e=e.checked,e!=null&&qF(n,"checked",e,!1)}function NP(n,e){c8(n,e);var t=ud(e.value),i=e.type;if(t!=null)i==="number"?(t===0&&n.value===""||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if(i==="submit"||i==="reset"){n.removeAttribute("value");return}e.hasOwnProperty("value")?LP(n,e.type,t):e.hasOwnProperty("defaultValue")&&LP(n,e.type,ud(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(n.defaultChecked=!!e.defaultChecked)}function bH(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var i=e.type;if(!(i!=="submit"&&i!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}t=n.name,t!==""&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,t!==""&&(n.name=t)}function LP(n,e,t){(e!=="number"||Y_(n.ownerDocument)!==n)&&(t==null?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var kx=Array.isArray;function jg(n,e,t,i){if(n=n.options,e){e={};for(var r=0;r<t.length;r++)e["$"+t[r]]=!0;for(t=0;t<n.length;t++)r=e.hasOwnProperty("$"+n[t].value),n[t].selected!==r&&(n[t].selected=r),r&&i&&(n[t].defaultSelected=!0)}else{for(t=""+ud(t),e=null,r=0;r<n.length;r++){if(n[r].value===t){n[r].selected=!0,i&&(n[r].defaultSelected=!0);return}e!==null||n[r].disabled||(e=n[r])}e!==null&&(e.selected=!0)}}function PP(n,e){if(e.dangerouslySetInnerHTML!=null)throw Error(et(91));return Di({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function xH(n,e){var t=e.value;if(t==null){if(t=e.children,e=e.defaultValue,t!=null){if(e!=null)throw Error(et(92));if(kx(t)){if(1<t.length)throw Error(et(93));t=t[0]}e=t}e==null&&(e=""),t=e}n._wrapperState={initialValue:ud(t)}}function h8(n,e){var t=ud(e.value),i=ud(e.defaultValue);t!=null&&(t=""+t,t!==n.value&&(n.value=t),e.defaultValue==null&&n.defaultValue!==t&&(n.defaultValue=t)),i!=null&&(n.defaultValue=""+i)}function vH(n){var e=n.textContent;e===n._wrapperState.initialValue&&e!==""&&e!==null&&(n.value=e)}function d8(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function DP(n,e){return n==null||n==="http://www.w3.org/1999/xhtml"?d8(e):n==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":n}var OT,p8=function(n){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,t,i,r){MSApp.execUnsafeLocalFunction(function(){return n(e,t,i,r)})}:n}(function(n,e){if(n.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in n)n.innerHTML=e;else{for(OT=OT||document.createElement("div"),OT.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=OT.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}});function gv(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&t.nodeType===3){t.nodeValue=e;return}}n.textContent=e}var Ux={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Vle=["Webkit","ms","Moz","O"];Object.keys(Ux).forEach(function(n){Vle.forEach(function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),Ux[e]=Ux[n]})});function f8(n,e,t){return e==null||typeof e=="boolean"||e===""?"":t||typeof e!="number"||e===0||Ux.hasOwnProperty(n)&&Ux[n]?(""+e).trim():e+"px"}function m8(n,e){n=n.style;for(var t in e)if(e.hasOwnProperty(t)){var i=t.indexOf("--")===0,r=f8(t,e[t],i);t==="float"&&(t="cssFloat"),i?n.setProperty(t,r):n[t]=r}}var Ule=Di({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function FP(n,e){if(e){if(Ule[n]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(et(137,n));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(et(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(et(61))}if(e.style!=null&&typeof e.style!="object")throw Error(et(62))}}function OP(n,e){if(n.indexOf("-")===-1)return typeof e.is=="string";switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var BP=null;function iO(n){return n=n.target||n.srcElement||window,n.correspondingUseElement&&(n=n.correspondingUseElement),n.nodeType===3?n.parentNode:n}var zP=null,Yg=null,Jg=null;function wH(n){if(n=M1(n)){if(typeof zP!="function")throw Error(et(280));var e=n.stateNode;e&&(e=LA(e),zP(n.stateNode,n.type,e))}}function g8(n){Yg?Jg?Jg.push(n):Jg=[n]:Yg=n}function y8(){if(Yg){var n=Yg,e=Jg;if(Jg=Yg=null,wH(n),e)for(n=0;n<e.length;n++)wH(e[n])}}function b8(n,e){return n(e)}function x8(){}var FR=!1;function v8(n,e,t){if(FR)return n(e,t);FR=!0;try{return b8(n,e,t)}finally{FR=!1,(Yg!==null||Jg!==null)&&(x8(),y8())}}function yv(n,e){var t=n.stateNode;if(t===null)return null;var i=LA(t);if(i===null)return null;t=i[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(n=n.type,i=!(n==="button"||n==="input"||n==="select"||n==="textarea")),n=!i;break e;default:n=!1}if(n)return null;if(t&&typeof t!="function")throw Error(et(231,e,typeof t));return t}var GP=!1;if(kc)try{var Xb={};Object.defineProperty(Xb,"passive",{get:function(){GP=!0}}),window.addEventListener("test",Xb,Xb),window.removeEventListener("test",Xb,Xb)}catch{GP=!1}function $le(n,e,t,i,r,s,o,a,l){var u=Array.prototype.slice.call(arguments,3);try{e.apply(t,u)}catch(c){this.onError(c)}}var $x=!1,J_=null,Q_=!1,VP=null,Wle={onError:function(n){$x=!0,J_=n}};function Hle(n,e,t,i,r,s,o,a,l){$x=!1,J_=null,$le.apply(Wle,arguments)}function Xle(n,e,t,i,r,s,o,a,l){if(Hle.apply(this,arguments),$x){if($x){var u=J_;$x=!1,J_=null}else throw Error(et(198));Q_||(Q_=!0,VP=u)}}function jf(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do e=n,e.flags&4098&&(t=e.return),n=e.return;while(n)}return e.tag===3?t:null}function w8(n){if(n.tag===13){var e=n.memoizedState;if(e===null&&(n=n.alternate,n!==null&&(e=n.memoizedState)),e!==null)return e.dehydrated}return null}function SH(n){if(jf(n)!==n)throw Error(et(188))}function Kle(n){var e=n.alternate;if(!e){if(e=jf(n),e===null)throw Error(et(188));return e!==n?null:n}for(var t=n,i=e;;){var r=t.return;if(r===null)break;var s=r.alternate;if(s===null){if(i=r.return,i!==null){t=i;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===t)return SH(r),n;if(s===i)return SH(r),e;s=s.sibling}throw Error(et(188))}if(t.return!==i.return)t=r,i=s;else{for(var o=!1,a=r.child;a;){if(a===t){o=!0,t=r,i=s;break}if(a===i){o=!0,i=r,t=s;break}a=a.sibling}if(!o){for(a=s.child;a;){if(a===t){o=!0,t=s,i=r;break}if(a===i){o=!0,i=s,t=r;break}a=a.sibling}if(!o)throw Error(et(189))}}if(t.alternate!==i)throw Error(et(190))}if(t.tag!==3)throw Error(et(188));return t.stateNode.current===t?n:e}function S8(n){return n=Kle(n),n!==null?T8(n):null}function T8(n){if(n.tag===5||n.tag===6)return n;for(n=n.child;n!==null;){var e=T8(n);if(e!==null)return e;n=n.sibling}return null}var C8=ua.unstable_scheduleCallback,TH=ua.unstable_cancelCallback,Zle=ua.unstable_shouldYield,jle=ua.unstable_requestPaint,er=ua.unstable_now,Yle=ua.unstable_getCurrentPriorityLevel,rO=ua.unstable_ImmediatePriority,_8=ua.unstable_UserBlockingPriority,q_=ua.unstable_NormalPriority,Jle=ua.unstable_LowPriority,M8=ua.unstable_IdlePriority,IA=null,Cu=null;function Qle(n){if(Cu&&typeof Cu.onCommitFiberRoot=="function")try{Cu.onCommitFiberRoot(IA,n,void 0,(n.current.flags&128)===128)}catch{}}var Il=Math.clz32?Math.clz32:tue,qle=Math.log,eue=Math.LN2;function tue(n){return n>>>=0,n===0?32:31-(qle(n)/eue|0)|0}var BT=64,zT=4194304;function Rx(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return n&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function eM(n,e){var t=n.pendingLanes;if(t===0)return 0;var i=0,r=n.suspendedLanes,s=n.pingedLanes,o=t&268435455;if(o!==0){var a=o&~r;a!==0?i=Rx(a):(s&=o,s!==0&&(i=Rx(s)))}else o=t&~r,o!==0?i=Rx(o):s!==0&&(i=Rx(s));if(i===0)return 0;if(e!==0&&e!==i&&!(e&r)&&(r=i&-i,s=e&-e,r>=s||r===16&&(s&4194240)!==0))return e;if(i&4&&(i|=t&16),e=n.entangledLanes,e!==0)for(n=n.entanglements,e&=i;0<e;)t=31-Il(e),r=1<<t,i|=n[t],e&=~r;return i}function nue(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function iue(n,e){for(var t=n.suspendedLanes,i=n.pingedLanes,r=n.expirationTimes,s=n.pendingLanes;0<s;){var o=31-Il(s),a=1<<o,l=r[o];l===-1?(!(a&t)||a&i)&&(r[o]=nue(a,e)):l<=e&&(n.expiredLanes|=a),s&=~a}}function UP(n){return n=n.pendingLanes&-1073741825,n!==0?n:n&1073741824?1073741824:0}function A8(){var n=BT;return BT<<=1,!(BT&4194240)&&(BT=64),n}function OR(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function C1(n,e,t){n.pendingLanes|=e,e!==536870912&&(n.suspendedLanes=0,n.pingedLanes=0),n=n.eventTimes,e=31-Il(e),n[e]=t}function rue(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var i=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-Il(t),s=1<<r;e[r]=0,i[r]=-1,n[r]=-1,t&=~s}}function sO(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var i=31-Il(t),r=1<<i;r&e|n[i]&e&&(n[i]|=e),t&=~r}}var Un=0;function E8(n){return n&=-n,1<n?4<n?n&268435455?16:536870912:4:1}var I8,oO,k8,R8,N8,$P=!1,GT=[],Wh=null,Hh=null,Xh=null,bv=new Map,xv=new Map,Ph=[],sue="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function CH(n,e){switch(n){case"focusin":case"focusout":Wh=null;break;case"dragenter":case"dragleave":Hh=null;break;case"mouseover":case"mouseout":Xh=null;break;case"pointerover":case"pointerout":bv.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":xv.delete(e.pointerId)}}function Kb(n,e,t,i,r,s){return n===null||n.nativeEvent!==s?(n={blockedOn:e,domEventName:t,eventSystemFlags:i,nativeEvent:s,targetContainers:[r]},e!==null&&(e=M1(e),e!==null&&oO(e)),n):(n.eventSystemFlags|=i,e=n.targetContainers,r!==null&&e.indexOf(r)===-1&&e.push(r),n)}function oue(n,e,t,i,r){switch(e){case"focusin":return Wh=Kb(Wh,n,e,t,i,r),!0;case"dragenter":return Hh=Kb(Hh,n,e,t,i,r),!0;case"mouseover":return Xh=Kb(Xh,n,e,t,i,r),!0;case"pointerover":var s=r.pointerId;return bv.set(s,Kb(bv.get(s)||null,n,e,t,i,r)),!0;case"gotpointercapture":return s=r.pointerId,xv.set(s,Kb(xv.get(s)||null,n,e,t,i,r)),!0}return!1}function L8(n){var e=Fp(n.target);if(e!==null){var t=jf(e);if(t!==null){if(e=t.tag,e===13){if(e=w8(t),e!==null){n.blockedOn=e,N8(n.priority,function(){k8(t)});return}}else if(e===3&&t.stateNode.current.memoizedState.isDehydrated){n.blockedOn=t.tag===3?t.stateNode.containerInfo:null;return}}}n.blockedOn=null}function w_(n){if(n.blockedOn!==null)return!1;for(var e=n.targetContainers;0<e.length;){var t=WP(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(t===null){t=n.nativeEvent;var i=new t.constructor(t.type,t);BP=i,t.target.dispatchEvent(i),BP=null}else return e=M1(t),e!==null&&oO(e),n.blockedOn=t,!1;e.shift()}return!0}function _H(n,e,t){w_(n)&&t.delete(e)}function aue(){$P=!1,Wh!==null&&w_(Wh)&&(Wh=null),Hh!==null&&w_(Hh)&&(Hh=null),Xh!==null&&w_(Xh)&&(Xh=null),bv.forEach(_H),xv.forEach(_H)}function Zb(n,e){n.blockedOn===e&&(n.blockedOn=null,$P||($P=!0,ua.unstable_scheduleCallback(ua.unstable_NormalPriority,aue)))}function vv(n){function e(r){return Zb(r,n)}if(0<GT.length){Zb(GT[0],n);for(var t=1;t<GT.length;t++){var i=GT[t];i.blockedOn===n&&(i.blockedOn=null)}}for(Wh!==null&&Zb(Wh,n),Hh!==null&&Zb(Hh,n),Xh!==null&&Zb(Xh,n),bv.forEach(e),xv.forEach(e),t=0;t<Ph.length;t++)i=Ph[t],i.blockedOn===n&&(i.blockedOn=null);for(;0<Ph.length&&(t=Ph[0],t.blockedOn===null);)L8(t),t.blockedOn===null&&Ph.shift()}var Qg=Xc.ReactCurrentBatchConfig,tM=!0;function lue(n,e,t,i){var r=Un,s=Qg.transition;Qg.transition=null;try{Un=1,aO(n,e,t,i)}finally{Un=r,Qg.transition=s}}function uue(n,e,t,i){var r=Un,s=Qg.transition;Qg.transition=null;try{Un=4,aO(n,e,t,i)}finally{Un=r,Qg.transition=s}}function aO(n,e,t,i){if(tM){var r=WP(n,e,t,i);if(r===null)KR(n,e,i,nM,t),CH(n,i);else if(oue(r,n,e,t,i))i.stopPropagation();else if(CH(n,i),e&4&&-1<sue.indexOf(n)){for(;r!==null;){var s=M1(r);if(s!==null&&I8(s),s=WP(n,e,t,i),s===null&&KR(n,e,i,nM,t),s===r)break;r=s}r!==null&&i.stopPropagation()}else KR(n,e,i,null,t)}}var nM=null;function WP(n,e,t,i){if(nM=null,n=iO(i),n=Fp(n),n!==null)if(e=jf(n),e===null)n=null;else if(t=e.tag,t===13){if(n=w8(e),n!==null)return n;n=null}else if(t===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return nM=n,null}function P8(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Yle()){case rO:return 1;case _8:return 4;case q_:case Jle:return 16;case M8:return 536870912;default:return 16}default:return 16}}var Oh=null,lO=null,S_=null;function D8(){if(S_)return S_;var n,e=lO,t=e.length,i,r="value"in Oh?Oh.value:Oh.textContent,s=r.length;for(n=0;n<t&&e[n]===r[n];n++);var o=t-n;for(i=1;i<=o&&e[t-i]===r[s-i];i++);return S_=r.slice(n,1<i?1-i:void 0)}function T_(n){var e=n.keyCode;return"charCode"in n?(n=n.charCode,n===0&&e===13&&(n=13)):n=e,n===10&&(n=13),32<=n||n===13?n:0}function VT(){return!0}function MH(){return!1}function ma(n){function e(t,i,r,s,o){this._reactName=t,this._targetInst=r,this.type=i,this.nativeEvent=s,this.target=o,this.currentTarget=null;for(var a in n)n.hasOwnProperty(a)&&(t=n[a],this[a]=t?t(s):s[a]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?VT:MH,this.isPropagationStopped=MH,this}return Di(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():typeof t.returnValue!="unknown"&&(t.returnValue=!1),this.isDefaultPrevented=VT)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():typeof t.cancelBubble!="unknown"&&(t.cancelBubble=!0),this.isPropagationStopped=VT)},persist:function(){},isPersistent:VT}),e}var Yy={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},uO=ma(Yy),_1=Di({},Yy,{view:0,detail:0}),cue=ma(_1),BR,zR,jb,kA=Di({},_1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:cO,button:0,buttons:0,relatedTarget:function(n){return n.relatedTarget===void 0?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==jb&&(jb&&n.type==="mousemove"?(BR=n.screenX-jb.screenX,zR=n.screenY-jb.screenY):zR=BR=0,jb=n),BR)},movementY:function(n){return"movementY"in n?n.movementY:zR}}),AH=ma(kA),hue=Di({},kA,{dataTransfer:0}),due=ma(hue),pue=Di({},_1,{relatedTarget:0}),GR=ma(pue),fue=Di({},Yy,{animationName:0,elapsedTime:0,pseudoElement:0}),mue=ma(fue),gue=Di({},Yy,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),yue=ma(gue),bue=Di({},Yy,{data:0}),EH=ma(bue),xue={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},vue={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},wue={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sue(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):(n=wue[n])?!!e[n]:!1}function cO(){return Sue}var Tue=Di({},_1,{key:function(n){if(n.key){var e=xue[n.key]||n.key;if(e!=="Unidentified")return e}return n.type==="keypress"?(n=T_(n),n===13?"Enter":String.fromCharCode(n)):n.type==="keydown"||n.type==="keyup"?vue[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:cO,charCode:function(n){return n.type==="keypress"?T_(n):0},keyCode:function(n){return n.type==="keydown"||n.type==="keyup"?n.keyCode:0},which:function(n){return n.type==="keypress"?T_(n):n.type==="keydown"||n.type==="keyup"?n.keyCode:0}}),Cue=ma(Tue),_ue=Di({},kA,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),IH=ma(_ue),Mue=Di({},_1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:cO}),Aue=ma(Mue),Eue=Di({},Yy,{propertyName:0,elapsedTime:0,pseudoElement:0}),Iue=ma(Eue),kue=Di({},kA,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),Rue=ma(kue),Nue=[9,13,27,32],hO=kc&&"CompositionEvent"in window,Wx=null;kc&&"documentMode"in document&&(Wx=document.documentMode);var Lue=kc&&"TextEvent"in window&&!Wx,F8=kc&&(!hO||Wx&&8<Wx&&11>=Wx),kH=String.fromCharCode(32),RH=!1;function O8(n,e){switch(n){case"keyup":return Nue.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function B8(n){return n=n.detail,typeof n=="object"&&"data"in n?n.data:null}var _g=!1;function Pue(n,e){switch(n){case"compositionend":return B8(e);case"keypress":return e.which!==32?null:(RH=!0,kH);case"textInput":return n=e.data,n===kH&&RH?null:n;default:return null}}function Due(n,e){if(_g)return n==="compositionend"||!hO&&O8(n,e)?(n=D8(),S_=lO=Oh=null,_g=!1,n):null;switch(n){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return F8&&e.locale!=="ko"?null:e.data;default:return null}}var Fue={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function NH(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e==="input"?!!Fue[n.type]:e==="textarea"}function z8(n,e,t,i){g8(i),e=iM(e,"onChange"),0<e.length&&(t=new uO("onChange","change",null,t,i),n.push({event:t,listeners:e}))}var Hx=null,wv=null;function Oue(n){Y8(n,0)}function RA(n){var e=Eg(n);if(u8(e))return n}function Bue(n,e){if(n==="change")return e}var G8=!1;if(kc){var VR;if(kc){var UR="oninput"in document;if(!UR){var LH=document.createElement("div");LH.setAttribute("oninput","return;"),UR=typeof LH.oninput=="function"}VR=UR}else VR=!1;G8=VR&&(!document.documentMode||9<document.documentMode)}function PH(){Hx&&(Hx.detachEvent("onpropertychange",V8),wv=Hx=null)}function V8(n){if(n.propertyName==="value"&&RA(wv)){var e=[];z8(e,wv,n,iO(n)),v8(Oue,e)}}function zue(n,e,t){n==="focusin"?(PH(),Hx=e,wv=t,Hx.attachEvent("onpropertychange",V8)):n==="focusout"&&PH()}function Gue(n){if(n==="selectionchange"||n==="keyup"||n==="keydown")return RA(wv)}function Vue(n,e){if(n==="click")return RA(e)}function Uue(n,e){if(n==="input"||n==="change")return RA(e)}function $ue(n,e){return n===e&&(n!==0||1/n===1/e)||n!==n&&e!==e}var Bl=typeof Object.is=="function"?Object.is:$ue;function Sv(n,e){if(Bl(n,e))return!0;if(typeof n!="object"||n===null||typeof e!="object"||e===null)return!1;var t=Object.keys(n),i=Object.keys(e);if(t.length!==i.length)return!1;for(i=0;i<t.length;i++){var r=t[i];if(!MP.call(e,r)||!Bl(n[r],e[r]))return!1}return!0}function DH(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function FH(n,e){var t=DH(n);n=0;for(var i;t;){if(t.nodeType===3){if(i=n+t.textContent.length,n<=e&&i>=e)return{node:t,offset:e-n};n=i}e:{for(;t;){if(t.nextSibling){t=t.nextSibling;break e}t=t.parentNode}t=void 0}t=DH(t)}}function U8(n,e){return n&&e?n===e?!0:n&&n.nodeType===3?!1:e&&e.nodeType===3?U8(n,e.parentNode):"contains"in n?n.contains(e):n.compareDocumentPosition?!!(n.compareDocumentPosition(e)&16):!1:!1}function $8(){for(var n=window,e=Y_();e instanceof n.HTMLIFrameElement;){try{var t=typeof e.contentWindow.location.href=="string"}catch{t=!1}if(t)n=e.contentWindow;else break;e=Y_(n.document)}return e}function dO(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&(e==="input"&&(n.type==="text"||n.type==="search"||n.type==="tel"||n.type==="url"||n.type==="password")||e==="textarea"||n.contentEditable==="true")}function Wue(n){var e=$8(),t=n.focusedElem,i=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&U8(t.ownerDocument.documentElement,t)){if(i!==null&&dO(t)){if(e=i.start,n=i.end,n===void 0&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if(n=(e=t.ownerDocument||document)&&e.defaultView||window,n.getSelection){n=n.getSelection();var r=t.textContent.length,s=Math.min(i.start,r);i=i.end===void 0?s:Math.min(i.end,r),!n.extend&&s>i&&(r=i,i=s,s=r),r=FH(t,s);var o=FH(t,i);r&&o&&(n.rangeCount!==1||n.anchorNode!==r.node||n.anchorOffset!==r.offset||n.focusNode!==o.node||n.focusOffset!==o.offset)&&(e=e.createRange(),e.setStart(r.node,r.offset),n.removeAllRanges(),s>i?(n.addRange(e),n.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),n.addRange(e)))}}for(e=[],n=t;n=n.parentNode;)n.nodeType===1&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for(typeof t.focus=="function"&&t.focus(),t=0;t<e.length;t++)n=e[t],n.element.scrollLeft=n.left,n.element.scrollTop=n.top}}var Hue=kc&&"documentMode"in document&&11>=document.documentMode,Mg=null,HP=null,Xx=null,XP=!1;function OH(n,e,t){var i=t.window===t?t.document:t.nodeType===9?t:t.ownerDocument;XP||Mg==null||Mg!==Y_(i)||(i=Mg,"selectionStart"in i&&dO(i)?i={start:i.selectionStart,end:i.selectionEnd}:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection(),i={anchorNode:i.anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset}),Xx&&Sv(Xx,i)||(Xx=i,i=iM(HP,"onSelect"),0<i.length&&(e=new uO("onSelect","select",null,e,t),n.push({event:e,listeners:i}),e.target=Mg)))}function UT(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var Ag={animationend:UT("Animation","AnimationEnd"),animationiteration:UT("Animation","AnimationIteration"),animationstart:UT("Animation","AnimationStart"),transitionend:UT("Transition","TransitionEnd")},$R={},W8={};kc&&(W8=document.createElement("div").style,"AnimationEvent"in window||(delete Ag.animationend.animation,delete Ag.animationiteration.animation,delete Ag.animationstart.animation),"TransitionEvent"in window||delete Ag.transitionend.transition);function NA(n){if($R[n])return $R[n];if(!Ag[n])return n;var e=Ag[n],t;for(t in e)if(e.hasOwnProperty(t)&&t in W8)return $R[n]=e[t];return n}var H8=NA("animationend"),X8=NA("animationiteration"),K8=NA("animationstart"),Z8=NA("transitionend"),j8=new Map,BH="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Md(n,e){j8.set(n,e),Zf(e,[n])}for(var WR=0;WR<BH.length;WR++){var HR=BH[WR],Xue=HR.toLowerCase(),Kue=HR[0].toUpperCase()+HR.slice(1);Md(Xue,"on"+Kue)}Md(H8,"onAnimationEnd");Md(X8,"onAnimationIteration");Md(K8,"onAnimationStart");Md("dblclick","onDoubleClick");Md("focusin","onFocus");Md("focusout","onBlur");Md(Z8,"onTransitionEnd");dy("onMouseEnter",["mouseout","mouseover"]);dy("onMouseLeave",["mouseout","mouseover"]);dy("onPointerEnter",["pointerout","pointerover"]);dy("onPointerLeave",["pointerout","pointerover"]);Zf("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Zf("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Zf("onBeforeInput",["compositionend","keypress","textInput","paste"]);Zf("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Zf("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Zf("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Nx="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Zue=new Set("cancel close invalid load scroll toggle".split(" ").concat(Nx));function zH(n,e,t){var i=n.type||"unknown-event";n.currentTarget=t,Xle(i,e,void 0,n),n.currentTarget=null}function Y8(n,e){e=(e&4)!==0;for(var t=0;t<n.length;t++){var i=n[t],r=i.event;i=i.listeners;e:{var s=void 0;if(e)for(var o=i.length-1;0<=o;o--){var a=i[o],l=a.instance,u=a.currentTarget;if(a=a.listener,l!==s&&r.isPropagationStopped())break e;zH(r,a,u),s=l}else for(o=0;o<i.length;o++){if(a=i[o],l=a.instance,u=a.currentTarget,a=a.listener,l!==s&&r.isPropagationStopped())break e;zH(r,a,u),s=l}}}if(Q_)throw n=VP,Q_=!1,VP=null,n}function ai(n,e){var t=e[JP];t===void 0&&(t=e[JP]=new Set);var i=n+"__bubble";t.has(i)||(J8(e,n,2,!1),t.add(i))}function XR(n,e,t){var i=0;e&&(i|=4),J8(t,n,i,e)}var $T="_reactListening"+Math.random().toString(36).slice(2);function Tv(n){if(!n[$T]){n[$T]=!0,r8.forEach(function(t){t!=="selectionchange"&&(Zue.has(t)||XR(t,!1,n),XR(t,!0,n))});var e=n.nodeType===9?n:n.ownerDocument;e===null||e[$T]||(e[$T]=!0,XR("selectionchange",!1,e))}}function J8(n,e,t,i){switch(P8(e)){case 1:var r=lue;break;case 4:r=uue;break;default:r=aO}t=r.bind(null,e,t,n),r=void 0,!GP||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(r=!0),i?r!==void 0?n.addEventListener(e,t,{capture:!0,passive:r}):n.addEventListener(e,t,!0):r!==void 0?n.addEventListener(e,t,{passive:r}):n.addEventListener(e,t,!1)}function KR(n,e,t,i,r){var s=i;if(!(e&1)&&!(e&2)&&i!==null)e:for(;;){if(i===null)return;var o=i.tag;if(o===3||o===4){var a=i.stateNode.containerInfo;if(a===r||a.nodeType===8&&a.parentNode===r)break;if(o===4)for(o=i.return;o!==null;){var l=o.tag;if((l===3||l===4)&&(l=o.stateNode.containerInfo,l===r||l.nodeType===8&&l.parentNode===r))return;o=o.return}for(;a!==null;){if(o=Fp(a),o===null)return;if(l=o.tag,l===5||l===6){i=s=o;continue e}a=a.parentNode}}i=i.return}v8(function(){var u=s,c=iO(t),h=[];e:{var d=j8.get(n);if(d!==void 0){var p=uO,f=n;switch(n){case"keypress":if(T_(t)===0)break e;case"keydown":case"keyup":p=Cue;break;case"focusin":f="focus",p=GR;break;case"focusout":f="blur",p=GR;break;case"beforeblur":case"afterblur":p=GR;break;case"click":if(t.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=AH;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=due;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=Aue;break;case H8:case X8:case K8:p=mue;break;case Z8:p=Iue;break;case"scroll":p=cue;break;case"wheel":p=Rue;break;case"copy":case"cut":case"paste":p=yue;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=IH}var g=(e&4)!==0,y=!g&&n==="scroll",m=g?d!==null?d+"Capture":null:d;g=[];for(var v=u,w;v!==null;){w=v;var S=w.stateNode;if(w.tag===5&&S!==null&&(w=S,m!==null&&(S=yv(v,m),S!=null&&g.push(Cv(v,S,w)))),y)break;v=v.return}0<g.length&&(d=new p(d,f,null,t,c),h.push({event:d,listeners:g}))}}if(!(e&7)){e:{if(d=n==="mouseover"||n==="pointerover",p=n==="mouseout"||n==="pointerout",d&&t!==BP&&(f=t.relatedTarget||t.fromElement)&&(Fp(f)||f[Rc]))break e;if((p||d)&&(d=c.window===c?c:(d=c.ownerDocument)?d.defaultView||d.parentWindow:window,p?(f=t.relatedTarget||t.toElement,p=u,f=f?Fp(f):null,f!==null&&(y=jf(f),f!==y||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=u),p!==f)){if(g=AH,S="onMouseLeave",m="onMouseEnter",v="mouse",(n==="pointerout"||n==="pointerover")&&(g=IH,S="onPointerLeave",m="onPointerEnter",v="pointer"),y=p==null?d:Eg(p),w=f==null?d:Eg(f),d=new g(S,v+"leave",p,t,c),d.target=y,d.relatedTarget=w,S=null,Fp(c)===u&&(g=new g(m,v+"enter",f,t,c),g.target=w,g.relatedTarget=y,S=g),y=S,p&&f)t:{for(g=p,m=f,v=0,w=g;w;w=Wm(w))v++;for(w=0,S=m;S;S=Wm(S))w++;for(;0<v-w;)g=Wm(g),v--;for(;0<w-v;)m=Wm(m),w--;for(;v--;){if(g===m||m!==null&&g===m.alternate)break t;g=Wm(g),m=Wm(m)}g=null}else g=null;p!==null&&GH(h,d,p,g,!1),f!==null&&y!==null&&GH(h,y,f,g,!0)}}e:{if(d=u?Eg(u):window,p=d.nodeName&&d.nodeName.toLowerCase(),p==="select"||p==="input"&&d.type==="file")var C=Bue;else if(NH(d))if(G8)C=Uue;else{C=Gue;var _=zue}else(p=d.nodeName)&&p.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(C=Vue);if(C&&(C=C(n,u))){z8(h,C,t,c);break e}_&&_(n,d,u),n==="focusout"&&(_=d._wrapperState)&&_.controlled&&d.type==="number"&&LP(d,"number",d.value)}switch(_=u?Eg(u):window,n){case"focusin":(NH(_)||_.contentEditable==="true")&&(Mg=_,HP=u,Xx=null);break;case"focusout":Xx=HP=Mg=null;break;case"mousedown":XP=!0;break;case"contextmenu":case"mouseup":case"dragend":XP=!1,OH(h,t,c);break;case"selectionchange":if(Hue)break;case"keydown":case"keyup":OH(h,t,c)}var A;if(hO)e:{switch(n){case"compositionstart":var I="onCompositionStart";break e;case"compositionend":I="onCompositionEnd";break e;case"compositionupdate":I="onCompositionUpdate";break e}I=void 0}else _g?O8(n,t)&&(I="onCompositionEnd"):n==="keydown"&&t.keyCode===229&&(I="onCompositionStart");I&&(F8&&t.locale!=="ko"&&(_g||I!=="onCompositionStart"?I==="onCompositionEnd"&&_g&&(A=D8()):(Oh=c,lO="value"in Oh?Oh.value:Oh.textContent,_g=!0)),_=iM(u,I),0<_.length&&(I=new EH(I,n,null,t,c),h.push({event:I,listeners:_}),A?I.data=A:(A=B8(t),A!==null&&(I.data=A)))),(A=Lue?Pue(n,t):Due(n,t))&&(u=iM(u,"onBeforeInput"),0<u.length&&(c=new EH("onBeforeInput","beforeinput",null,t,c),h.push({event:c,listeners:u}),c.data=A))}Y8(h,e)})}function Cv(n,e,t){return{instance:n,listener:e,currentTarget:t}}function iM(n,e){for(var t=e+"Capture",i=[];n!==null;){var r=n,s=r.stateNode;r.tag===5&&s!==null&&(r=s,s=yv(n,t),s!=null&&i.unshift(Cv(n,s,r)),s=yv(n,e),s!=null&&i.push(Cv(n,s,r))),n=n.return}return i}function Wm(n){if(n===null)return null;do n=n.return;while(n&&n.tag!==5);return n||null}function GH(n,e,t,i,r){for(var s=e._reactName,o=[];t!==null&&t!==i;){var a=t,l=a.alternate,u=a.stateNode;if(l!==null&&l===i)break;a.tag===5&&u!==null&&(a=u,r?(l=yv(t,s),l!=null&&o.unshift(Cv(t,l,a))):r||(l=yv(t,s),l!=null&&o.push(Cv(t,l,a)))),t=t.return}o.length!==0&&n.push({event:e,listeners:o})}var jue=/\r\n?/g,Yue=/\u0000|\uFFFD/g;function VH(n){return(typeof n=="string"?n:""+n).replace(jue,`
`).replace(Yue,"")}function WT(n,e,t){if(e=VH(e),VH(n)!==e&&t)throw Error(et(425))}function rM(){}var KP=null,ZP=null;function jP(n,e){return n==="textarea"||n==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var YP=typeof setTimeout=="function"?setTimeout:void 0,Jue=typeof clearTimeout=="function"?clearTimeout:void 0,UH=typeof Promise=="function"?Promise:void 0,Que=typeof queueMicrotask=="function"?queueMicrotask:typeof UH<"u"?function(n){return UH.resolve(null).then(n).catch(que)}:YP;function que(n){setTimeout(function(){throw n})}function ZR(n,e){var t=e,i=0;do{var r=t.nextSibling;if(n.removeChild(t),r&&r.nodeType===8)if(t=r.data,t==="/$"){if(i===0){n.removeChild(r),vv(e);return}i--}else t!=="$"&&t!=="$?"&&t!=="$!"||i++;t=r}while(t);vv(e)}function Kh(n){for(;n!=null;n=n.nextSibling){var e=n.nodeType;if(e===1||e===3)break;if(e===8){if(e=n.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return n}function $H(n){n=n.previousSibling;for(var e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="$"||t==="$!"||t==="$?"){if(e===0)return n;e--}else t==="/$"&&e++}n=n.previousSibling}return null}var Jy=Math.random().toString(36).slice(2),bu="__reactFiber$"+Jy,_v="__reactProps$"+Jy,Rc="__reactContainer$"+Jy,JP="__reactEvents$"+Jy,ece="__reactListeners$"+Jy,tce="__reactHandles$"+Jy;function Fp(n){var e=n[bu];if(e)return e;for(var t=n.parentNode;t;){if(e=t[Rc]||t[bu]){if(t=e.alternate,e.child!==null||t!==null&&t.child!==null)for(n=$H(n);n!==null;){if(t=n[bu])return t;n=$H(n)}return e}n=t,t=n.parentNode}return null}function M1(n){return n=n[bu]||n[Rc],!n||n.tag!==5&&n.tag!==6&&n.tag!==13&&n.tag!==3?null:n}function Eg(n){if(n.tag===5||n.tag===6)return n.stateNode;throw Error(et(33))}function LA(n){return n[_v]||null}var QP=[],Ig=-1;function Ad(n){return{current:n}}function di(n){0>Ig||(n.current=QP[Ig],QP[Ig]=null,Ig--)}function ei(n,e){Ig++,QP[Ig]=n.current,n.current=e}var cd={},Ns=Ad(cd),Mo=Ad(!1),df=cd;function py(n,e){var t=n.type.contextTypes;if(!t)return cd;var i=n.stateNode;if(i&&i.__reactInternalMemoizedUnmaskedChildContext===e)return i.__reactInternalMemoizedMaskedChildContext;var r={},s;for(s in t)r[s]=e[s];return i&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=r),r}function Ao(n){return n=n.childContextTypes,n!=null}function sM(){di(Mo),di(Ns)}function WH(n,e,t){if(Ns.current!==cd)throw Error(et(168));ei(Ns,e),ei(Mo,t)}function Q8(n,e,t){var i=n.stateNode;if(e=e.childContextTypes,typeof i.getChildContext!="function")return t;i=i.getChildContext();for(var r in i)if(!(r in e))throw Error(et(108,zle(n)||"Unknown",r));return Di({},t,i)}function oM(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||cd,df=Ns.current,ei(Ns,n),ei(Mo,Mo.current),!0}function HH(n,e,t){var i=n.stateNode;if(!i)throw Error(et(169));t?(n=Q8(n,e,df),i.__reactInternalMemoizedMergedChildContext=n,di(Mo),di(Ns),ei(Ns,n)):di(Mo),ei(Mo,t)}var lc=null,PA=!1,jR=!1;function q8(n){lc===null?lc=[n]:lc.push(n)}function nce(n){PA=!0,q8(n)}function Ed(){if(!jR&&lc!==null){jR=!0;var n=0,e=Un;try{var t=lc;for(Un=1;n<t.length;n++){var i=t[n];do i=i(!0);while(i!==null)}lc=null,PA=!1}catch(r){throw lc!==null&&(lc=lc.slice(n+1)),C8(rO,Ed),r}finally{Un=e,jR=!1}}return null}var kg=[],Rg=0,aM=null,lM=0,Va=[],Ua=0,pf=null,gc=1,yc="";function yp(n,e){kg[Rg++]=lM,kg[Rg++]=aM,aM=n,lM=e}function e6(n,e,t){Va[Ua++]=gc,Va[Ua++]=yc,Va[Ua++]=pf,pf=n;var i=gc;n=yc;var r=32-Il(i)-1;i&=~(1<<r),t+=1;var s=32-Il(e)+r;if(30<s){var o=r-r%5;s=(i&(1<<o)-1).toString(32),i>>=o,r-=o,gc=1<<32-Il(e)+r|t<<r|i,yc=s+n}else gc=1<<s|t<<r|i,yc=n}function pO(n){n.return!==null&&(yp(n,1),e6(n,1,0))}function fO(n){for(;n===aM;)aM=kg[--Rg],kg[Rg]=null,lM=kg[--Rg],kg[Rg]=null;for(;n===pf;)pf=Va[--Ua],Va[Ua]=null,yc=Va[--Ua],Va[Ua]=null,gc=Va[--Ua],Va[Ua]=null}var na=null,Jo=null,xi=!1,Sl=null;function t6(n,e){var t=Wa(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,e=n.deletions,e===null?(n.deletions=[t],n.flags|=16):e.push(t)}function XH(n,e){switch(n.tag){case 5:var t=n.type;return e=e.nodeType!==1||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(n.stateNode=e,na=n,Jo=Kh(e.firstChild),!0):!1;case 6:return e=n.pendingProps===""||e.nodeType!==3?null:e,e!==null?(n.stateNode=e,na=n,Jo=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(t=pf!==null?{id:gc,overflow:yc}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},t=Wa(18,null,null,0),t.stateNode=e,t.return=n,n.child=t,na=n,Jo=null,!0):!1;default:return!1}}function qP(n){return(n.mode&1)!==0&&(n.flags&128)===0}function eD(n){if(xi){var e=Jo;if(e){var t=e;if(!XH(n,e)){if(qP(n))throw Error(et(418));e=Kh(t.nextSibling);var i=na;e&&XH(n,e)?t6(i,t):(n.flags=n.flags&-4097|2,xi=!1,na=n)}}else{if(qP(n))throw Error(et(418));n.flags=n.flags&-4097|2,xi=!1,na=n}}}function KH(n){for(n=n.return;n!==null&&n.tag!==5&&n.tag!==3&&n.tag!==13;)n=n.return;na=n}function HT(n){if(n!==na)return!1;if(!xi)return KH(n),xi=!0,!1;var e;if((e=n.tag!==3)&&!(e=n.tag!==5)&&(e=n.type,e=e!=="head"&&e!=="body"&&!jP(n.type,n.memoizedProps)),e&&(e=Jo)){if(qP(n))throw n6(),Error(et(418));for(;e;)t6(n,e),e=Kh(e.nextSibling)}if(KH(n),n.tag===13){if(n=n.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(et(317));e:{for(n=n.nextSibling,e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="/$"){if(e===0){Jo=Kh(n.nextSibling);break e}e--}else t!=="$"&&t!=="$!"&&t!=="$?"||e++}n=n.nextSibling}Jo=null}}else Jo=na?Kh(n.stateNode.nextSibling):null;return!0}function n6(){for(var n=Jo;n;)n=Kh(n.nextSibling)}function fy(){Jo=na=null,xi=!1}function mO(n){Sl===null?Sl=[n]:Sl.push(n)}var ice=Xc.ReactCurrentBatchConfig;function bl(n,e){if(n&&n.defaultProps){e=Di({},e),n=n.defaultProps;for(var t in n)e[t]===void 0&&(e[t]=n[t]);return e}return e}var uM=Ad(null),cM=null,Ng=null,gO=null;function yO(){gO=Ng=cM=null}function bO(n){var e=uM.current;di(uM),n._currentValue=e}function tD(n,e,t){for(;n!==null;){var i=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,i!==null&&(i.childLanes|=e)):i!==null&&(i.childLanes&e)!==e&&(i.childLanes|=e),n===t)break;n=n.return}}function qg(n,e){cM=n,gO=Ng=null,n=n.dependencies,n!==null&&n.firstContext!==null&&(n.lanes&e&&(So=!0),n.firstContext=null)}function Ya(n){var e=n._currentValue;if(gO!==n)if(n={context:n,memoizedValue:e,next:null},Ng===null){if(cM===null)throw Error(et(308));Ng=n,cM.dependencies={lanes:0,firstContext:n}}else Ng=Ng.next=n;return e}var Op=null;function xO(n){Op===null?Op=[n]:Op.push(n)}function i6(n,e,t,i){var r=e.interleaved;return r===null?(t.next=t,xO(e)):(t.next=r.next,r.next=t),e.interleaved=t,Nc(n,i)}function Nc(n,e){n.lanes|=e;var t=n.alternate;for(t!==null&&(t.lanes|=e),t=n,n=n.return;n!==null;)n.childLanes|=e,t=n.alternate,t!==null&&(t.childLanes|=e),t=n,n=n.return;return t.tag===3?t.stateNode:null}var Eh=!1;function vO(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function r6(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function wc(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function Zh(n,e,t){var i=n.updateQueue;if(i===null)return null;if(i=i.shared,kn&2){var r=i.pending;return r===null?e.next=e:(e.next=r.next,r.next=e),i.pending=e,Nc(n,t)}return r=i.interleaved,r===null?(e.next=e,xO(i)):(e.next=r.next,r.next=e),i.interleaved=e,Nc(n,t)}function C_(n,e,t){if(e=e.updateQueue,e!==null&&(e=e.shared,(t&4194240)!==0)){var i=e.lanes;i&=n.pendingLanes,t|=i,e.lanes=t,sO(n,t)}}function ZH(n,e){var t=n.updateQueue,i=n.alternate;if(i!==null&&(i=i.updateQueue,t===i)){var r=null,s=null;if(t=t.firstBaseUpdate,t!==null){do{var o={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};s===null?r=s=o:s=s.next=o,t=t.next}while(t!==null);s===null?r=s=e:s=s.next=e}else r=s=e;t={baseState:i.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:i.shared,effects:i.effects},n.updateQueue=t;return}n=t.lastBaseUpdate,n===null?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function hM(n,e,t,i){var r=n.updateQueue;Eh=!1;var s=r.firstBaseUpdate,o=r.lastBaseUpdate,a=r.shared.pending;if(a!==null){r.shared.pending=null;var l=a,u=l.next;l.next=null,o===null?s=u:o.next=u,o=l;var c=n.alternate;c!==null&&(c=c.updateQueue,a=c.lastBaseUpdate,a!==o&&(a===null?c.firstBaseUpdate=u:a.next=u,c.lastBaseUpdate=l))}if(s!==null){var h=r.baseState;o=0,c=u=l=null,a=s;do{var d=a.lane,p=a.eventTime;if((i&d)===d){c!==null&&(c=c.next={eventTime:p,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var f=n,g=a;switch(d=e,p=t,g.tag){case 1:if(f=g.payload,typeof f=="function"){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=g.payload,d=typeof f=="function"?f.call(p,h,d):f,d==null)break e;h=Di({},h,d);break e;case 2:Eh=!0}}a.callback!==null&&a.lane!==0&&(n.flags|=64,d=r.effects,d===null?r.effects=[a]:d.push(a))}else p={eventTime:p,lane:d,tag:a.tag,payload:a.payload,callback:a.callback,next:null},c===null?(u=c=p,l=h):c=c.next=p,o|=d;if(a=a.next,a===null){if(a=r.shared.pending,a===null)break;d=a,a=d.next,d.next=null,r.lastBaseUpdate=d,r.shared.pending=null}}while(1);if(c===null&&(l=h),r.baseState=l,r.firstBaseUpdate=u,r.lastBaseUpdate=c,e=r.shared.interleaved,e!==null){r=e;do o|=r.lane,r=r.next;while(r!==e)}else s===null&&(r.shared.lanes=0);mf|=o,n.lanes=o,n.memoizedState=h}}function jH(n,e,t){if(n=e.effects,e.effects=null,n!==null)for(e=0;e<n.length;e++){var i=n[e],r=i.callback;if(r!==null){if(i.callback=null,i=t,typeof r!="function")throw Error(et(191,r));r.call(i)}}}var s6=new i8.Component().refs;function nD(n,e,t,i){e=n.memoizedState,t=t(i,e),t=t==null?e:Di({},e,t),n.memoizedState=t,n.lanes===0&&(n.updateQueue.baseState=t)}var DA={isMounted:function(n){return(n=n._reactInternals)?jf(n)===n:!1},enqueueSetState:function(n,e,t){n=n._reactInternals;var i=Zs(),r=Yh(n),s=wc(i,r);s.payload=e,t!=null&&(s.callback=t),e=Zh(n,s,r),e!==null&&(kl(e,n,r,i),C_(e,n,r))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var i=Zs(),r=Yh(n),s=wc(i,r);s.tag=1,s.payload=e,t!=null&&(s.callback=t),e=Zh(n,s,r),e!==null&&(kl(e,n,r,i),C_(e,n,r))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=Zs(),i=Yh(n),r=wc(t,i);r.tag=2,e!=null&&(r.callback=e),e=Zh(n,r,i),e!==null&&(kl(e,n,i,t),C_(e,n,i))}};function YH(n,e,t,i,r,s,o){return n=n.stateNode,typeof n.shouldComponentUpdate=="function"?n.shouldComponentUpdate(i,s,o):e.prototype&&e.prototype.isPureReactComponent?!Sv(t,i)||!Sv(r,s):!0}function o6(n,e,t){var i=!1,r=cd,s=e.contextType;return typeof s=="object"&&s!==null?s=Ya(s):(r=Ao(e)?df:Ns.current,i=e.contextTypes,s=(i=i!=null)?py(n,r):cd),e=new e(t,s),n.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=DA,n.stateNode=e,e._reactInternals=n,i&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=s),e}function JH(n,e,t,i){n=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(t,i),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(t,i),e.state!==n&&DA.enqueueReplaceState(e,e.state,null)}function iD(n,e,t,i){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=s6,vO(n);var s=e.contextType;typeof s=="object"&&s!==null?r.context=Ya(s):(s=Ao(e)?df:Ns.current,r.context=py(n,s)),r.state=n.memoizedState,s=e.getDerivedStateFromProps,typeof s=="function"&&(nD(n,e,s,t),r.state=n.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof r.getSnapshotBeforeUpdate=="function"||typeof r.UNSAFE_componentWillMount!="function"&&typeof r.componentWillMount!="function"||(e=r.state,typeof r.componentWillMount=="function"&&r.componentWillMount(),typeof r.UNSAFE_componentWillMount=="function"&&r.UNSAFE_componentWillMount(),e!==r.state&&DA.enqueueReplaceState(r,r.state,null),hM(n,t,r,i),r.state=n.memoizedState),typeof r.componentDidMount=="function"&&(n.flags|=4194308)}function Yb(n,e,t){if(n=t.ref,n!==null&&typeof n!="function"&&typeof n!="object"){if(t._owner){if(t=t._owner,t){if(t.tag!==1)throw Error(et(309));var i=t.stateNode}if(!i)throw Error(et(147,n));var r=i,s=""+n;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===s?e.ref:(e=function(o){var a=r.refs;a===s6&&(a=r.refs={}),o===null?delete a[s]:a[s]=o},e._stringRef=s,e)}if(typeof n!="string")throw Error(et(284));if(!t._owner)throw Error(et(290,n))}return n}function XT(n,e){throw n=Object.prototype.toString.call(e),Error(et(31,n==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function QH(n){var e=n._init;return e(n._payload)}function a6(n){function e(m,v){if(n){var w=m.deletions;w===null?(m.deletions=[v],m.flags|=16):w.push(v)}}function t(m,v){if(!n)return null;for(;v!==null;)e(m,v),v=v.sibling;return null}function i(m,v){for(m=new Map;v!==null;)v.key!==null?m.set(v.key,v):m.set(v.index,v),v=v.sibling;return m}function r(m,v){return m=Jh(m,v),m.index=0,m.sibling=null,m}function s(m,v,w){return m.index=w,n?(w=m.alternate,w!==null?(w=w.index,w<v?(m.flags|=2,v):w):(m.flags|=2,v)):(m.flags|=1048576,v)}function o(m){return n&&m.alternate===null&&(m.flags|=2),m}function a(m,v,w,S){return v===null||v.tag!==6?(v=nN(w,m.mode,S),v.return=m,v):(v=r(v,w),v.return=m,v)}function l(m,v,w,S){var C=w.type;return C===Cg?c(m,v,w.props.children,S,w.key):v!==null&&(v.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===Ah&&QH(C)===v.type)?(S=r(v,w.props),S.ref=Yb(m,v,w),S.return=m,S):(S=k_(w.type,w.key,w.props,null,m.mode,S),S.ref=Yb(m,v,w),S.return=m,S)}function u(m,v,w,S){return v===null||v.tag!==4||v.stateNode.containerInfo!==w.containerInfo||v.stateNode.implementation!==w.implementation?(v=iN(w,m.mode,S),v.return=m,v):(v=r(v,w.children||[]),v.return=m,v)}function c(m,v,w,S,C){return v===null||v.tag!==7?(v=Jp(w,m.mode,S,C),v.return=m,v):(v=r(v,w),v.return=m,v)}function h(m,v,w){if(typeof v=="string"&&v!==""||typeof v=="number")return v=nN(""+v,m.mode,w),v.return=m,v;if(typeof v=="object"&&v!==null){switch(v.$$typeof){case DT:return w=k_(v.type,v.key,v.props,null,m.mode,w),w.ref=Yb(m,null,v),w.return=m,w;case Tg:return v=iN(v,m.mode,w),v.return=m,v;case Ah:var S=v._init;return h(m,S(v._payload),w)}if(kx(v)||Hb(v))return v=Jp(v,m.mode,w,null),v.return=m,v;XT(m,v)}return null}function d(m,v,w,S){var C=v!==null?v.key:null;if(typeof w=="string"&&w!==""||typeof w=="number")return C!==null?null:a(m,v,""+w,S);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case DT:return w.key===C?l(m,v,w,S):null;case Tg:return w.key===C?u(m,v,w,S):null;case Ah:return C=w._init,d(m,v,C(w._payload),S)}if(kx(w)||Hb(w))return C!==null?null:c(m,v,w,S,null);XT(m,w)}return null}function p(m,v,w,S,C){if(typeof S=="string"&&S!==""||typeof S=="number")return m=m.get(w)||null,a(v,m,""+S,C);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case DT:return m=m.get(S.key===null?w:S.key)||null,l(v,m,S,C);case Tg:return m=m.get(S.key===null?w:S.key)||null,u(v,m,S,C);case Ah:var _=S._init;return p(m,v,w,_(S._payload),C)}if(kx(S)||Hb(S))return m=m.get(w)||null,c(v,m,S,C,null);XT(v,S)}return null}function f(m,v,w,S){for(var C=null,_=null,A=v,I=v=0,E=null;A!==null&&I<w.length;I++){A.index>I?(E=A,A=null):E=A.sibling;var k=d(m,A,w[I],S);if(k===null){A===null&&(A=E);break}n&&A&&k.alternate===null&&e(m,A),v=s(k,v,I),_===null?C=k:_.sibling=k,_=k,A=E}if(I===w.length)return t(m,A),xi&&yp(m,I),C;if(A===null){for(;I<w.length;I++)A=h(m,w[I],S),A!==null&&(v=s(A,v,I),_===null?C=A:_.sibling=A,_=A);return xi&&yp(m,I),C}for(A=i(m,A);I<w.length;I++)E=p(A,m,I,w[I],S),E!==null&&(n&&E.alternate!==null&&A.delete(E.key===null?I:E.key),v=s(E,v,I),_===null?C=E:_.sibling=E,_=E);return n&&A.forEach(function(P){return e(m,P)}),xi&&yp(m,I),C}function g(m,v,w,S){var C=Hb(w);if(typeof C!="function")throw Error(et(150));if(w=C.call(w),w==null)throw Error(et(151));for(var _=C=null,A=v,I=v=0,E=null,k=w.next();A!==null&&!k.done;I++,k=w.next()){A.index>I?(E=A,A=null):E=A.sibling;var P=d(m,A,k.value,S);if(P===null){A===null&&(A=E);break}n&&A&&P.alternate===null&&e(m,A),v=s(P,v,I),_===null?C=P:_.sibling=P,_=P,A=E}if(k.done)return t(m,A),xi&&yp(m,I),C;if(A===null){for(;!k.done;I++,k=w.next())k=h(m,k.value,S),k!==null&&(v=s(k,v,I),_===null?C=k:_.sibling=k,_=k);return xi&&yp(m,I),C}for(A=i(m,A);!k.done;I++,k=w.next())k=p(A,m,I,k.value,S),k!==null&&(n&&k.alternate!==null&&A.delete(k.key===null?I:k.key),v=s(k,v,I),_===null?C=k:_.sibling=k,_=k);return n&&A.forEach(function(V){return e(m,V)}),xi&&yp(m,I),C}function y(m,v,w,S){if(typeof w=="object"&&w!==null&&w.type===Cg&&w.key===null&&(w=w.props.children),typeof w=="object"&&w!==null){switch(w.$$typeof){case DT:e:{for(var C=w.key,_=v;_!==null;){if(_.key===C){if(C=w.type,C===Cg){if(_.tag===7){t(m,_.sibling),v=r(_,w.props.children),v.return=m,m=v;break e}}else if(_.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===Ah&&QH(C)===_.type){t(m,_.sibling),v=r(_,w.props),v.ref=Yb(m,_,w),v.return=m,m=v;break e}t(m,_);break}else e(m,_);_=_.sibling}w.type===Cg?(v=Jp(w.props.children,m.mode,S,w.key),v.return=m,m=v):(S=k_(w.type,w.key,w.props,null,m.mode,S),S.ref=Yb(m,v,w),S.return=m,m=S)}return o(m);case Tg:e:{for(_=w.key;v!==null;){if(v.key===_)if(v.tag===4&&v.stateNode.containerInfo===w.containerInfo&&v.stateNode.implementation===w.implementation){t(m,v.sibling),v=r(v,w.children||[]),v.return=m,m=v;break e}else{t(m,v);break}else e(m,v);v=v.sibling}v=iN(w,m.mode,S),v.return=m,m=v}return o(m);case Ah:return _=w._init,y(m,v,_(w._payload),S)}if(kx(w))return f(m,v,w,S);if(Hb(w))return g(m,v,w,S);XT(m,w)}return typeof w=="string"&&w!==""||typeof w=="number"?(w=""+w,v!==null&&v.tag===6?(t(m,v.sibling),v=r(v,w),v.return=m,m=v):(t(m,v),v=nN(w,m.mode,S),v.return=m,m=v),o(m)):t(m,v)}return y}var my=a6(!0),l6=a6(!1),A1={},_u=Ad(A1),Mv=Ad(A1),Av=Ad(A1);function Bp(n){if(n===A1)throw Error(et(174));return n}function wO(n,e){switch(ei(Av,e),ei(Mv,n),ei(_u,A1),n=e.nodeType,n){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:DP(null,"");break;default:n=n===8?e.parentNode:e,e=n.namespaceURI||null,n=n.tagName,e=DP(e,n)}di(_u),ei(_u,e)}function gy(){di(_u),di(Mv),di(Av)}function u6(n){Bp(Av.current);var e=Bp(_u.current),t=DP(e,n.type);e!==t&&(ei(Mv,n),ei(_u,t))}function SO(n){Mv.current===n&&(di(_u),di(Mv))}var Ai=Ad(0);function dM(n){for(var e=n;e!==null;){if(e.tag===13){var t=e.memoizedState;if(t!==null&&(t=t.dehydrated,t===null||t.data==="$?"||t.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var YR=[];function TO(){for(var n=0;n<YR.length;n++)YR[n]._workInProgressVersionPrimary=null;YR.length=0}var __=Xc.ReactCurrentDispatcher,JR=Xc.ReactCurrentBatchConfig,ff=0,Ni=null,wr=null,Vr=null,pM=!1,Kx=!1,Ev=0,rce=0;function xs(){throw Error(et(321))}function CO(n,e){if(e===null)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!Bl(n[t],e[t]))return!1;return!0}function _O(n,e,t,i,r,s){if(ff=s,Ni=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,__.current=n===null||n.memoizedState===null?lce:uce,n=t(i,r),Kx){s=0;do{if(Kx=!1,Ev=0,25<=s)throw Error(et(301));s+=1,Vr=wr=null,e.updateQueue=null,__.current=cce,n=t(i,r)}while(Kx)}if(__.current=fM,e=wr!==null&&wr.next!==null,ff=0,Vr=wr=Ni=null,pM=!1,e)throw Error(et(300));return n}function MO(){var n=Ev!==0;return Ev=0,n}function pu(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Vr===null?Ni.memoizedState=Vr=n:Vr=Vr.next=n,Vr}function Ja(){if(wr===null){var n=Ni.alternate;n=n!==null?n.memoizedState:null}else n=wr.next;var e=Vr===null?Ni.memoizedState:Vr.next;if(e!==null)Vr=e,wr=n;else{if(n===null)throw Error(et(310));wr=n,n={memoizedState:wr.memoizedState,baseState:wr.baseState,baseQueue:wr.baseQueue,queue:wr.queue,next:null},Vr===null?Ni.memoizedState=Vr=n:Vr=Vr.next=n}return Vr}function Iv(n,e){return typeof e=="function"?e(n):e}function QR(n){var e=Ja(),t=e.queue;if(t===null)throw Error(et(311));t.lastRenderedReducer=n;var i=wr,r=i.baseQueue,s=t.pending;if(s!==null){if(r!==null){var o=r.next;r.next=s.next,s.next=o}i.baseQueue=r=s,t.pending=null}if(r!==null){s=r.next,i=i.baseState;var a=o=null,l=null,u=s;do{var c=u.lane;if((ff&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),i=u.hasEagerState?u.eagerState:n(i,u.action);else{var h={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(a=l=h,o=i):l=l.next=h,Ni.lanes|=c,mf|=c}u=u.next}while(u!==null&&u!==s);l===null?o=i:l.next=a,Bl(i,e.memoizedState)||(So=!0),e.memoizedState=i,e.baseState=o,e.baseQueue=l,t.lastRenderedState=i}if(n=t.interleaved,n!==null){r=n;do s=r.lane,Ni.lanes|=s,mf|=s,r=r.next;while(r!==n)}else r===null&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function qR(n){var e=Ja(),t=e.queue;if(t===null)throw Error(et(311));t.lastRenderedReducer=n;var i=t.dispatch,r=t.pending,s=e.memoizedState;if(r!==null){t.pending=null;var o=r=r.next;do s=n(s,o.action),o=o.next;while(o!==r);Bl(s,e.memoizedState)||(So=!0),e.memoizedState=s,e.baseQueue===null&&(e.baseState=s),t.lastRenderedState=s}return[s,i]}function c6(){}function h6(n,e){var t=Ni,i=Ja(),r=e(),s=!Bl(i.memoizedState,r);if(s&&(i.memoizedState=r,So=!0),i=i.queue,AO(f6.bind(null,t,i,n),[n]),i.getSnapshot!==e||s||Vr!==null&&Vr.memoizedState.tag&1){if(t.flags|=2048,kv(9,p6.bind(null,t,i,r,e),void 0,null),Hr===null)throw Error(et(349));ff&30||d6(t,e,r)}return r}function d6(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},e=Ni.updateQueue,e===null?(e={lastEffect:null,stores:null},Ni.updateQueue=e,e.stores=[n]):(t=e.stores,t===null?e.stores=[n]:t.push(n))}function p6(n,e,t,i){e.value=t,e.getSnapshot=i,m6(e)&&g6(n)}function f6(n,e,t){return t(function(){m6(e)&&g6(n)})}function m6(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!Bl(n,t)}catch{return!0}}function g6(n){var e=Nc(n,1);e!==null&&kl(e,n,1,-1)}function qH(n){var e=pu();return typeof n=="function"&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Iv,lastRenderedState:n},e.queue=n,n=n.dispatch=ace.bind(null,Ni,n),[e.memoizedState,n]}function kv(n,e,t,i){return n={tag:n,create:e,destroy:t,deps:i,next:null},e=Ni.updateQueue,e===null?(e={lastEffect:null,stores:null},Ni.updateQueue=e,e.lastEffect=n.next=n):(t=e.lastEffect,t===null?e.lastEffect=n.next=n:(i=t.next,t.next=n,n.next=i,e.lastEffect=n)),n}function y6(){return Ja().memoizedState}function M_(n,e,t,i){var r=pu();Ni.flags|=n,r.memoizedState=kv(1|e,t,void 0,i===void 0?null:i)}function FA(n,e,t,i){var r=Ja();i=i===void 0?null:i;var s=void 0;if(wr!==null){var o=wr.memoizedState;if(s=o.destroy,i!==null&&CO(i,o.deps)){r.memoizedState=kv(e,t,s,i);return}}Ni.flags|=n,r.memoizedState=kv(1|e,t,s,i)}function eX(n,e){return M_(8390656,8,n,e)}function AO(n,e){return FA(2048,8,n,e)}function b6(n,e){return FA(4,2,n,e)}function x6(n,e){return FA(4,4,n,e)}function v6(n,e){if(typeof e=="function")return n=n(),e(n),function(){e(null)};if(e!=null)return n=n(),e.current=n,function(){e.current=null}}function w6(n,e,t){return t=t!=null?t.concat([n]):null,FA(4,4,v6.bind(null,e,n),t)}function EO(){}function S6(n,e){var t=Ja();e=e===void 0?null:e;var i=t.memoizedState;return i!==null&&e!==null&&CO(e,i[1])?i[0]:(t.memoizedState=[n,e],n)}function T6(n,e){var t=Ja();e=e===void 0?null:e;var i=t.memoizedState;return i!==null&&e!==null&&CO(e,i[1])?i[0]:(n=n(),t.memoizedState=[n,e],n)}function C6(n,e,t){return ff&21?(Bl(t,e)||(t=A8(),Ni.lanes|=t,mf|=t,n.baseState=!0),e):(n.baseState&&(n.baseState=!1,So=!0),n.memoizedState=t)}function sce(n,e){var t=Un;Un=t!==0&&4>t?t:4,n(!0);var i=JR.transition;JR.transition={};try{n(!1),e()}finally{Un=t,JR.transition=i}}function _6(){return Ja().memoizedState}function oce(n,e,t){var i=Yh(n);if(t={lane:i,action:t,hasEagerState:!1,eagerState:null,next:null},M6(n))A6(e,t);else if(t=i6(n,e,t,i),t!==null){var r=Zs();kl(t,n,i,r),E6(t,e,i)}}function ace(n,e,t){var i=Yh(n),r={lane:i,action:t,hasEagerState:!1,eagerState:null,next:null};if(M6(n))A6(e,r);else{var s=n.alternate;if(n.lanes===0&&(s===null||s.lanes===0)&&(s=e.lastRenderedReducer,s!==null))try{var o=e.lastRenderedState,a=s(o,t);if(r.hasEagerState=!0,r.eagerState=a,Bl(a,o)){var l=e.interleaved;l===null?(r.next=r,xO(e)):(r.next=l.next,l.next=r),e.interleaved=r;return}}catch{}finally{}t=i6(n,e,r,i),t!==null&&(r=Zs(),kl(t,n,i,r),E6(t,e,i))}}function M6(n){var e=n.alternate;return n===Ni||e!==null&&e===Ni}function A6(n,e){Kx=pM=!0;var t=n.pending;t===null?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function E6(n,e,t){if(t&4194240){var i=e.lanes;i&=n.pendingLanes,t|=i,e.lanes=t,sO(n,t)}}var fM={readContext:Ya,useCallback:xs,useContext:xs,useEffect:xs,useImperativeHandle:xs,useInsertionEffect:xs,useLayoutEffect:xs,useMemo:xs,useReducer:xs,useRef:xs,useState:xs,useDebugValue:xs,useDeferredValue:xs,useTransition:xs,useMutableSource:xs,useSyncExternalStore:xs,useId:xs,unstable_isNewReconciler:!1},lce={readContext:Ya,useCallback:function(n,e){return pu().memoizedState=[n,e===void 0?null:e],n},useContext:Ya,useEffect:eX,useImperativeHandle:function(n,e,t){return t=t!=null?t.concat([n]):null,M_(4194308,4,v6.bind(null,e,n),t)},useLayoutEffect:function(n,e){return M_(4194308,4,n,e)},useInsertionEffect:function(n,e){return M_(4,2,n,e)},useMemo:function(n,e){var t=pu();return e=e===void 0?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var i=pu();return e=t!==void 0?t(e):e,i.memoizedState=i.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},i.queue=n,n=n.dispatch=oce.bind(null,Ni,n),[i.memoizedState,n]},useRef:function(n){var e=pu();return n={current:n},e.memoizedState=n},useState:qH,useDebugValue:EO,useDeferredValue:function(n){return pu().memoizedState=n},useTransition:function(){var n=qH(!1),e=n[0];return n=sce.bind(null,n[1]),pu().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var i=Ni,r=pu();if(xi){if(t===void 0)throw Error(et(407));t=t()}else{if(t=e(),Hr===null)throw Error(et(349));ff&30||d6(i,e,t)}r.memoizedState=t;var s={value:t,getSnapshot:e};return r.queue=s,eX(f6.bind(null,i,s,n),[n]),i.flags|=2048,kv(9,p6.bind(null,i,s,t,e),void 0,null),t},useId:function(){var n=pu(),e=Hr.identifierPrefix;if(xi){var t=yc,i=gc;t=(i&~(1<<32-Il(i)-1)).toString(32)+t,e=":"+e+"R"+t,t=Ev++,0<t&&(e+="H"+t.toString(32)),e+=":"}else t=rce++,e=":"+e+"r"+t.toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},uce={readContext:Ya,useCallback:S6,useContext:Ya,useEffect:AO,useImperativeHandle:w6,useInsertionEffect:b6,useLayoutEffect:x6,useMemo:T6,useReducer:QR,useRef:y6,useState:function(){return QR(Iv)},useDebugValue:EO,useDeferredValue:function(n){var e=Ja();return C6(e,wr.memoizedState,n)},useTransition:function(){var n=QR(Iv)[0],e=Ja().memoizedState;return[n,e]},useMutableSource:c6,useSyncExternalStore:h6,useId:_6,unstable_isNewReconciler:!1},cce={readContext:Ya,useCallback:S6,useContext:Ya,useEffect:AO,useImperativeHandle:w6,useInsertionEffect:b6,useLayoutEffect:x6,useMemo:T6,useReducer:qR,useRef:y6,useState:function(){return qR(Iv)},useDebugValue:EO,useDeferredValue:function(n){var e=Ja();return wr===null?e.memoizedState=n:C6(e,wr.memoizedState,n)},useTransition:function(){var n=qR(Iv)[0],e=Ja().memoizedState;return[n,e]},useMutableSource:c6,useSyncExternalStore:h6,useId:_6,unstable_isNewReconciler:!1};function yy(n,e){try{var t="",i=e;do t+=Ble(i),i=i.return;while(i);var r=t}catch(s){r=`
Error generating stack: `+s.message+`
`+s.stack}return{value:n,source:e,stack:r,digest:null}}function eN(n,e,t){return{value:n,source:null,stack:t??null,digest:e??null}}function rD(n,e){try{console.error(e.value)}catch(t){setTimeout(function(){throw t})}}var hce=typeof WeakMap=="function"?WeakMap:Map;function I6(n,e,t){t=wc(-1,t),t.tag=3,t.payload={element:null};var i=e.value;return t.callback=function(){gM||(gM=!0,fD=i),rD(n,e)},t}function k6(n,e,t){t=wc(-1,t),t.tag=3;var i=n.type.getDerivedStateFromError;if(typeof i=="function"){var r=e.value;t.payload=function(){return i(r)},t.callback=function(){rD(n,e)}}var s=n.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(t.callback=function(){rD(n,e),typeof i!="function"&&(jh===null?jh=new Set([this]):jh.add(this));var o=e.stack;this.componentDidCatch(e.value,{componentStack:o!==null?o:""})}),t}function tX(n,e,t){var i=n.pingCache;if(i===null){i=n.pingCache=new hce;var r=new Set;i.set(e,r)}else r=i.get(e),r===void 0&&(r=new Set,i.set(e,r));r.has(t)||(r.add(t),n=_ce.bind(null,n,e,t),e.then(n,n))}function nX(n){do{var e;if((e=n.tag===13)&&(e=n.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return n;n=n.return}while(n!==null);return null}function iX(n,e,t,i,r){return n.mode&1?(n.flags|=65536,n.lanes=r,n):(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,t.tag===1&&(t.alternate===null?t.tag=17:(e=wc(-1,1),e.tag=2,Zh(t,e,1))),t.lanes|=1),n)}var dce=Xc.ReactCurrentOwner,So=!1;function Hs(n,e,t,i){e.child=n===null?l6(e,null,t,i):my(e,n.child,t,i)}function rX(n,e,t,i,r){t=t.render;var s=e.ref;return qg(e,r),i=_O(n,e,t,i,s,r),t=MO(),n!==null&&!So?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Lc(n,e,r)):(xi&&t&&pO(e),e.flags|=1,Hs(n,e,i,r),e.child)}function sX(n,e,t,i,r){if(n===null){var s=t.type;return typeof s=="function"&&!FO(s)&&s.defaultProps===void 0&&t.compare===null&&t.defaultProps===void 0?(e.tag=15,e.type=s,R6(n,e,s,i,r)):(n=k_(t.type,null,i,e,e.mode,r),n.ref=e.ref,n.return=e,e.child=n)}if(s=n.child,!(n.lanes&r)){var o=s.memoizedProps;if(t=t.compare,t=t!==null?t:Sv,t(o,i)&&n.ref===e.ref)return Lc(n,e,r)}return e.flags|=1,n=Jh(s,i),n.ref=e.ref,n.return=e,e.child=n}function R6(n,e,t,i,r){if(n!==null){var s=n.memoizedProps;if(Sv(s,i)&&n.ref===e.ref)if(So=!1,e.pendingProps=i=s,(n.lanes&r)!==0)n.flags&131072&&(So=!0);else return e.lanes=n.lanes,Lc(n,e,r)}return sD(n,e,t,i,r)}function N6(n,e,t){var i=e.pendingProps,r=i.children,s=n!==null?n.memoizedState:null;if(i.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},ei(Pg,Ko),Ko|=t;else{if(!(t&1073741824))return n=s!==null?s.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,ei(Pg,Ko),Ko|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},i=s!==null?s.baseLanes:t,ei(Pg,Ko),Ko|=i}else s!==null?(i=s.baseLanes|t,e.memoizedState=null):i=t,ei(Pg,Ko),Ko|=i;return Hs(n,e,r,t),e.child}function L6(n,e){var t=e.ref;(n===null&&t!==null||n!==null&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function sD(n,e,t,i,r){var s=Ao(t)?df:Ns.current;return s=py(e,s),qg(e,r),t=_O(n,e,t,i,s,r),i=MO(),n!==null&&!So?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Lc(n,e,r)):(xi&&i&&pO(e),e.flags|=1,Hs(n,e,t,r),e.child)}function oX(n,e,t,i,r){if(Ao(t)){var s=!0;oM(e)}else s=!1;if(qg(e,r),e.stateNode===null)A_(n,e),o6(e,t,i),iD(e,t,i,r),i=!0;else if(n===null){var o=e.stateNode,a=e.memoizedProps;o.props=a;var l=o.context,u=t.contextType;typeof u=="object"&&u!==null?u=Ya(u):(u=Ao(t)?df:Ns.current,u=py(e,u));var c=t.getDerivedStateFromProps,h=typeof c=="function"||typeof o.getSnapshotBeforeUpdate=="function";h||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==i||l!==u)&&JH(e,o,i,u),Eh=!1;var d=e.memoizedState;o.state=d,hM(e,i,o,r),l=e.memoizedState,a!==i||d!==l||Mo.current||Eh?(typeof c=="function"&&(nD(e,t,c,i),l=e.memoizedState),(a=Eh||YH(e,t,a,i,d,l,u))?(h||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(e.flags|=4194308)):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=i,e.memoizedState=l),o.props=i,o.state=l,o.context=u,i=a):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),i=!1)}else{o=e.stateNode,r6(n,e),a=e.memoizedProps,u=e.type===e.elementType?a:bl(e.type,a),o.props=u,h=e.pendingProps,d=o.context,l=t.contextType,typeof l=="object"&&l!==null?l=Ya(l):(l=Ao(t)?df:Ns.current,l=py(e,l));var p=t.getDerivedStateFromProps;(c=typeof p=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==h||d!==l)&&JH(e,o,i,l),Eh=!1,d=e.memoizedState,o.state=d,hM(e,i,o,r);var f=e.memoizedState;a!==h||d!==f||Mo.current||Eh?(typeof p=="function"&&(nD(e,t,p,i),f=e.memoizedState),(u=Eh||YH(e,t,u,i,d,f,l)||!1)?(c||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(i,f,l),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(i,f,l)),typeof o.componentDidUpdate=="function"&&(e.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),e.memoizedProps=i,e.memoizedState=f),o.props=i,o.state=f,o.context=l,i=u):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),i=!1)}return oD(n,e,t,i,s,r)}function oD(n,e,t,i,r,s){L6(n,e);var o=(e.flags&128)!==0;if(!i&&!o)return r&&HH(e,t,!1),Lc(n,e,s);i=e.stateNode,dce.current=e;var a=o&&typeof t.getDerivedStateFromError!="function"?null:i.render();return e.flags|=1,n!==null&&o?(e.child=my(e,n.child,null,s),e.child=my(e,null,a,s)):Hs(n,e,a,s),e.memoizedState=i.state,r&&HH(e,t,!0),e.child}function P6(n){var e=n.stateNode;e.pendingContext?WH(n,e.pendingContext,e.pendingContext!==e.context):e.context&&WH(n,e.context,!1),wO(n,e.containerInfo)}function aX(n,e,t,i,r){return fy(),mO(r),e.flags|=256,Hs(n,e,t,i),e.child}var aD={dehydrated:null,treeContext:null,retryLane:0};function lD(n){return{baseLanes:n,cachePool:null,transitions:null}}function D6(n,e,t){var i=e.pendingProps,r=Ai.current,s=!1,o=(e.flags&128)!==0,a;if((a=o)||(a=n!==null&&n.memoizedState===null?!1:(r&2)!==0),a?(s=!0,e.flags&=-129):(n===null||n.memoizedState!==null)&&(r|=1),ei(Ai,r&1),n===null)return eD(e),n=e.memoizedState,n!==null&&(n=n.dehydrated,n!==null)?(e.mode&1?n.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(o=i.children,n=i.fallback,s?(i=e.mode,s=e.child,o={mode:"hidden",children:o},!(i&1)&&s!==null?(s.childLanes=0,s.pendingProps=o):s=zA(o,i,0,null),n=Jp(n,i,t,null),s.return=e,n.return=e,s.sibling=n,e.child=s,e.child.memoizedState=lD(t),e.memoizedState=aD,n):IO(e,o));if(r=n.memoizedState,r!==null&&(a=r.dehydrated,a!==null))return pce(n,e,o,i,a,r,t);if(s){s=i.fallback,o=e.mode,r=n.child,a=r.sibling;var l={mode:"hidden",children:i.children};return!(o&1)&&e.child!==r?(i=e.child,i.childLanes=0,i.pendingProps=l,e.deletions=null):(i=Jh(r,l),i.subtreeFlags=r.subtreeFlags&14680064),a!==null?s=Jh(a,s):(s=Jp(s,o,t,null),s.flags|=2),s.return=e,i.return=e,i.sibling=s,e.child=i,i=s,s=e.child,o=n.child.memoizedState,o=o===null?lD(t):{baseLanes:o.baseLanes|t,cachePool:null,transitions:o.transitions},s.memoizedState=o,s.childLanes=n.childLanes&~t,e.memoizedState=aD,i}return s=n.child,n=s.sibling,i=Jh(s,{mode:"visible",children:i.children}),!(e.mode&1)&&(i.lanes=t),i.return=e,i.sibling=null,n!==null&&(t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=i,e.memoizedState=null,i}function IO(n,e){return e=zA({mode:"visible",children:e},n.mode,0,null),e.return=n,n.child=e}function KT(n,e,t,i){return i!==null&&mO(i),my(e,n.child,null,t),n=IO(e,e.pendingProps.children),n.flags|=2,e.memoizedState=null,n}function pce(n,e,t,i,r,s,o){if(t)return e.flags&256?(e.flags&=-257,i=eN(Error(et(422))),KT(n,e,o,i)):e.memoizedState!==null?(e.child=n.child,e.flags|=128,null):(s=i.fallback,r=e.mode,i=zA({mode:"visible",children:i.children},r,0,null),s=Jp(s,r,o,null),s.flags|=2,i.return=e,s.return=e,i.sibling=s,e.child=i,e.mode&1&&my(e,n.child,null,o),e.child.memoizedState=lD(o),e.memoizedState=aD,s);if(!(e.mode&1))return KT(n,e,o,null);if(r.data==="$!"){if(i=r.nextSibling&&r.nextSibling.dataset,i)var a=i.dgst;return i=a,s=Error(et(419)),i=eN(s,i,void 0),KT(n,e,o,i)}if(a=(o&n.childLanes)!==0,So||a){if(i=Hr,i!==null){switch(o&-o){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}r=r&(i.suspendedLanes|o)?0:r,r!==0&&r!==s.retryLane&&(s.retryLane=r,Nc(n,r),kl(i,n,r,-1))}return DO(),i=eN(Error(et(421))),KT(n,e,o,i)}return r.data==="$?"?(e.flags|=128,e.child=n.child,e=Mce.bind(null,n),r._reactRetry=e,null):(n=s.treeContext,Jo=Kh(r.nextSibling),na=e,xi=!0,Sl=null,n!==null&&(Va[Ua++]=gc,Va[Ua++]=yc,Va[Ua++]=pf,gc=n.id,yc=n.overflow,pf=e),e=IO(e,i.children),e.flags|=4096,e)}function lX(n,e,t){n.lanes|=e;var i=n.alternate;i!==null&&(i.lanes|=e),tD(n.return,e,t)}function tN(n,e,t,i,r){var s=n.memoizedState;s===null?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:i,tail:t,tailMode:r}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=i,s.tail=t,s.tailMode=r)}function F6(n,e,t){var i=e.pendingProps,r=i.revealOrder,s=i.tail;if(Hs(n,e,i.children,t),i=Ai.current,i&2)i=i&1|2,e.flags|=128;else{if(n!==null&&n.flags&128)e:for(n=e.child;n!==null;){if(n.tag===13)n.memoizedState!==null&&lX(n,t,e);else if(n.tag===19)lX(n,t,e);else if(n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break e;for(;n.sibling===null;){if(n.return===null||n.return===e)break e;n=n.return}n.sibling.return=n.return,n=n.sibling}i&=1}if(ei(Ai,i),!(e.mode&1))e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;t!==null;)n=t.alternate,n!==null&&dM(n)===null&&(r=t),t=t.sibling;t=r,t===null?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),tN(e,!1,r,t,s);break;case"backwards":for(t=null,r=e.child,e.child=null;r!==null;){if(n=r.alternate,n!==null&&dM(n)===null){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}tN(e,!0,t,null,s);break;case"together":tN(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function A_(n,e){!(e.mode&1)&&n!==null&&(n.alternate=null,e.alternate=null,e.flags|=2)}function Lc(n,e,t){if(n!==null&&(e.dependencies=n.dependencies),mf|=e.lanes,!(t&e.childLanes))return null;if(n!==null&&e.child!==n.child)throw Error(et(153));if(e.child!==null){for(n=e.child,t=Jh(n,n.pendingProps),e.child=t,t.return=e;n.sibling!==null;)n=n.sibling,t=t.sibling=Jh(n,n.pendingProps),t.return=e;t.sibling=null}return e.child}function fce(n,e,t){switch(e.tag){case 3:P6(e),fy();break;case 5:u6(e);break;case 1:Ao(e.type)&&oM(e);break;case 4:wO(e,e.stateNode.containerInfo);break;case 10:var i=e.type._context,r=e.memoizedProps.value;ei(uM,i._currentValue),i._currentValue=r;break;case 13:if(i=e.memoizedState,i!==null)return i.dehydrated!==null?(ei(Ai,Ai.current&1),e.flags|=128,null):t&e.child.childLanes?D6(n,e,t):(ei(Ai,Ai.current&1),n=Lc(n,e,t),n!==null?n.sibling:null);ei(Ai,Ai.current&1);break;case 19:if(i=(t&e.childLanes)!==0,n.flags&128){if(i)return F6(n,e,t);e.flags|=128}if(r=e.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),ei(Ai,Ai.current),i)break;return null;case 22:case 23:return e.lanes=0,N6(n,e,t)}return Lc(n,e,t)}var O6,uD,B6,z6;O6=function(n,e){for(var t=e.child;t!==null;){if(t.tag===5||t.tag===6)n.appendChild(t.stateNode);else if(t.tag!==4&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}};uD=function(){};B6=function(n,e,t,i){var r=n.memoizedProps;if(r!==i){n=e.stateNode,Bp(_u.current);var s=null;switch(t){case"input":r=RP(n,r),i=RP(n,i),s=[];break;case"select":r=Di({},r,{value:void 0}),i=Di({},i,{value:void 0}),s=[];break;case"textarea":r=PP(n,r),i=PP(n,i),s=[];break;default:typeof r.onClick!="function"&&typeof i.onClick=="function"&&(n.onclick=rM)}FP(t,i);var o;t=null;for(u in r)if(!i.hasOwnProperty(u)&&r.hasOwnProperty(u)&&r[u]!=null)if(u==="style"){var a=r[u];for(o in a)a.hasOwnProperty(o)&&(t||(t={}),t[o]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(mv.hasOwnProperty(u)?s||(s=[]):(s=s||[]).push(u,null));for(u in i){var l=i[u];if(a=r!=null?r[u]:void 0,i.hasOwnProperty(u)&&l!==a&&(l!=null||a!=null))if(u==="style")if(a){for(o in a)!a.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(t||(t={}),t[o]="");for(o in l)l.hasOwnProperty(o)&&a[o]!==l[o]&&(t||(t={}),t[o]=l[o])}else t||(s||(s=[]),s.push(u,t)),t=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(s=s||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(mv.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&ai("scroll",n),s||a===l||(s=[])):(s=s||[]).push(u,l))}t&&(s=s||[]).push("style",t);var u=s;(e.updateQueue=u)&&(e.flags|=4)}};z6=function(n,e,t,i){t!==i&&(e.flags|=4)};function Jb(n,e){if(!xi)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;e!==null;)e.alternate!==null&&(t=e),e=e.sibling;t===null?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var i=null;t!==null;)t.alternate!==null&&(i=t),t=t.sibling;i===null?e||n.tail===null?n.tail=null:n.tail.sibling=null:i.sibling=null}}function vs(n){var e=n.alternate!==null&&n.alternate.child===n.child,t=0,i=0;if(e)for(var r=n.child;r!==null;)t|=r.lanes|r.childLanes,i|=r.subtreeFlags&14680064,i|=r.flags&14680064,r.return=n,r=r.sibling;else for(r=n.child;r!==null;)t|=r.lanes|r.childLanes,i|=r.subtreeFlags,i|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=i,n.childLanes=t,e}function mce(n,e,t){var i=e.pendingProps;switch(fO(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return vs(e),null;case 1:return Ao(e.type)&&sM(),vs(e),null;case 3:return i=e.stateNode,gy(),di(Mo),di(Ns),TO(),i.pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),(n===null||n.child===null)&&(HT(e)?e.flags|=4:n===null||n.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,Sl!==null&&(yD(Sl),Sl=null))),uD(n,e),vs(e),null;case 5:SO(e);var r=Bp(Av.current);if(t=e.type,n!==null&&e.stateNode!=null)B6(n,e,t,i,r),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!i){if(e.stateNode===null)throw Error(et(166));return vs(e),null}if(n=Bp(_u.current),HT(e)){i=e.stateNode,t=e.type;var s=e.memoizedProps;switch(i[bu]=e,i[_v]=s,n=(e.mode&1)!==0,t){case"dialog":ai("cancel",i),ai("close",i);break;case"iframe":case"object":case"embed":ai("load",i);break;case"video":case"audio":for(r=0;r<Nx.length;r++)ai(Nx[r],i);break;case"source":ai("error",i);break;case"img":case"image":case"link":ai("error",i),ai("load",i);break;case"details":ai("toggle",i);break;case"input":yH(i,s),ai("invalid",i);break;case"select":i._wrapperState={wasMultiple:!!s.multiple},ai("invalid",i);break;case"textarea":xH(i,s),ai("invalid",i)}FP(t,s),r=null;for(var o in s)if(s.hasOwnProperty(o)){var a=s[o];o==="children"?typeof a=="string"?i.textContent!==a&&(s.suppressHydrationWarning!==!0&&WT(i.textContent,a,n),r=["children",a]):typeof a=="number"&&i.textContent!==""+a&&(s.suppressHydrationWarning!==!0&&WT(i.textContent,a,n),r=["children",""+a]):mv.hasOwnProperty(o)&&a!=null&&o==="onScroll"&&ai("scroll",i)}switch(t){case"input":FT(i),bH(i,s,!0);break;case"textarea":FT(i),vH(i);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(i.onclick=rM)}i=r,e.updateQueue=i,i!==null&&(e.flags|=4)}else{o=r.nodeType===9?r:r.ownerDocument,n==="http://www.w3.org/1999/xhtml"&&(n=d8(t)),n==="http://www.w3.org/1999/xhtml"?t==="script"?(n=o.createElement("div"),n.innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):typeof i.is=="string"?n=o.createElement(t,{is:i.is}):(n=o.createElement(t),t==="select"&&(o=n,i.multiple?o.multiple=!0:i.size&&(o.size=i.size))):n=o.createElementNS(n,t),n[bu]=e,n[_v]=i,O6(n,e,!1,!1),e.stateNode=n;e:{switch(o=OP(t,i),t){case"dialog":ai("cancel",n),ai("close",n),r=i;break;case"iframe":case"object":case"embed":ai("load",n),r=i;break;case"video":case"audio":for(r=0;r<Nx.length;r++)ai(Nx[r],n);r=i;break;case"source":ai("error",n),r=i;break;case"img":case"image":case"link":ai("error",n),ai("load",n),r=i;break;case"details":ai("toggle",n),r=i;break;case"input":yH(n,i),r=RP(n,i),ai("invalid",n);break;case"option":r=i;break;case"select":n._wrapperState={wasMultiple:!!i.multiple},r=Di({},i,{value:void 0}),ai("invalid",n);break;case"textarea":xH(n,i),r=PP(n,i),ai("invalid",n);break;default:r=i}FP(t,r),a=r;for(s in a)if(a.hasOwnProperty(s)){var l=a[s];s==="style"?m8(n,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&p8(n,l)):s==="children"?typeof l=="string"?(t!=="textarea"||l!=="")&&gv(n,l):typeof l=="number"&&gv(n,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(mv.hasOwnProperty(s)?l!=null&&s==="onScroll"&&ai("scroll",n):l!=null&&qF(n,s,l,o))}switch(t){case"input":FT(n),bH(n,i,!1);break;case"textarea":FT(n),vH(n);break;case"option":i.value!=null&&n.setAttribute("value",""+ud(i.value));break;case"select":n.multiple=!!i.multiple,s=i.value,s!=null?jg(n,!!i.multiple,s,!1):i.defaultValue!=null&&jg(n,!!i.multiple,i.defaultValue,!0);break;default:typeof r.onClick=="function"&&(n.onclick=rM)}switch(t){case"button":case"input":case"select":case"textarea":i=!!i.autoFocus;break e;case"img":i=!0;break e;default:i=!1}}i&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return vs(e),null;case 6:if(n&&e.stateNode!=null)z6(n,e,n.memoizedProps,i);else{if(typeof i!="string"&&e.stateNode===null)throw Error(et(166));if(t=Bp(Av.current),Bp(_u.current),HT(e)){if(i=e.stateNode,t=e.memoizedProps,i[bu]=e,(s=i.nodeValue!==t)&&(n=na,n!==null))switch(n.tag){case 3:WT(i.nodeValue,t,(n.mode&1)!==0);break;case 5:n.memoizedProps.suppressHydrationWarning!==!0&&WT(i.nodeValue,t,(n.mode&1)!==0)}s&&(e.flags|=4)}else i=(t.nodeType===9?t:t.ownerDocument).createTextNode(i),i[bu]=e,e.stateNode=i}return vs(e),null;case 13:if(di(Ai),i=e.memoizedState,n===null||n.memoizedState!==null&&n.memoizedState.dehydrated!==null){if(xi&&Jo!==null&&e.mode&1&&!(e.flags&128))n6(),fy(),e.flags|=98560,s=!1;else if(s=HT(e),i!==null&&i.dehydrated!==null){if(n===null){if(!s)throw Error(et(318));if(s=e.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(et(317));s[bu]=e}else fy(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;vs(e),s=!1}else Sl!==null&&(yD(Sl),Sl=null),s=!0;if(!s)return e.flags&65536?e:null}return e.flags&128?(e.lanes=t,e):(i=i!==null,i!==(n!==null&&n.memoizedState!==null)&&i&&(e.child.flags|=8192,e.mode&1&&(n===null||Ai.current&1?Cr===0&&(Cr=3):DO())),e.updateQueue!==null&&(e.flags|=4),vs(e),null);case 4:return gy(),uD(n,e),n===null&&Tv(e.stateNode.containerInfo),vs(e),null;case 10:return bO(e.type._context),vs(e),null;case 17:return Ao(e.type)&&sM(),vs(e),null;case 19:if(di(Ai),s=e.memoizedState,s===null)return vs(e),null;if(i=(e.flags&128)!==0,o=s.rendering,o===null)if(i)Jb(s,!1);else{if(Cr!==0||n!==null&&n.flags&128)for(n=e.child;n!==null;){if(o=dM(n),o!==null){for(e.flags|=128,Jb(s,!1),i=o.updateQueue,i!==null&&(e.updateQueue=i,e.flags|=4),e.subtreeFlags=0,i=t,t=e.child;t!==null;)s=t,n=i,s.flags&=14680066,o=s.alternate,o===null?(s.childLanes=0,s.lanes=n,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=o.childLanes,s.lanes=o.lanes,s.child=o.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=o.memoizedProps,s.memoizedState=o.memoizedState,s.updateQueue=o.updateQueue,s.type=o.type,n=o.dependencies,s.dependencies=n===null?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return ei(Ai,Ai.current&1|2),e.child}n=n.sibling}s.tail!==null&&er()>by&&(e.flags|=128,i=!0,Jb(s,!1),e.lanes=4194304)}else{if(!i)if(n=dM(o),n!==null){if(e.flags|=128,i=!0,t=n.updateQueue,t!==null&&(e.updateQueue=t,e.flags|=4),Jb(s,!0),s.tail===null&&s.tailMode==="hidden"&&!o.alternate&&!xi)return vs(e),null}else 2*er()-s.renderingStartTime>by&&t!==1073741824&&(e.flags|=128,i=!0,Jb(s,!1),e.lanes=4194304);s.isBackwards?(o.sibling=e.child,e.child=o):(t=s.last,t!==null?t.sibling=o:e.child=o,s.last=o)}return s.tail!==null?(e=s.tail,s.rendering=e,s.tail=e.sibling,s.renderingStartTime=er(),e.sibling=null,t=Ai.current,ei(Ai,i?t&1|2:t&1),e):(vs(e),null);case 22:case 23:return PO(),i=e.memoizedState!==null,n!==null&&n.memoizedState!==null!==i&&(e.flags|=8192),i&&e.mode&1?Ko&1073741824&&(vs(e),e.subtreeFlags&6&&(e.flags|=8192)):vs(e),null;case 24:return null;case 25:return null}throw Error(et(156,e.tag))}function gce(n,e){switch(fO(e),e.tag){case 1:return Ao(e.type)&&sM(),n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 3:return gy(),di(Mo),di(Ns),TO(),n=e.flags,n&65536&&!(n&128)?(e.flags=n&-65537|128,e):null;case 5:return SO(e),null;case 13:if(di(Ai),n=e.memoizedState,n!==null&&n.dehydrated!==null){if(e.alternate===null)throw Error(et(340));fy()}return n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 19:return di(Ai),null;case 4:return gy(),null;case 10:return bO(e.type._context),null;case 22:case 23:return PO(),null;case 24:return null;default:return null}}var ZT=!1,Cs=!1,yce=typeof WeakSet=="function"?WeakSet:Set,St=null;function Lg(n,e){var t=n.ref;if(t!==null)if(typeof t=="function")try{t(null)}catch(i){Gi(n,e,i)}else t.current=null}function cD(n,e,t){try{t()}catch(i){Gi(n,e,i)}}var uX=!1;function bce(n,e){if(KP=tM,n=$8(),dO(n)){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else e:{t=(t=n.ownerDocument)&&t.defaultView||window;var i=t.getSelection&&t.getSelection();if(i&&i.rangeCount!==0){t=i.anchorNode;var r=i.anchorOffset,s=i.focusNode;i=i.focusOffset;try{t.nodeType,s.nodeType}catch{t=null;break e}var o=0,a=-1,l=-1,u=0,c=0,h=n,d=null;t:for(;;){for(var p;h!==t||r!==0&&h.nodeType!==3||(a=o+r),h!==s||i!==0&&h.nodeType!==3||(l=o+i),h.nodeType===3&&(o+=h.nodeValue.length),(p=h.firstChild)!==null;)d=h,h=p;for(;;){if(h===n)break t;if(d===t&&++u===r&&(a=o),d===s&&++c===i&&(l=o),(p=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=p}t=a===-1||l===-1?null:{start:a,end:l}}else t=null}t=t||{start:0,end:0}}else t=null;for(ZP={focusedElem:n,selectionRange:t},tM=!1,St=e;St!==null;)if(e=St,n=e.child,(e.subtreeFlags&1028)!==0&&n!==null)n.return=e,St=n;else for(;St!==null;){e=St;try{var f=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var g=f.memoizedProps,y=f.memoizedState,m=e.stateNode,v=m.getSnapshotBeforeUpdate(e.elementType===e.type?g:bl(e.type,g),y);m.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var w=e.stateNode.containerInfo;w.nodeType===1?w.textContent="":w.nodeType===9&&w.documentElement&&w.removeChild(w.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(et(163))}}catch(S){Gi(e,e.return,S)}if(n=e.sibling,n!==null){n.return=e.return,St=n;break}St=e.return}return f=uX,uX=!1,f}function Zx(n,e,t){var i=e.updateQueue;if(i=i!==null?i.lastEffect:null,i!==null){var r=i=i.next;do{if((r.tag&n)===n){var s=r.destroy;r.destroy=void 0,s!==void 0&&cD(e,t,s)}r=r.next}while(r!==i)}}function OA(n,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var t=e=e.next;do{if((t.tag&n)===n){var i=t.create;t.destroy=i()}t=t.next}while(t!==e)}}function hD(n){var e=n.ref;if(e!==null){var t=n.stateNode;switch(n.tag){case 5:n=t;break;default:n=t}typeof e=="function"?e(n):e.current=n}}function G6(n){var e=n.alternate;e!==null&&(n.alternate=null,G6(e)),n.child=null,n.deletions=null,n.sibling=null,n.tag===5&&(e=n.stateNode,e!==null&&(delete e[bu],delete e[_v],delete e[JP],delete e[ece],delete e[tce])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function V6(n){return n.tag===5||n.tag===3||n.tag===4}function cX(n){e:for(;;){for(;n.sibling===null;){if(n.return===null||V6(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;n.tag!==5&&n.tag!==6&&n.tag!==18;){if(n.flags&2||n.child===null||n.tag===4)continue e;n.child.return=n,n=n.child}if(!(n.flags&2))return n.stateNode}}function dD(n,e,t){var i=n.tag;if(i===5||i===6)n=n.stateNode,e?t.nodeType===8?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(t.nodeType===8?(e=t.parentNode,e.insertBefore(n,t)):(e=t,e.appendChild(n)),t=t._reactRootContainer,t!=null||e.onclick!==null||(e.onclick=rM));else if(i!==4&&(n=n.child,n!==null))for(dD(n,e,t),n=n.sibling;n!==null;)dD(n,e,t),n=n.sibling}function pD(n,e,t){var i=n.tag;if(i===5||i===6)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(i!==4&&(n=n.child,n!==null))for(pD(n,e,t),n=n.sibling;n!==null;)pD(n,e,t),n=n.sibling}var os=null,vl=!1;function fh(n,e,t){for(t=t.child;t!==null;)U6(n,e,t),t=t.sibling}function U6(n,e,t){if(Cu&&typeof Cu.onCommitFiberUnmount=="function")try{Cu.onCommitFiberUnmount(IA,t)}catch{}switch(t.tag){case 5:Cs||Lg(t,e);case 6:var i=os,r=vl;os=null,fh(n,e,t),os=i,vl=r,os!==null&&(vl?(n=os,t=t.stateNode,n.nodeType===8?n.parentNode.removeChild(t):n.removeChild(t)):os.removeChild(t.stateNode));break;case 18:os!==null&&(vl?(n=os,t=t.stateNode,n.nodeType===8?ZR(n.parentNode,t):n.nodeType===1&&ZR(n,t),vv(n)):ZR(os,t.stateNode));break;case 4:i=os,r=vl,os=t.stateNode.containerInfo,vl=!0,fh(n,e,t),os=i,vl=r;break;case 0:case 11:case 14:case 15:if(!Cs&&(i=t.updateQueue,i!==null&&(i=i.lastEffect,i!==null))){r=i=i.next;do{var s=r,o=s.destroy;s=s.tag,o!==void 0&&(s&2||s&4)&&cD(t,e,o),r=r.next}while(r!==i)}fh(n,e,t);break;case 1:if(!Cs&&(Lg(t,e),i=t.stateNode,typeof i.componentWillUnmount=="function"))try{i.props=t.memoizedProps,i.state=t.memoizedState,i.componentWillUnmount()}catch(a){Gi(t,e,a)}fh(n,e,t);break;case 21:fh(n,e,t);break;case 22:t.mode&1?(Cs=(i=Cs)||t.memoizedState!==null,fh(n,e,t),Cs=i):fh(n,e,t);break;default:fh(n,e,t)}}function hX(n){var e=n.updateQueue;if(e!==null){n.updateQueue=null;var t=n.stateNode;t===null&&(t=n.stateNode=new yce),e.forEach(function(i){var r=Ace.bind(null,n,i);t.has(i)||(t.add(i),i.then(r,r))})}}function cl(n,e){var t=e.deletions;if(t!==null)for(var i=0;i<t.length;i++){var r=t[i];try{var s=n,o=e,a=o;e:for(;a!==null;){switch(a.tag){case 5:os=a.stateNode,vl=!1;break e;case 3:os=a.stateNode.containerInfo,vl=!0;break e;case 4:os=a.stateNode.containerInfo,vl=!0;break e}a=a.return}if(os===null)throw Error(et(160));U6(s,o,r),os=null,vl=!1;var l=r.alternate;l!==null&&(l.return=null),r.return=null}catch(u){Gi(r,e,u)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)$6(e,n),e=e.sibling}function $6(n,e){var t=n.alternate,i=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(cl(e,n),au(n),i&4){try{Zx(3,n,n.return),OA(3,n)}catch(g){Gi(n,n.return,g)}try{Zx(5,n,n.return)}catch(g){Gi(n,n.return,g)}}break;case 1:cl(e,n),au(n),i&512&&t!==null&&Lg(t,t.return);break;case 5:if(cl(e,n),au(n),i&512&&t!==null&&Lg(t,t.return),n.flags&32){var r=n.stateNode;try{gv(r,"")}catch(g){Gi(n,n.return,g)}}if(i&4&&(r=n.stateNode,r!=null)){var s=n.memoizedProps,o=t!==null?t.memoizedProps:s,a=n.type,l=n.updateQueue;if(n.updateQueue=null,l!==null)try{a==="input"&&s.type==="radio"&&s.name!=null&&c8(r,s),OP(a,o);var u=OP(a,s);for(o=0;o<l.length;o+=2){var c=l[o],h=l[o+1];c==="style"?m8(r,h):c==="dangerouslySetInnerHTML"?p8(r,h):c==="children"?gv(r,h):qF(r,c,h,u)}switch(a){case"input":NP(r,s);break;case"textarea":h8(r,s);break;case"select":var d=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!s.multiple;var p=s.value;p!=null?jg(r,!!s.multiple,p,!1):d!==!!s.multiple&&(s.defaultValue!=null?jg(r,!!s.multiple,s.defaultValue,!0):jg(r,!!s.multiple,s.multiple?[]:"",!1))}r[_v]=s}catch(g){Gi(n,n.return,g)}}break;case 6:if(cl(e,n),au(n),i&4){if(n.stateNode===null)throw Error(et(162));r=n.stateNode,s=n.memoizedProps;try{r.nodeValue=s}catch(g){Gi(n,n.return,g)}}break;case 3:if(cl(e,n),au(n),i&4&&t!==null&&t.memoizedState.isDehydrated)try{vv(e.containerInfo)}catch(g){Gi(n,n.return,g)}break;case 4:cl(e,n),au(n);break;case 13:cl(e,n),au(n),r=n.child,r.flags&8192&&(s=r.memoizedState!==null,r.stateNode.isHidden=s,!s||r.alternate!==null&&r.alternate.memoizedState!==null||(NO=er())),i&4&&hX(n);break;case 22:if(c=t!==null&&t.memoizedState!==null,n.mode&1?(Cs=(u=Cs)||c,cl(e,n),Cs=u):cl(e,n),au(n),i&8192){if(u=n.memoizedState!==null,(n.stateNode.isHidden=u)&&!c&&n.mode&1)for(St=n,c=n.child;c!==null;){for(h=St=c;St!==null;){switch(d=St,p=d.child,d.tag){case 0:case 11:case 14:case 15:Zx(4,d,d.return);break;case 1:Lg(d,d.return);var f=d.stateNode;if(typeof f.componentWillUnmount=="function"){i=d,t=d.return;try{e=i,f.props=e.memoizedProps,f.state=e.memoizedState,f.componentWillUnmount()}catch(g){Gi(i,t,g)}}break;case 5:Lg(d,d.return);break;case 22:if(d.memoizedState!==null){pX(h);continue}}p!==null?(p.return=d,St=p):pX(h)}c=c.sibling}e:for(c=null,h=n;;){if(h.tag===5){if(c===null){c=h;try{r=h.stateNode,u?(s=r.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(a=h.stateNode,l=h.memoizedProps.style,o=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=f8("display",o))}catch(g){Gi(n,n.return,g)}}}else if(h.tag===6){if(c===null)try{h.stateNode.nodeValue=u?"":h.memoizedProps}catch(g){Gi(n,n.return,g)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===n)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===n)break e;for(;h.sibling===null;){if(h.return===null||h.return===n)break e;c===h&&(c=null),h=h.return}c===h&&(c=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:cl(e,n),au(n),i&4&&hX(n);break;case 21:break;default:cl(e,n),au(n)}}function au(n){var e=n.flags;if(e&2){try{e:{for(var t=n.return;t!==null;){if(V6(t)){var i=t;break e}t=t.return}throw Error(et(160))}switch(i.tag){case 5:var r=i.stateNode;i.flags&32&&(gv(r,""),i.flags&=-33);var s=cX(n);pD(n,s,r);break;case 3:case 4:var o=i.stateNode.containerInfo,a=cX(n);dD(n,a,o);break;default:throw Error(et(161))}}catch(l){Gi(n,n.return,l)}n.flags&=-3}e&4096&&(n.flags&=-4097)}function xce(n,e,t){St=n,W6(n)}function W6(n,e,t){for(var i=(n.mode&1)!==0;St!==null;){var r=St,s=r.child;if(r.tag===22&&i){var o=r.memoizedState!==null||ZT;if(!o){var a=r.alternate,l=a!==null&&a.memoizedState!==null||Cs;a=ZT;var u=Cs;if(ZT=o,(Cs=l)&&!u)for(St=r;St!==null;)o=St,l=o.child,o.tag===22&&o.memoizedState!==null?fX(r):l!==null?(l.return=o,St=l):fX(r);for(;s!==null;)St=s,W6(s),s=s.sibling;St=r,ZT=a,Cs=u}dX(n)}else r.subtreeFlags&8772&&s!==null?(s.return=r,St=s):dX(n)}}function dX(n){for(;St!==null;){var e=St;if(e.flags&8772){var t=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:Cs||OA(5,e);break;case 1:var i=e.stateNode;if(e.flags&4&&!Cs)if(t===null)i.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:bl(e.type,t.memoizedProps);i.componentDidUpdate(r,t.memoizedState,i.__reactInternalSnapshotBeforeUpdate)}var s=e.updateQueue;s!==null&&jH(e,s,i);break;case 3:var o=e.updateQueue;if(o!==null){if(t=null,e.child!==null)switch(e.child.tag){case 5:t=e.child.stateNode;break;case 1:t=e.child.stateNode}jH(e,o,t)}break;case 5:var a=e.stateNode;if(t===null&&e.flags&4){t=a;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&t.focus();break;case"img":l.src&&(t.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var u=e.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var h=c.dehydrated;h!==null&&vv(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(et(163))}Cs||e.flags&512&&hD(e)}catch(d){Gi(e,e.return,d)}}if(e===n){St=null;break}if(t=e.sibling,t!==null){t.return=e.return,St=t;break}St=e.return}}function pX(n){for(;St!==null;){var e=St;if(e===n){St=null;break}var t=e.sibling;if(t!==null){t.return=e.return,St=t;break}St=e.return}}function fX(n){for(;St!==null;){var e=St;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{OA(4,e)}catch(l){Gi(e,t,l)}break;case 1:var i=e.stateNode;if(typeof i.componentDidMount=="function"){var r=e.return;try{i.componentDidMount()}catch(l){Gi(e,r,l)}}var s=e.return;try{hD(e)}catch(l){Gi(e,s,l)}break;case 5:var o=e.return;try{hD(e)}catch(l){Gi(e,o,l)}}}catch(l){Gi(e,e.return,l)}if(e===n){St=null;break}var a=e.sibling;if(a!==null){a.return=e.return,St=a;break}St=e.return}}var vce=Math.ceil,mM=Xc.ReactCurrentDispatcher,kO=Xc.ReactCurrentOwner,ja=Xc.ReactCurrentBatchConfig,kn=0,Hr=null,hr=null,us=0,Ko=0,Pg=Ad(0),Cr=0,Rv=null,mf=0,BA=0,RO=0,jx=null,go=null,NO=0,by=1/0,ac=null,gM=!1,fD=null,jh=null,jT=!1,Bh=null,yM=0,Yx=0,mD=null,E_=-1,I_=0;function Zs(){return kn&6?er():E_!==-1?E_:E_=er()}function Yh(n){return n.mode&1?kn&2&&us!==0?us&-us:ice.transition!==null?(I_===0&&(I_=A8()),I_):(n=Un,n!==0||(n=window.event,n=n===void 0?16:P8(n.type)),n):1}function kl(n,e,t,i){if(50<Yx)throw Yx=0,mD=null,Error(et(185));C1(n,t,i),(!(kn&2)||n!==Hr)&&(n===Hr&&(!(kn&2)&&(BA|=t),Cr===4&&Dh(n,us)),Eo(n,i),t===1&&kn===0&&!(e.mode&1)&&(by=er()+500,PA&&Ed()))}function Eo(n,e){var t=n.callbackNode;iue(n,e);var i=eM(n,n===Hr?us:0);if(i===0)t!==null&&TH(t),n.callbackNode=null,n.callbackPriority=0;else if(e=i&-i,n.callbackPriority!==e){if(t!=null&&TH(t),e===1)n.tag===0?nce(mX.bind(null,n)):q8(mX.bind(null,n)),Que(function(){!(kn&6)&&Ed()}),t=null;else{switch(E8(i)){case 1:t=rO;break;case 4:t=_8;break;case 16:t=q_;break;case 536870912:t=M8;break;default:t=q_}t=Q6(t,H6.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function H6(n,e){if(E_=-1,I_=0,kn&6)throw Error(et(327));var t=n.callbackNode;if(ey()&&n.callbackNode!==t)return null;var i=eM(n,n===Hr?us:0);if(i===0)return null;if(i&30||i&n.expiredLanes||e)e=bM(n,i);else{e=i;var r=kn;kn|=2;var s=K6();(Hr!==n||us!==e)&&(ac=null,by=er()+500,Yp(n,e));do try{Tce();break}catch(a){X6(n,a)}while(1);yO(),mM.current=s,kn=r,hr!==null?e=0:(Hr=null,us=0,e=Cr)}if(e!==0){if(e===2&&(r=UP(n),r!==0&&(i=r,e=gD(n,r))),e===1)throw t=Rv,Yp(n,0),Dh(n,i),Eo(n,er()),t;if(e===6)Dh(n,i);else{if(r=n.current.alternate,!(i&30)&&!wce(r)&&(e=bM(n,i),e===2&&(s=UP(n),s!==0&&(i=s,e=gD(n,s))),e===1))throw t=Rv,Yp(n,0),Dh(n,i),Eo(n,er()),t;switch(n.finishedWork=r,n.finishedLanes=i,e){case 0:case 1:throw Error(et(345));case 2:bp(n,go,ac);break;case 3:if(Dh(n,i),(i&130023424)===i&&(e=NO+500-er(),10<e)){if(eM(n,0)!==0)break;if(r=n.suspendedLanes,(r&i)!==i){Zs(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=YP(bp.bind(null,n,go,ac),e);break}bp(n,go,ac);break;case 4:if(Dh(n,i),(i&4194240)===i)break;for(e=n.eventTimes,r=-1;0<i;){var o=31-Il(i);s=1<<o,o=e[o],o>r&&(r=o),i&=~s}if(i=r,i=er()-i,i=(120>i?120:480>i?480:1080>i?1080:1920>i?1920:3e3>i?3e3:4320>i?4320:1960*vce(i/1960))-i,10<i){n.timeoutHandle=YP(bp.bind(null,n,go,ac),i);break}bp(n,go,ac);break;case 5:bp(n,go,ac);break;default:throw Error(et(329))}}}return Eo(n,er()),n.callbackNode===t?H6.bind(null,n):null}function gD(n,e){var t=jx;return n.current.memoizedState.isDehydrated&&(Yp(n,e).flags|=256),n=bM(n,e),n!==2&&(e=go,go=t,e!==null&&yD(e)),n}function yD(n){go===null?go=n:go.push.apply(go,n)}function wce(n){for(var e=n;;){if(e.flags&16384){var t=e.updateQueue;if(t!==null&&(t=t.stores,t!==null))for(var i=0;i<t.length;i++){var r=t[i],s=r.getSnapshot;r=r.value;try{if(!Bl(s(),r))return!1}catch{return!1}}}if(t=e.child,e.subtreeFlags&16384&&t!==null)t.return=e,e=t;else{if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Dh(n,e){for(e&=~RO,e&=~BA,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-Il(e),i=1<<t;n[t]=-1,e&=~i}}function mX(n){if(kn&6)throw Error(et(327));ey();var e=eM(n,0);if(!(e&1))return Eo(n,er()),null;var t=bM(n,e);if(n.tag!==0&&t===2){var i=UP(n);i!==0&&(e=i,t=gD(n,i))}if(t===1)throw t=Rv,Yp(n,0),Dh(n,e),Eo(n,er()),t;if(t===6)throw Error(et(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,bp(n,go,ac),Eo(n,er()),null}function LO(n,e){var t=kn;kn|=1;try{return n(e)}finally{kn=t,kn===0&&(by=er()+500,PA&&Ed())}}function gf(n){Bh!==null&&Bh.tag===0&&!(kn&6)&&ey();var e=kn;kn|=1;var t=ja.transition,i=Un;try{if(ja.transition=null,Un=1,n)return n()}finally{Un=i,ja.transition=t,kn=e,!(kn&6)&&Ed()}}function PO(){Ko=Pg.current,di(Pg)}function Yp(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==-1&&(n.timeoutHandle=-1,Jue(t)),hr!==null)for(t=hr.return;t!==null;){var i=t;switch(fO(i),i.tag){case 1:i=i.type.childContextTypes,i!=null&&sM();break;case 3:gy(),di(Mo),di(Ns),TO();break;case 5:SO(i);break;case 4:gy();break;case 13:di(Ai);break;case 19:di(Ai);break;case 10:bO(i.type._context);break;case 22:case 23:PO()}t=t.return}if(Hr=n,hr=n=Jh(n.current,null),us=Ko=e,Cr=0,Rv=null,RO=BA=mf=0,go=jx=null,Op!==null){for(e=0;e<Op.length;e++)if(t=Op[e],i=t.interleaved,i!==null){t.interleaved=null;var r=i.next,s=t.pending;if(s!==null){var o=s.next;s.next=r,i.next=o}t.pending=i}Op=null}return n}function X6(n,e){do{var t=hr;try{if(yO(),__.current=fM,pM){for(var i=Ni.memoizedState;i!==null;){var r=i.queue;r!==null&&(r.pending=null),i=i.next}pM=!1}if(ff=0,Vr=wr=Ni=null,Kx=!1,Ev=0,kO.current=null,t===null||t.return===null){Cr=1,Rv=e,hr=null;break}e:{var s=n,o=t.return,a=t,l=e;if(e=us,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=a,h=c.tag;if(!(c.mode&1)&&(h===0||h===11||h===15)){var d=c.alternate;d?(c.updateQueue=d.updateQueue,c.memoizedState=d.memoizedState,c.lanes=d.lanes):(c.updateQueue=null,c.memoizedState=null)}var p=nX(o);if(p!==null){p.flags&=-257,iX(p,o,a,s,e),p.mode&1&&tX(s,u,e),e=p,l=u;var f=e.updateQueue;if(f===null){var g=new Set;g.add(l),e.updateQueue=g}else f.add(l);break e}else{if(!(e&1)){tX(s,u,e),DO();break e}l=Error(et(426))}}else if(xi&&a.mode&1){var y=nX(o);if(y!==null){!(y.flags&65536)&&(y.flags|=256),iX(y,o,a,s,e),mO(yy(l,a));break e}}s=l=yy(l,a),Cr!==4&&(Cr=2),jx===null?jx=[s]:jx.push(s),s=o;do{switch(s.tag){case 3:s.flags|=65536,e&=-e,s.lanes|=e;var m=I6(s,l,e);ZH(s,m);break e;case 1:a=l;var v=s.type,w=s.stateNode;if(!(s.flags&128)&&(typeof v.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(jh===null||!jh.has(w)))){s.flags|=65536,e&=-e,s.lanes|=e;var S=k6(s,a,e);ZH(s,S);break e}}s=s.return}while(s!==null)}j6(t)}catch(C){e=C,hr===t&&t!==null&&(hr=t=t.return);continue}break}while(1)}function K6(){var n=mM.current;return mM.current=fM,n===null?fM:n}function DO(){(Cr===0||Cr===3||Cr===2)&&(Cr=4),Hr===null||!(mf&268435455)&&!(BA&268435455)||Dh(Hr,us)}function bM(n,e){var t=kn;kn|=2;var i=K6();(Hr!==n||us!==e)&&(ac=null,Yp(n,e));do try{Sce();break}catch(r){X6(n,r)}while(1);if(yO(),kn=t,mM.current=i,hr!==null)throw Error(et(261));return Hr=null,us=0,Cr}function Sce(){for(;hr!==null;)Z6(hr)}function Tce(){for(;hr!==null&&!Zle();)Z6(hr)}function Z6(n){var e=J6(n.alternate,n,Ko);n.memoizedProps=n.pendingProps,e===null?j6(n):hr=e,kO.current=null}function j6(n){var e=n;do{var t=e.alternate;if(n=e.return,e.flags&32768){if(t=gce(t,e),t!==null){t.flags&=32767,hr=t;return}if(n!==null)n.flags|=32768,n.subtreeFlags=0,n.deletions=null;else{Cr=6,hr=null;return}}else if(t=mce(t,e,Ko),t!==null){hr=t;return}if(e=e.sibling,e!==null){hr=e;return}hr=e=n}while(e!==null);Cr===0&&(Cr=5)}function bp(n,e,t){var i=Un,r=ja.transition;try{ja.transition=null,Un=1,Cce(n,e,t,i)}finally{ja.transition=r,Un=i}return null}function Cce(n,e,t,i){do ey();while(Bh!==null);if(kn&6)throw Error(et(327));t=n.finishedWork;var r=n.finishedLanes;if(t===null)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(et(177));n.callbackNode=null,n.callbackPriority=0;var s=t.lanes|t.childLanes;if(rue(n,s),n===Hr&&(hr=Hr=null,us=0),!(t.subtreeFlags&2064)&&!(t.flags&2064)||jT||(jT=!0,Q6(q_,function(){return ey(),null})),s=(t.flags&15990)!==0,t.subtreeFlags&15990||s){s=ja.transition,ja.transition=null;var o=Un;Un=1;var a=kn;kn|=4,kO.current=null,bce(n,t),$6(t,n),Wue(ZP),tM=!!KP,ZP=KP=null,n.current=t,xce(t),jle(),kn=a,Un=o,ja.transition=s}else n.current=t;if(jT&&(jT=!1,Bh=n,yM=r),s=n.pendingLanes,s===0&&(jh=null),Qle(t.stateNode),Eo(n,er()),e!==null)for(i=n.onRecoverableError,t=0;t<e.length;t++)r=e[t],i(r.value,{componentStack:r.stack,digest:r.digest});if(gM)throw gM=!1,n=fD,fD=null,n;return yM&1&&n.tag!==0&&ey(),s=n.pendingLanes,s&1?n===mD?Yx++:(Yx=0,mD=n):Yx=0,Ed(),null}function ey(){if(Bh!==null){var n=E8(yM),e=ja.transition,t=Un;try{if(ja.transition=null,Un=16>n?16:n,Bh===null)var i=!1;else{if(n=Bh,Bh=null,yM=0,kn&6)throw Error(et(331));var r=kn;for(kn|=4,St=n.current;St!==null;){var s=St,o=s.child;if(St.flags&16){var a=s.deletions;if(a!==null){for(var l=0;l<a.length;l++){var u=a[l];for(St=u;St!==null;){var c=St;switch(c.tag){case 0:case 11:case 15:Zx(8,c,s)}var h=c.child;if(h!==null)h.return=c,St=h;else for(;St!==null;){c=St;var d=c.sibling,p=c.return;if(G6(c),c===u){St=null;break}if(d!==null){d.return=p,St=d;break}St=p}}}var f=s.alternate;if(f!==null){var g=f.child;if(g!==null){f.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(g!==null)}}St=s}}if(s.subtreeFlags&2064&&o!==null)o.return=s,St=o;else e:for(;St!==null;){if(s=St,s.flags&2048)switch(s.tag){case 0:case 11:case 15:Zx(9,s,s.return)}var m=s.sibling;if(m!==null){m.return=s.return,St=m;break e}St=s.return}}var v=n.current;for(St=v;St!==null;){o=St;var w=o.child;if(o.subtreeFlags&2064&&w!==null)w.return=o,St=w;else e:for(o=v;St!==null;){if(a=St,a.flags&2048)try{switch(a.tag){case 0:case 11:case 15:OA(9,a)}}catch(C){Gi(a,a.return,C)}if(a===o){St=null;break e}var S=a.sibling;if(S!==null){S.return=a.return,St=S;break e}St=a.return}}if(kn=r,Ed(),Cu&&typeof Cu.onPostCommitFiberRoot=="function")try{Cu.onPostCommitFiberRoot(IA,n)}catch{}i=!0}return i}finally{Un=t,ja.transition=e}}return!1}function gX(n,e,t){e=yy(t,e),e=I6(n,e,1),n=Zh(n,e,1),e=Zs(),n!==null&&(C1(n,1,e),Eo(n,e))}function Gi(n,e,t){if(n.tag===3)gX(n,n,t);else for(;e!==null;){if(e.tag===3){gX(e,n,t);break}else if(e.tag===1){var i=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof i.componentDidCatch=="function"&&(jh===null||!jh.has(i))){n=yy(t,n),n=k6(e,n,1),e=Zh(e,n,1),n=Zs(),e!==null&&(C1(e,1,n),Eo(e,n));break}}e=e.return}}function _ce(n,e,t){var i=n.pingCache;i!==null&&i.delete(e),e=Zs(),n.pingedLanes|=n.suspendedLanes&t,Hr===n&&(us&t)===t&&(Cr===4||Cr===3&&(us&130023424)===us&&500>er()-NO?Yp(n,0):RO|=t),Eo(n,e)}function Y6(n,e){e===0&&(n.mode&1?(e=zT,zT<<=1,!(zT&130023424)&&(zT=4194304)):e=1);var t=Zs();n=Nc(n,e),n!==null&&(C1(n,e,t),Eo(n,t))}function Mce(n){var e=n.memoizedState,t=0;e!==null&&(t=e.retryLane),Y6(n,t)}function Ace(n,e){var t=0;switch(n.tag){case 13:var i=n.stateNode,r=n.memoizedState;r!==null&&(t=r.retryLane);break;case 19:i=n.stateNode;break;default:throw Error(et(314))}i!==null&&i.delete(e),Y6(n,t)}var J6;J6=function(n,e,t){if(n!==null)if(n.memoizedProps!==e.pendingProps||Mo.current)So=!0;else{if(!(n.lanes&t)&&!(e.flags&128))return So=!1,fce(n,e,t);So=!!(n.flags&131072)}else So=!1,xi&&e.flags&1048576&&e6(e,lM,e.index);switch(e.lanes=0,e.tag){case 2:var i=e.type;A_(n,e),n=e.pendingProps;var r=py(e,Ns.current);qg(e,t),r=_O(null,e,i,n,r,t);var s=MO();return e.flags|=1,typeof r=="object"&&r!==null&&typeof r.render=="function"&&r.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Ao(i)?(s=!0,oM(e)):s=!1,e.memoizedState=r.state!==null&&r.state!==void 0?r.state:null,vO(e),r.updater=DA,e.stateNode=r,r._reactInternals=e,iD(e,i,n,t),e=oD(null,e,i,!0,s,t)):(e.tag=0,xi&&s&&pO(e),Hs(null,e,r,t),e=e.child),e;case 16:i=e.elementType;e:{switch(A_(n,e),n=e.pendingProps,r=i._init,i=r(i._payload),e.type=i,r=e.tag=Ice(i),n=bl(i,n),r){case 0:e=sD(null,e,i,n,t);break e;case 1:e=oX(null,e,i,n,t);break e;case 11:e=rX(null,e,i,n,t);break e;case 14:e=sX(null,e,i,bl(i.type,n),t);break e}throw Error(et(306,i,""))}return e;case 0:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:bl(i,r),sD(n,e,i,r,t);case 1:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:bl(i,r),oX(n,e,i,r,t);case 3:e:{if(P6(e),n===null)throw Error(et(387));i=e.pendingProps,s=e.memoizedState,r=s.element,r6(n,e),hM(e,i,null,t);var o=e.memoizedState;if(i=o.element,s.isDehydrated)if(s={element:i,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},e.updateQueue.baseState=s,e.memoizedState=s,e.flags&256){r=yy(Error(et(423)),e),e=aX(n,e,i,t,r);break e}else if(i!==r){r=yy(Error(et(424)),e),e=aX(n,e,i,t,r);break e}else for(Jo=Kh(e.stateNode.containerInfo.firstChild),na=e,xi=!0,Sl=null,t=l6(e,null,i,t),e.child=t;t;)t.flags=t.flags&-3|4096,t=t.sibling;else{if(fy(),i===r){e=Lc(n,e,t);break e}Hs(n,e,i,t)}e=e.child}return e;case 5:return u6(e),n===null&&eD(e),i=e.type,r=e.pendingProps,s=n!==null?n.memoizedProps:null,o=r.children,jP(i,r)?o=null:s!==null&&jP(i,s)&&(e.flags|=32),L6(n,e),Hs(n,e,o,t),e.child;case 6:return n===null&&eD(e),null;case 13:return D6(n,e,t);case 4:return wO(e,e.stateNode.containerInfo),i=e.pendingProps,n===null?e.child=my(e,null,i,t):Hs(n,e,i,t),e.child;case 11:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:bl(i,r),rX(n,e,i,r,t);case 7:return Hs(n,e,e.pendingProps,t),e.child;case 8:return Hs(n,e,e.pendingProps.children,t),e.child;case 12:return Hs(n,e,e.pendingProps.children,t),e.child;case 10:e:{if(i=e.type._context,r=e.pendingProps,s=e.memoizedProps,o=r.value,ei(uM,i._currentValue),i._currentValue=o,s!==null)if(Bl(s.value,o)){if(s.children===r.children&&!Mo.current){e=Lc(n,e,t);break e}}else for(s=e.child,s!==null&&(s.return=e);s!==null;){var a=s.dependencies;if(a!==null){o=s.child;for(var l=a.firstContext;l!==null;){if(l.context===i){if(s.tag===1){l=wc(-1,t&-t),l.tag=2;var u=s.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}s.lanes|=t,l=s.alternate,l!==null&&(l.lanes|=t),tD(s.return,t,e),a.lanes|=t;break}l=l.next}}else if(s.tag===10)o=s.type===e.type?null:s.child;else if(s.tag===18){if(o=s.return,o===null)throw Error(et(341));o.lanes|=t,a=o.alternate,a!==null&&(a.lanes|=t),tD(o,t,e),o=s.sibling}else o=s.child;if(o!==null)o.return=s;else for(o=s;o!==null;){if(o===e){o=null;break}if(s=o.sibling,s!==null){s.return=o.return,o=s;break}o=o.return}s=o}Hs(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,i=e.pendingProps.children,qg(e,t),r=Ya(r),i=i(r),e.flags|=1,Hs(n,e,i,t),e.child;case 14:return i=e.type,r=bl(i,e.pendingProps),r=bl(i.type,r),sX(n,e,i,r,t);case 15:return R6(n,e,e.type,e.pendingProps,t);case 17:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:bl(i,r),A_(n,e),e.tag=1,Ao(i)?(n=!0,oM(e)):n=!1,qg(e,t),o6(e,i,r),iD(e,i,r,t),oD(null,e,i,!0,n,t);case 19:return F6(n,e,t);case 22:return N6(n,e,t)}throw Error(et(156,e.tag))};function Q6(n,e){return C8(n,e)}function Ece(n,e,t,i){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Wa(n,e,t,i){return new Ece(n,e,t,i)}function FO(n){return n=n.prototype,!(!n||!n.isReactComponent)}function Ice(n){if(typeof n=="function")return FO(n)?1:0;if(n!=null){if(n=n.$$typeof,n===tO)return 11;if(n===nO)return 14}return 2}function Jh(n,e){var t=n.alternate;return t===null?(t=Wa(n.tag,e,n.key,n.mode),t.elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=n.flags&14680064,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function k_(n,e,t,i,r,s){var o=2;if(i=n,typeof n=="function")FO(n)&&(o=1);else if(typeof n=="string")o=5;else e:switch(n){case Cg:return Jp(t.children,r,s,e);case eO:o=8,r|=8;break;case AP:return n=Wa(12,t,e,r|2),n.elementType=AP,n.lanes=s,n;case EP:return n=Wa(13,t,e,r),n.elementType=EP,n.lanes=s,n;case IP:return n=Wa(19,t,e,r),n.elementType=IP,n.lanes=s,n;case a8:return zA(t,r,s,e);default:if(typeof n=="object"&&n!==null)switch(n.$$typeof){case s8:o=10;break e;case o8:o=9;break e;case tO:o=11;break e;case nO:o=14;break e;case Ah:o=16,i=null;break e}throw Error(et(130,n==null?n:typeof n,""))}return e=Wa(o,t,e,r),e.elementType=n,e.type=i,e.lanes=s,e}function Jp(n,e,t,i){return n=Wa(7,n,i,e),n.lanes=t,n}function zA(n,e,t,i){return n=Wa(22,n,i,e),n.elementType=a8,n.lanes=t,n.stateNode={isHidden:!1},n}function nN(n,e,t){return n=Wa(6,n,null,e),n.lanes=t,n}function iN(n,e,t){return e=Wa(4,n.children!==null?n.children:[],n.key,e),e.lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function kce(n,e,t,i,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=OR(0),this.expirationTimes=OR(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=OR(0),this.identifierPrefix=i,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function OO(n,e,t,i,r,s,o,a,l){return n=new kce(n,e,t,a,l),e===1?(e=1,s===!0&&(e|=8)):e=0,s=Wa(3,null,null,e),n.current=s,s.stateNode=n,s.memoizedState={element:i,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},vO(s),n}function Rce(n,e,t){var i=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Tg,key:i==null?null:""+i,children:n,containerInfo:e,implementation:t}}function q6(n){if(!n)return cd;n=n._reactInternals;e:{if(jf(n)!==n||n.tag!==1)throw Error(et(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Ao(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(et(171))}if(n.tag===1){var t=n.type;if(Ao(t))return Q8(n,t,e)}return e}function eY(n,e,t,i,r,s,o,a,l){return n=OO(t,i,!0,n,r,s,o,a,l),n.context=q6(null),t=n.current,i=Zs(),r=Yh(t),s=wc(i,r),s.callback=e??null,Zh(t,s,r),n.current.lanes=r,C1(n,r,i),Eo(n,i),n}function GA(n,e,t,i){var r=e.current,s=Zs(),o=Yh(r);return t=q6(t),e.context===null?e.context=t:e.pendingContext=t,e=wc(s,o),e.payload={element:n},i=i===void 0?null:i,i!==null&&(e.callback=i),n=Zh(r,e,o),n!==null&&(kl(n,r,o,s),C_(n,r,o)),o}function xM(n){if(n=n.current,!n.child)return null;switch(n.child.tag){case 5:return n.child.stateNode;default:return n.child.stateNode}}function yX(n,e){if(n=n.memoizedState,n!==null&&n.dehydrated!==null){var t=n.retryLane;n.retryLane=t!==0&&t<e?t:e}}function BO(n,e){yX(n,e),(n=n.alternate)&&yX(n,e)}function Nce(){return null}var tY=typeof reportError=="function"?reportError:function(n){console.error(n)};function zO(n){this._internalRoot=n}VA.prototype.render=zO.prototype.render=function(n){var e=this._internalRoot;if(e===null)throw Error(et(409));GA(n,e,null,null)};VA.prototype.unmount=zO.prototype.unmount=function(){var n=this._internalRoot;if(n!==null){this._internalRoot=null;var e=n.containerInfo;gf(function(){GA(null,n,null,null)}),e[Rc]=null}};function VA(n){this._internalRoot=n}VA.prototype.unstable_scheduleHydration=function(n){if(n){var e=R8();n={blockedOn:null,target:n,priority:e};for(var t=0;t<Ph.length&&e!==0&&e<Ph[t].priority;t++);Ph.splice(t,0,n),t===0&&L8(n)}};function GO(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11)}function UA(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11&&(n.nodeType!==8||n.nodeValue!==" react-mount-point-unstable "))}function bX(){}function Lce(n,e,t,i,r){if(r){if(typeof i=="function"){var s=i;i=function(){var u=xM(o);s.call(u)}}var o=eY(e,i,n,0,null,!1,!1,"",bX);return n._reactRootContainer=o,n[Rc]=o.current,Tv(n.nodeType===8?n.parentNode:n),gf(),o}for(;r=n.lastChild;)n.removeChild(r);if(typeof i=="function"){var a=i;i=function(){var u=xM(l);a.call(u)}}var l=OO(n,0,!1,null,null,!1,!1,"",bX);return n._reactRootContainer=l,n[Rc]=l.current,Tv(n.nodeType===8?n.parentNode:n),gf(function(){GA(e,l,t,i)}),l}function $A(n,e,t,i,r){var s=t._reactRootContainer;if(s){var o=s;if(typeof r=="function"){var a=r;r=function(){var l=xM(o);a.call(l)}}GA(e,o,n,r)}else o=Lce(t,e,n,r,i);return xM(o)}I8=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=Rx(e.pendingLanes);t!==0&&(sO(e,t|1),Eo(e,er()),!(kn&6)&&(by=er()+500,Ed()))}break;case 13:gf(function(){var i=Nc(n,1);if(i!==null){var r=Zs();kl(i,n,1,r)}}),BO(n,1)}};oO=function(n){if(n.tag===13){var e=Nc(n,134217728);if(e!==null){var t=Zs();kl(e,n,134217728,t)}BO(n,134217728)}};k8=function(n){if(n.tag===13){var e=Yh(n),t=Nc(n,e);if(t!==null){var i=Zs();kl(t,n,e,i)}BO(n,e)}};R8=function(){return Un};N8=function(n,e){var t=Un;try{return Un=n,e()}finally{Un=t}};zP=function(n,e,t){switch(e){case"input":if(NP(n,t),e=t.name,t.type==="radio"&&e!=null){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var i=t[e];if(i!==n&&i.form===n.form){var r=LA(i);if(!r)throw Error(et(90));u8(i),NP(i,r)}}}break;case"textarea":h8(n,t);break;case"select":e=t.value,e!=null&&jg(n,!!t.multiple,e,!1)}};b8=LO;x8=gf;var Pce={usingClientEntryPoint:!1,Events:[M1,Eg,LA,g8,y8,LO]},Qb={findFiberByHostInstance:Fp,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},Dce={bundleType:Qb.bundleType,version:Qb.version,rendererPackageName:Qb.rendererPackageName,rendererConfig:Qb.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Xc.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return n=S8(n),n===null?null:n.stateNode},findFiberByHostInstance:Qb.findFiberByHostInstance||Nce,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var YT=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!YT.isDisabled&&YT.supportsFiber)try{IA=YT.inject(Dce),Cu=YT}catch{}}fa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Pce;fa.createPortal=function(n,e){var t=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!GO(e))throw Error(et(200));return Rce(n,e,null,t)};fa.createRoot=function(n,e){if(!GO(n))throw Error(et(299));var t=!1,i="",r=tY;return e!=null&&(e.unstable_strictMode===!0&&(t=!0),e.identifierPrefix!==void 0&&(i=e.identifierPrefix),e.onRecoverableError!==void 0&&(r=e.onRecoverableError)),e=OO(n,1,!1,null,null,t,!1,i,r),n[Rc]=e.current,Tv(n.nodeType===8?n.parentNode:n),new zO(e)};fa.findDOMNode=function(n){if(n==null)return null;if(n.nodeType===1)return n;var e=n._reactInternals;if(e===void 0)throw typeof n.render=="function"?Error(et(188)):(n=Object.keys(n).join(","),Error(et(268,n)));return n=S8(e),n=n===null?null:n.stateNode,n};fa.flushSync=function(n){return gf(n)};fa.hydrate=function(n,e,t){if(!UA(e))throw Error(et(200));return $A(null,n,e,!0,t)};fa.hydrateRoot=function(n,e,t){if(!GO(n))throw Error(et(405));var i=t!=null&&t.hydratedSources||null,r=!1,s="",o=tY;if(t!=null&&(t.unstable_strictMode===!0&&(r=!0),t.identifierPrefix!==void 0&&(s=t.identifierPrefix),t.onRecoverableError!==void 0&&(o=t.onRecoverableError)),e=eY(e,null,n,1,t??null,r,!1,s,o),n[Rc]=e.current,Tv(n),i)for(n=0;n<i.length;n++)t=i[n],r=t._getVersion,r=r(t._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[t,r]:e.mutableSourceEagerHydrationData.push(t,r);return new VA(e)};fa.render=function(n,e,t){if(!UA(e))throw Error(et(200));return $A(null,n,e,!1,t)};fa.unmountComponentAtNode=function(n){if(!UA(n))throw Error(et(40));return n._reactRootContainer?(gf(function(){$A(null,null,n,!1,function(){n._reactRootContainer=null,n[Rc]=null})}),!0):!1};fa.unstable_batchedUpdates=LO;fa.unstable_renderSubtreeIntoContainer=function(n,e,t,i){if(!UA(t))throw Error(et(200));if(n==null||n._reactInternals===void 0)throw Error(et(38));return $A(n,e,t,!1,i)};fa.version="18.2.0-next-9e3b772b8-20220608";function nY(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(nY)}catch(n){console.error(n)}}nY(),e8.exports=fa;var VO=e8.exports;const Fce=Zy(VO),Oce=$j({__proto__:null,default:Fce},[VO]);var xX=VO;_P.createRoot=xX.createRoot,_P.hydrateRoot=xX.hydrateRoot;/**
 * @remix-run/router v1.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Vi(){return Vi=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},Vi.apply(this,arguments)}var Ji;(function(n){n.Pop="POP",n.Push="PUSH",n.Replace="REPLACE"})(Ji||(Ji={}));const vX="popstate";function Bce(n){n===void 0&&(n={});function e(i,r){let{pathname:s,search:o,hash:a}=i.location;return Nv("",{pathname:s,search:o,hash:a},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function t(i,r){return typeof r=="string"?r:bf(r)}return Gce(e,t,null,n)}function mn(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function yf(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function zce(){return Math.random().toString(36).substr(2,8)}function wX(n,e){return{usr:n.state,key:n.key,idx:e}}function Nv(n,e,t,i){return t===void 0&&(t=null),Vi({pathname:typeof n=="string"?n:n.pathname,search:"",hash:""},typeof e=="string"?Kc(e):e,{state:t,key:e&&e.key||i||zce()})}function bf(n){let{pathname:e="/",search:t="",hash:i=""}=n;return t&&t!=="?"&&(e+=t.charAt(0)==="?"?t:"?"+t),i&&i!=="#"&&(e+=i.charAt(0)==="#"?i:"#"+i),e}function Kc(n){let e={};if(n){let t=n.indexOf("#");t>=0&&(e.hash=n.substr(t),n=n.substr(0,t));let i=n.indexOf("?");i>=0&&(e.search=n.substr(i),n=n.substr(0,i)),n&&(e.pathname=n)}return e}function Gce(n,e,t,i){i===void 0&&(i={});let{window:r=document.defaultView,v5Compat:s=!1}=i,o=r.history,a=Ji.Pop,l=null,u=c();u==null&&(u=0,o.replaceState(Vi({},o.state,{idx:u}),""));function c(){return(o.state||{idx:null}).idx}function h(){a=Ji.Pop;let y=c(),m=y==null?null:y-u;u=y,l&&l({action:a,location:g.location,delta:m})}function d(y,m){a=Ji.Push;let v=Nv(g.location,y,m);t&&t(v,y),u=c()+1;let w=wX(v,u),S=g.createHref(v);try{o.pushState(w,"",S)}catch(C){if(C instanceof DOMException&&C.name==="DataCloneError")throw C;r.location.assign(S)}s&&l&&l({action:a,location:g.location,delta:1})}function p(y,m){a=Ji.Replace;let v=Nv(g.location,y,m);t&&t(v,y),u=c();let w=wX(v,u),S=g.createHref(v);o.replaceState(w,"",S),s&&l&&l({action:a,location:g.location,delta:0})}function f(y){let m=r.location.origin!=="null"?r.location.origin:r.location.href,v=typeof y=="string"?y:bf(y);return mn(m,"No window.location.(origin|href) available to create URL for href: "+v),new URL(v,m)}let g={get action(){return a},get location(){return n(r,o)},listen(y){if(l)throw new Error("A history only accepts one active listener");return r.addEventListener(vX,h),l=y,()=>{r.removeEventListener(vX,h),l=null}},createHref(y){return e(r,y)},createURL:f,encodeLocation(y){let m=f(y);return{pathname:m.pathname,search:m.search,hash:m.hash}},push:d,replace:p,go(y){return o.go(y)}};return g}var Qi;(function(n){n.data="data",n.deferred="deferred",n.redirect="redirect",n.error="error"})(Qi||(Qi={}));const Vce=new Set(["lazy","caseSensitive","path","id","index","children"]);function Uce(n){return n.index===!0}function bD(n,e,t,i){return t===void 0&&(t=[]),i===void 0&&(i={}),n.map((r,s)=>{let o=[...t,s],a=typeof r.id=="string"?r.id:o.join("-");if(mn(r.index!==!0||!r.children,"Cannot specify children on an index route"),mn(!i[a],'Found a route id collision on id "'+a+`".  Route id's must be globally unique within Data Router usages`),Uce(r)){let l=Vi({},r,e(r),{id:a});return i[a]=l,l}else{let l=Vi({},r,e(r),{id:a,children:void 0});return i[a]=l,r.children&&(l.children=bD(r.children,e,o,i)),l}})}function Dg(n,e,t){t===void 0&&(t="/");let i=typeof e=="string"?Kc(e):e,r=hd(i.pathname||"/",t);if(r==null)return null;let s=iY(n);Wce(s);let o=null;for(let a=0;o==null&&a<s.length;++a)o=qce(s[a],the(r));return o}function $ce(n,e){let{route:t,pathname:i,params:r}=n;return{id:t.id,pathname:i,params:r,data:e[t.id],handle:t.handle}}function iY(n,e,t,i){e===void 0&&(e=[]),t===void 0&&(t=[]),i===void 0&&(i="");let r=(s,o,a)=>{let l={relativePath:a===void 0?s.path||"":a,caseSensitive:s.caseSensitive===!0,childrenIndex:o,route:s};l.relativePath.startsWith("/")&&(mn(l.relativePath.startsWith(i),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+i+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(i.length));let u=Sc([i,l.relativePath]),c=t.concat(l);s.children&&s.children.length>0&&(mn(s.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),iY(s.children,e,c,u)),!(s.path==null&&!s.index)&&e.push({path:u,score:Jce(u,s.index),routesMeta:c})};return n.forEach((s,o)=>{var a;if(s.path===""||!((a=s.path)!=null&&a.includes("?")))r(s,o);else for(let l of rY(s.path))r(s,o,l)}),e}function rY(n){let e=n.split("/");if(e.length===0)return[];let[t,...i]=e,r=t.endsWith("?"),s=t.replace(/\?$/,"");if(i.length===0)return r?[s,""]:[s];let o=rY(i.join("/")),a=[];return a.push(...o.map(l=>l===""?s:[s,l].join("/"))),r&&a.push(...o),a.map(l=>n.startsWith("/")&&l===""?"/":l)}function Wce(n){n.sort((e,t)=>e.score!==t.score?t.score-e.score:Qce(e.routesMeta.map(i=>i.childrenIndex),t.routesMeta.map(i=>i.childrenIndex)))}const Hce=/^:\w+$/,Xce=3,Kce=2,Zce=1,jce=10,Yce=-2,SX=n=>n==="*";function Jce(n,e){let t=n.split("/"),i=t.length;return t.some(SX)&&(i+=Yce),e&&(i+=Kce),t.filter(r=>!SX(r)).reduce((r,s)=>r+(Hce.test(s)?Xce:s===""?Zce:jce),i)}function Qce(n,e){return n.length===e.length&&n.slice(0,-1).every((i,r)=>i===e[r])?n[n.length-1]-e[e.length-1]:0}function qce(n,e){let{routesMeta:t}=n,i={},r="/",s=[];for(let o=0;o<t.length;++o){let a=t[o],l=o===t.length-1,u=r==="/"?e:e.slice(r.length)||"/",c=xD({path:a.relativePath,caseSensitive:a.caseSensitive,end:l},u);if(!c)return null;Object.assign(i,c.params);let h=a.route;s.push({params:i,pathname:Sc([r,c.pathname]),pathnameBase:she(Sc([r,c.pathnameBase])),route:h}),c.pathnameBase!=="/"&&(r=Sc([r,c.pathnameBase]))}return s}function xD(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[t,i]=ehe(n.path,n.caseSensitive,n.end),r=e.match(t);if(!r)return null;let s=r[0],o=s.replace(/(.)\/+$/,"$1"),a=r.slice(1);return{params:i.reduce((u,c,h)=>{let{paramName:d,isOptional:p}=c;if(d==="*"){let g=a[h]||"";o=s.slice(0,s.length-g.length).replace(/(.)\/+$/,"$1")}const f=a[h];return p&&!f?u[d]=void 0:u[d]=nhe(f||"",d),u},{}),pathname:s,pathnameBase:o,pattern:n}}function ehe(n,e,t){e===void 0&&(e=!1),t===void 0&&(t=!0),yf(n==="*"||!n.endsWith("*")||n.endsWith("/*"),'Route path "'+n+'" will be treated as if it were '+('"'+n.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+n.replace(/\*$/,"/*")+'".'));let i=[],r="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:(\w+)(\?)?/g,(o,a,l)=>(i.push({paramName:a,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return n.endsWith("*")?(i.push({paramName:"*"}),r+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?r+="\\/*$":n!==""&&n!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,e?void 0:"i"),i]}function the(n){try{return decodeURI(n)}catch(e){return yf(!1,'The URL path "'+n+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+e+").")),n}}function nhe(n,e){try{return decodeURIComponent(n)}catch(t){return yf(!1,'The value for the URL param "'+e+'" will not be decoded because'+(' the string "'+n+'" is a malformed URL segment. This is probably')+(" due to a bad percent encoding ("+t+").")),n}}function hd(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,i=n.charAt(t);return i&&i!=="/"?null:n.slice(t)||"/"}function ihe(n,e){e===void 0&&(e="/");let{pathname:t,search:i="",hash:r=""}=typeof n=="string"?Kc(n):n;return{pathname:t?t.startsWith("/")?t:rhe(t,e):e,search:ohe(i),hash:ahe(r)}}function rhe(n,e){let t=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(r=>{r===".."?t.length>1&&t.pop():r!=="."&&t.push(r)}),t.length>1?t.join("/"):"/"}function rN(n,e,t,i){return"Cannot include a '"+n+"' character in a manually specified "+("`to."+e+"` field ["+JSON.stringify(i)+"].  Please separate it out to the ")+("`to."+t+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function WA(n){return n.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function UO(n,e,t,i){i===void 0&&(i=!1);let r;typeof n=="string"?r=Kc(n):(r=Vi({},n),mn(!r.pathname||!r.pathname.includes("?"),rN("?","pathname","search",r)),mn(!r.pathname||!r.pathname.includes("#"),rN("#","pathname","hash",r)),mn(!r.search||!r.search.includes("#"),rN("#","search","hash",r)));let s=n===""||r.pathname==="",o=s?"/":r.pathname,a;if(o==null)a=t;else if(i){let h=e[e.length-1].replace(/^\//,"").split("/");if(o.startsWith("..")){let d=o.split("/");for(;d[0]==="..";)d.shift(),h.pop();r.pathname=d.join("/")}a="/"+h.join("/")}else{let h=e.length-1;if(o.startsWith("..")){let d=o.split("/");for(;d[0]==="..";)d.shift(),h-=1;r.pathname=d.join("/")}a=h>=0?e[h]:"/"}let l=ihe(r,a),u=o&&o!=="/"&&o.endsWith("/"),c=(s||o===".")&&t.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}const Sc=n=>n.join("/").replace(/\/\/+/g,"/"),she=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),ohe=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,ahe=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n;class $O{constructor(e,t,i,r){r===void 0&&(r=!1),this.status=e,this.statusText=t||"",this.internal=r,i instanceof Error?(this.data=i.toString(),this.error=i):this.data=i}}function sY(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}const oY=["post","put","patch","delete"],lhe=new Set(oY),uhe=["get",...oY],che=new Set(uhe),hhe=new Set([301,302,303,307,308]),dhe=new Set([307,308]),sN={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},phe={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},qb={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},aY=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,fhe=n=>({hasErrorBoundary:!!n.hasErrorBoundary}),lY="remix-router-transitions";function mhe(n){const e=n.window?n.window:typeof window<"u"?window:void 0,t=typeof e<"u"&&typeof e.document<"u"&&typeof e.document.createElement<"u",i=!t;mn(n.routes.length>0,"You must provide a non-empty routes array to createRouter");let r;if(n.mapRouteProperties)r=n.mapRouteProperties;else if(n.detectErrorBoundary){let G=n.detectErrorBoundary;r=re=>({hasErrorBoundary:G(re)})}else r=fhe;let s={},o=bD(n.routes,r,void 0,s),a,l=n.basename||"/",u=Vi({v7_fetcherPersist:!1,v7_normalizeFormMethod:!1,v7_prependBasename:!1},n.future),c=null,h=new Set,d=null,p=null,f=null,g=n.hydrationData!=null,y=Dg(o,n.history.location,l),m=null;if(y==null){let G=za(404,{pathname:n.history.location.pathname}),{matches:re,route:pe}=kX(o);y=re,m={[pe.id]:G}}let v=!y.some(G=>G.route.lazy)&&(!y.some(G=>G.route.loader)||n.hydrationData!=null),w,S={historyAction:n.history.action,location:n.history.location,matches:y,initialized:v,navigation:sN,restoreScrollPosition:n.hydrationData!=null?!1:null,preventScrollReset:!1,revalidation:"idle",loaderData:n.hydrationData&&n.hydrationData.loaderData||{},actionData:n.hydrationData&&n.hydrationData.actionData||null,errors:n.hydrationData&&n.hydrationData.errors||m,fetchers:new Map,blockers:new Map},C=Ji.Pop,_=!1,A,I=!1,E=new Map,k=null,P=!1,V=!1,U=[],F=[],$=new Map,J=0,q=-1,O=new Map,X=new Set,j=new Map,z=new Map,Z=new Set,ce=new Map,fe=new Map,ge=!1;function Ne(){if(c=n.history.listen(G=>{let{action:re,location:pe,delta:de}=G;if(ge){ge=!1;return}yf(fe.size===0||de!=null,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");let Te=Qe({currentLocation:S.location,nextLocation:pe,historyAction:re});if(Te&&de!=null){ge=!0,n.history.go(de*-1),Xt(Te,{state:"blocked",location:pe,proceed(){Xt(Te,{state:"proceeding",proceed:void 0,reset:void 0,location:pe}),n.history.go(de)},reset(){let Je=new Map(S.blockers);Je.set(Te,qb),Ue({blockers:Je})}});return}return De(re,pe)}),t){Mhe(e,E);let G=()=>Ahe(e,E);e.addEventListener("pagehide",G),k=()=>e.removeEventListener("pagehide",G)}return S.initialized||De(Ji.Pop,S.location),w}function Fe(){c&&c(),k&&k(),h.clear(),A&&A.abort(),S.fetchers.forEach((G,re)=>oe(re)),S.blockers.forEach((G,re)=>Ot(re))}function We(G){return h.add(G),()=>h.delete(G)}function Ue(G,re){re===void 0&&(re={}),S=Vi({},S,G);let pe=[],de=[];u.v7_fetcherPersist&&S.fetchers.forEach((Te,Je)=>{Te.state==="idle"&&(Z.has(Je)?de.push(Je):pe.push(Je))}),[...h].forEach(Te=>Te(S,{deletedFetchers:de,unstable_viewTransitionOpts:re.viewTransitionOpts,unstable_flushSync:re.flushSync===!0})),u.v7_fetcherPersist&&(pe.forEach(Te=>S.fetchers.delete(Te)),de.forEach(Te=>oe(Te)))}function Ye(G,re,pe){var de,Te;let{flushSync:Je}=pe===void 0?{}:pe,rt=S.actionData!=null&&S.navigation.formMethod!=null&&wl(S.navigation.formMethod)&&S.navigation.state==="loading"&&((de=G.state)==null?void 0:de._isRedirect)!==!0,ht;re.actionData?Object.keys(re.actionData).length>0?ht=re.actionData:ht=null:rt?ht=S.actionData:ht=null;let pt=re.loaderData?IX(S.loaderData,re.loaderData,re.matches||[],re.errors):S.loaderData,vt=S.blockers;vt.size>0&&(vt=new Map(vt),vt.forEach((Nn,zn)=>vt.set(zn,qb)));let Tn=_===!0||S.navigation.formMethod!=null&&wl(S.navigation.formMethod)&&((Te=G.state)==null?void 0:Te._isRedirect)!==!0;a&&(o=a,a=void 0),P||C===Ji.Pop||(C===Ji.Push?n.history.push(G,G.state):C===Ji.Replace&&n.history.replace(G,G.state));let Ut;if(C===Ji.Pop){let Nn=E.get(S.location.pathname);Nn&&Nn.has(G.pathname)?Ut={currentLocation:S.location,nextLocation:G}:E.has(G.pathname)&&(Ut={currentLocation:G,nextLocation:S.location})}else if(I){let Nn=E.get(S.location.pathname);Nn?Nn.add(G.pathname):(Nn=new Set([G.pathname]),E.set(S.location.pathname,Nn)),Ut={currentLocation:S.location,nextLocation:G}}Ue(Vi({},re,{actionData:ht,loaderData:pt,historyAction:C,location:G,initialized:!0,navigation:sN,revalidation:"idle",restoreScrollPosition:Ke(G,re.matches||S.matches),preventScrollReset:Tn,blockers:vt}),{viewTransitionOpts:Ut,flushSync:Je===!0}),C=Ji.Pop,_=!1,I=!1,P=!1,V=!1,U=[],F=[]}async function $e(G,re){if(typeof G=="number"){n.history.go(G);return}let pe=vD(S.location,S.matches,l,u.v7_prependBasename,G,re==null?void 0:re.fromRouteId,re==null?void 0:re.relative),{path:de,submission:Te,error:Je}=TX(u.v7_normalizeFormMethod,!1,pe,re),rt=S.location,ht=Nv(S.location,de,re&&re.state);ht=Vi({},ht,n.history.encodeLocation(ht));let pt=re&&re.replace!=null?re.replace:void 0,vt=Ji.Push;pt===!0?vt=Ji.Replace:pt===!1||Te!=null&&wl(Te.formMethod)&&Te.formAction===S.location.pathname+S.location.search&&(vt=Ji.Replace);let Tn=re&&"preventScrollReset"in re?re.preventScrollReset===!0:void 0,Ut=(re&&re.unstable_flushSync)===!0,Nn=Qe({currentLocation:rt,nextLocation:ht,historyAction:vt});if(Nn){Xt(Nn,{state:"blocked",location:ht,proceed(){Xt(Nn,{state:"proceeding",proceed:void 0,reset:void 0,location:ht}),$e(G,re)},reset(){let zn=new Map(S.blockers);zn.set(Nn,qb),Ue({blockers:zn})}});return}return await De(vt,ht,{submission:Te,pendingError:Je,preventScrollReset:Tn,replace:re&&re.replace,enableViewTransition:re&&re.unstable_viewTransition,flushSync:Ut})}function ee(){if(Lt(),Ue({revalidation:"loading"}),S.navigation.state!=="submitting"){if(S.navigation.state==="idle"){De(S.historyAction,S.location,{startUninterruptedRevalidation:!0});return}De(C||S.historyAction,S.navigation.location,{overrideNavigation:S.navigation})}}async function De(G,re,pe){A&&A.abort(),A=null,C=G,P=(pe&&pe.startUninterruptedRevalidation)===!0,je(S.location,S.matches),_=(pe&&pe.preventScrollReset)===!0,I=(pe&&pe.enableViewTransition)===!0;let de=a||o,Te=pe&&pe.overrideNavigation,Je=Dg(de,re,l),rt=(pe&&pe.flushSync)===!0;if(!Je){let zn=za(404,{pathname:re.pathname}),{matches:Fi,route:xr}=kX(de);sn(),Ye(re,{matches:Fi,loaderData:{},errors:{[xr.id]:zn}},{flushSync:rt});return}if(S.initialized&&!V&&vhe(S.location,re)&&!(pe&&pe.submission&&wl(pe.submission.formMethod))){Ye(re,{matches:Je},{flushSync:rt});return}A=new AbortController;let ht=tx(n.history,re,A.signal,pe&&pe.submission),pt,vt;if(pe&&pe.pendingError)vt={[Jx(Je).route.id]:pe.pendingError};else if(pe&&pe.submission&&wl(pe.submission.formMethod)){let zn=await _e(ht,re,pe.submission,Je,{replace:pe.replace,flushSync:rt});if(zn.shortCircuited)return;pt=zn.pendingActionData,vt=zn.pendingActionError,Te=oN(re,pe.submission),rt=!1,ht=new Request(ht.url,{signal:ht.signal})}let{shortCircuited:Tn,loaderData:Ut,errors:Nn}=await ze(ht,re,Je,Te,pe&&pe.submission,pe&&pe.fetcherSubmission,pe&&pe.replace,rt,pt,vt);Tn||(A=null,Ye(re,Vi({matches:Je},pt?{actionData:pt}:{},{loaderData:Ut,errors:Nn})))}async function _e(G,re,pe,de,Te){Te===void 0&&(Te={}),Lt();let Je=Che(re,pe);Ue({navigation:Je},{flushSync:Te.flushSync===!0});let rt,ht=SD(de,re);if(!ht.route.action&&!ht.route.lazy)rt={type:Qi.error,error:za(405,{method:G.method,pathname:re.pathname,routeId:ht.route.id})};else if(rt=await ex("action",G,ht,de,s,r,l),G.signal.aborted)return{shortCircuited:!0};if(ty(rt)){let pt;return Te&&Te.replace!=null?pt=Te.replace:pt=rt.location===S.location.pathname+S.location.search,await st(S,rt,{submission:pe,replace:pt}),{shortCircuited:!0}}if(Qx(rt)){let pt=Jx(de,ht.route.id);return(Te&&Te.replace)!==!0&&(C=Ji.Push),{pendingActionData:{},pendingActionError:{[pt.route.id]:rt.error}}}if(zp(rt))throw za(400,{type:"defer-action"});return{pendingActionData:{[ht.route.id]:rt.data}}}async function ze(G,re,pe,de,Te,Je,rt,ht,pt,vt){let Tn=de||oN(re,Te),Ut=Te||Je||LX(Tn),Nn=a||o,[zn,Fi]=CX(n.history,S,pe,Ut,re,V,U,F,j,X,Nn,l,pt,vt);if(sn(Se=>!(pe&&pe.some(Ee=>Ee.route.id===Se))||zn&&zn.some(Ee=>Ee.route.id===Se)),q=++J,zn.length===0&&Fi.length===0){let Se=ct();return Ye(re,Vi({matches:pe,loaderData:{},errors:vt||null},pt?{actionData:pt}:{},Se?{fetchers:new Map(S.fetchers)}:{}),{flushSync:ht}),{shortCircuited:!0}}if(!P){Fi.forEach(Ee=>{let tt=S.fetchers.get(Ee.key),Ct=nx(void 0,tt?tt.data:void 0);S.fetchers.set(Ee.key,Ct)});let Se=pt||S.actionData;Ue(Vi({navigation:Tn},Se?Object.keys(Se).length===0?{actionData:null}:{actionData:Se}:{},Fi.length>0?{fetchers:new Map(S.fetchers)}:{}),{flushSync:ht})}Fi.forEach(Se=>{$.has(Se.key)&&Me(Se.key),Se.controller&&$.set(Se.key,Se.controller)});let xr=()=>Fi.forEach(Se=>Me(Se.key));A&&A.signal.addEventListener("abort",xr);let{results:xa,loaderResults:rh,fetcherResults:al}=await yt(S.matches,pe,zn,Fi,G);if(G.signal.aborted)return{shortCircuited:!0};A&&A.signal.removeEventListener("abort",xr),Fi.forEach(Se=>$.delete(Se.key));let zs=RX(xa);if(zs){if(zs.idx>=zn.length){let Se=Fi[zs.idx-zn.length].key;X.add(Se)}return await st(S,zs.result,{replace:rt}),{shortCircuited:!0}}let{loaderData:sh,errors:Hd}=EX(S,pe,zn,rh,vt,Fi,al,ce);ce.forEach((Se,Ee)=>{Se.subscribe(tt=>{(tt||Se.done)&&ce.delete(Ee)})});let Q=ct(),we=qe(q),Ae=Q||we||Fi.length>0;return Vi({loaderData:sh,errors:Hd},Ae?{fetchers:new Map(S.fetchers)}:{})}function Re(G,re,pe,de){if(i)throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");$.has(G)&&Me(G);let Te=(de&&de.unstable_flushSync)===!0,Je=a||o,rt=vD(S.location,S.matches,l,u.v7_prependBasename,pe,re,de==null?void 0:de.relative),ht=Dg(Je,rt,l);if(!ht){H(G,re,za(404,{pathname:rt}),{flushSync:Te});return}let{path:pt,submission:vt,error:Tn}=TX(u.v7_normalizeFormMethod,!0,rt,de);if(Tn){H(G,re,Tn,{flushSync:Te});return}let Ut=SD(ht,pt);if(_=(de&&de.preventScrollReset)===!0,vt&&wl(vt.formMethod)){nt(G,re,pt,Ut,ht,Te,vt);return}j.set(G,{routeId:re,path:pt}),Ze(G,re,pt,Ut,ht,Te,vt)}async function nt(G,re,pe,de,Te,Je,rt){if(Lt(),j.delete(G),!de.route.action&&!de.route.lazy){let tt=za(405,{method:rt.formMethod,pathname:pe,routeId:re});H(G,re,tt,{flushSync:Je});return}let ht=S.fetchers.get(G);ye(G,_he(rt,ht),{flushSync:Je});let pt=new AbortController,vt=tx(n.history,pe,pt.signal,rt);$.set(G,pt);let Tn=J,Ut=await ex("action",vt,de,Te,s,r,l);if(vt.signal.aborted){$.get(G)===pt&&$.delete(G);return}if(Z.has(G)){ye(G,Ch(void 0));return}if(ty(Ut))if($.delete(G),q>Tn){ye(G,Ch(void 0));return}else return X.add(G),ye(G,nx(rt)),st(S,Ut,{fetcherSubmission:rt});if(Qx(Ut)){H(G,re,Ut.error);return}if(zp(Ut))throw za(400,{type:"defer-action"});let Nn=S.navigation.location||S.location,zn=tx(n.history,Nn,pt.signal),Fi=a||o,xr=S.navigation.state!=="idle"?Dg(Fi,S.navigation.location,l):S.matches;mn(xr,"Didn't find any matches after fetcher action");let xa=++J;O.set(G,xa);let rh=nx(rt,Ut.data);S.fetchers.set(G,rh);let[al,zs]=CX(n.history,S,xr,rt,Nn,V,U,F,j,X,Fi,l,{[de.route.id]:Ut.data},void 0);zs.filter(tt=>tt.key!==G).forEach(tt=>{let Ct=tt.key,Bt=S.fetchers.get(Ct),Gt=nx(void 0,Bt?Bt.data:void 0);S.fetchers.set(Ct,Gt),$.has(Ct)&&Me(Ct),tt.controller&&$.set(Ct,tt.controller)}),Ue({fetchers:new Map(S.fetchers)});let sh=()=>zs.forEach(tt=>Me(tt.key));pt.signal.addEventListener("abort",sh);let{results:Hd,loaderResults:Q,fetcherResults:we}=await yt(S.matches,xr,al,zs,zn);if(pt.signal.aborted)return;pt.signal.removeEventListener("abort",sh),O.delete(G),$.delete(G),zs.forEach(tt=>$.delete(tt.key));let Ae=RX(Hd);if(Ae){if(Ae.idx>=al.length){let tt=zs[Ae.idx-al.length].key;X.add(tt)}return st(S,Ae.result)}let{loaderData:Se,errors:Ee}=EX(S,S.matches,al,Q,void 0,zs,we,ce);if(S.fetchers.has(G)){let tt=Ch(Ut.data);S.fetchers.set(G,tt)}qe(xa),S.navigation.state==="loading"&&xa>q?(mn(C,"Expected pending action"),A&&A.abort(),Ye(S.navigation.location,{matches:xr,loaderData:Se,errors:Ee,fetchers:new Map(S.fetchers)})):(Ue({errors:Ee,loaderData:IX(S.loaderData,Se,xr,Ee),fetchers:new Map(S.fetchers)}),V=!1)}async function Ze(G,re,pe,de,Te,Je,rt){let ht=S.fetchers.get(G);ye(G,nx(rt,ht?ht.data:void 0),{flushSync:Je});let pt=new AbortController,vt=tx(n.history,pe,pt.signal);$.set(G,pt);let Tn=J,Ut=await ex("loader",vt,de,Te,s,r,l);if(zp(Ut)&&(Ut=await hY(Ut,vt.signal,!0)||Ut),$.get(G)===pt&&$.delete(G),!vt.signal.aborted){if(Z.has(G)){ye(G,Ch(void 0));return}if(ty(Ut))if(q>Tn){ye(G,Ch(void 0));return}else{X.add(G),await st(S,Ut);return}if(Qx(Ut)){H(G,re,Ut.error);return}mn(!zp(Ut),"Unhandled fetcher deferred data"),ye(G,Ch(Ut.data))}}async function st(G,re,pe){let{submission:de,fetcherSubmission:Te,replace:Je}=pe===void 0?{}:pe;re.revalidate&&(V=!0);let rt=Nv(G.location,re.location,{_isRedirect:!0});if(mn(rt,"Expected a location on the redirect navigation"),t){let Nn=!1;if(re.reloadDocument)Nn=!0;else if(aY.test(re.location)){const zn=n.history.createURL(re.location);Nn=zn.origin!==e.location.origin||hd(zn.pathname,l)==null}if(Nn){Je?e.location.replace(re.location):e.location.assign(re.location);return}}A=null;let ht=Je===!0?Ji.Replace:Ji.Push,{formMethod:pt,formAction:vt,formEncType:Tn}=G.navigation;!de&&!Te&&pt&&vt&&Tn&&(de=LX(G.navigation));let Ut=de||Te;if(dhe.has(re.status)&&Ut&&wl(Ut.formMethod))await De(ht,rt,{submission:Vi({},Ut,{formAction:re.location}),preventScrollReset:_});else{let Nn=oN(rt,de);await De(ht,rt,{overrideNavigation:Nn,fetcherSubmission:Te,preventScrollReset:_})}}async function yt(G,re,pe,de,Te){let Je=await Promise.all([...pe.map(pt=>ex("loader",Te,pt,re,s,r,l)),...de.map(pt=>pt.matches&&pt.match&&pt.controller?ex("loader",tx(n.history,pt.path,pt.controller.signal),pt.match,pt.matches,s,r,l):{type:Qi.error,error:za(404,{pathname:pt.path})})]),rt=Je.slice(0,pe.length),ht=Je.slice(pe.length);return await Promise.all([NX(G,pe,rt,rt.map(()=>Te.signal),!1,S.loaderData),NX(G,de.map(pt=>pt.match),ht,de.map(pt=>pt.controller?pt.controller.signal:null),!0)]),{results:Je,loaderResults:rt,fetcherResults:ht}}function Lt(){V=!0,U.push(...sn()),j.forEach((G,re)=>{$.has(re)&&(F.push(re),Me(re))})}function ye(G,re,pe){pe===void 0&&(pe={}),S.fetchers.set(G,re),Ue({fetchers:new Map(S.fetchers)},{flushSync:(pe&&pe.flushSync)===!0})}function H(G,re,pe,de){de===void 0&&(de={});let Te=Jx(S.matches,re);oe(G),Ue({errors:{[Te.route.id]:pe},fetchers:new Map(S.fetchers)},{flushSync:(de&&de.flushSync)===!0})}function D(G){return u.v7_fetcherPersist&&(z.set(G,(z.get(G)||0)+1),Z.has(G)&&Z.delete(G)),S.fetchers.get(G)||phe}function oe(G){let re=S.fetchers.get(G);$.has(G)&&!(re&&re.state==="loading"&&O.has(G))&&Me(G),j.delete(G),O.delete(G),X.delete(G),Z.delete(G),S.fetchers.delete(G)}function Ie(G){if(u.v7_fetcherPersist){let re=(z.get(G)||0)-1;re<=0?(z.delete(G),Z.add(G)):z.set(G,re)}else oe(G);Ue({fetchers:new Map(S.fetchers)})}function Me(G){let re=$.get(G);mn(re,"Expected fetch controller: "+G),re.abort(),$.delete(G)}function Ve(G){for(let re of G){let pe=D(re),de=Ch(pe.data);S.fetchers.set(re,de)}}function ct(){let G=[],re=!1;for(let pe of X){let de=S.fetchers.get(pe);mn(de,"Expected fetcher: "+pe),de.state==="loading"&&(X.delete(pe),G.push(pe),re=!0)}return Ve(G),re}function qe(G){let re=[];for(let[pe,de]of O)if(de<G){let Te=S.fetchers.get(pe);mn(Te,"Expected fetcher: "+pe),Te.state==="loading"&&(Me(pe),O.delete(pe),re.push(pe))}return Ve(re),re.length>0}function at(G,re){let pe=S.blockers.get(G)||qb;return fe.get(G)!==re&&fe.set(G,re),pe}function Ot(G){S.blockers.delete(G),fe.delete(G)}function Xt(G,re){let pe=S.blockers.get(G)||qb;mn(pe.state==="unblocked"&&re.state==="blocked"||pe.state==="blocked"&&re.state==="blocked"||pe.state==="blocked"&&re.state==="proceeding"||pe.state==="blocked"&&re.state==="unblocked"||pe.state==="proceeding"&&re.state==="unblocked","Invalid blocker state transition: "+pe.state+" -> "+re.state);let de=new Map(S.blockers);de.set(G,re),Ue({blockers:de})}function Qe(G){let{currentLocation:re,nextLocation:pe,historyAction:de}=G;if(fe.size===0)return;fe.size>1&&yf(!1,"A router only supports one blocker at a time");let Te=Array.from(fe.entries()),[Je,rt]=Te[Te.length-1],ht=S.blockers.get(Je);if(!(ht&&ht.state==="proceeding")&&rt({currentLocation:re,nextLocation:pe,historyAction:de}))return Je}function sn(G){let re=[];return ce.forEach((pe,de)=>{(!G||G(de))&&(pe.cancel(),re.push(de),ce.delete(de))}),re}function le(G,re,pe){if(d=G,f=re,p=pe||null,!g&&S.navigation===sN){g=!0;let de=Ke(S.location,S.matches);de!=null&&Ue({restoreScrollPosition:de})}return()=>{d=null,f=null,p=null}}function Oe(G,re){return p&&p(G,re.map(de=>$ce(de,S.loaderData)))||G.key}function je(G,re){if(d&&f){let pe=Oe(G,re);d[pe]=f()}}function Ke(G,re){if(d){let pe=Oe(G,re),de=d[pe];if(typeof de=="number")return de}return null}function Pt(G){s={},a=bD(G,r,void 0,s)}return w={get basename(){return l},get state(){return S},get routes(){return o},get window(){return e},initialize:Ne,subscribe:We,enableScrollRestoration:le,navigate:$e,fetch:Re,revalidate:ee,createHref:G=>n.history.createHref(G),encodeLocation:G=>n.history.encodeLocation(G),getFetcher:D,deleteFetcher:Ie,dispose:Fe,getBlocker:at,deleteBlocker:Ot,_internalFetchControllers:$,_internalActiveDeferreds:ce,_internalSetRoutes:Pt},w}function ghe(n){return n!=null&&("formData"in n&&n.formData!=null||"body"in n&&n.body!==void 0)}function vD(n,e,t,i,r,s,o){let a,l;if(s){a=[];for(let c of e)if(a.push(c),c.route.id===s){l=c;break}}else a=e,l=e[e.length-1];let u=UO(r||".",WA(a).map(c=>c.pathnameBase),hd(n.pathname,t)||n.pathname,o==="path");return r==null&&(u.search=n.search,u.hash=n.hash),(r==null||r===""||r===".")&&l&&l.route.index&&!WO(u.search)&&(u.search=u.search?u.search.replace(/^\?/,"?index&"):"?index"),i&&t!=="/"&&(u.pathname=u.pathname==="/"?t:Sc([t,u.pathname])),bf(u)}function TX(n,e,t,i){if(!i||!ghe(i))return{path:t};if(i.formMethod&&!The(i.formMethod))return{path:t,error:za(405,{method:i.formMethod})};let r=()=>({path:t,error:za(400,{type:"invalid-body"})}),s=i.formMethod||"get",o=n?s.toUpperCase():s.toLowerCase(),a=cY(t);if(i.body!==void 0){if(i.formEncType==="text/plain"){if(!wl(o))return r();let d=typeof i.body=="string"?i.body:i.body instanceof FormData||i.body instanceof URLSearchParams?Array.from(i.body.entries()).reduce((p,f)=>{let[g,y]=f;return""+p+g+"="+y+`
`},""):String(i.body);return{path:t,submission:{formMethod:o,formAction:a,formEncType:i.formEncType,formData:void 0,json:void 0,text:d}}}else if(i.formEncType==="application/json"){if(!wl(o))return r();try{let d=typeof i.body=="string"?JSON.parse(i.body):i.body;return{path:t,submission:{formMethod:o,formAction:a,formEncType:i.formEncType,formData:void 0,json:d,text:void 0}}}catch{return r()}}}mn(typeof FormData=="function","FormData is not available in this environment");let l,u;if(i.formData)l=wD(i.formData),u=i.formData;else if(i.body instanceof FormData)l=wD(i.body),u=i.body;else if(i.body instanceof URLSearchParams)l=i.body,u=AX(l);else if(i.body==null)l=new URLSearchParams,u=new FormData;else try{l=new URLSearchParams(i.body),u=AX(l)}catch{return r()}let c={formMethod:o,formAction:a,formEncType:i&&i.formEncType||"application/x-www-form-urlencoded",formData:u,json:void 0,text:void 0};if(wl(c.formMethod))return{path:t,submission:c};let h=Kc(t);return e&&h.search&&WO(h.search)&&l.append("index",""),h.search="?"+l,{path:bf(h),submission:c}}function yhe(n,e){let t=n;if(e){let i=n.findIndex(r=>r.route.id===e);i>=0&&(t=n.slice(0,i))}return t}function CX(n,e,t,i,r,s,o,a,l,u,c,h,d,p){let f=p?Object.values(p)[0]:d?Object.values(d)[0]:void 0,g=n.createURL(e.location),y=n.createURL(r),m=p?Object.keys(p)[0]:void 0,w=yhe(t,m).filter((C,_)=>{if(C.route.lazy)return!0;if(C.route.loader==null)return!1;if(bhe(e.loaderData,e.matches[_],C)||o.some(E=>E===C.route.id))return!0;let A=e.matches[_],I=C;return _X(C,Vi({currentUrl:g,currentParams:A.params,nextUrl:y,nextParams:I.params},i,{actionResult:f,defaultShouldRevalidate:s||g.pathname+g.search===y.pathname+y.search||g.search!==y.search||uY(A,I)}))}),S=[];return l.forEach((C,_)=>{if(!t.some(P=>P.route.id===C.routeId))return;let A=Dg(c,C.path,h);if(!A){S.push({key:_,routeId:C.routeId,path:C.path,matches:null,match:null,controller:null});return}let I=e.fetchers.get(_),E=SD(A,C.path),k=!1;u.has(_)?k=!1:a.includes(_)?k=!0:I&&I.state!=="idle"&&I.data===void 0?k=s:k=_X(E,Vi({currentUrl:g,currentParams:e.matches[e.matches.length-1].params,nextUrl:y,nextParams:t[t.length-1].params},i,{actionResult:f,defaultShouldRevalidate:s})),k&&S.push({key:_,routeId:C.routeId,path:C.path,matches:A,match:E,controller:new AbortController})}),[w,S]}function bhe(n,e,t){let i=!e||t.route.id!==e.route.id,r=n[t.route.id]===void 0;return i||r}function uY(n,e){let t=n.route.path;return n.pathname!==e.pathname||t!=null&&t.endsWith("*")&&n.params["*"]!==e.params["*"]}function _X(n,e){if(n.route.shouldRevalidate){let t=n.route.shouldRevalidate(e);if(typeof t=="boolean")return t}return e.defaultShouldRevalidate}async function MX(n,e,t){if(!n.lazy)return;let i=await n.lazy();if(!n.lazy)return;let r=t[n.id];mn(r,"No route found in manifest");let s={};for(let o in i){let l=r[o]!==void 0&&o!=="hasErrorBoundary";yf(!l,'Route "'+r.id+'" has a static property "'+o+'" defined but its lazy function is also returning a value for this property. '+('The lazy route property "'+o+'" will be ignored.')),!l&&!Vce.has(o)&&(s[o]=i[o])}Object.assign(r,s),Object.assign(r,Vi({},e(r),{lazy:void 0}))}async function ex(n,e,t,i,r,s,o,a){a===void 0&&(a={});let l,u,c,h=f=>{let g,y=new Promise((m,v)=>g=v);return c=()=>g(),e.signal.addEventListener("abort",c),Promise.race([f({request:e,params:t.params,context:a.requestContext}),y])};try{let f=t.route[n];if(t.route.lazy)if(f){let g,y=await Promise.all([h(f).catch(m=>{g=m}),MX(t.route,s,r)]);if(g)throw g;u=y[0]}else if(await MX(t.route,s,r),f=t.route[n],f)u=await h(f);else if(n==="action"){let g=new URL(e.url),y=g.pathname+g.search;throw za(405,{method:e.method,pathname:y,routeId:t.route.id})}else return{type:Qi.data,data:void 0};else if(f)u=await h(f);else{let g=new URL(e.url),y=g.pathname+g.search;throw za(404,{pathname:y})}mn(u!==void 0,"You defined "+(n==="action"?"an action":"a loader")+" for route "+('"'+t.route.id+"\" but didn't return anything from your `"+n+"` ")+"function. Please return a value or `null`.")}catch(f){l=Qi.error,u=f}finally{c&&e.signal.removeEventListener("abort",c)}if(She(u)){let f=u.status;if(hhe.has(f)){let m=u.headers.get("Location");if(mn(m,"Redirects returned/thrown from loaders/actions must have a Location header"),!aY.test(m))m=vD(new URL(e.url),i.slice(0,i.indexOf(t)+1),o,!0,m);else if(!a.isStaticRequest){let v=new URL(e.url),w=m.startsWith("//")?new URL(v.protocol+m):new URL(m),S=hd(w.pathname,o)!=null;w.origin===v.origin&&S&&(m=w.pathname+w.search+w.hash)}if(a.isStaticRequest)throw u.headers.set("Location",m),u;return{type:Qi.redirect,status:f,location:m,revalidate:u.headers.get("X-Remix-Revalidate")!==null,reloadDocument:u.headers.get("X-Remix-Reload-Document")!==null}}if(a.isRouteRequest)throw{type:l===Qi.error?Qi.error:Qi.data,response:u};let g,y=u.headers.get("Content-Type");return y&&/\bapplication\/json\b/.test(y)?g=await u.json():g=await u.text(),l===Qi.error?{type:l,error:new $O(f,u.statusText,g),headers:u.headers}:{type:Qi.data,data:g,statusCode:u.status,headers:u.headers}}if(l===Qi.error)return{type:l,error:u};if(whe(u)){var d,p;return{type:Qi.deferred,deferredData:u,statusCode:(d=u.init)==null?void 0:d.status,headers:((p=u.init)==null?void 0:p.headers)&&new Headers(u.init.headers)}}return{type:Qi.data,data:u}}function tx(n,e,t,i){let r=n.createURL(cY(e)).toString(),s={signal:t};if(i&&wl(i.formMethod)){let{formMethod:o,formEncType:a}=i;s.method=o.toUpperCase(),a==="application/json"?(s.headers=new Headers({"Content-Type":a}),s.body=JSON.stringify(i.json)):a==="text/plain"?s.body=i.text:a==="application/x-www-form-urlencoded"&&i.formData?s.body=wD(i.formData):s.body=i.formData}return new Request(r,s)}function wD(n){let e=new URLSearchParams;for(let[t,i]of n.entries())e.append(t,typeof i=="string"?i:i.name);return e}function AX(n){let e=new FormData;for(let[t,i]of n.entries())e.append(t,i);return e}function xhe(n,e,t,i,r){let s={},o=null,a,l=!1,u={};return t.forEach((c,h)=>{let d=e[h].route.id;if(mn(!ty(c),"Cannot handle redirect results in processLoaderData"),Qx(c)){let p=Jx(n,d),f=c.error;i&&(f=Object.values(i)[0],i=void 0),o=o||{},o[p.route.id]==null&&(o[p.route.id]=f),s[d]=void 0,l||(l=!0,a=sY(c.error)?c.error.status:500),c.headers&&(u[d]=c.headers)}else zp(c)?(r.set(d,c.deferredData),s[d]=c.deferredData.data):s[d]=c.data,c.statusCode!=null&&c.statusCode!==200&&!l&&(a=c.statusCode),c.headers&&(u[d]=c.headers)}),i&&(o=i,s[Object.keys(i)[0]]=void 0),{loaderData:s,errors:o,statusCode:a||200,loaderHeaders:u}}function EX(n,e,t,i,r,s,o,a){let{loaderData:l,errors:u}=xhe(e,t,i,r,a);for(let c=0;c<s.length;c++){let{key:h,match:d,controller:p}=s[c];mn(o!==void 0&&o[c]!==void 0,"Did not find corresponding fetcher result");let f=o[c];if(!(p&&p.signal.aborted))if(Qx(f)){let g=Jx(n.matches,d==null?void 0:d.route.id);u&&u[g.route.id]||(u=Vi({},u,{[g.route.id]:f.error})),n.fetchers.delete(h)}else if(ty(f))mn(!1,"Unhandled fetcher revalidation redirect");else if(zp(f))mn(!1,"Unhandled fetcher deferred data");else{let g=Ch(f.data);n.fetchers.set(h,g)}}return{loaderData:l,errors:u}}function IX(n,e,t,i){let r=Vi({},e);for(let s of t){let o=s.route.id;if(e.hasOwnProperty(o)?e[o]!==void 0&&(r[o]=e[o]):n[o]!==void 0&&s.route.loader&&(r[o]=n[o]),i&&i.hasOwnProperty(o))break}return r}function Jx(n,e){return(e?n.slice(0,n.findIndex(i=>i.route.id===e)+1):[...n]).reverse().find(i=>i.route.hasErrorBoundary===!0)||n[0]}function kX(n){let e=n.length===1?n[0]:n.find(t=>t.index||!t.path||t.path==="/")||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:e}],route:e}}function za(n,e){let{pathname:t,routeId:i,method:r,type:s}=e===void 0?{}:e,o="Unknown Server Error",a="Unknown @remix-run/router error";return n===400?(o="Bad Request",r&&t&&i?a="You made a "+r+' request to "'+t+'" but '+('did not provide a `loader` for route "'+i+'", ')+"so there is no way to handle the request.":s==="defer-action"?a="defer() is not supported in actions":s==="invalid-body"&&(a="Unable to encode submission body")):n===403?(o="Forbidden",a='Route "'+i+'" does not match URL "'+t+'"'):n===404?(o="Not Found",a='No route matches URL "'+t+'"'):n===405&&(o="Method Not Allowed",r&&t&&i?a="You made a "+r.toUpperCase()+' request to "'+t+'" but '+('did not provide an `action` for route "'+i+'", ')+"so there is no way to handle the request.":r&&(a='Invalid request method "'+r.toUpperCase()+'"')),new $O(n||500,o,new Error(a),!0)}function RX(n){for(let e=n.length-1;e>=0;e--){let t=n[e];if(ty(t))return{result:t,idx:e}}}function cY(n){let e=typeof n=="string"?Kc(n):n;return bf(Vi({},e,{hash:""}))}function vhe(n,e){return n.pathname!==e.pathname||n.search!==e.search?!1:n.hash===""?e.hash!=="":n.hash===e.hash?!0:e.hash!==""}function zp(n){return n.type===Qi.deferred}function Qx(n){return n.type===Qi.error}function ty(n){return(n&&n.type)===Qi.redirect}function whe(n){let e=n;return e&&typeof e=="object"&&typeof e.data=="object"&&typeof e.subscribe=="function"&&typeof e.cancel=="function"&&typeof e.resolveData=="function"}function She(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.headers=="object"&&typeof n.body<"u"}function The(n){return che.has(n.toLowerCase())}function wl(n){return lhe.has(n.toLowerCase())}async function NX(n,e,t,i,r,s){for(let o=0;o<t.length;o++){let a=t[o],l=e[o];if(!l)continue;let u=n.find(h=>h.route.id===l.route.id),c=u!=null&&!uY(u,l)&&(s&&s[l.route.id])!==void 0;if(zp(a)&&(r||c)){let h=i[o];mn(h,"Expected an AbortSignal for revalidating fetcher deferred result"),await hY(a,h,r).then(d=>{d&&(t[o]=d||t[o])})}}}async function hY(n,e,t){if(t===void 0&&(t=!1),!await n.deferredData.resolveData(e)){if(t)try{return{type:Qi.data,data:n.deferredData.unwrappedData}}catch(r){return{type:Qi.error,error:r}}return{type:Qi.data,data:n.deferredData.data}}}function WO(n){return new URLSearchParams(n).getAll("index").some(e=>e==="")}function SD(n,e){let t=typeof e=="string"?Kc(e).search:e.search;if(n[n.length-1].route.index&&WO(t||""))return n[n.length-1];let i=WA(n);return i[i.length-1]}function LX(n){let{formMethod:e,formAction:t,formEncType:i,text:r,formData:s,json:o}=n;if(!(!e||!t||!i)){if(r!=null)return{formMethod:e,formAction:t,formEncType:i,formData:void 0,json:void 0,text:r};if(s!=null)return{formMethod:e,formAction:t,formEncType:i,formData:s,json:void 0,text:void 0};if(o!==void 0)return{formMethod:e,formAction:t,formEncType:i,formData:void 0,json:o,text:void 0}}}function oN(n,e){return e?{state:"loading",location:n,formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text}:{state:"loading",location:n,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0}}function Che(n,e){return{state:"submitting",location:n,formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text}}function nx(n,e){return n?{state:"loading",formMethod:n.formMethod,formAction:n.formAction,formEncType:n.formEncType,formData:n.formData,json:n.json,text:n.text,data:e}:{state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:e}}function _he(n,e){return{state:"submitting",formMethod:n.formMethod,formAction:n.formAction,formEncType:n.formEncType,formData:n.formData,json:n.json,text:n.text,data:e?e.data:void 0}}function Ch(n){return{state:"idle",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:n}}function Mhe(n,e){try{let t=n.sessionStorage.getItem(lY);if(t){let i=JSON.parse(t);for(let[r,s]of Object.entries(i||{}))s&&Array.isArray(s)&&e.set(r,new Set(s||[]))}}catch{}}function Ahe(n,e){if(e.size>0){let t={};for(let[i,r]of e)t[i]=[...r];try{n.sessionStorage.setItem(lY,JSON.stringify(t))}catch(i){yf(!1,"Failed to save applied view transitions in sessionStorage ("+i+").")}}}/**
 * React Router v6.19.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function vM(){return vM=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},vM.apply(this,arguments)}const E1=K.createContext(null),HO=K.createContext(null),Yf=K.createContext(null),HA=K.createContext(null),Id=K.createContext({outlet:null,matches:[],isDataRoute:!1}),dY=K.createContext(null);function Ehe(n,e){let{relative:t}=e===void 0?{}:e;I1()||mn(!1);let{basename:i,navigator:r}=K.useContext(Yf),{hash:s,pathname:o,search:a}=XA(n,{relative:t}),l=o;return i!=="/"&&(l=o==="/"?i:Sc([i,o])),r.createHref({pathname:l,search:a,hash:s})}function I1(){return K.useContext(HA)!=null}function k1(){return I1()||mn(!1),K.useContext(HA).location}function pY(n){K.useContext(Yf).static||K.useLayoutEffect(n)}function Ihe(){let{isDataRoute:n}=K.useContext(Id);return n?$he():khe()}function khe(){I1()||mn(!1);let n=K.useContext(E1),{basename:e,navigator:t}=K.useContext(Yf),{matches:i}=K.useContext(Id),{pathname:r}=k1(),s=JSON.stringify(WA(i).map(l=>l.pathnameBase)),o=K.useRef(!1);return pY(()=>{o.current=!0}),K.useCallback(function(l,u){if(u===void 0&&(u={}),!o.current)return;if(typeof l=="number"){t.go(l);return}let c=UO(l,JSON.parse(s),r,u.relative==="path");n==null&&e!=="/"&&(c.pathname=c.pathname==="/"?e:Sc([e,c.pathname])),(u.replace?t.replace:t.push)(c,u.state,u)},[e,t,s,r,n])}const Rhe=K.createContext(null);function Nhe(n){let e=K.useContext(Id).outlet;return e&&K.createElement(Rhe.Provider,{value:n},e)}function XA(n,e){let{relative:t}=e===void 0?{}:e,{matches:i}=K.useContext(Id),{pathname:r}=k1(),s=JSON.stringify(WA(i).map((o,a)=>a===i.length-1?o.pathname:o.pathnameBase));return K.useMemo(()=>UO(n,JSON.parse(s),r,t==="path"),[n,s,r,t])}function Lhe(n,e,t){I1()||mn(!1);let{navigator:i}=K.useContext(Yf),{matches:r}=K.useContext(Id),s=r[r.length-1],o=s?s.params:{};s&&s.pathname;let a=s?s.pathnameBase:"/";s&&s.route;let l=k1(),u;if(e){var c;let g=typeof e=="string"?Kc(e):e;a==="/"||(c=g.pathname)!=null&&c.startsWith(a)||mn(!1),u=g}else u=l;let h=u.pathname||"/",d=a==="/"?h:h.slice(a.length)||"/",p=Dg(n,{pathname:d}),f=Bhe(p&&p.map(g=>Object.assign({},g,{params:Object.assign({},o,g.params),pathname:Sc([a,i.encodeLocation?i.encodeLocation(g.pathname).pathname:g.pathname]),pathnameBase:g.pathnameBase==="/"?a:Sc([a,i.encodeLocation?i.encodeLocation(g.pathnameBase).pathname:g.pathnameBase])})),r,t);return e&&f?K.createElement(HA.Provider,{value:{location:vM({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:Ji.Pop}},f):f}function Phe(){let n=Uhe(),e=sY(n)?n.status+" "+n.statusText:n instanceof Error?n.message:JSON.stringify(n),t=n instanceof Error?n.stack:null,r={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"},s=null;return K.createElement(K.Fragment,null,K.createElement("h2",null,"Unexpected Application Error!"),K.createElement("h3",{style:{fontStyle:"italic"}},e),t?K.createElement("pre",{style:r},t):null,s)}const Dhe=K.createElement(Phe,null);class Fhe extends K.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error||t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return this.state.error?K.createElement(Id.Provider,{value:this.props.routeContext},K.createElement(dY.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Ohe(n){let{routeContext:e,match:t,children:i}=n,r=K.useContext(E1);return r&&r.static&&r.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=t.route.id),K.createElement(Id.Provider,{value:e},i)}function Bhe(n,e,t){var i;if(e===void 0&&(e=[]),t===void 0&&(t=null),n==null){var r;if((r=t)!=null&&r.errors)n=t.matches;else return null}let s=n,o=(i=t)==null?void 0:i.errors;if(o!=null){let a=s.findIndex(l=>l.route.id&&(o==null?void 0:o[l.route.id]));a>=0||mn(!1),s=s.slice(0,Math.min(s.length,a+1))}return s.reduceRight((a,l,u)=>{let c=l.route.id?o==null?void 0:o[l.route.id]:null,h=null;t&&(h=l.route.errorElement||Dhe);let d=e.concat(s.slice(0,u+1)),p=()=>{let f;return c?f=h:l.route.Component?f=K.createElement(l.route.Component,null):l.route.element?f=l.route.element:f=a,K.createElement(Ohe,{match:l,routeContext:{outlet:a,matches:d,isDataRoute:t!=null},children:f})};return t&&(l.route.ErrorBoundary||l.route.errorElement||u===0)?K.createElement(Fhe,{location:t.location,revalidation:t.revalidation,component:h,error:c,children:p(),routeContext:{outlet:null,matches:d,isDataRoute:!0}}):p()},null)}var fY=function(n){return n.UseBlocker="useBlocker",n.UseRevalidator="useRevalidator",n.UseNavigateStable="useNavigate",n}(fY||{}),wM=function(n){return n.UseBlocker="useBlocker",n.UseLoaderData="useLoaderData",n.UseActionData="useActionData",n.UseRouteError="useRouteError",n.UseNavigation="useNavigation",n.UseRouteLoaderData="useRouteLoaderData",n.UseMatches="useMatches",n.UseRevalidator="useRevalidator",n.UseNavigateStable="useNavigate",n.UseRouteId="useRouteId",n}(wM||{});function zhe(n){let e=K.useContext(E1);return e||mn(!1),e}function Ghe(n){let e=K.useContext(HO);return e||mn(!1),e}function Vhe(n){let e=K.useContext(Id);return e||mn(!1),e}function mY(n){let e=Vhe(),t=e.matches[e.matches.length-1];return t.route.id||mn(!1),t.route.id}function Uhe(){var n;let e=K.useContext(dY),t=Ghe(wM.UseRouteError),i=mY(wM.UseRouteError);return e||((n=t.errors)==null?void 0:n[i])}function $he(){let{router:n}=zhe(fY.UseNavigateStable),e=mY(wM.UseNavigateStable),t=K.useRef(!1);return pY(()=>{t.current=!0}),K.useCallback(function(r,s){s===void 0&&(s={}),t.current&&(typeof r=="number"?n.navigate(r):n.navigate(r,vM({fromRouteId:e},s)))},[n,e])}function Whe(n){return Nhe(n.context)}function Hhe(n){let{basename:e="/",children:t=null,location:i,navigationType:r=Ji.Pop,navigator:s,static:o=!1}=n;I1()&&mn(!1);let a=e.replace(/^\/*/,"/"),l=K.useMemo(()=>({basename:a,navigator:s,static:o}),[a,s,o]);typeof i=="string"&&(i=Kc(i));let{pathname:u="/",search:c="",hash:h="",state:d=null,key:p="default"}=i,f=K.useMemo(()=>{let g=hd(u,a);return g==null?null:{location:{pathname:g,search:c,hash:h,state:d,key:p},navigationType:r}},[a,u,c,h,d,p,r]);return f==null?null:K.createElement(Yf.Provider,{value:l},K.createElement(HA.Provider,{children:t,value:f}))}new Promise(()=>{});function Xhe(n){let e={hasErrorBoundary:n.ErrorBoundary!=null||n.errorElement!=null};return n.Component&&Object.assign(e,{element:K.createElement(n.Component),Component:void 0}),n.ErrorBoundary&&Object.assign(e,{errorElement:K.createElement(n.ErrorBoundary),ErrorBoundary:void 0}),e}/**
 * React Router DOM v6.19.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function xy(){return xy=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},xy.apply(this,arguments)}function gY(n,e){if(n==null)return{};var t={},i=Object.keys(n),r,s;for(s=0;s<i.length;s++)r=i[s],!(e.indexOf(r)>=0)&&(t[r]=n[r]);return t}function Khe(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function Zhe(n,e){return n.button===0&&(!e||e==="_self")&&!Khe(n)}const jhe=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],Yhe=["aria-current","caseSensitive","className","end","style","to","unstable_viewTransition","children"];function Jhe(n,e){return mhe({basename:e==null?void 0:e.basename,future:xy({},e==null?void 0:e.future,{v7_prependBasename:!0}),history:Bce({window:e==null?void 0:e.window}),hydrationData:(e==null?void 0:e.hydrationData)||Qhe(),routes:n,mapRouteProperties:Xhe,window:e==null?void 0:e.window}).initialize()}function Qhe(){var n;let e=(n=window)==null?void 0:n.__staticRouterHydrationData;return e&&e.errors&&(e=xy({},e,{errors:qhe(e.errors)})),e}function qhe(n){if(!n)return null;let e=Object.entries(n),t={};for(let[i,r]of e)if(r&&r.__type==="RouteErrorResponse")t[i]=new $O(r.status,r.statusText,r.data,r.internal===!0);else if(r&&r.__type==="Error"){if(r.__subType){let s=window[r.__subType];if(typeof s=="function")try{let o=new s(r.message);o.stack="",t[i]=o}catch{}}if(t[i]==null){let s=new Error(r.message);s.stack="",t[i]=s}}else t[i]=r;return t}const yY=K.createContext({isTransitioning:!1}),ede=K.createContext(new Map),tde="startTransition",PX=Mle[tde],nde="flushSync",DX=Oce[nde];function ide(n){PX?PX(n):n()}function ix(n){DX?DX(n):n()}class rde{constructor(){this.status="pending",this.promise=new Promise((e,t)=>{this.resolve=i=>{this.status==="pending"&&(this.status="resolved",e(i))},this.reject=i=>{this.status==="pending"&&(this.status="rejected",t(i))}})}}function sde(n){let{fallbackElement:e,router:t,future:i}=n,[r,s]=K.useState(t.state),[o,a]=K.useState(),[l,u]=K.useState({isTransitioning:!1}),[c,h]=K.useState(),[d,p]=K.useState(),[f,g]=K.useState(),y=K.useRef(new Map),{v7_startTransition:m}=i||{},v=K.useCallback(A=>{m?ide(A):A()},[m]),w=K.useCallback((A,I)=>{let{deletedFetchers:E,unstable_flushSync:k,unstable_viewTransitionOpts:P}=I;E.forEach(U=>y.current.delete(U)),A.fetchers.forEach((U,F)=>{U.data!==void 0&&y.current.set(F,U.data)});let V=t.window==null||typeof t.window.document.startViewTransition!="function";if(!P||V){k?ix(()=>s(A)):v(()=>s(A));return}if(k){ix(()=>{d&&(c&&c.resolve(),d.skipTransition()),u({isTransitioning:!0,flushSync:!0,currentLocation:P.currentLocation,nextLocation:P.nextLocation})});let U=t.window.document.startViewTransition(()=>{ix(()=>s(A))});U.finished.finally(()=>{ix(()=>{h(void 0),p(void 0),a(void 0),u({isTransitioning:!1})})}),ix(()=>p(U));return}d?(c&&c.resolve(),d.skipTransition(),g({state:A,currentLocation:P.currentLocation,nextLocation:P.nextLocation})):(a(A),u({isTransitioning:!0,flushSync:!1,currentLocation:P.currentLocation,nextLocation:P.nextLocation}))},[t.window,d,c,y,v]);K.useLayoutEffect(()=>t.subscribe(w),[t,w]),K.useEffect(()=>{l.isTransitioning&&!l.flushSync&&h(new rde)},[l]),K.useEffect(()=>{if(c&&o&&t.window){let A=o,I=c.promise,E=t.window.document.startViewTransition(async()=>{v(()=>s(A)),await I});E.finished.finally(()=>{h(void 0),p(void 0),a(void 0),u({isTransitioning:!1})}),p(E)}},[v,o,c,t.window]),K.useEffect(()=>{c&&o&&r.location.key===o.location.key&&c.resolve()},[c,d,r.location,o]),K.useEffect(()=>{!l.isTransitioning&&f&&(a(f.state),u({isTransitioning:!0,flushSync:!1,currentLocation:f.currentLocation,nextLocation:f.nextLocation}),g(void 0))},[l.isTransitioning,f]);let S=K.useMemo(()=>({createHref:t.createHref,encodeLocation:t.encodeLocation,go:A=>t.navigate(A),push:(A,I,E)=>t.navigate(A,{state:I,preventScrollReset:E==null?void 0:E.preventScrollReset}),replace:(A,I,E)=>t.navigate(A,{replace:!0,state:I,preventScrollReset:E==null?void 0:E.preventScrollReset})}),[t]),C=t.basename||"/",_=K.useMemo(()=>({router:t,navigator:S,static:!1,basename:C}),[t,S,C]);return K.createElement(K.Fragment,null,K.createElement(E1.Provider,{value:_},K.createElement(HO.Provider,{value:r},K.createElement(ede.Provider,{value:y.current},K.createElement(yY.Provider,{value:l},K.createElement(Hhe,{basename:C,location:r.location,navigationType:r.historyAction,navigator:S},r.initialized?K.createElement(ode,{routes:t.routes,state:r}):e))))),null)}function ode(n){let{routes:e,state:t}=n;return Lhe(e,void 0,t)}const ade=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",lde=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,R1=K.forwardRef(function(e,t){let{onClick:i,relative:r,reloadDocument:s,replace:o,state:a,target:l,to:u,preventScrollReset:c,unstable_viewTransition:h}=e,d=gY(e,jhe),{basename:p}=K.useContext(Yf),f,g=!1;if(typeof u=="string"&&lde.test(u)&&(f=u,ade))try{let w=new URL(window.location.href),S=u.startsWith("//")?new URL(w.protocol+u):new URL(u),C=hd(S.pathname,p);S.origin===w.origin&&C!=null?u=C+S.search+S.hash:g=!0}catch{}let y=Ehe(u,{relative:r}),m=cde(u,{replace:o,state:a,target:l,preventScrollReset:c,relative:r,unstable_viewTransition:h});function v(w){i&&i(w),w.defaultPrevented||m(w)}return K.createElement("a",xy({},d,{href:f||y,onClick:g||s?i:v,ref:t,target:l}))}),bY=K.forwardRef(function(e,t){let{"aria-current":i="page",caseSensitive:r=!1,className:s="",end:o=!1,style:a,to:l,unstable_viewTransition:u,children:c}=e,h=gY(e,Yhe),d=XA(l,{relative:h.relative}),p=k1(),f=K.useContext(HO),{navigator:g}=K.useContext(Yf),y=f!=null&&hde(d)&&u===!0,m=g.encodeLocation?g.encodeLocation(d).pathname:d.pathname,v=p.pathname,w=f&&f.navigation&&f.navigation.location?f.navigation.location.pathname:null;r||(v=v.toLowerCase(),w=w?w.toLowerCase():null,m=m.toLowerCase());const S=m!=="/"&&m.endsWith("/")?m.length-1:m.length;let C=v===m||!o&&v.startsWith(m)&&v.charAt(S)==="/",_=w!=null&&(w===m||!o&&w.startsWith(m)&&w.charAt(m.length)==="/"),A={isActive:C,isPending:_,isTransitioning:y},I=C?i:void 0,E;typeof s=="function"?E=s(A):E=[s,C?"active":null,_?"pending":null,y?"transitioning":null].filter(Boolean).join(" ");let k=typeof a=="function"?a(A):a;return K.createElement(R1,xy({},h,{"aria-current":I,className:E,ref:t,style:k,to:l,unstable_viewTransition:u}),typeof c=="function"?c(A):c)});var TD;(function(n){n.UseScrollRestoration="useScrollRestoration",n.UseSubmit="useSubmit",n.UseSubmitFetcher="useSubmitFetcher",n.UseFetcher="useFetcher",n.useViewTransitionState="useViewTransitionState"})(TD||(TD={}));var FX;(function(n){n.UseFetcher="useFetcher",n.UseFetchers="useFetchers",n.UseScrollRestoration="useScrollRestoration"})(FX||(FX={}));function ude(n){let e=K.useContext(E1);return e||mn(!1),e}function cde(n,e){let{target:t,replace:i,state:r,preventScrollReset:s,relative:o,unstable_viewTransition:a}=e===void 0?{}:e,l=Ihe(),u=k1(),c=XA(n,{relative:o});return K.useCallback(h=>{if(Zhe(h,t)){h.preventDefault();let d=i!==void 0?i:bf(u)===bf(c);l(n,{replace:d,state:r,preventScrollReset:s,relative:o,unstable_viewTransition:a})}},[u,l,c,i,r,t,n,s,o,a])}function hde(n,e){e===void 0&&(e={});let t=K.useContext(yY);t==null&&mn(!1);let{basename:i}=ude(TD.useViewTransitionState),r=XA(n,{relative:e.relative});if(!t.isTransitioning)return!1;let s=hd(t.currentLocation.pathname,i)||t.currentLocation.pathname,o=hd(t.nextLocation.pathname,i)||t.nextLocation.pathname;return xD(r.pathname,o)!=null||xD(r.pathname,s)!=null}function dde(n){if(Array.isArray(n)){for(var e=0,t=Array(n.length);e<n.length;e++)t[e]=n[e];return t}else return Array.from(n)}var XO=!1;if(typeof window<"u"){var OX={get passive(){XO=!0}};window.addEventListener("testPassive",null,OX),window.removeEventListener("testPassive",null,OX)}var SM=typeof window<"u"&&window.navigator&&window.navigator.platform&&(/iP(ad|hone|od)/.test(window.navigator.platform)||window.navigator.platform==="MacIntel"&&window.navigator.maxTouchPoints>1),Qp=[],TM=!1,xY=-1,qx=void 0,kp=void 0,ev=void 0,vY=function(e){return Qp.some(function(t){return!!(t.options.allowTouchMove&&t.options.allowTouchMove(e))})},CM=function(e){var t=e||window.event;return vY(t.target)||t.touches.length>1?!0:(t.preventDefault&&t.preventDefault(),!1)},pde=function(e){if(ev===void 0){var t=!!e&&e.reserveScrollBarGap===!0,i=window.innerWidth-document.documentElement.clientWidth;if(t&&i>0){var r=parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"),10);ev=document.body.style.paddingRight,document.body.style.paddingRight=r+i+"px"}}qx===void 0&&(qx=document.body.style.overflow,document.body.style.overflow="hidden")},fde=function(){ev!==void 0&&(document.body.style.paddingRight=ev,ev=void 0),qx!==void 0&&(document.body.style.overflow=qx,qx=void 0)},mde=function(){return window.requestAnimationFrame(function(){if(kp===void 0){kp={position:document.body.style.position,top:document.body.style.top,left:document.body.style.left};var e=window,t=e.scrollY,i=e.scrollX,r=e.innerHeight;document.body.style.position="fixed",document.body.style.top=-t,document.body.style.left=-i,setTimeout(function(){return window.requestAnimationFrame(function(){var s=r-window.innerHeight;s&&t>=r&&(document.body.style.top=-(t+s))})},300)}})},gde=function(){if(kp!==void 0){var e=-parseInt(document.body.style.top,10),t=-parseInt(document.body.style.left,10);document.body.style.position=kp.position,document.body.style.top=kp.top,document.body.style.left=kp.left,window.scrollTo(t,e),kp=void 0}},yde=function(e){return e?e.scrollHeight-e.scrollTop<=e.clientHeight:!1},bde=function(e,t){var i=e.targetTouches[0].clientY-xY;return vY(e.target)?!1:t&&t.scrollTop===0&&i>0||yde(t)&&i<0?CM(e):(e.stopPropagation(),!0)},xde=function(e,t){if(!e){console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");return}if(!Qp.some(function(r){return r.targetElement===e})){var i={targetElement:e,options:t||{}};Qp=[].concat(dde(Qp),[i]),SM?mde():pde(t),SM&&(e.ontouchstart=function(r){r.targetTouches.length===1&&(xY=r.targetTouches[0].clientY)},e.ontouchmove=function(r){r.targetTouches.length===1&&bde(r,e)},TM||(document.addEventListener("touchmove",CM,XO?{passive:!1}:void 0),TM=!0))}},vde=function(e){if(!e){console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");return}Qp=Qp.filter(function(t){return t.targetElement!==e}),SM&&(e.ontouchstart=null,e.ontouchmove=null,TM&&Qp.length===0&&(document.removeEventListener("touchmove",CM,XO?{passive:!1}:void 0),TM=!1)),SM?gde():fde()};const wY=K.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"}),KA=K.createContext({}),ZA=K.createContext(null),jA=typeof document<"u",KO=jA?K.useLayoutEffect:K.useEffect,SY=K.createContext({strict:!1});function wde(n,e,t,i){const{visualElement:r}=K.useContext(KA),s=K.useContext(SY),o=K.useContext(ZA),a=K.useContext(wY).reducedMotion,l=K.useRef();i=i||s.renderer,!l.current&&i&&(l.current=i(n,{visualState:e,parent:r,props:t,presenceContext:o,blockInitialAnimation:o?o.initial===!1:!1,reducedMotionConfig:a}));const u=l.current;K.useInsertionEffect(()=>{u&&u.update(t,o)});const c=K.useRef(!!window.HandoffAppearAnimations);return KO(()=>{u&&(u.render(),c.current&&u.animationState&&u.animationState.animateChanges())}),K.useEffect(()=>{u&&(u.updateFeatures(),!c.current&&u.animationState&&u.animationState.animateChanges(),window.HandoffAppearAnimations=void 0,c.current=!1)}),u}function Fg(n){return typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function Sde(n,e,t){return K.useCallback(i=>{i&&n.mount&&n.mount(i),e&&(i?e.mount(i):e.unmount()),t&&(typeof t=="function"?t(i):Fg(t)&&(t.current=i))},[e])}function Lv(n){return typeof n=="string"||Array.isArray(n)}function YA(n){return typeof n=="object"&&typeof n.start=="function"}const ZO=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],jO=["initial",...ZO];function JA(n){return YA(n.animate)||jO.some(e=>Lv(n[e]))}function TY(n){return!!(JA(n)||n.variants)}function Tde(n,e){if(JA(n)){const{initial:t,animate:i}=n;return{initial:t===!1||Lv(t)?t:void 0,animate:Lv(i)?i:void 0}}return n.inherit!==!1?e:{}}function Cde(n){const{initial:e,animate:t}=Tde(n,K.useContext(KA));return K.useMemo(()=>({initial:e,animate:t}),[BX(e),BX(t)])}function BX(n){return Array.isArray(n)?n.join(" "):n}const zX={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Pv={};for(const n in zX)Pv[n]={isEnabled:e=>zX[n].some(t=>!!e[t])};function _de(n){for(const e in n)Pv[e]={...Pv[e],...n[e]}}const YO=K.createContext({}),CY=K.createContext({}),Mde=Symbol.for("motionComponentSymbol");function Ade({preloadedFeatures:n,createVisualElement:e,useRender:t,useVisualState:i,Component:r}){n&&_de(n);function s(a,l){let u;const c={...K.useContext(wY),...a,layoutId:Ede(a)},{isStatic:h}=c,d=Cde(a),p=i(a,h);if(!h&&jA){d.visualElement=wde(r,p,c,e);const f=K.useContext(CY),g=K.useContext(SY).strict;d.visualElement&&(u=d.visualElement.loadFeatures(c,g,n,f))}return K.createElement(KA.Provider,{value:d},u&&d.visualElement?K.createElement(u,{visualElement:d.visualElement,...c}):null,t(r,a,Sde(p,d.visualElement,l),p,h,d.visualElement))}const o=K.forwardRef(s);return o[Mde]=r,o}function Ede({layoutId:n}){const e=K.useContext(YO).id;return e&&n!==void 0?e+"-"+n:n}function Ide(n){function e(i,r={}){return Ade(n(i,r))}if(typeof Proxy>"u")return e;const t=new Map;return new Proxy(e,{get:(i,r)=>(t.has(r)||t.set(r,e(r)),t.get(r))})}const kde=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function JO(n){return typeof n!="string"||n.includes("-")?!1:!!(kde.indexOf(n)>-1||/[A-Z]/.test(n))}const _M={};function Rde(n){Object.assign(_M,n)}const N1=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Jf=new Set(N1);function _Y(n,{layout:e,layoutId:t}){return Jf.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!_M[n]||n==="opacity")}const Io=n=>!!(n&&n.getVelocity),Nde={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},Lde=N1.length;function Pde(n,{enableHardwareAcceleration:e=!0,allowTransformNone:t=!0},i,r){let s="";for(let o=0;o<Lde;o++){const a=N1[o];if(n[a]!==void 0){const l=Nde[a]||a;s+=`${l}(${n[a]}) `}}return e&&!n.z&&(s+="translateZ(0)"),s=s.trim(),r?s=r(n,i?"":s):t&&i&&(s="none"),s}const MY=n=>e=>typeof e=="string"&&e.startsWith(n),AY=MY("--"),CD=MY("var(--"),Dde=/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,Fde=(n,e)=>e&&typeof n=="number"?e.transform(n):n,dd=(n,e,t)=>Math.min(Math.max(t,n),e),Qf={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},tv={...Qf,transform:n=>dd(0,1,n)},JT={...Qf,default:1},nv=n=>Math.round(n*1e5)/1e5,QA=/(-)?([\d]*\.?[\d])+/g,EY=/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,Ode=/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function L1(n){return typeof n=="string"}const P1=n=>({test:e=>L1(e)&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),_h=P1("deg"),Mu=P1("%"),$t=P1("px"),Bde=P1("vh"),zde=P1("vw"),GX={...Mu,parse:n=>Mu.parse(n)/100,transform:n=>Mu.transform(n*100)},VX={...Qf,transform:Math.round},IY={borderWidth:$t,borderTopWidth:$t,borderRightWidth:$t,borderBottomWidth:$t,borderLeftWidth:$t,borderRadius:$t,radius:$t,borderTopLeftRadius:$t,borderTopRightRadius:$t,borderBottomRightRadius:$t,borderBottomLeftRadius:$t,width:$t,maxWidth:$t,height:$t,maxHeight:$t,size:$t,top:$t,right:$t,bottom:$t,left:$t,padding:$t,paddingTop:$t,paddingRight:$t,paddingBottom:$t,paddingLeft:$t,margin:$t,marginTop:$t,marginRight:$t,marginBottom:$t,marginLeft:$t,rotate:_h,rotateX:_h,rotateY:_h,rotateZ:_h,scale:JT,scaleX:JT,scaleY:JT,scaleZ:JT,skew:_h,skewX:_h,skewY:_h,distance:$t,translateX:$t,translateY:$t,translateZ:$t,x:$t,y:$t,z:$t,perspective:$t,transformPerspective:$t,opacity:tv,originX:GX,originY:GX,originZ:$t,zIndex:VX,fillOpacity:tv,strokeOpacity:tv,numOctaves:VX};function QO(n,e,t,i){const{style:r,vars:s,transform:o,transformOrigin:a}=n;let l=!1,u=!1,c=!0;for(const h in e){const d=e[h];if(AY(h)){s[h]=d;continue}const p=IY[h],f=Fde(d,p);if(Jf.has(h)){if(l=!0,o[h]=f,!c)continue;d!==(p.default||0)&&(c=!1)}else h.startsWith("origin")?(u=!0,a[h]=f):r[h]=f}if(e.transform||(l||i?r.transform=Pde(n.transform,t,c,i):r.transform&&(r.transform="none")),u){const{originX:h="50%",originY:d="50%",originZ:p=0}=a;r.transformOrigin=`${h} ${d} ${p}`}}const qO=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function kY(n,e,t){for(const i in e)!Io(e[i])&&!_Y(i,t)&&(n[i]=e[i])}function Gde({transformTemplate:n},e,t){return K.useMemo(()=>{const i=qO();return QO(i,e,{enableHardwareAcceleration:!t},n),Object.assign({},i.vars,i.style)},[e])}function Vde(n,e,t){const i=n.style||{},r={};return kY(r,i,n),Object.assign(r,Gde(n,e,t)),n.transformValues?n.transformValues(r):r}function Ude(n,e,t){const i={},r=Vde(n,e,t);return n.drag&&n.dragListener!==!1&&(i.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(i.tabIndex=0),i.style=r,i}const $de=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","onLayoutAnimationStart","onLayoutAnimationComplete","onLayoutMeasure","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","ignoreStrict","viewport"]);function MM(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||$de.has(n)}let RY=n=>!MM(n);function Wde(n){n&&(RY=e=>e.startsWith("on")?!MM(e):n(e))}try{Wde(require("@emotion/is-prop-valid").default)}catch{}function Hde(n,e,t){const i={};for(const r in n)r==="values"&&typeof n.values=="object"||(RY(r)||t===!0&&MM(r)||!e&&!MM(r)||n.draggable&&r.startsWith("onDrag"))&&(i[r]=n[r]);return i}function UX(n,e,t){return typeof n=="string"?n:$t.transform(e+t*n)}function Xde(n,e,t){const i=UX(e,n.x,n.width),r=UX(t,n.y,n.height);return`${i} ${r}`}const Kde={offset:"stroke-dashoffset",array:"stroke-dasharray"},Zde={offset:"strokeDashoffset",array:"strokeDasharray"};function jde(n,e,t=1,i=0,r=!0){n.pathLength=1;const s=r?Kde:Zde;n[s.offset]=$t.transform(-i);const o=$t.transform(e),a=$t.transform(t);n[s.array]=`${o} ${a}`}function eB(n,{attrX:e,attrY:t,attrScale:i,originX:r,originY:s,pathLength:o,pathSpacing:a=1,pathOffset:l=0,...u},c,h,d){if(QO(n,u,c,d),h){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:f,dimensions:g}=n;p.transform&&(g&&(f.transform=p.transform),delete p.transform),g&&(r!==void 0||s!==void 0||f.transform)&&(f.transformOrigin=Xde(g,r!==void 0?r:.5,s!==void 0?s:.5)),e!==void 0&&(p.x=e),t!==void 0&&(p.y=t),i!==void 0&&(p.scale=i),o!==void 0&&jde(p,o,a,l,!1)}const NY=()=>({...qO(),attrs:{}}),tB=n=>typeof n=="string"&&n.toLowerCase()==="svg";function Yde(n,e,t,i){const r=K.useMemo(()=>{const s=NY();return eB(s,e,{enableHardwareAcceleration:!1},tB(i),n.transformTemplate),{...s.attrs,style:{...s.style}}},[e]);if(n.style){const s={};kY(s,n.style,n),r.style={...s,...r.style}}return r}function Jde(n=!1){return(t,i,r,{latestValues:s},o)=>{const l=(JO(t)?Yde:Ude)(i,s,o,t),c={...Hde(i,typeof t=="string",n),...l,ref:r},{children:h}=i,d=K.useMemo(()=>Io(h)?h.get():h,[h]);return K.createElement(t,{...c,children:d})}}const nB=n=>n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();function LY(n,{style:e,vars:t},i,r){Object.assign(n.style,e,r&&r.getProjectionStyles(i));for(const s in t)n.style.setProperty(s,t[s])}const PY=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function DY(n,e,t,i){LY(n,e,void 0,i);for(const r in e.attrs)n.setAttribute(PY.has(r)?r:nB(r),e.attrs[r])}function iB(n,e){const{style:t}=n,i={};for(const r in t)(Io(t[r])||e.style&&Io(e.style[r])||_Y(r,n))&&(i[r]=t[r]);return i}function FY(n,e){const t=iB(n,e);for(const i in n)if(Io(n[i])||Io(e[i])){const r=N1.indexOf(i)!==-1?"attr"+i.charAt(0).toUpperCase()+i.substring(1):i;t[r]=n[i]}return t}function rB(n,e,t,i={},r={}){return typeof e=="function"&&(e=e(t!==void 0?t:n.custom,i,r)),typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"&&(e=e(t!==void 0?t:n.custom,i,r)),e}function OY(n){const e=K.useRef(null);return e.current===null&&(e.current=n()),e.current}const AM=n=>Array.isArray(n),Qde=n=>!!(n&&typeof n=="object"&&n.mix&&n.toValue),qde=n=>AM(n)?n[n.length-1]||0:n;function R_(n){const e=Io(n)?n.get():n;return Qde(e)?e.toValue():e}function epe({scrapeMotionValuesFromProps:n,createRenderState:e,onMount:t},i,r,s){const o={latestValues:tpe(i,r,s,n),renderState:e()};return t&&(o.mount=a=>t(i,a,o)),o}const BY=n=>(e,t)=>{const i=K.useContext(KA),r=K.useContext(ZA),s=()=>epe(n,e,i,r);return t?s():OY(s)};function tpe(n,e,t,i){const r={},s=i(n,{});for(const d in s)r[d]=R_(s[d]);let{initial:o,animate:a}=n;const l=JA(n),u=TY(n);e&&u&&!l&&n.inherit!==!1&&(o===void 0&&(o=e.initial),a===void 0&&(a=e.animate));let c=t?t.initial===!1:!1;c=c||o===!1;const h=c?a:o;return h&&typeof h!="boolean"&&!YA(h)&&(Array.isArray(h)?h:[h]).forEach(p=>{const f=rB(n,p);if(!f)return;const{transitionEnd:g,transition:y,...m}=f;for(const v in m){let w=m[v];if(Array.isArray(w)){const S=c?w.length-1:0;w=w[S]}w!==null&&(r[v]=w)}for(const v in g)r[v]=g[v]}),r}const $i=n=>n;class $X{constructor(){this.order=[],this.scheduled=new Set}add(e){if(!this.scheduled.has(e))return this.scheduled.add(e),this.order.push(e),!0}remove(e){const t=this.order.indexOf(e);t!==-1&&(this.order.splice(t,1),this.scheduled.delete(e))}clear(){this.order.length=0,this.scheduled.clear()}}function npe(n){let e=new $X,t=new $X,i=0,r=!1,s=!1;const o=new WeakSet,a={schedule:(l,u=!1,c=!1)=>{const h=c&&r,d=h?e:t;return u&&o.add(l),d.add(l)&&h&&r&&(i=e.order.length),l},cancel:l=>{t.remove(l),o.delete(l)},process:l=>{if(r){s=!0;return}if(r=!0,[e,t]=[t,e],t.clear(),i=e.order.length,i)for(let u=0;u<i;u++){const c=e.order[u];c(l),o.has(c)&&(a.schedule(c),n())}r=!1,s&&(s=!1,a.process(l))}};return a}const QT=["prepare","read","update","preRender","render","postRender"],ipe=40;function rpe(n,e){let t=!1,i=!0;const r={delta:0,timestamp:0,isProcessing:!1},s=QT.reduce((h,d)=>(h[d]=npe(()=>t=!0),h),{}),o=h=>s[h].process(r),a=()=>{const h=performance.now();t=!1,r.delta=i?1e3/60:Math.max(Math.min(h-r.timestamp,ipe),1),r.timestamp=h,r.isProcessing=!0,QT.forEach(o),r.isProcessing=!1,t&&e&&(i=!1,n(a))},l=()=>{t=!0,i=!0,r.isProcessing||n(a)};return{schedule:QT.reduce((h,d)=>{const p=s[d];return h[d]=(f,g=!1,y=!1)=>(t||l(),p.schedule(f,g,y)),h},{}),cancel:h=>QT.forEach(d=>s[d].cancel(h)),state:r,steps:s}}const{schedule:ti,cancel:Pc,state:Gr,steps:aN}=rpe(typeof requestAnimationFrame<"u"?requestAnimationFrame:$i,!0),spe={useVisualState:BY({scrapeMotionValuesFromProps:FY,createRenderState:NY,onMount:(n,e,{renderState:t,latestValues:i})=>{ti.read(()=>{try{t.dimensions=typeof e.getBBox=="function"?e.getBBox():e.getBoundingClientRect()}catch{t.dimensions={x:0,y:0,width:0,height:0}}}),ti.render(()=>{eB(t,i,{enableHardwareAcceleration:!1},tB(e.tagName),n.transformTemplate),DY(e,t)})}})},ope={useVisualState:BY({scrapeMotionValuesFromProps:iB,createRenderState:qO})};function ape(n,{forwardMotionProps:e=!1},t,i){return{...JO(n)?spe:ope,preloadedFeatures:t,useRender:Jde(e),createVisualElement:i,Component:n}}function bc(n,e,t,i={passive:!0}){return n.addEventListener(e,t,i),()=>n.removeEventListener(e,t)}const zY=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1;function qA(n,e="page"){return{point:{x:n[e+"X"],y:n[e+"Y"]}}}const lpe=n=>e=>zY(e)&&n(e,qA(e));function Tc(n,e,t,i){return bc(n,e,lpe(t),i)}const upe=(n,e)=>t=>e(n(t)),Qh=(...n)=>n.reduce(upe);function GY(n){let e=null;return()=>{const t=()=>{e=null};return e===null?(e=n,t):!1}}const WX=GY("dragHorizontal"),HX=GY("dragVertical");function VY(n){let e=!1;if(n==="y")e=HX();else if(n==="x")e=WX();else{const t=WX(),i=HX();t&&i?e=()=>{t(),i()}:(t&&t(),i&&i())}return e}function UY(){const n=VY(!0);return n?(n(),!1):!0}class kd{constructor(e){this.isMounted=!1,this.node=e}update(){}}function XX(n,e){const t="pointer"+(e?"enter":"leave"),i="onHover"+(e?"Start":"End"),r=(s,o)=>{if(s.type==="touch"||UY())return;const a=n.getProps();n.animationState&&a.whileHover&&n.animationState.setActive("whileHover",e),a[i]&&ti.update(()=>a[i](s,o))};return Tc(n.current,t,r,{passive:!n.getProps()[i]})}class cpe extends kd{mount(){this.unmount=Qh(XX(this.node,!0),XX(this.node,!1))}unmount(){}}class hpe extends kd{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Qh(bc(this.node.current,"focus",()=>this.onFocus()),bc(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const $Y=(n,e)=>e?n===e?!0:$Y(n,e.parentElement):!1;function lN(n,e){if(!e)return;const t=new PointerEvent("pointer"+n);e(t,qA(t))}class dpe extends kd{constructor(){super(...arguments),this.removeStartListeners=$i,this.removeEndListeners=$i,this.removeAccessibleListeners=$i,this.startPointerPress=(e,t)=>{if(this.removeEndListeners(),this.isPressing)return;const i=this.node.getProps(),s=Tc(window,"pointerup",(a,l)=>{if(!this.checkPressEnd())return;const{onTap:u,onTapCancel:c}=this.node.getProps();ti.update(()=>{$Y(this.node.current,a.target)?u&&u(a,l):c&&c(a,l)})},{passive:!(i.onTap||i.onPointerUp)}),o=Tc(window,"pointercancel",(a,l)=>this.cancelPress(a,l),{passive:!(i.onTapCancel||i.onPointerCancel)});this.removeEndListeners=Qh(s,o),this.startPress(e,t)},this.startAccessiblePress=()=>{const e=s=>{if(s.key!=="Enter"||this.isPressing)return;const o=a=>{a.key!=="Enter"||!this.checkPressEnd()||lN("up",(l,u)=>{const{onTap:c}=this.node.getProps();c&&ti.update(()=>c(l,u))})};this.removeEndListeners(),this.removeEndListeners=bc(this.node.current,"keyup",o),lN("down",(a,l)=>{this.startPress(a,l)})},t=bc(this.node.current,"keydown",e),i=()=>{this.isPressing&&lN("cancel",(s,o)=>this.cancelPress(s,o))},r=bc(this.node.current,"blur",i);this.removeAccessibleListeners=Qh(t,r)}}startPress(e,t){this.isPressing=!0;const{onTapStart:i,whileTap:r}=this.node.getProps();r&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),i&&ti.update(()=>i(e,t))}checkPressEnd(){return this.removeEndListeners(),this.isPressing=!1,this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!UY()}cancelPress(e,t){if(!this.checkPressEnd())return;const{onTapCancel:i}=this.node.getProps();i&&ti.update(()=>i(e,t))}mount(){const e=this.node.getProps(),t=Tc(this.node.current,"pointerdown",this.startPointerPress,{passive:!(e.onTapStart||e.onPointerStart)}),i=bc(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=Qh(t,i)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}const _D=new WeakMap,uN=new WeakMap,ppe=n=>{const e=_D.get(n.target);e&&e(n)},fpe=n=>{n.forEach(ppe)};function mpe({root:n,...e}){const t=n||document;uN.has(t)||uN.set(t,{});const i=uN.get(t),r=JSON.stringify(e);return i[r]||(i[r]=new IntersectionObserver(fpe,{root:n,...e})),i[r]}function gpe(n,e,t){const i=mpe(e);return _D.set(n,t),i.observe(n),()=>{_D.delete(n),i.unobserve(n)}}const ype={some:0,all:1};class bpe extends kd{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:i,amount:r="some",once:s}=e,o={root:t?t.current:void 0,rootMargin:i,threshold:typeof r=="number"?r:ype[r]},a=l=>{const{isIntersecting:u}=l;if(this.isInView===u||(this.isInView=u,s&&!u&&this.hasEnteredView))return;u&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",u);const{onViewportEnter:c,onViewportLeave:h}=this.node.getProps(),d=u?c:h;d&&d(l)};return gpe(this.node.current,o,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(xpe(e,t))&&this.startObserver()}unmount(){}}function xpe({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const vpe={inView:{Feature:bpe},tap:{Feature:dpe},focus:{Feature:hpe},hover:{Feature:cpe}};function WY(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let i=0;i<t;i++)if(e[i]!==n[i])return!1;return!0}function wpe(n){const e={};return n.values.forEach((t,i)=>e[i]=t.get()),e}function Spe(n){const e={};return n.values.forEach((t,i)=>e[i]=t.getVelocity()),e}function eE(n,e,t){const i=n.getProps();return rB(i,e,t!==void 0?t:i.custom,wpe(n),Spe(n))}const Tpe="framerAppearId",Cpe="data-"+nB(Tpe);let _pe=$i,sB=$i;const qh=n=>n*1e3,Cc=n=>n/1e3,Mpe={current:!1},HY=n=>Array.isArray(n)&&typeof n[0]=="number";function XY(n){return!!(!n||typeof n=="string"&&KY[n]||HY(n)||Array.isArray(n)&&n.every(XY))}const Lx=([n,e,t,i])=>`cubic-bezier(${n}, ${e}, ${t}, ${i})`,KY={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Lx([0,.65,.55,1]),circOut:Lx([.55,0,1,.45]),backIn:Lx([.31,.01,.66,-.59]),backOut:Lx([.33,1.53,.69,.99])};function ZY(n){if(n)return HY(n)?Lx(n):Array.isArray(n)?n.map(ZY):KY[n]}function Ape(n,e,t,{delay:i=0,duration:r,repeat:s=0,repeatType:o="loop",ease:a,times:l}={}){const u={[e]:t};l&&(u.offset=l);const c=ZY(a);return Array.isArray(c)&&(u.easing=c),n.animate(u,{delay:i,duration:r,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:s+1,direction:o==="reverse"?"alternate":"normal"})}function Epe(n,{repeat:e,repeatType:t="loop"}){const i=e&&t!=="loop"&&e%2===1?0:n.length-1;return n[i]}const jY=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,Ipe=1e-7,kpe=12;function Rpe(n,e,t,i,r){let s,o,a=0;do o=e+(t-e)/2,s=jY(o,i,r)-n,s>0?t=o:e=o;while(Math.abs(s)>Ipe&&++a<kpe);return o}function D1(n,e,t,i){if(n===e&&t===i)return $i;const r=s=>Rpe(s,0,1,n,t);return s=>s===0||s===1?s:jY(r(s),e,i)}const Npe=D1(.42,0,1,1),Lpe=D1(0,0,.58,1),YY=D1(.42,0,.58,1),Ppe=n=>Array.isArray(n)&&typeof n[0]!="number",JY=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,QY=n=>e=>1-n(1-e),qY=n=>1-Math.sin(Math.acos(n)),oB=QY(qY),Dpe=JY(oB),eJ=D1(.33,1.53,.69,.99),aB=QY(eJ),Fpe=JY(aB),Ope=n=>(n*=2)<1?.5*aB(n):.5*(2-Math.pow(2,-10*(n-1))),Bpe={linear:$i,easeIn:Npe,easeInOut:YY,easeOut:Lpe,circIn:qY,circInOut:Dpe,circOut:oB,backIn:aB,backInOut:Fpe,backOut:eJ,anticipate:Ope},KX=n=>{if(Array.isArray(n)){sB(n.length===4);const[e,t,i,r]=n;return D1(e,t,i,r)}else if(typeof n=="string")return Bpe[n];return n},lB=(n,e)=>t=>!!(L1(t)&&Ode.test(t)&&t.startsWith(n)||e&&Object.prototype.hasOwnProperty.call(t,e)),tJ=(n,e,t)=>i=>{if(!L1(i))return i;const[r,s,o,a]=i.match(QA);return{[n]:parseFloat(r),[e]:parseFloat(s),[t]:parseFloat(o),alpha:a!==void 0?parseFloat(a):1}},zpe=n=>dd(0,255,n),cN={...Qf,transform:n=>Math.round(zpe(n))},Gp={test:lB("rgb","red"),parse:tJ("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:i=1})=>"rgba("+cN.transform(n)+", "+cN.transform(e)+", "+cN.transform(t)+", "+nv(tv.transform(i))+")"};function Gpe(n){let e="",t="",i="",r="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),i=n.substring(5,7),r=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),i=n.substring(3,4),r=n.substring(4,5),e+=e,t+=t,i+=i,r+=r),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(i,16),alpha:r?parseInt(r,16)/255:1}}const MD={test:lB("#"),parse:Gpe,transform:Gp.transform},Og={test:lB("hsl","hue"),parse:tJ("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:i=1})=>"hsla("+Math.round(n)+", "+Mu.transform(nv(e))+", "+Mu.transform(nv(t))+", "+nv(tv.transform(i))+")"},Ws={test:n=>Gp.test(n)||MD.test(n)||Og.test(n),parse:n=>Gp.test(n)?Gp.parse(n):Og.test(n)?Og.parse(n):MD.parse(n),transform:n=>L1(n)?n:n.hasOwnProperty("red")?Gp.transform(n):Og.transform(n)},Ii=(n,e,t)=>-t*n+t*e+n;function hN(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function Vpe({hue:n,saturation:e,lightness:t,alpha:i}){n/=360,e/=100,t/=100;let r=0,s=0,o=0;if(!e)r=s=o=t;else{const a=t<.5?t*(1+e):t+e-t*e,l=2*t-a;r=hN(l,a,n+1/3),s=hN(l,a,n),o=hN(l,a,n-1/3)}return{red:Math.round(r*255),green:Math.round(s*255),blue:Math.round(o*255),alpha:i}}const dN=(n,e,t)=>{const i=n*n;return Math.sqrt(Math.max(0,t*(e*e-i)+i))},Upe=[MD,Gp,Og],$pe=n=>Upe.find(e=>e.test(n));function ZX(n){const e=$pe(n);let t=e.parse(n);return e===Og&&(t=Vpe(t)),t}const nJ=(n,e)=>{const t=ZX(n),i=ZX(e),r={...t};return s=>(r.red=dN(t.red,i.red,s),r.green=dN(t.green,i.green,s),r.blue=dN(t.blue,i.blue,s),r.alpha=Ii(t.alpha,i.alpha,s),Gp.transform(r))};function Wpe(n){var e,t;return isNaN(n)&&L1(n)&&(((e=n.match(QA))===null||e===void 0?void 0:e.length)||0)+(((t=n.match(EY))===null||t===void 0?void 0:t.length)||0)>0}const iJ={regex:Dde,countKey:"Vars",token:"${v}",parse:$i},rJ={regex:EY,countKey:"Colors",token:"${c}",parse:Ws.parse},sJ={regex:QA,countKey:"Numbers",token:"${n}",parse:Qf.parse};function pN(n,{regex:e,countKey:t,token:i,parse:r}){const s=n.tokenised.match(e);s&&(n["num"+t]=s.length,n.tokenised=n.tokenised.replace(e,i),n.values.push(...s.map(r)))}function EM(n){const e=n.toString(),t={value:e,tokenised:e,values:[],numVars:0,numColors:0,numNumbers:0};return t.value.includes("var(--")&&pN(t,iJ),pN(t,rJ),pN(t,sJ),t}function oJ(n){return EM(n).values}function aJ(n){const{values:e,numColors:t,numVars:i,tokenised:r}=EM(n),s=e.length;return o=>{let a=r;for(let l=0;l<s;l++)l<i?a=a.replace(iJ.token,o[l]):l<i+t?a=a.replace(rJ.token,Ws.transform(o[l])):a=a.replace(sJ.token,nv(o[l]));return a}}const Hpe=n=>typeof n=="number"?0:n;function Xpe(n){const e=oJ(n);return aJ(n)(e.map(Hpe))}const pd={test:Wpe,parse:oJ,createTransformer:aJ,getAnimatableNone:Xpe},lJ=(n,e)=>t=>`${t>0?e:n}`;function uJ(n,e){return typeof n=="number"?t=>Ii(n,e,t):Ws.test(n)?nJ(n,e):n.startsWith("var(")?lJ(n,e):hJ(n,e)}const cJ=(n,e)=>{const t=[...n],i=t.length,r=n.map((s,o)=>uJ(s,e[o]));return s=>{for(let o=0;o<i;o++)t[o]=r[o](s);return t}},Kpe=(n,e)=>{const t={...n,...e},i={};for(const r in t)n[r]!==void 0&&e[r]!==void 0&&(i[r]=uJ(n[r],e[r]));return r=>{for(const s in i)t[s]=i[s](r);return t}},hJ=(n,e)=>{const t=pd.createTransformer(e),i=EM(n),r=EM(e);return i.numVars===r.numVars&&i.numColors===r.numColors&&i.numNumbers>=r.numNumbers?Qh(cJ(i.values,r.values),t):lJ(n,e)},Dv=(n,e,t)=>{const i=e-n;return i===0?1:(t-n)/i},jX=(n,e)=>t=>Ii(n,e,t);function Zpe(n){return typeof n=="number"?jX:typeof n=="string"?Ws.test(n)?nJ:hJ:Array.isArray(n)?cJ:typeof n=="object"?Kpe:jX}function jpe(n,e,t){const i=[],r=t||Zpe(n[0]),s=n.length-1;for(let o=0;o<s;o++){let a=r(n[o],n[o+1]);if(e){const l=Array.isArray(e)?e[o]||$i:e;a=Qh(l,a)}i.push(a)}return i}function dJ(n,e,{clamp:t=!0,ease:i,mixer:r}={}){const s=n.length;if(sB(s===e.length),s===1)return()=>e[0];n[0]>n[s-1]&&(n=[...n].reverse(),e=[...e].reverse());const o=jpe(e,i,r),a=o.length,l=u=>{let c=0;if(a>1)for(;c<n.length-2&&!(u<n[c+1]);c++);const h=Dv(n[c],n[c+1],u);return o[c](h)};return t?u=>l(dd(n[0],n[s-1],u)):l}function Ype(n,e){const t=n[n.length-1];for(let i=1;i<=e;i++){const r=Dv(0,e,i);n.push(Ii(t,1,r))}}function Jpe(n){const e=[0];return Ype(e,n.length-1),e}function Qpe(n,e){return n.map(t=>t*e)}function qpe(n,e){return n.map(()=>e||YY).splice(0,n.length-1)}function IM({duration:n=300,keyframes:e,times:t,ease:i="easeInOut"}){const r=Ppe(i)?i.map(KX):KX(i),s={done:!1,value:e[0]},o=Qpe(t&&t.length===e.length?t:Jpe(e),n),a=dJ(o,e,{ease:Array.isArray(r)?r:qpe(e,r)});return{calculatedDuration:n,next:l=>(s.value=a(l),s.done=l>=n,s)}}function pJ(n,e){return e?n*(1e3/e):0}const efe=5;function fJ(n,e,t){const i=Math.max(e-efe,0);return pJ(t-n(i),e-i)}const fN=.001,tfe=.01,YX=10,nfe=.05,ife=1;function rfe({duration:n=800,bounce:e=.25,velocity:t=0,mass:i=1}){let r,s;_pe(n<=qh(YX));let o=1-e;o=dd(nfe,ife,o),n=dd(tfe,YX,Cc(n)),o<1?(r=u=>{const c=u*o,h=c*n,d=c-t,p=AD(u,o),f=Math.exp(-h);return fN-d/p*f},s=u=>{const h=u*o*n,d=h*t+t,p=Math.pow(o,2)*Math.pow(u,2)*n,f=Math.exp(-h),g=AD(Math.pow(u,2),o);return(-r(u)+fN>0?-1:1)*((d-p)*f)/g}):(r=u=>{const c=Math.exp(-u*n),h=(u-t)*n+1;return-fN+c*h},s=u=>{const c=Math.exp(-u*n),h=(t-u)*(n*n);return c*h});const a=5/n,l=ofe(r,s,a);if(n=qh(n),isNaN(l))return{stiffness:100,damping:10,duration:n};{const u=Math.pow(l,2)*i;return{stiffness:u,damping:o*2*Math.sqrt(i*u),duration:n}}}const sfe=12;function ofe(n,e,t){let i=t;for(let r=1;r<sfe;r++)i=i-n(i)/e(i);return i}function AD(n,e){return n*Math.sqrt(1-e*e)}const afe=["duration","bounce"],lfe=["stiffness","damping","mass"];function JX(n,e){return e.some(t=>n[t]!==void 0)}function ufe(n){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...n};if(!JX(n,lfe)&&JX(n,afe)){const t=rfe(n);e={...e,...t,velocity:0,mass:1},e.isResolvedFromDuration=!0}return e}function mJ({keyframes:n,restDelta:e,restSpeed:t,...i}){const r=n[0],s=n[n.length-1],o={done:!1,value:r},{stiffness:a,damping:l,mass:u,velocity:c,duration:h,isResolvedFromDuration:d}=ufe(i),p=c?-Cc(c):0,f=l/(2*Math.sqrt(a*u)),g=s-r,y=Cc(Math.sqrt(a/u)),m=Math.abs(g)<5;t||(t=m?.01:2),e||(e=m?.005:.5);let v;if(f<1){const w=AD(y,f);v=S=>{const C=Math.exp(-f*y*S);return s-C*((p+f*y*g)/w*Math.sin(w*S)+g*Math.cos(w*S))}}else if(f===1)v=w=>s-Math.exp(-y*w)*(g+(p+y*g)*w);else{const w=y*Math.sqrt(f*f-1);v=S=>{const C=Math.exp(-f*y*S),_=Math.min(w*S,300);return s-C*((p+f*y*g)*Math.sinh(_)+w*g*Math.cosh(_))/w}}return{calculatedDuration:d&&h||null,next:w=>{const S=v(w);if(d)o.done=w>=h;else{let C=p;w!==0&&(f<1?C=fJ(v,w,S):C=0);const _=Math.abs(C)<=t,A=Math.abs(s-S)<=e;o.done=_&&A}return o.value=o.done?s:S,o}}}function QX({keyframes:n,velocity:e=0,power:t=.8,timeConstant:i=325,bounceDamping:r=10,bounceStiffness:s=500,modifyTarget:o,min:a,max:l,restDelta:u=.5,restSpeed:c}){const h=n[0],d={done:!1,value:h},p=I=>a!==void 0&&I<a||l!==void 0&&I>l,f=I=>a===void 0?l:l===void 0||Math.abs(a-I)<Math.abs(l-I)?a:l;let g=t*e;const y=h+g,m=o===void 0?y:o(y);m!==y&&(g=m-h);const v=I=>-g*Math.exp(-I/i),w=I=>m+v(I),S=I=>{const E=v(I),k=w(I);d.done=Math.abs(E)<=u,d.value=d.done?m:k};let C,_;const A=I=>{p(d.value)&&(C=I,_=mJ({keyframes:[d.value,f(d.value)],velocity:fJ(w,I,d.value),damping:r,stiffness:s,restDelta:u,restSpeed:c}))};return A(0),{calculatedDuration:null,next:I=>{let E=!1;return!_&&C===void 0&&(E=!0,S(I),A(I)),C!==void 0&&I>C?_.next(I-C):(!E&&S(I),d)}}}const cfe=n=>{const e=({timestamp:t})=>n(t);return{start:()=>ti.update(e,!0),stop:()=>Pc(e),now:()=>Gr.isProcessing?Gr.timestamp:performance.now()}},qX=2e4;function e4(n){let e=0;const t=50;let i=n.next(e);for(;!i.done&&e<qX;)e+=t,i=n.next(e);return e>=qX?1/0:e}const hfe={decay:QX,inertia:QX,tween:IM,keyframes:IM,spring:mJ};function kM({autoplay:n=!0,delay:e=0,driver:t=cfe,keyframes:i,type:r="keyframes",repeat:s=0,repeatDelay:o=0,repeatType:a="loop",onPlay:l,onStop:u,onComplete:c,onUpdate:h,...d}){let p=1,f=!1,g,y;const m=()=>{y=new Promise(z=>{g=z})};m();let v;const w=hfe[r]||IM;let S;w!==IM&&typeof i[0]!="number"&&(S=dJ([0,100],i,{clamp:!1}),i=[0,100]);const C=w({...d,keyframes:i});let _;a==="mirror"&&(_=w({...d,keyframes:[...i].reverse(),velocity:-(d.velocity||0)}));let A="idle",I=null,E=null,k=null;C.calculatedDuration===null&&s&&(C.calculatedDuration=e4(C));const{calculatedDuration:P}=C;let V=1/0,U=1/0;P!==null&&(V=P+o,U=V*(s+1)-o);let F=0;const $=z=>{if(E===null)return;p>0&&(E=Math.min(E,z)),p<0&&(E=Math.min(z-U/p,E)),I!==null?F=I:F=Math.round(z-E)*p;const Z=F-e*(p>=0?1:-1),ce=p>=0?Z<0:Z>U;F=Math.max(Z,0),A==="finished"&&I===null&&(F=U);let fe=F,ge=C;if(s){const Ue=F/V;let Ye=Math.floor(Ue),$e=Ue%1;!$e&&Ue>=1&&($e=1),$e===1&&Ye--,Ye=Math.min(Ye,s+1);const ee=!!(Ye%2);ee&&(a==="reverse"?($e=1-$e,o&&($e-=o/V)):a==="mirror"&&(ge=_));let De=dd(0,1,$e);F>U&&(De=a==="reverse"&&ee?1:0),fe=De*V}const Ne=ce?{done:!1,value:i[0]}:ge.next(fe);S&&(Ne.value=S(Ne.value));let{done:Fe}=Ne;!ce&&P!==null&&(Fe=p>=0?F>=U:F<=0);const We=I===null&&(A==="finished"||A==="running"&&Fe);return h&&h(Ne.value),We&&O(),Ne},J=()=>{v&&v.stop(),v=void 0},q=()=>{A="idle",J(),g(),m(),E=k=null},O=()=>{A="finished",c&&c(),J(),g()},X=()=>{if(f)return;v||(v=t($));const z=v.now();l&&l(),I!==null?E=z-I:(!E||A==="finished")&&(E=z),A==="finished"&&m(),k=E,I=null,A="running",v.start()};n&&X();const j={then(z,Z){return y.then(z,Z)},get time(){return Cc(F)},set time(z){z=qh(z),F=z,I!==null||!v||p===0?I=z:E=v.now()-z/p},get duration(){const z=C.calculatedDuration===null?e4(C):C.calculatedDuration;return Cc(z)},get speed(){return p},set speed(z){z===p||!v||(p=z,j.time=Cc(F))},get state(){return A},play:X,pause:()=>{A="paused",I=F},stop:()=>{f=!0,A!=="idle"&&(A="idle",u&&u(),q())},cancel:()=>{k!==null&&$(k),q()},complete:()=>{A="finished"},sample:z=>(E=0,$(z))};return j}function dfe(n){let e;return()=>(e===void 0&&(e=n()),e)}const pfe=dfe(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),ffe=new Set(["opacity","clipPath","filter","transform","backgroundColor"]),qT=10,mfe=2e4,gfe=(n,e)=>e.type==="spring"||n==="backgroundColor"||!XY(e.ease);function yfe(n,e,{onUpdate:t,onComplete:i,...r}){if(!(pfe()&&ffe.has(e)&&!r.repeatDelay&&r.repeatType!=="mirror"&&r.damping!==0&&r.type!=="inertia"))return!1;let o=!1,a,l;const u=()=>{l=new Promise(v=>{a=v})};u();let{keyframes:c,duration:h=300,ease:d,times:p}=r;if(gfe(e,r)){const v=kM({...r,repeat:0,delay:0});let w={done:!1,value:c[0]};const S=[];let C=0;for(;!w.done&&C<mfe;)w=v.sample(C),S.push(w.value),C+=qT;p=void 0,c=S,h=C-qT,d="linear"}const f=Ape(n.owner.current,e,c,{...r,duration:h,ease:d,times:p});r.syncStart&&(f.startTime=Gr.isProcessing?Gr.timestamp:document.timeline?document.timeline.currentTime:performance.now());const g=()=>f.cancel(),y=()=>{ti.update(g),a(),u()};return f.onfinish=()=>{n.set(Epe(c,r)),i&&i(),y()},{then(v,w){return l.then(v,w)},attachTimeline(v){return f.timeline=v,f.onfinish=null,$i},get time(){return Cc(f.currentTime||0)},set time(v){f.currentTime=qh(v)},get speed(){return f.playbackRate},set speed(v){f.playbackRate=v},get duration(){return Cc(h)},play:()=>{o||(f.play(),Pc(g))},pause:()=>f.pause(),stop:()=>{if(o=!0,f.playState==="idle")return;const{currentTime:v}=f;if(v){const w=kM({...r,autoplay:!1});n.setWithVelocity(w.sample(v-qT).value,w.sample(v).value,qT)}y()},complete:()=>f.finish(),cancel:y}}function bfe({keyframes:n,delay:e,onUpdate:t,onComplete:i}){const r=()=>(t&&t(n[n.length-1]),i&&i(),{time:0,speed:1,duration:0,play:$i,pause:$i,stop:$i,then:s=>(s(),Promise.resolve()),cancel:$i,complete:$i});return e?kM({keyframes:[0,1],duration:0,delay:e,onComplete:r}):r()}const xfe={type:"spring",stiffness:500,damping:25,restSpeed:10},vfe=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),wfe={type:"keyframes",duration:.8},Sfe={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},Tfe=(n,{keyframes:e})=>e.length>2?wfe:Jf.has(n)?n.startsWith("scale")?vfe(e[1]):xfe:Sfe,ED=(n,e)=>n==="zIndex"?!1:!!(typeof e=="number"||Array.isArray(e)||typeof e=="string"&&(pd.test(e)||e==="0")&&!e.startsWith("url(")),Cfe=new Set(["brightness","contrast","saturate","opacity"]);function _fe(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[i]=t.match(QA)||[];if(!i)return n;const r=t.replace(i,"");let s=Cfe.has(e)?1:0;return i!==t&&(s*=100),e+"("+s+r+")"}const Mfe=/([a-z-]*)\(.*?\)/g,ID={...pd,getAnimatableNone:n=>{const e=n.match(Mfe);return e?e.map(_fe).join(" "):n}},Afe={...IY,color:Ws,backgroundColor:Ws,outlineColor:Ws,fill:Ws,stroke:Ws,borderColor:Ws,borderTopColor:Ws,borderRightColor:Ws,borderBottomColor:Ws,borderLeftColor:Ws,filter:ID,WebkitFilter:ID},uB=n=>Afe[n];function gJ(n,e){let t=uB(n);return t!==ID&&(t=pd),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const yJ=n=>/^0[^.\s]+$/.test(n);function Efe(n){if(typeof n=="number")return n===0;if(n!==null)return n==="none"||n==="0"||yJ(n)}function Ife(n,e,t,i){const r=ED(e,t);let s;Array.isArray(t)?s=[...t]:s=[null,t];const o=i.from!==void 0?i.from:n.get();let a;const l=[];for(let u=0;u<s.length;u++)s[u]===null&&(s[u]=u===0?o:s[u-1]),Efe(s[u])&&l.push(u),typeof s[u]=="string"&&s[u]!=="none"&&s[u]!=="0"&&(a=s[u]);if(r&&l.length&&a)for(let u=0;u<l.length;u++){const c=l[u];s[c]=gJ(e,a)}return s}function kfe({when:n,delay:e,delayChildren:t,staggerChildren:i,staggerDirection:r,repeat:s,repeatType:o,repeatDelay:a,from:l,elapsed:u,...c}){return!!Object.keys(c).length}function bJ(n,e){return n[e]||n.default||n}const cB=(n,e,t,i={})=>r=>{const s=bJ(i,n)||{},o=s.delay||i.delay||0;let{elapsed:a=0}=i;a=a-qh(o);const l=Ife(e,n,t,s),u=l[0],c=l[l.length-1],h=ED(n,u),d=ED(n,c);let p={keyframes:l,velocity:e.getVelocity(),ease:"easeOut",...s,delay:-a,onUpdate:f=>{e.set(f),s.onUpdate&&s.onUpdate(f)},onComplete:()=>{r(),s.onComplete&&s.onComplete()}};if(kfe(s)||(p={...p,...Tfe(n,p)}),p.duration&&(p.duration=qh(p.duration)),p.repeatDelay&&(p.repeatDelay=qh(p.repeatDelay)),!h||!d||Mpe.current||s.type===!1)return bfe(p);if(e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate){const f=yfe(e,n,p);if(f)return f}return kM(p)};function RM(n){return!!(Io(n)&&n.add)}const xJ=n=>/^\-?\d*\.?\d+$/.test(n);function hB(n,e){n.indexOf(e)===-1&&n.push(e)}function dB(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}class pB{constructor(){this.subscriptions=[]}add(e){return hB(this.subscriptions,e),()=>dB(this.subscriptions,e)}notify(e,t,i){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,t,i);else for(let s=0;s<r;s++){const o=this.subscriptions[s];o&&o(e,t,i)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Rfe=n=>!isNaN(parseFloat(n));class Nfe{constructor(e,t={}){this.version="10.16.5",this.timeDelta=0,this.lastUpdated=0,this.canTrackVelocity=!1,this.events={},this.updateAndNotify=(i,r=!0)=>{this.prev=this.current,this.current=i;const{delta:s,timestamp:o}=Gr;this.lastUpdated!==o&&(this.timeDelta=s,this.lastUpdated=o,ti.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&&this.events.change&&this.events.change.notify(this.current),this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()),r&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.scheduleVelocityCheck=()=>ti.postRender(this.velocityCheck),this.velocityCheck=({timestamp:i})=>{i!==this.lastUpdated&&(this.prev=this.current,this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()))},this.hasAnimated=!1,this.prev=this.current=e,this.canTrackVelocity=Rfe(this.current),this.owner=t.owner}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new pB);const i=this.events[e].add(t);return e==="change"?()=>{i(),ti.read(()=>{this.events.change.getSize()||this.stop()})}:i}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e,t=!0){!t||!this.passiveEffect?this.updateAndNotify(e,t):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,t,i){this.set(t),this.prev=e,this.timeDelta=i}jump(e){this.updateAndNotify(e),this.prev=e,this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){return this.canTrackVelocity?pJ(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function vy(n,e){return new Nfe(n,e)}const vJ=n=>e=>e.test(n),Lfe={test:n=>n==="auto",parse:n=>n},wJ=[Qf,$t,Mu,_h,zde,Bde,Lfe],rx=n=>wJ.find(vJ(n)),Pfe=[...wJ,Ws,pd],Dfe=n=>Pfe.find(vJ(n));function Ffe(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,vy(t))}function Ofe(n,e){const t=eE(n,e);let{transitionEnd:i={},transition:r={},...s}=t?n.makeTargetAnimatable(t,!1):{};s={...s,...i};for(const o in s){const a=qde(s[o]);Ffe(n,o,a)}}function Bfe(n,e,t){var i,r;const s=Object.keys(e).filter(a=>!n.hasValue(a)),o=s.length;if(o)for(let a=0;a<o;a++){const l=s[a],u=e[l];let c=null;Array.isArray(u)&&(c=u[0]),c===null&&(c=(r=(i=t[l])!==null&&i!==void 0?i:n.readValue(l))!==null&&r!==void 0?r:e[l]),c!=null&&(typeof c=="string"&&(xJ(c)||yJ(c))?c=parseFloat(c):!Dfe(c)&&pd.test(u)&&(c=gJ(l,u)),n.addValue(l,vy(c,{owner:n})),t[l]===void 0&&(t[l]=c),c!==null&&n.setBaseTarget(l,c))}}function zfe(n,e){return e?(e[n]||e.default||e).from:void 0}function Gfe(n,e,t){const i={};for(const r in n){const s=zfe(r,e);if(s!==void 0)i[r]=s;else{const o=t.getValue(r);o&&(i[r]=o.get())}}return i}function Vfe({protectedKeys:n,needsAnimating:e},t){const i=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,i}function SJ(n,e,{delay:t=0,transitionOverride:i,type:r}={}){let{transition:s=n.getDefaultTransition(),transitionEnd:o,...a}=n.makeTargetAnimatable(e);const l=n.getValue("willChange");i&&(s=i);const u=[],c=r&&n.animationState&&n.animationState.getState()[r];for(const h in a){const d=n.getValue(h),p=a[h];if(!d||p===void 0||c&&Vfe(c,h))continue;const f={delay:t,elapsed:0,...s};if(window.HandoffAppearAnimations&&!d.hasAnimated){const y=n.getProps()[Cpe];y&&(f.elapsed=window.HandoffAppearAnimations(y,h,d,ti),f.syncStart=!0)}d.start(cB(h,d,p,n.shouldReduceMotion&&Jf.has(h)?{type:!1}:f));const g=d.animation;RM(l)&&(l.add(h),g.then(()=>l.remove(h))),u.push(g)}return o&&Promise.all(u).then(()=>{o&&Ofe(n,o)}),u}function kD(n,e,t={}){const i=eE(n,e,t.custom);let{transition:r=n.getDefaultTransition()||{}}=i||{};t.transitionOverride&&(r=t.transitionOverride);const s=i?()=>Promise.all(SJ(n,i,t)):()=>Promise.resolve(),o=n.variantChildren&&n.variantChildren.size?(l=0)=>{const{delayChildren:u=0,staggerChildren:c,staggerDirection:h}=r;return Ufe(n,e,u+l,c,h,t)}:()=>Promise.resolve(),{when:a}=r;if(a){const[l,u]=a==="beforeChildren"?[s,o]:[o,s];return l().then(()=>u())}else return Promise.all([s(),o(t.delay)])}function Ufe(n,e,t=0,i=0,r=1,s){const o=[],a=(n.variantChildren.size-1)*i,l=r===1?(u=0)=>u*i:(u=0)=>a-u*i;return Array.from(n.variantChildren).sort($fe).forEach((u,c)=>{u.notify("AnimationStart",e),o.push(kD(u,e,{...s,delay:t+l(c)}).then(()=>u.notify("AnimationComplete",e)))}),Promise.all(o)}function $fe(n,e){return n.sortNodePosition(e)}function Wfe(n,e,t={}){n.notify("AnimationStart",e);let i;if(Array.isArray(e)){const r=e.map(s=>kD(n,s,t));i=Promise.all(r)}else if(typeof e=="string")i=kD(n,e,t);else{const r=typeof e=="function"?eE(n,e,t.custom):e;i=Promise.all(SJ(n,r,t))}return i.then(()=>n.notify("AnimationComplete",e))}const Hfe=[...ZO].reverse(),Xfe=ZO.length;function Kfe(n){return e=>Promise.all(e.map(({animation:t,options:i})=>Wfe(n,t,i)))}function Zfe(n){let e=Kfe(n);const t=Yfe();let i=!0;const r=(l,u)=>{const c=eE(n,u);if(c){const{transition:h,transitionEnd:d,...p}=c;l={...l,...p,...d}}return l};function s(l){e=l(n)}function o(l,u){const c=n.getProps(),h=n.getVariantContext(!0)||{},d=[],p=new Set;let f={},g=1/0;for(let m=0;m<Xfe;m++){const v=Hfe[m],w=t[v],S=c[v]!==void 0?c[v]:h[v],C=Lv(S),_=v===u?w.isActive:null;_===!1&&(g=m);let A=S===h[v]&&S!==c[v]&&C;if(A&&i&&n.manuallyAnimateOnMount&&(A=!1),w.protectedKeys={...f},!w.isActive&&_===null||!S&&!w.prevProp||YA(S)||typeof S=="boolean")continue;const I=jfe(w.prevProp,S);let E=I||v===u&&w.isActive&&!A&&C||m>g&&C;const k=Array.isArray(S)?S:[S];let P=k.reduce(r,{});_===!1&&(P={});const{prevResolvedValues:V={}}=w,U={...V,...P},F=$=>{E=!0,p.delete($),w.needsAnimating[$]=!0};for(const $ in U){const J=P[$],q=V[$];f.hasOwnProperty($)||(J!==q?AM(J)&&AM(q)?!WY(J,q)||I?F($):w.protectedKeys[$]=!0:J!==void 0?F($):p.add($):J!==void 0&&p.has($)?F($):w.protectedKeys[$]=!0)}w.prevProp=S,w.prevResolvedValues=P,w.isActive&&(f={...f,...P}),i&&n.blockInitialAnimation&&(E=!1),E&&!A&&d.push(...k.map($=>({animation:$,options:{type:v,...l}})))}if(p.size){const m={};p.forEach(v=>{const w=n.getBaseTarget(v);w!==void 0&&(m[v]=w)}),d.push({animation:m})}let y=!!d.length;return i&&c.initial===!1&&!n.manuallyAnimateOnMount&&(y=!1),i=!1,y?e(d):Promise.resolve()}function a(l,u,c){var h;if(t[l].isActive===u)return Promise.resolve();(h=n.variantChildren)===null||h===void 0||h.forEach(p=>{var f;return(f=p.animationState)===null||f===void 0?void 0:f.setActive(l,u)}),t[l].isActive=u;const d=o(c,l);for(const p in t)t[p].protectedKeys={};return d}return{animateChanges:o,setActive:a,setAnimateFunction:s,getState:()=>t}}function jfe(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!WY(e,n):!1}function tp(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function Yfe(){return{animate:tp(!0),whileInView:tp(),whileHover:tp(),whileTap:tp(),whileDrag:tp(),whileFocus:tp(),exit:tp()}}class Jfe extends kd{constructor(e){super(e),e.animationState||(e.animationState=Zfe(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();this.unmount(),YA(e)&&(this.unmount=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){}}let Qfe=0;class qfe extends kd{constructor(){super(...arguments),this.id=Qfe++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t,custom:i}=this.node.presenceContext,{isPresent:r}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===r)return;const s=this.node.animationState.setActive("exit",!e,{custom:i??this.node.getProps().custom});t&&!e&&s.then(()=>t(this.id))}mount(){const{register:e}=this.node.presenceContext||{};e&&(this.unmount=e(this.id))}unmount(){}}const eme={animation:{Feature:Jfe},exit:{Feature:qfe}},t4=(n,e)=>Math.abs(n-e);function tme(n,e){const t=t4(n.x,e.x),i=t4(n.y,e.y);return Math.sqrt(t**2+i**2)}class TJ{constructor(e,t,{transformPagePoint:i}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const u=gN(this.lastMoveEventInfo,this.history),c=this.startEvent!==null,h=tme(u.offset,{x:0,y:0})>=3;if(!c&&!h)return;const{point:d}=u,{timestamp:p}=Gr;this.history.push({...d,timestamp:p});const{onStart:f,onMove:g}=this.handlers;c||(f&&f(this.lastMoveEvent,u),this.startEvent=this.lastMoveEvent),g&&g(this.lastMoveEvent,u)},this.handlePointerMove=(u,c)=>{this.lastMoveEvent=u,this.lastMoveEventInfo=mN(c,this.transformPagePoint),ti.update(this.updatePoint,!0)},this.handlePointerUp=(u,c)=>{if(this.end(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const{onEnd:h,onSessionEnd:d}=this.handlers,p=gN(u.type==="pointercancel"?this.lastMoveEventInfo:mN(c,this.transformPagePoint),this.history);this.startEvent&&h&&h(u,p),d&&d(u,p)},!zY(e))return;this.handlers=t,this.transformPagePoint=i;const r=qA(e),s=mN(r,this.transformPagePoint),{point:o}=s,{timestamp:a}=Gr;this.history=[{...o,timestamp:a}];const{onSessionStart:l}=t;l&&l(e,gN(s,this.history)),this.removeListeners=Qh(Tc(window,"pointermove",this.handlePointerMove),Tc(window,"pointerup",this.handlePointerUp),Tc(window,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),Pc(this.updatePoint)}}function mN(n,e){return e?{point:e(n.point)}:n}function n4(n,e){return{x:n.x-e.x,y:n.y-e.y}}function gN({point:n},e){return{point:n,delta:n4(n,CJ(e)),offset:n4(n,nme(e)),velocity:ime(e,.1)}}function nme(n){return n[0]}function CJ(n){return n[n.length-1]}function ime(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,i=null;const r=CJ(n);for(;t>=0&&(i=n[t],!(r.timestamp-i.timestamp>qh(e)));)t--;if(!i)return{x:0,y:0};const s=Cc(r.timestamp-i.timestamp);if(s===0)return{x:0,y:0};const o={x:(r.x-i.x)/s,y:(r.y-i.y)/s};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function ca(n){return n.max-n.min}function RD(n,e=0,t=.01){return Math.abs(n-e)<=t}function i4(n,e,t,i=.5){n.origin=i,n.originPoint=Ii(e.min,e.max,n.origin),n.scale=ca(t)/ca(e),(RD(n.scale,1,1e-4)||isNaN(n.scale))&&(n.scale=1),n.translate=Ii(t.min,t.max,n.origin)-n.originPoint,(RD(n.translate)||isNaN(n.translate))&&(n.translate=0)}function iv(n,e,t,i){i4(n.x,e.x,t.x,i?i.originX:void 0),i4(n.y,e.y,t.y,i?i.originY:void 0)}function r4(n,e,t){n.min=t.min+e.min,n.max=n.min+ca(e)}function rme(n,e,t){r4(n.x,e.x,t.x),r4(n.y,e.y,t.y)}function s4(n,e,t){n.min=e.min-t.min,n.max=n.min+ca(e)}function rv(n,e,t){s4(n.x,e.x,t.x),s4(n.y,e.y,t.y)}function sme(n,{min:e,max:t},i){return e!==void 0&&n<e?n=i?Ii(e,n,i.min):Math.max(n,e):t!==void 0&&n>t&&(n=i?Ii(t,n,i.max):Math.min(n,t)),n}function o4(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function ome(n,{top:e,left:t,bottom:i,right:r}){return{x:o4(n.x,t,r),y:o4(n.y,e,i)}}function a4(n,e){let t=e.min-n.min,i=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,i]=[i,t]),{min:t,max:i}}function ame(n,e){return{x:a4(n.x,e.x),y:a4(n.y,e.y)}}function lme(n,e){let t=.5;const i=ca(n),r=ca(e);return r>i?t=Dv(e.min,e.max-i,n.min):i>r&&(t=Dv(n.min,n.max-r,e.min)),dd(0,1,t)}function ume(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const ND=.35;function cme(n=ND){return n===!1?n=0:n===!0&&(n=ND),{x:l4(n,"left","right"),y:l4(n,"top","bottom")}}function l4(n,e,t){return{min:u4(n,e),max:u4(n,t)}}function u4(n,e){return typeof n=="number"?n:n[e]||0}const c4=()=>({translate:0,scale:1,origin:0,originPoint:0}),Bg=()=>({x:c4(),y:c4()}),h4=()=>({min:0,max:0}),cr=()=>({x:h4(),y:h4()});function fu(n){return[n("x"),n("y")]}function _J({top:n,left:e,right:t,bottom:i}){return{x:{min:e,max:t},y:{min:n,max:i}}}function hme({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function dme(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),i=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:i.y,right:i.x}}function yN(n){return n===void 0||n===1}function LD({scale:n,scaleX:e,scaleY:t}){return!yN(n)||!yN(e)||!yN(t)}function xp(n){return LD(n)||MJ(n)||n.z||n.rotate||n.rotateX||n.rotateY}function MJ(n){return d4(n.x)||d4(n.y)}function d4(n){return n&&n!=="0%"}function NM(n,e,t){const i=n-t,r=e*i;return t+r}function p4(n,e,t,i,r){return r!==void 0&&(n=NM(n,r,i)),NM(n,t,i)+e}function PD(n,e=0,t=1,i,r){n.min=p4(n.min,e,t,i,r),n.max=p4(n.max,e,t,i,r)}function AJ(n,{x:e,y:t}){PD(n.x,e.translate,e.scale,e.originPoint),PD(n.y,t.translate,t.scale,t.originPoint)}function pme(n,e,t,i=!1){const r=t.length;if(!r)return;e.x=e.y=1;let s,o;for(let a=0;a<r;a++){s=t[a],o=s.projectionDelta;const l=s.instance;l&&l.style&&l.style.display==="contents"||(i&&s.options.layoutScroll&&s.scroll&&s!==s.root&&zg(n,{x:-s.scroll.offset.x,y:-s.scroll.offset.y}),o&&(e.x*=o.x.scale,e.y*=o.y.scale,AJ(n,o)),i&&xp(s.latestValues)&&zg(n,s.latestValues))}e.x=f4(e.x),e.y=f4(e.y)}function f4(n){return Number.isInteger(n)||n>1.0000000000001||n<.999999999999?n:1}function Ih(n,e){n.min=n.min+e,n.max=n.max+e}function m4(n,e,[t,i,r]){const s=e[r]!==void 0?e[r]:.5,o=Ii(n.min,n.max,s);PD(n,e[t],e[i],o,e.scale)}const fme=["x","scaleX","originX"],mme=["y","scaleY","originY"];function zg(n,e){m4(n.x,e,fme),m4(n.y,e,mme)}function EJ(n,e){return _J(dme(n.getBoundingClientRect(),e))}function gme(n,e,t){const i=EJ(n,t),{scroll:r}=e;return r&&(Ih(i.x,r.offset.x),Ih(i.y,r.offset.y)),i}const yme=new WeakMap;class bme{constructor(e){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=cr(),this.visualElement=e}start(e,{snapToCursor:t=!1}={}){const{presenceContext:i}=this.visualElement;if(i&&i.isPresent===!1)return;const r=l=>{this.stopAnimation(),t&&this.snapToCursor(qA(l,"page").point)},s=(l,u)=>{const{drag:c,dragPropagation:h,onDragStart:d}=this.getProps();if(c&&!h&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=VY(c),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),fu(f=>{let g=this.getAxisMotionValue(f).get()||0;if(Mu.test(g)){const{projection:y}=this.visualElement;if(y&&y.layout){const m=y.layout.layoutBox[f];m&&(g=ca(m)*(parseFloat(g)/100))}}this.originPoint[f]=g}),d&&ti.update(()=>d(l,u),!1,!0);const{animationState:p}=this.visualElement;p&&p.setActive("whileDrag",!0)},o=(l,u)=>{const{dragPropagation:c,dragDirectionLock:h,onDirectionLock:d,onDrag:p}=this.getProps();if(!c&&!this.openGlobalLock)return;const{offset:f}=u;if(h&&this.currentDirection===null){this.currentDirection=xme(f),this.currentDirection!==null&&d&&d(this.currentDirection);return}this.updateAxis("x",u.point,f),this.updateAxis("y",u.point,f),this.visualElement.render(),p&&p(l,u)},a=(l,u)=>this.stop(l,u);this.panSession=new TJ(e,{onSessionStart:r,onStart:s,onMove:o,onSessionEnd:a},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(e,t){const i=this.isDragging;if(this.cancel(),!i)return;const{velocity:r}=t;this.startAnimation(r);const{onDragEnd:s}=this.getProps();s&&ti.update(()=>s(e,t))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:i}=this.getProps();!i&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,i){const{drag:r}=this.getProps();if(!i||!eC(e,r,this.currentDirection))return;const s=this.getAxisMotionValue(e);let o=this.originPoint[e]+i[e];this.constraints&&this.constraints[e]&&(o=sme(o,this.constraints[e],this.elastic[e])),s.set(o)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),{layout:i}=this.visualElement.projection||{},r=this.constraints;e&&Fg(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&i?this.constraints=ome(i.layoutBox,e):this.constraints=!1,this.elastic=cme(t),r!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&fu(s=>{this.getAxisMotionValue(s)&&(this.constraints[s]=ume(i.layoutBox[s],this.constraints[s]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!Fg(e))return!1;const i=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const s=gme(i,r.root,this.visualElement.getTransformPagePoint());let o=ame(r.layout.layoutBox,s);if(t){const a=t(hme(o));this.hasMutatedConstraints=!!a,a&&(o=_J(a))}return o}startAnimation(e){const{drag:t,dragMomentum:i,dragElastic:r,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},u=fu(c=>{if(!eC(c,t,this.currentDirection))return;let h=l&&l[c]||{};o&&(h={min:0,max:0});const d=r?200:1e6,p=r?40:1e7,f={type:"inertia",velocity:i?e[c]:0,bounceStiffness:d,bounceDamping:p,timeConstant:750,restDelta:1,restSpeed:10,...s,...h};return this.startAxisValueAnimation(c,f)});return Promise.all(u).then(a)}startAxisValueAnimation(e,t){const i=this.getAxisMotionValue(e);return i.start(cB(e,i,0,t))}stopAnimation(){fu(e=>this.getAxisMotionValue(e).stop())}getAxisMotionValue(e){const t="_drag"+e.toUpperCase(),i=this.visualElement.getProps(),r=i[t];return r||this.visualElement.getValue(e,(i.initial?i.initial[e]:void 0)||0)}snapToCursor(e){fu(t=>{const{drag:i}=this.getProps();if(!eC(t,i,this.currentDirection))return;const{projection:r}=this.visualElement,s=this.getAxisMotionValue(t);if(r&&r.layout){const{min:o,max:a}=r.layout.layoutBox[t];s.set(e[t]-Ii(o,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:i}=this.visualElement;if(!Fg(t)||!i||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};fu(o=>{const a=this.getAxisMotionValue(o);if(a){const l=a.get();r[o]=lme({min:l,max:l},this.constraints[o])}});const{transformTemplate:s}=this.visualElement.getProps();this.visualElement.current.style.transform=s?s({},""):"none",i.root&&i.root.updateScroll(),i.updateLayout(),this.resolveConstraints(),fu(o=>{if(!eC(o,e,null))return;const a=this.getAxisMotionValue(o),{min:l,max:u}=this.constraints[o];a.set(Ii(l,u,r[o]))})}addListeners(){if(!this.visualElement.current)return;yme.set(this.visualElement,this);const e=this.visualElement.current,t=Tc(e,"pointerdown",l=>{const{drag:u,dragListener:c=!0}=this.getProps();u&&c&&this.start(l)}),i=()=>{const{dragConstraints:l}=this.getProps();Fg(l)&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,s=r.addEventListener("measure",i);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),i();const o=bc(window,"resize",()=>this.scalePositionWithinConstraints()),a=r.addEventListener("didUpdate",({delta:l,hasLayoutChanged:u})=>{this.isDragging&&u&&(fu(c=>{const h=this.getAxisMotionValue(c);h&&(this.originPoint[c]+=l[c].translate,h.set(h.get()+l[c].translate))}),this.visualElement.render())});return()=>{o(),t(),s(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:i=!1,dragPropagation:r=!1,dragConstraints:s=!1,dragElastic:o=ND,dragMomentum:a=!0}=e;return{...e,drag:t,dragDirectionLock:i,dragPropagation:r,dragConstraints:s,dragElastic:o,dragMomentum:a}}}function eC(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function xme(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class vme extends kd{constructor(e){super(e),this.removeGroupControls=$i,this.removeListeners=$i,this.controls=new bme(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||$i}unmount(){this.removeGroupControls(),this.removeListeners()}}const g4=n=>(e,t)=>{n&&ti.update(()=>n(e,t))};class wme extends kd{constructor(){super(...arguments),this.removePointerDownListener=$i}onPointerDown(e){this.session=new TJ(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint()})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:i,onPanEnd:r}=this.node.getProps();return{onSessionStart:g4(e),onStart:g4(t),onMove:i,onEnd:(s,o)=>{delete this.session,r&&ti.update(()=>r(s,o))}}}mount(){this.removePointerDownListener=Tc(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}function Sme(){const n=K.useContext(ZA);if(n===null)return[!0,null];const{isPresent:e,onExitComplete:t,register:i}=n,r=K.useId();return K.useEffect(()=>i(r),[]),!e&&t?[!1,()=>t&&t(r)]:[!0]}const N_={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function y4(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const sx={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if($t.test(n))n=parseFloat(n);else return n;const t=y4(n,e.target.x),i=y4(n,e.target.y);return`${t}% ${i}%`}},Tme={correct:(n,{treeScale:e,projectionDelta:t})=>{const i=n,r=pd.parse(n);if(r.length>5)return i;const s=pd.createTransformer(n),o=typeof r[0]!="number"?1:0,a=t.x.scale*e.x,l=t.y.scale*e.y;r[0+o]/=a,r[1+o]/=l;const u=Ii(a,l,.5);return typeof r[2+o]=="number"&&(r[2+o]/=u),typeof r[3+o]=="number"&&(r[3+o]/=u),s(r)}};class Cme extends Is.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:i,layoutId:r}=this.props,{projection:s}=e;Rde(_me),s&&(t.group&&t.group.add(s),i&&i.register&&r&&i.register(s),s.root.didUpdate(),s.addEventListener("animationComplete",()=>{this.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=>this.safeToRemove()})),N_.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:i,drag:r,isPresent:s}=this.props,o=i.projection;return o&&(o.isPresent=s,r||e.layoutDependency!==t||t===void 0?o.willUpdate():this.safeToRemove(),e.isPresent!==s&&(s?o.promote():o.relegate()||ti.postRender(()=>{const a=o.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),queueMicrotask(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:i}=this.props,{projection:r}=e;r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),i&&i.deregister&&i.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function IJ(n){const[e,t]=Sme(),i=K.useContext(YO);return Is.createElement(Cme,{...n,layoutGroup:i,switchLayoutGroup:K.useContext(CY),isPresent:e,safeToRemove:t})}const _me={borderRadius:{...sx,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:sx,borderTopRightRadius:sx,borderBottomLeftRadius:sx,borderBottomRightRadius:sx,boxShadow:Tme},kJ=["TopLeft","TopRight","BottomLeft","BottomRight"],Mme=kJ.length,b4=n=>typeof n=="string"?parseFloat(n):n,x4=n=>typeof n=="number"||$t.test(n);function Ame(n,e,t,i,r,s){r?(n.opacity=Ii(0,t.opacity!==void 0?t.opacity:1,Eme(i)),n.opacityExit=Ii(e.opacity!==void 0?e.opacity:1,0,Ime(i))):s&&(n.opacity=Ii(e.opacity!==void 0?e.opacity:1,t.opacity!==void 0?t.opacity:1,i));for(let o=0;o<Mme;o++){const a=`border${kJ[o]}Radius`;let l=v4(e,a),u=v4(t,a);if(l===void 0&&u===void 0)continue;l||(l=0),u||(u=0),l===0||u===0||x4(l)===x4(u)?(n[a]=Math.max(Ii(b4(l),b4(u),i),0),(Mu.test(u)||Mu.test(l))&&(n[a]+="%")):n[a]=u}(e.rotate||t.rotate)&&(n.rotate=Ii(e.rotate||0,t.rotate||0,i))}function v4(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const Eme=RJ(0,.5,oB),Ime=RJ(.5,.95,$i);function RJ(n,e,t){return i=>i<n?0:i>e?1:t(Dv(n,e,i))}function w4(n,e){n.min=e.min,n.max=e.max}function ka(n,e){w4(n.x,e.x),w4(n.y,e.y)}function S4(n,e,t,i,r){return n-=e,n=NM(n,1/t,i),r!==void 0&&(n=NM(n,1/r,i)),n}function kme(n,e=0,t=1,i=.5,r,s=n,o=n){if(Mu.test(e)&&(e=parseFloat(e),e=Ii(o.min,o.max,e/100)-o.min),typeof e!="number")return;let a=Ii(s.min,s.max,i);n===s&&(a-=e),n.min=S4(n.min,e,t,a,r),n.max=S4(n.max,e,t,a,r)}function T4(n,e,[t,i,r],s,o){kme(n,e[t],e[i],e[r],e.scale,s,o)}const Rme=["x","scaleX","originX"],Nme=["y","scaleY","originY"];function C4(n,e,t,i){T4(n.x,e,Rme,t?t.x:void 0,i?i.x:void 0),T4(n.y,e,Nme,t?t.y:void 0,i?i.y:void 0)}function _4(n){return n.translate===0&&n.scale===1}function NJ(n){return _4(n.x)&&_4(n.y)}function Lme(n,e){return n.x.min===e.x.min&&n.x.max===e.x.max&&n.y.min===e.y.min&&n.y.max===e.y.max}function LJ(n,e){return Math.round(n.x.min)===Math.round(e.x.min)&&Math.round(n.x.max)===Math.round(e.x.max)&&Math.round(n.y.min)===Math.round(e.y.min)&&Math.round(n.y.max)===Math.round(e.y.max)}function M4(n){return ca(n.x)/ca(n.y)}class Pme{constructor(){this.members=[]}add(e){hB(this.members,e),e.scheduleRender()}remove(e){if(dB(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(r=>e===r);if(t===0)return!1;let i;for(let r=t;r>=0;r--){const s=this.members[r];if(s.isPresent!==!1){i=s;break}}return i?(this.promote(i),!0):!1}promote(e,t){const i=this.lead;if(e!==i&&(this.prevLead=i,this.lead=e,e.show(),i)){i.instance&&i.scheduleRender(),e.scheduleRender(),e.resumeFrom=i,t&&(e.resumeFrom.preserveOpacity=!0),i.snapshot&&(e.snapshot=i.snapshot,e.snapshot.latestValues=i.animationValues||i.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&i.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:i}=e;t.onExitComplete&&t.onExitComplete(),i&&i.options.onExitComplete&&i.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function A4(n,e,t){let i="";const r=n.x.translate/e.x,s=n.y.translate/e.y;if((r||s)&&(i=`translate3d(${r}px, ${s}px, 0) `),(e.x!==1||e.y!==1)&&(i+=`scale(${1/e.x}, ${1/e.y}) `),t){const{rotate:l,rotateX:u,rotateY:c}=t;l&&(i+=`rotate(${l}deg) `),u&&(i+=`rotateX(${u}deg) `),c&&(i+=`rotateY(${c}deg) `)}const o=n.x.scale*e.x,a=n.y.scale*e.y;return(o!==1||a!==1)&&(i+=`scale(${o}, ${a})`),i||"none"}const Dme=(n,e)=>n.depth-e.depth;class Fme{constructor(){this.children=[],this.isDirty=!1}add(e){hB(this.children,e),this.isDirty=!0}remove(e){dB(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(Dme),this.isDirty=!1,this.children.forEach(e)}}function Ome(n,e){const t=performance.now(),i=({timestamp:r})=>{const s=r-t;s>=e&&(Pc(i),n(s-e))};return ti.read(i,!0),()=>Pc(i)}function Bme(n){window.MotionDebug&&window.MotionDebug.record(n)}function zme(n){return n instanceof SVGElement&&n.tagName!=="svg"}function Gme(n,e,t){const i=Io(n)?n:vy(n);return i.start(cB("",i,e,t)),i.animation}const E4=["","X","Y","Z"],I4=1e3;let Vme=0;const vp={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0};function PJ({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:i,resetTransform:r}){return class{constructor(o={},a=e==null?void 0:e()){this.id=Vme++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{vp.totalNodes=vp.resolvedTargetDeltas=vp.recalculatedProjection=0,this.nodes.forEach(Wme),this.nodes.forEach(jme),this.nodes.forEach(Yme),this.nodes.forEach(Hme),Bme(vp)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new Fme)}addEventListener(o,a){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new pB),this.eventHandlers.get(o).add(a)}notifyListeners(o,...a){const l=this.eventHandlers.get(o);l&&l.notify(...a)}hasListeners(o){return this.eventHandlers.has(o)}mount(o,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=zme(o),this.instance=o;const{layoutId:l,layout:u,visualElement:c}=this.options;if(c&&!c.current&&c.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(u||l)&&(this.isLayoutDirty=!0),n){let h;const d=()=>this.root.updateBlockedByResize=!1;n(o,()=>{this.root.updateBlockedByResize=!0,h&&h(),h=Ome(d,250),N_.hasAnimatedSinceResize&&(N_.hasAnimatedSinceResize=!1,this.nodes.forEach(R4))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&c&&(l||u)&&this.addEventListener("didUpdate",({delta:h,hasLayoutChanged:d,hasRelativeTargetChanged:p,layout:f})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const g=this.options.transition||c.getDefaultTransition()||tge,{onLayoutAnimationStart:y,onLayoutAnimationComplete:m}=c.getProps(),v=!this.targetLayout||!LJ(this.targetLayout,f)||p,w=!d&&p;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||w||d&&(v||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(h,w);const S={...bJ(g,"layout"),onPlay:y,onComplete:m};(c.shouldReduceMotion||this.options.layoutRoot)&&(S.delay=0,S.type=!1),this.startAnimation(S)}else d||R4(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=f})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,Pc(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Jme),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let c=0;c<this.path.length;c++){const h=this.path[c];h.shouldResetTransform=!0,h.updateScroll("snapshot"),h.options.layoutRoot&&h.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const u=this.getTransformTemplate();this.prevTransformTemplateValue=u?u(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(k4);return}this.isUpdating||this.nodes.forEach(Kme),this.isUpdating=!1,this.nodes.forEach(Zme),this.nodes.forEach(Ume),this.nodes.forEach($me),this.clearAllSnapshots();const a=performance.now();Gr.delta=dd(0,1e3/60,a-Gr.timestamp),Gr.timestamp=a,Gr.isProcessing=!0,aN.update.process(Gr),aN.preRender.process(Gr),aN.render.process(Gr),Gr.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask(()=>this.update()))}clearAllSnapshots(){this.nodes.forEach(Xme),this.sharedNodes.forEach(Qme)}scheduleUpdateProjection(){ti.preRender(this.updateProjection,!1,!0)}scheduleCheckAfterUnmount(){ti.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure())}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutCorrected=cr(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let a=!!(this.options.layoutScroll&&this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(a=!1),a&&(this.scroll={animationId:this.root.animationId,phase:o,isRoot:i(this.instance),offset:t(this.instance)})}resetTransform(){if(!r)return;const o=this.isLayoutDirty||this.shouldResetTransform,a=this.projectionDelta&&!NJ(this.projectionDelta),l=this.getTransformTemplate(),u=l?l(this.latestValues,""):void 0,c=u!==this.prevTransformTemplateValue;o&&(a||xp(this.latestValues)||c)&&(r(this.instance,u),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return o&&(l=this.removeTransform(l)),nge(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return cr();const a=o.measureViewportBox(),{scroll:l}=this.root;return l&&(Ih(a.x,l.offset.x),Ih(a.y,l.offset.y)),a}removeElementScroll(o){const a=cr();ka(a,o);for(let l=0;l<this.path.length;l++){const u=this.path[l],{scroll:c,options:h}=u;if(u!==this.root&&c&&h.layoutScroll){if(c.isRoot){ka(a,o);const{scroll:d}=this.root;d&&(Ih(a.x,-d.offset.x),Ih(a.y,-d.offset.y))}Ih(a.x,c.offset.x),Ih(a.y,c.offset.y)}}return a}applyTransform(o,a=!1){const l=cr();ka(l,o);for(let u=0;u<this.path.length;u++){const c=this.path[u];!a&&c.options.layoutScroll&&c.scroll&&c!==c.root&&zg(l,{x:-c.scroll.offset.x,y:-c.scroll.offset.y}),xp(c.latestValues)&&zg(l,c.latestValues)}return xp(this.latestValues)&&zg(l,this.latestValues),l}removeTransform(o){const a=cr();ka(a,o);for(let l=0;l<this.path.length;l++){const u=this.path[l];if(!u.instance||!xp(u.latestValues))continue;LD(u.latestValues)&&u.updateSnapshot();const c=cr(),h=u.measurePageBox();ka(c,h),C4(a,u.latestValues,u.snapshot?u.snapshot.layoutBox:void 0,c)}return xp(this.latestValues)&&C4(a,this.latestValues),a}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==Gr.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){var a;const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const u=!!this.resumingFrom||this!==l;if(!(o||u&&this.isSharedProjectionDirty||this.isProjectionDirty||!((a=this.parent)===null||a===void 0)&&a.isProjectionDirty||this.attemptToResolveRelativeTarget))return;const{layout:h,layoutId:d}=this.options;if(!(!this.layout||!(h||d))){if(this.resolvedRelativeTargetAt=Gr.timestamp,!this.targetDelta&&!this.relativeTarget){const p=this.getClosestProjectingParent();p&&p.layout&&this.animationProgress!==1?(this.relativeParent=p,this.forceRelativeParentToResolveTarget(),this.relativeTarget=cr(),this.relativeTargetOrigin=cr(),rv(this.relativeTargetOrigin,this.layout.layoutBox,p.layout.layoutBox),ka(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)){if(this.target||(this.target=cr(),this.targetWithTransforms=cr()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),rme(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):ka(this.target,this.layout.layoutBox),AJ(this.target,this.targetDelta)):ka(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const p=this.getClosestProjectingParent();p&&!!p.resumingFrom==!!this.resumingFrom&&!p.options.layoutScroll&&p.target&&this.animationProgress!==1?(this.relativeParent=p,this.forceRelativeParentToResolveTarget(),this.relativeTarget=cr(),this.relativeTargetOrigin=cr(),rv(this.relativeTargetOrigin,this.target,p.target),ka(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}vp.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(!(!this.parent||LD(this.parent.latestValues)||MJ(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var o;const a=this.getLead(),l=!!this.resumingFrom||this!==a;let u=!0;if((this.isProjectionDirty||!((o=this.parent)===null||o===void 0)&&o.isProjectionDirty)&&(u=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(u=!1),this.resolvedRelativeTargetAt===Gr.timestamp&&(u=!1),u)return;const{layout:c,layoutId:h}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(c||h))return;ka(this.layoutCorrected,this.layout.layoutBox);const d=this.treeScale.x,p=this.treeScale.y;pme(this.layoutCorrected,this.treeScale,this.path,l),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox);const{target:f}=a;if(!f){this.projectionTransform&&(this.projectionDelta=Bg(),this.projectionTransform="none",this.scheduleRender());return}this.projectionDelta||(this.projectionDelta=Bg(),this.projectionDeltaWithTransform=Bg());const g=this.projectionTransform;iv(this.projectionDelta,this.layoutCorrected,f,this.latestValues),this.projectionTransform=A4(this.projectionDelta,this.treeScale),(this.projectionTransform!==g||this.treeScale.x!==d||this.treeScale.y!==p)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",f)),vp.recalculatedProjection++}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.scheduleRender&&this.options.scheduleRender(),o){const a=this.getStack();a&&a.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(o,a=!1){const l=this.snapshot,u=l?l.latestValues:{},c={...this.latestValues},h=Bg();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const d=cr(),p=l?l.source:void 0,f=this.layout?this.layout.source:void 0,g=p!==f,y=this.getStack(),m=!y||y.members.length<=1,v=!!(g&&!m&&this.options.crossfade===!0&&!this.path.some(ege));this.animationProgress=0;let w;this.mixTargetDelta=S=>{const C=S/1e3;N4(h.x,o.x,C),N4(h.y,o.y,C),this.setTargetDelta(h),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(rv(d,this.layout.layoutBox,this.relativeParent.layout.layoutBox),qme(this.relativeTarget,this.relativeTargetOrigin,d,C),w&&Lme(this.relativeTarget,w)&&(this.isProjectionDirty=!1),w||(w=cr()),ka(w,this.relativeTarget)),g&&(this.animationValues=c,Ame(c,u,this.latestValues,C,v,m)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=C},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(Pc(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=ti.update(()=>{N_.hasAnimatedSinceResize=!0,this.currentAnimation=Gme(0,I4,{...o,onUpdate:a=>{this.mixTargetDelta(a),o.onUpdate&&o.onUpdate(a)},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(I4),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:a,target:l,layout:u,latestValues:c}=o;if(!(!a||!l||!u)){if(this!==o&&this.layout&&u&&DJ(this.options.animationType,this.layout.layoutBox,u.layoutBox)){l=this.target||cr();const h=ca(this.layout.layoutBox.x);l.x.min=o.target.x.min,l.x.max=l.x.min+h;const d=ca(this.layout.layoutBox.y);l.y.min=o.target.y.min,l.y.max=l.y.min+d}ka(a,l),zg(a,c),iv(this.projectionDeltaWithTransform,this.layoutCorrected,a,c)}}registerSharedNode(o,a){this.sharedNodes.has(o)||this.sharedNodes.set(o,new Pme),this.sharedNodes.get(o).add(a);const u=a.options.initialPromotionConfig;a.promote({transition:u?u.transition:void 0,preserveFollowOpacity:u&&u.shouldPreserveFollowOpacity?u.shouldPreserveFollowOpacity(a):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){var o;const{layoutId:a}=this.options;return a?((o=this.getStack())===null||o===void 0?void 0:o.lead)||this:this}getPrevLead(){var o;const{layoutId:a}=this.options;return a?(o=this.getStack())===null||o===void 0?void 0:o.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:a,preserveFollowOpacity:l}={}){const u=this.getStack();u&&u.promote(this,l),o&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetRotation(){const{visualElement:o}=this.options;if(!o)return;let a=!1;const{latestValues:l}=o;if((l.rotate||l.rotateX||l.rotateY||l.rotateZ)&&(a=!0),!a)return;const u={};for(let c=0;c<E4.length;c++){const h="rotate"+E4[c];l[h]&&(u[h]=l[h],o.setStaticValue(h,0))}o.render();for(const c in u)o.setStaticValue(c,u[c]);o.scheduleRender()}getProjectionStyles(o={}){var a,l;const u={};if(!this.instance||this.isSVG)return u;if(this.isVisible)u.visibility="";else return{visibility:"hidden"};const c=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,u.opacity="",u.pointerEvents=R_(o.pointerEvents)||"",u.transform=c?c(this.latestValues,""):"none",u;const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){const g={};return this.options.layoutId&&(g.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,g.pointerEvents=R_(o.pointerEvents)||""),this.hasProjected&&!xp(this.latestValues)&&(g.transform=c?c({},""):"none",this.hasProjected=!1),g}const d=h.animationValues||h.latestValues;this.applyTransformsToTarget(),u.transform=A4(this.projectionDeltaWithTransform,this.treeScale,d),c&&(u.transform=c(d,u.transform));const{x:p,y:f}=this.projectionDelta;u.transformOrigin=`${p.origin*100}% ${f.origin*100}% 0`,h.animationValues?u.opacity=h===this?(l=(a=d.opacity)!==null&&a!==void 0?a:this.latestValues.opacity)!==null&&l!==void 0?l:1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:u.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const g in _M){if(d[g]===void 0)continue;const{correct:y,applyTo:m}=_M[g],v=u.transform==="none"?d[g]:y(d[g],h);if(m){const w=m.length;for(let S=0;S<w;S++)u[m[S]]=v}else u[g]=v}return this.options.layoutId&&(u.pointerEvents=h===this?R_(o.pointerEvents)||"":"none"),u}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>{var a;return(a=o.currentAnimation)===null||a===void 0?void 0:a.stop()}),this.root.nodes.forEach(k4),this.root.sharedNodes.clear()}}}function Ume(n){n.updateLayout()}function $me(n){var e;const t=((e=n.resumeFrom)===null||e===void 0?void 0:e.snapshot)||n.snapshot;if(n.isLead()&&n.layout&&t&&n.hasListeners("didUpdate")){const{layoutBox:i,measuredBox:r}=n.layout,{animationType:s}=n.options,o=t.source!==n.layout.source;s==="size"?fu(h=>{const d=o?t.measuredBox[h]:t.layoutBox[h],p=ca(d);d.min=i[h].min,d.max=d.min+p}):DJ(s,t.layoutBox,i)&&fu(h=>{const d=o?t.measuredBox[h]:t.layoutBox[h],p=ca(i[h]);d.max=d.min+p,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[h].max=n.relativeTarget[h].min+p)});const a=Bg();iv(a,i,t.layoutBox);const l=Bg();o?iv(l,n.applyTransform(r,!0),t.measuredBox):iv(l,i,t.layoutBox);const u=!NJ(a);let c=!1;if(!n.resumeFrom){const h=n.getClosestProjectingParent();if(h&&!h.resumeFrom){const{snapshot:d,layout:p}=h;if(d&&p){const f=cr();rv(f,t.layoutBox,d.layoutBox);const g=cr();rv(g,i,p.layoutBox),LJ(f,g)||(c=!0),h.options.layoutRoot&&(n.relativeTarget=g,n.relativeTargetOrigin=f,n.relativeParent=h)}}}n.notifyListeners("didUpdate",{layout:i,snapshot:t,delta:l,layoutDelta:a,hasLayoutChanged:u,hasRelativeTargetChanged:c})}else if(n.isLead()){const{onExitComplete:i}=n.options;i&&i()}n.options.transition=void 0}function Wme(n){vp.totalNodes++,n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Hme(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Xme(n){n.clearSnapshot()}function k4(n){n.clearMeasurements()}function Kme(n){n.isLayoutDirty=!1}function Zme(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function R4(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function jme(n){n.resolveTargetDelta()}function Yme(n){n.calcProjection()}function Jme(n){n.resetRotation()}function Qme(n){n.removeLeadSnapshot()}function N4(n,e,t){n.translate=Ii(e.translate,0,t),n.scale=Ii(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function L4(n,e,t,i){n.min=Ii(e.min,t.min,i),n.max=Ii(e.max,t.max,i)}function qme(n,e,t,i){L4(n.x,e.x,t.x,i),L4(n.y,e.y,t.y,i)}function ege(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const tge={duration:.45,ease:[.4,0,.1,1]},P4=n=>typeof navigator<"u"&&navigator.userAgent.toLowerCase().includes(n),D4=P4("applewebkit/")&&!P4("chrome/")?Math.round:$i;function F4(n){n.min=D4(n.min),n.max=D4(n.max)}function nge(n){F4(n.x),F4(n.y)}function DJ(n,e,t){return n==="position"||n==="preserve-aspect"&&!RD(M4(e),M4(t),.2)}const ige=PJ({attachResizeListener:(n,e)=>bc(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),bN={current:void 0},FJ=PJ({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!bN.current){const n=new ige({});n.mount(window),n.setOptions({layoutScroll:!0}),bN.current=n}return bN.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),rge={pan:{Feature:wme},drag:{Feature:vme,ProjectionNode:FJ,MeasureLayout:IJ}},sge=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function oge(n){const e=sge.exec(n);if(!e)return[,];const[,t,i]=e;return[t,i]}function DD(n,e,t=1){const[i,r]=oge(n);if(!i)return;const s=window.getComputedStyle(e).getPropertyValue(i);if(s){const o=s.trim();return xJ(o)?parseFloat(o):o}else return CD(r)?DD(r,e,t+1):r}function age(n,{...e},t){const i=n.current;if(!(i instanceof Element))return{target:e,transitionEnd:t};t&&(t={...t}),n.values.forEach(r=>{const s=r.get();if(!CD(s))return;const o=DD(s,i);o&&r.set(o)});for(const r in e){const s=e[r];if(!CD(s))continue;const o=DD(s,i);o&&(e[r]=o,t||(t={}),t[r]===void 0&&(t[r]=s))}return{target:e,transitionEnd:t}}const lge=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),OJ=n=>lge.has(n),uge=n=>Object.keys(n).some(OJ),O4=n=>n===Qf||n===$t,B4=(n,e)=>parseFloat(n.split(", ")[e]),z4=(n,e)=>(t,{transform:i})=>{if(i==="none"||!i)return 0;const r=i.match(/^matrix3d\((.+)\)$/);if(r)return B4(r[1],e);{const s=i.match(/^matrix\((.+)\)$/);return s?B4(s[1],n):0}},cge=new Set(["x","y","z"]),hge=N1.filter(n=>!cge.has(n));function dge(n){const e=[];return hge.forEach(t=>{const i=n.getValue(t);i!==void 0&&(e.push([t,i.get()]),i.set(t.startsWith("scale")?1:0))}),e.length&&n.render(),e}const wy={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:z4(4,13),y:z4(5,14)};wy.translateX=wy.x;wy.translateY=wy.y;const pge=(n,e,t)=>{const i=e.measureViewportBox(),r=e.current,s=getComputedStyle(r),{display:o}=s,a={};o==="none"&&e.setStaticValue("display",n.display||"block"),t.forEach(u=>{a[u]=wy[u](i,s)}),e.render();const l=e.measureViewportBox();return t.forEach(u=>{const c=e.getValue(u);c&&c.jump(a[u]),n[u]=wy[u](l,s)}),n},fge=(n,e,t={},i={})=>{e={...e},i={...i};const r=Object.keys(e).filter(OJ);let s=[],o=!1;const a=[];if(r.forEach(l=>{const u=n.getValue(l);if(!n.hasValue(l))return;let c=t[l],h=rx(c);const d=e[l];let p;if(AM(d)){const f=d.length,g=d[0]===null?1:0;c=d[g],h=rx(c);for(let y=g;y<f&&d[y]!==null;y++)p?sB(rx(d[y])===p):p=rx(d[y])}else p=rx(d);if(h!==p)if(O4(h)&&O4(p)){const f=u.get();typeof f=="string"&&u.set(parseFloat(f)),typeof d=="string"?e[l]=parseFloat(d):Array.isArray(d)&&p===$t&&(e[l]=d.map(parseFloat))}else h!=null&&h.transform&&(p!=null&&p.transform)&&(c===0||d===0)?c===0?u.set(p.transform(c)):e[l]=h.transform(d):(o||(s=dge(n),o=!0),a.push(l),i[l]=i[l]!==void 0?i[l]:e[l],u.jump(d))}),a.length){const l=a.indexOf("height")>=0?window.pageYOffset:null,u=pge(e,n,a);return s.length&&s.forEach(([c,h])=>{n.getValue(c).set(h)}),n.render(),jA&&l!==null&&window.scrollTo({top:l}),{target:u,transitionEnd:i}}else return{target:e,transitionEnd:i}};function mge(n,e,t,i){return uge(e)?fge(n,e,t,i):{target:e,transitionEnd:i}}const gge=(n,e,t,i)=>{const r=age(n,e,i);return e=r.target,i=r.transitionEnd,mge(n,e,t,i)},FD={current:null},BJ={current:!1};function yge(){if(BJ.current=!0,!!jA)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>FD.current=n.matches;n.addListener(e),e()}else FD.current=!1}function bge(n,e,t){const{willChange:i}=e;for(const r in e){const s=e[r],o=t[r];if(Io(s))n.addValue(r,s),RM(i)&&i.add(r);else if(Io(o))n.addValue(r,vy(s,{owner:n})),RM(i)&&i.remove(r);else if(o!==s)if(n.hasValue(r)){const a=n.getValue(r);!a.hasAnimated&&a.set(s)}else{const a=n.getStaticValue(r);n.addValue(r,vy(a!==void 0?a:s,{owner:n}))}}for(const r in t)e[r]===void 0&&n.removeValue(r);return e}const G4=new WeakMap,zJ=Object.keys(Pv),xge=zJ.length,V4=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"],vge=jO.length;class wge{constructor({parent:e,props:t,presenceContext:i,reducedMotionConfig:r,visualState:s},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>ti.render(this.render,!1,!0);const{latestValues:a,renderState:l}=s;this.latestValues=a,this.baseTarget={...a},this.initialValues=t.initial?{...a}:{},this.renderState=l,this.parent=e,this.props=t,this.presenceContext=i,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=o,this.isControllingVariants=JA(t),this.isVariantNode=TY(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:u,...c}=this.scrapeMotionValuesFromProps(t,{});for(const h in c){const d=c[h];a[h]!==void 0&&Io(d)&&(d.set(a[h],!1),RM(u)&&u.add(h))}}scrapeMotionValuesFromProps(e,t){return{}}mount(e){this.current=e,G4.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,i)=>this.bindToMotionValue(i,t)),BJ.current||yge(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:FD.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){G4.delete(this.current),this.projection&&this.projection.unmount(),Pc(this.notifyUpdate),Pc(this.render),this.valueSubscriptions.forEach(e=>e()),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features)this.features[e].unmount();this.current=null}bindToMotionValue(e,t){const i=Jf.has(e),r=t.on("change",o=>{this.latestValues[e]=o,this.props.onUpdate&&ti.update(this.notifyUpdate,!1,!0),i&&this.projection&&(this.projection.isTransformDirty=!0)}),s=t.on("renderRequest",this.scheduleRender);this.valueSubscriptions.set(e,()=>{r(),s()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}loadFeatures({children:e,...t},i,r,s){let o,a;for(let l=0;l<xge;l++){const u=zJ[l],{isEnabled:c,Feature:h,ProjectionNode:d,MeasureLayout:p}=Pv[u];d&&(o=d),c(t)&&(!this.features[u]&&h&&(this.features[u]=new h(this)),p&&(a=p))}if(!this.projection&&o){this.projection=new o(this.latestValues,this.parent&&this.parent.projection);const{layoutId:l,layout:u,drag:c,dragConstraints:h,layoutScroll:d,layoutRoot:p}=t;this.projection.setOptions({layoutId:l,layout:u,alwaysMeasureLayout:!!c||h&&Fg(h),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:typeof u=="string"?u:"both",initialPromotionConfig:s,layoutScroll:d,layoutRoot:p})}return a}updateFeatures(){for(const e in this.features){const t=this.features[e];t.isMounted?t.update():(t.mount(),t.isMounted=!0)}}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):cr()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}makeTargetAnimatable(e,t=!0){return this.makeTargetAnimatableFromInstance(e,this.props,t)}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let i=0;i<V4.length;i++){const r=V4[i];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const s=e["on"+r];s&&(this.propEventSubscriptions[r]=this.on(r,s))}this.prevMotionValues=bge(this,this.scrapeMotionValuesFromProps(e,this.prevProps),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}getVariantContext(e=!1){if(e)return this.parent?this.parent.getVariantContext():void 0;if(!this.isControllingVariants){const i=this.parent?this.parent.getVariantContext()||{}:{};return this.props.initial!==void 0&&(i.initial=this.props.initial),i}const t={};for(let i=0;i<vge;i++){const r=jO[i],s=this.props[r];(Lv(s)||s===!1)&&(t[r]=s)}return t}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){t!==this.values.get(e)&&(this.removeValue(e),this.bindToMotionValue(e,t)),this.values.set(e,t),this.latestValues[e]=t.get()}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let i=this.values.get(e);return i===void 0&&t!==void 0&&(i=vy(t,{owner:this}),this.addValue(e,i)),i}readValue(e){var t;return this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:(t=this.getBaseTargetFromProps(this.props,e))!==null&&t!==void 0?t:this.readValueFromInstance(this.current,e,this.options)}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){var t;const{initial:i}=this.props,r=typeof i=="string"||typeof i=="object"?(t=rB(this.props,i))===null||t===void 0?void 0:t[e]:void 0;if(i&&r!==void 0)return r;const s=this.getBaseTargetFromProps(this.props,e);return s!==void 0&&!Io(s)?s:this.initialValues[e]!==void 0&&r===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new pB),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}}class GJ extends wge{sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:i}){delete t[e],delete i[e]}makeTargetAnimatableFromInstance({transition:e,transitionEnd:t,...i},{transformValues:r},s){let o=Gfe(i,e||{},this);if(r&&(t&&(t=r(t)),i&&(i=r(i)),o&&(o=r(o))),s){Bfe(this,i,o);const a=gge(this,i,o,t);t=a.transitionEnd,i=a.target}return{transition:e,transitionEnd:t,...i}}}function Sge(n){return window.getComputedStyle(n)}class Tge extends GJ{readValueFromInstance(e,t){if(Jf.has(t)){const i=uB(t);return i&&i.default||0}else{const i=Sge(e),r=(AY(t)?i.getPropertyValue(t):i[t])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:t}){return EJ(e,t)}build(e,t,i,r){QO(e,t,i,r.transformTemplate)}scrapeMotionValuesFromProps(e,t){return iB(e,t)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;Io(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}renderInstance(e,t,i,r){LY(e,t,i,r)}}class Cge extends GJ{constructor(){super(...arguments),this.isSVGTag=!1}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Jf.has(t)){const i=uB(t);return i&&i.default||0}return t=PY.has(t)?t:nB(t),e.getAttribute(t)}measureInstanceViewportBox(){return cr()}scrapeMotionValuesFromProps(e,t){return FY(e,t)}build(e,t,i,r){eB(e,t,i,this.isSVGTag,r.transformTemplate)}renderInstance(e,t,i,r){DY(e,t,i,r)}mount(e){this.isSVGTag=tB(e.tagName),super.mount(e)}}const _ge=(n,e)=>JO(n)?new Cge(e,{enableHardwareAcceleration:!1}):new Tge(e,{enableHardwareAcceleration:!0}),Mge={layout:{ProjectionNode:FJ,MeasureLayout:IJ}},Age={...eme,...vpe,...rge,...Mge},On=Ide((n,e)=>ape(n,e,Age,_ge));function VJ(){const n=K.useRef(!1);return KO(()=>(n.current=!0,()=>{n.current=!1}),[]),n}function Ege(){const n=VJ(),[e,t]=K.useState(0),i=K.useCallback(()=>{n.current&&t(e+1)},[e]);return[K.useCallback(()=>ti.postRender(i),[i]),e]}class Ige extends K.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const i=this.props.sizeRef.current;i.height=t.offsetHeight||0,i.width=t.offsetWidth||0,i.top=t.offsetTop,i.left=t.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function kge({children:n,isPresent:e}){const t=K.useId(),i=K.useRef(null),r=K.useRef({width:0,height:0,top:0,left:0});return K.useInsertionEffect(()=>{const{width:s,height:o,top:a,left:l}=r.current;if(e||!i.current||!s||!o)return;i.current.dataset.motionPopId=t;const u=document.createElement("style");return document.head.appendChild(u),u.sheet&&u.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${o}px !important;
            top: ${a}px !important;
            left: ${l}px !important;
          }
        `),()=>{document.head.removeChild(u)}},[e]),K.createElement(Ige,{isPresent:e,childRef:i,sizeRef:r},K.cloneElement(n,{ref:i}))}const xN=({children:n,initial:e,isPresent:t,onExitComplete:i,custom:r,presenceAffectsLayout:s,mode:o})=>{const a=OY(Rge),l=K.useId(),u=K.useMemo(()=>({id:l,initial:e,isPresent:t,custom:r,onExitComplete:c=>{a.set(c,!0);for(const h of a.values())if(!h)return;i&&i()},register:c=>(a.set(c,!1),()=>a.delete(c))}),s?void 0:[t]);return K.useMemo(()=>{a.forEach((c,h)=>a.set(h,!1))},[t]),K.useEffect(()=>{!t&&!a.size&&i&&i()},[t]),o==="popLayout"&&(n=K.createElement(kge,{isPresent:t},n)),K.createElement(ZA.Provider,{value:u},n)};function Rge(){return new Map}function Nge(n){return K.useEffect(()=>()=>n(),[])}const wp=n=>n.key||"";function Lge(n,e){n.forEach(t=>{const i=wp(t);e.set(i,t)})}function Pge(n){const e=[];return K.Children.forEach(n,t=>{K.isValidElement(t)&&e.push(t)}),e}const OD=({children:n,custom:e,initial:t=!0,onExitComplete:i,exitBeforeEnter:r,presenceAffectsLayout:s=!0,mode:o="sync"})=>{const a=K.useContext(YO).forceRender||Ege()[0],l=VJ(),u=Pge(n);let c=u;const h=K.useRef(new Map).current,d=K.useRef(c),p=K.useRef(new Map).current,f=K.useRef(!0);if(KO(()=>{f.current=!1,Lge(u,p),d.current=c}),Nge(()=>{f.current=!0,p.clear(),h.clear()}),f.current)return K.createElement(K.Fragment,null,c.map(v=>K.createElement(xN,{key:wp(v),isPresent:!0,initial:t?void 0:!1,presenceAffectsLayout:s,mode:o},v)));c=[...c];const g=d.current.map(wp),y=u.map(wp),m=g.length;for(let v=0;v<m;v++){const w=g[v];y.indexOf(w)===-1&&!h.has(w)&&h.set(w,void 0)}return o==="wait"&&h.size&&(c=[]),h.forEach((v,w)=>{if(y.indexOf(w)!==-1)return;const S=p.get(w);if(!S)return;const C=g.indexOf(w);let _=v;if(!_){const A=()=>{h.delete(w);const I=Array.from(p.keys()).filter(E=>!y.includes(E));if(I.forEach(E=>p.delete(E)),d.current=u.filter(E=>{const k=wp(E);return k===w||I.includes(k)}),!h.size){if(l.current===!1)return;a(),i&&i()}};_=K.createElement(xN,{key:wp(S),isPresent:!1,onExitComplete:A,custom:e,presenceAffectsLayout:s,mode:o},S),h.set(w,_)}c.splice(C,0,_)}),c=c.map(v=>{const w=v.key;return h.has(w)?v:K.createElement(xN,{key:wp(v),isPresent:!0,presenceAffectsLayout:s,mode:o},v)}),K.createElement(K.Fragment,null,h.size?c:c.map(v=>K.cloneElement(v)))},sv="generated",Dge="pointerdown",Fge="pointerup",BD="pointerleave",Oge="pointerout",xf="pointermove",Bge="touchstart",U4="touchend",zge="touchmove",Gge="touchcancel",Vge="resize",Uge="visibilitychange",Qa="tsParticles - Error";class Xo{constructor(e,t,i){if(this._updateFromAngle=(r,s)=>{this.x=Math.cos(r)*s,this.y=Math.sin(r)*s},!Nl(e)&&e){this.x=e.x,this.y=e.y;const r=e;this.z=r.z?r.z:0}else if(e!==void 0&&t!==void 0)this.x=e,this.y=t,this.z=i??0;else throw new Error(`${Qa} Vector3d not initialized correctly`)}static get origin(){return Xo.create(0,0,0)}get angle(){return Math.atan2(this.y,this.x)}set angle(e){this._updateFromAngle(e,this.length)}get length(){return Math.sqrt(this.getLengthSq())}set length(e){this._updateFromAngle(this.angle,e)}static clone(e){return Xo.create(e.x,e.y,e.z)}static create(e,t,i){return new Xo(e,t,i)}add(e){return Xo.create(this.x+e.x,this.y+e.y,this.z+e.z)}addTo(e){this.x+=e.x,this.y+=e.y,this.z+=e.z}copy(){return Xo.clone(this)}distanceTo(e){return this.sub(e).length}distanceToSq(e){return this.sub(e).getLengthSq()}div(e){return Xo.create(this.x/e,this.y/e,this.z/e)}divTo(e){this.x/=e,this.y/=e,this.z/=e}getLengthSq(){return this.x**2+this.y**2}mult(e){return Xo.create(this.x*e,this.y*e,this.z*e)}multTo(e){this.x*=e,this.y*=e,this.z*=e}normalize(){const e=this.length;e!=0&&this.multTo(1/e)}rotate(e){return Xo.create(this.x*Math.cos(e)-this.y*Math.sin(e),this.x*Math.sin(e)+this.y*Math.cos(e),0)}setTo(e){this.x=e.x,this.y=e.y;const t=e;this.z=t.z?t.z:0}sub(e){return Xo.create(this.x-e.x,this.y-e.y,this.z-e.z)}subFrom(e){this.x-=e.x,this.y-=e.y,this.z-=e.z}}class Xr extends Xo{constructor(e,t){super(e,t,0)}static get origin(){return Xr.create(0,0)}static clone(e){return Xr.create(e.x,e.y)}static create(e,t){return new Xr(e,t)}}let $ge=Math.random;const zD=new Map;function vN(n,e){zD.get(n)||zD.set(n,e)}function UJ(n){return zD.get(n)||(e=>e)}function pi(){return zl($ge(),0,1-1e-16)}function zl(n,e,t){return Math.min(Math.max(n,e),t)}function wN(n,e,t,i){return Math.floor((n*t+e*i)/(t+i))}function To(n){const e=zh(n);let t=fB(n);return e===t&&(t=0),pi()*(e-t)+t}function Vt(n){return Nl(n)?n:To(n)}function fB(n){return Nl(n)?n:n.min}function zh(n){return Nl(n)?n:n.max}function dn(n,e){if(n===e||e===void 0&&Nl(n))return n;const t=fB(n),i=zh(n);return e!==void 0?{min:Math.min(t,e),max:Math.max(i,e)}:dn(t,i)}function vf(n){const e=n.random,{enable:t,minimumValue:i}=ed(e)?{enable:e,minimumValue:0}:e;return Vt(t?dn(n.value,i):n.value)}function js(n,e){const t=n.x-e.x,i=n.y-e.y;return{dx:t,dy:i,distance:Math.sqrt(t**2+i**2)}}function ia(n,e){return js(n,e).distance}function Wge(n,e,t){if(Nl(n))return n*Math.PI/180;switch(n){case"top":return-Math.PI/2;case"top-right":return-Math.PI/4;case"right":return 0;case"bottom-right":return Math.PI/4;case"bottom":return Math.PI/2;case"bottom-left":return 3*Math.PI/4;case"left":return Math.PI;case"top-left":return-3*Math.PI/4;case"inside":return Math.atan2(t.y-e.y,t.x-e.x);case"outside":return Math.atan2(e.y-t.y,e.x-t.x);default:return pi()*Math.PI*2}}function Hge(n){const e=Xr.origin;return e.length=1,e.angle=n,e}function $4(n,e,t,i){return Xr.create(n.x*(t-i)/(t+i)+e.x*2*i/(t+i),n.y)}function Xge(n){var e,t;return{x:((e=n.position)==null?void 0:e.x)??pi()*n.size.width,y:((t=n.position)==null?void 0:t.y)??pi()*n.size.height}}function $J(n){return n?n.endsWith("%")?parseFloat(n)/100:parseFloat(n):1}const Kge={debug:console.debug,error:console.error,info:console.info,log:console.log,verbose:console.log,warning:console.warn};function wf(){return Kge}function W4(n){const e={bounced:!1},{pSide:t,pOtherSide:i,rectSide:r,rectOtherSide:s,velocity:o,factor:a}=n;return i.min<s.min||i.min>s.max||i.max<s.min||i.max>s.max||(t.max>=r.min&&t.max<=(r.max+r.min)/2&&o>0||t.min<=r.max&&t.min>(r.max+r.min)/2&&o<0)&&(e.velocity=o*-a,e.bounced=!0),e}function Zge(n,e){const t=Kr(e,i=>n.matches(i));return ra(t)?t.some(i=>i):t}function Sy(){return typeof window>"u"||!window||typeof window.document>"u"||!window.document}function jge(){return!Sy()&&typeof matchMedia<"u"}function WJ(n){if(jge())return matchMedia(n)}function Yge(n){if(!(Sy()||typeof MutationObserver>"u"))return new MutationObserver(n)}function nr(n,e){return n===e||ra(e)&&e.indexOf(n)>-1}async function Jge(n,e){try{await document.fonts.load(`${e??"400"} 36px '${n??"Verdana"}'`)}catch{}}function Qge(n){return Math.floor(pi()*n.length)}function tE(n,e,t=!0){return n[e!==void 0&&t?e%n.length:Qge(n)]}function mB(n,e,t,i,r){return qge(F1(n,i??0),e,t,r)}function qge(n,e,t,i){let r=!0;return(!i||i==="bottom")&&(r=n.top<e.height+t.x),r&&(!i||i==="left")&&(r=n.right>t.x),r&&(!i||i==="right")&&(r=n.left<e.width+t.y),r&&(!i||i==="top")&&(r=n.bottom>t.y),r}function F1(n,e){return{bottom:n.y+e,left:n.x-e,right:n.x+e,top:n.y-e}}function ks(n,...e){for(const t of e){if(t==null)continue;if(!Gg(t)){n=t;continue}const i=Array.isArray(t);i&&(Gg(n)||!n||!Array.isArray(n))?n=[]:!i&&(Gg(n)||!n||Array.isArray(n))&&(n={});for(const r in t){if(r==="__proto__")continue;const s=t,o=s[r],a=n;a[r]=Gg(o)&&Array.isArray(o)?o.map(l=>ks(a[r],l)):ks(a[r],o)}}return n}function gB(n,e){return!!KJ(e,t=>t.enable&&nr(n,t.mode))}function yB(n,e,t){Kr(e,i=>{const r=i.mode;i.enable&&nr(n,r)&&eye(i,t)})}function eye(n,e){const t=n.selectors;Kr(t,i=>{e(i,n)})}function HJ(n,e){if(!(!e||!n))return KJ(n,t=>Zge(e,t.selectors))}function GD(n){return{position:n.getPosition(),radius:n.getRadius(),mass:n.getMass(),velocity:n.velocity,factor:Xr.create(vf(n.options.bounce.horizontal),vf(n.options.bounce.vertical))}}function XJ(n,e){const{x:t,y:i}=n.velocity.sub(e.velocity),[r,s]=[n.position,e.position],{dx:o,dy:a}=js(s,r);if(t*o+i*a<0)return;const l=-Math.atan2(a,o),u=n.mass,c=e.mass,h=n.velocity.rotate(l),d=e.velocity.rotate(l),p=$4(h,d,u,c),f=$4(d,h,u,c),g=p.rotate(-l),y=f.rotate(-l);n.velocity.x=g.x*n.factor.x,n.velocity.y=g.y*n.factor.y,e.velocity.x=y.x*e.factor.x,e.velocity.y=y.y*e.factor.y}function tye(n,e){const t=n.getPosition(),i=n.getRadius(),r=F1(t,i),s=W4({pSide:{min:r.left,max:r.right},pOtherSide:{min:r.top,max:r.bottom},rectSide:{min:e.left,max:e.right},rectOtherSide:{min:e.top,max:e.bottom},velocity:n.velocity.x,factor:vf(n.options.bounce.horizontal)});s.bounced&&(s.velocity!==void 0&&(n.velocity.x=s.velocity),s.position!==void 0&&(n.position.x=s.position));const o=W4({pSide:{min:r.top,max:r.bottom},pOtherSide:{min:r.left,max:r.right},rectSide:{min:e.top,max:e.bottom},rectOtherSide:{min:e.left,max:e.right},velocity:n.velocity.y,factor:vf(n.options.bounce.vertical)});o.bounced&&(o.velocity!==void 0&&(n.velocity.y=o.velocity),o.position!==void 0&&(n.position.y=o.position))}function Kr(n,e){return ra(n)?n.map((t,i)=>e(t,i)):e(n,0)}function _c(n,e,t){return ra(n)?tE(n,e,t):n}function KJ(n,e){return ra(n)?n.find((t,i)=>e(t,i)):e(n,0)?n:void 0}function ZJ(n,e){const t=n.value,i=n.animation,r={delayTime:Vt(i.delay)*1e3,enable:i.enable,value:Vt(n.value)*e,max:zh(t)*e,min:fB(t)*e,loops:0,maxLoops:Vt(i.count),time:0};if(i.enable){switch(r.decay=1-Vt(i.decay),i.mode){case"increase":r.status="increasing";break;case"decrease":r.status="decreasing";break;case"random":r.status=pi()>=.5?"increasing":"decreasing";break}const s=i.mode==="auto";switch(i.startValue){case"min":r.value=r.min,s&&(r.status="increasing");break;case"max":r.value=r.max,s&&(r.status="decreasing");break;case"random":default:r.value=To(r),s&&(r.status=pi()>=.5?"increasing":"decreasing");break}}return r.initialValue=r.value,r}function nye(n,e){if(!(n.mode==="percent")){const{mode:r,...s}=n;return s}return"x"in n?{x:n.x/100*e.width,y:n.y/100*e.height}:{width:n.width/100*e.width,height:n.height/100*e.height}}function jJ(n,e){return nye(n,e)}function ed(n){return typeof n=="boolean"}function Rl(n){return typeof n=="string"}function Nl(n){return typeof n=="number"}function YJ(n){return typeof n=="function"}function Gg(n){return typeof n=="object"&&n!==null}function ra(n){return Array.isArray(n)}const LM="random",L_="mid",nE=new Map;function H4(n){nE.set(n.key,n)}function SN(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function iye(n){for(const[,s]of nE)if(n.startsWith(s.stringPrefix))return s.parseString(n);const e=/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,t=n.replace(e,(s,o,a,l,u)=>o+o+a+a+l+l+(u!==void 0?u+u:"")),i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i,r=i.exec(t);return r?{a:r[4]!==void 0?parseInt(r[4],16)/255:1,b:parseInt(r[3],16),g:parseInt(r[2],16),r:parseInt(r[1],16)}:void 0}function Ll(n,e,t=!0){if(!n)return;const i=Rl(n)?{value:n}:n;if(Rl(i.value))return JJ(i.value,e,t);if(ra(i.value))return Ll({value:tE(i.value,e,t)});for(const[,r]of nE){const s=r.handleRangeColor(i);if(s)return s}}function JJ(n,e,t=!0){if(!n)return;const i=Rl(n)?{value:n}:n;if(Rl(i.value))return i.value===LM?qJ():rye(i.value);if(ra(i.value))return JJ({value:tE(i.value,e,t)});for(const[,r]of nE){const s=r.handleColor(i);if(s)return s}}function Fv(n,e,t=!0){const i=Ll(n,e,t);return i?QJ(i):void 0}function QJ(n){const e=n.r/255,t=n.g/255,i=n.b/255,r=Math.max(e,t,i),s=Math.min(e,t,i),o={h:0,l:(r+s)/2,s:0};return r!==s&&(o.s=o.l<.5?(r-s)/(r+s):(r-s)/(2-r-s),o.h=e===r?(t-i)/(r-s):o.h=t===r?2+(i-e)/(r-s):4+(e-t)/(r-s)),o.l*=100,o.s*=100,o.h*=60,o.h<0&&(o.h+=360),o.h>=360&&(o.h-=360),o}function rye(n){return iye(n)}function Ty(n){const e={b:0,g:0,r:0},t={h:n.h/360,l:n.l/100,s:n.s/100};if(!t.s)e.r=e.g=e.b=t.l;else{const i=t.l<.5?t.l*(1+t.s):t.l+t.s-t.l*t.s,r=2*t.l-i;e.r=SN(r,i,t.h+1/3),e.g=SN(r,i,t.h),e.b=SN(r,i,t.h-1/3)}return e.r=Math.floor(e.r*255),e.g=Math.floor(e.g*255),e.b=Math.floor(e.b*255),e}function sye(n){const e=Ty(n);return{a:n.a,b:e.b,g:e.g,r:e.r}}function qJ(n){const e=n??0;return{b:Math.floor(To(dn(e,256))),g:Math.floor(To(dn(e,256))),r:Math.floor(To(dn(e,256)))}}function Mc(n,e){return`rgba(${n.r}, ${n.g}, ${n.b}, ${e??1})`}function Ov(n,e){return`hsla(${n.h}, ${n.s}%, ${n.l}%, ${e??1})`}function bB(n,e,t,i){let r=n,s=e;return r.r===void 0&&(r=Ty(n)),s.r===void 0&&(s=Ty(e)),{b:wN(r.b,s.b,t,i),g:wN(r.g,s.g,t,i),r:wN(r.r,s.r,t,i)}}function VD(n,e,t){if(t===LM)return qJ();if(t===L_){const i=n.getFillColor()??n.getStrokeColor(),r=(e==null?void 0:e.getFillColor())??(e==null?void 0:e.getStrokeColor());if(i&&r&&e)return bB(i,r,n.getRadius(),e.getRadius());{const s=i??r;if(s)return Ty(s)}}else return t}function e7(n,e,t){const i=Rl(n)?n:n.value;return i===LM?t?Ll({value:i}):e?LM:L_:i===L_?L_:Ll({value:i})}function X4(n){return n!==void 0?{h:n.h.value,s:n.s.value,l:n.l.value}:void 0}function t7(n,e,t){const i={h:{enable:!1,value:n.h},s:{enable:!1,value:n.s},l:{enable:!1,value:n.l}};return e&&(TN(i.h,e.h,t),TN(i.s,e.s,t),TN(i.l,e.l,t)),i}function TN(n,e,t){n.enable=e.enable,n.enable?(n.velocity=Vt(e.speed)/100*t,n.decay=1-Vt(e.decay),n.status="increasing",n.loops=0,n.maxLoops=Vt(e.count),n.time=0,n.delayTime=Vt(e.delay)*1e3,e.sync||(n.velocity*=pi(),n.value*=pi()),n.initialValue=n.value):n.velocity=0}function ov(n,e,t){n.beginPath(),n.moveTo(e.x,e.y),n.lineTo(t.x,t.y),n.closePath()}function oye(n,e,t,i){n.beginPath(),n.moveTo(e.x,e.y),n.lineTo(t.x,t.y),n.lineTo(i.x,i.y),n.closePath()}function aye(n,e,t){n.fillStyle=t??"rgba(0,0,0,0)",n.fillRect(0,0,e.width,e.height)}function lye(n,e,t,i){t&&(n.globalAlpha=i,n.drawImage(t,0,0,e.width,e.height),n.globalAlpha=1)}function CN(n,e){n.clearRect(0,0,e.width,e.height)}function uye(n){const{container:e,context:t,particle:i,delta:r,colorStyles:s,backgroundMask:o,composite:a,radius:l,opacity:u,shadow:c,transform:h}=n,d=i.getPosition(),p=i.rotation+(i.pathRotation?i.velocity.angle:0),f={sin:Math.sin(p),cos:Math.cos(p)},g={a:f.cos*(h.a??1),b:f.sin*(h.b??1),c:-f.sin*(h.c??1),d:f.cos*(h.d??1)};t.setTransform(g.a,g.b,g.c,g.d,d.x,d.y),t.beginPath(),o&&(t.globalCompositeOperation=a);const y=i.shadowColor;c.enable&&y&&(t.shadowBlur=c.blur,t.shadowColor=Mc(y),t.shadowOffsetX=c.offset.x,t.shadowOffsetY=c.offset.y),s.fill&&(t.fillStyle=s.fill);const m=i.strokeWidth??0;t.lineWidth=m,s.stroke&&(t.strokeStyle=s.stroke),cye(e,t,i,l,u,r),m>0&&t.stroke(),i.close&&t.closePath(),i.fill&&t.fill(),hye(e,t,i,l,u,r),t.globalCompositeOperation="source-over",t.setTransform(1,0,0,1,0,0)}function cye(n,e,t,i,r,s){if(!t.shape)return;const o=n.drawers.get(t.shape);o&&o.draw(e,t,i,r,s,n.retina.pixelRatio)}function hye(n,e,t,i,r,s){if(!t.shape)return;const o=n.drawers.get(t.shape);!o||!o.afterEffect||o.afterEffect(e,t,i,r,s,n.retina.pixelRatio)}function dye(n,e,t){e.draw&&e.draw(n,t)}function pye(n,e,t,i){e.drawParticle&&e.drawParticle(n,t,i)}function fye(n,e,t){return{h:n.h,s:n.s,l:n.l+(e==="darken"?-1:1)*t}}function mye(n,e,t){const i=e[t];i!==void 0&&(n[t]=(n[t]??1)*i)}let gye=class{constructor(e){this.container=e,this._applyPostDrawUpdaters=t=>{for(const i of this._postDrawUpdaters)i.afterDraw&&i.afterDraw(t)},this._applyPreDrawUpdaters=(t,i,r,s,o,a)=>{for(const l of this._preDrawUpdaters){if(l.getColorStyles){const{fill:u,stroke:c}=l.getColorStyles(i,t,r,s);u&&(o.fill=u),c&&(o.stroke=c)}if(l.getTransformValues){const u=l.getTransformValues(i);for(const c in u)mye(a,u,c)}l.beforeDraw&&l.beforeDraw(i)}},this._applyResizePlugins=()=>{for(const t of this._resizePlugins)t.resize&&t.resize()},this._getPluginParticleColors=t=>{let i,r;for(const s of this._colorPlugins)if(!i&&s.particleFillColor&&(i=Fv(s.particleFillColor(t))),!r&&s.particleStrokeColor&&(r=Fv(s.particleStrokeColor(t))),i&&r)break;return[i,r]},this._initCover=()=>{const t=this.container.actualOptions,i=t.backgroundMask.cover,r=i.color,s=Ll(r);if(s){const o={...s,a:i.opacity};this._coverColorStyle=Mc(o,o.a)}},this._initStyle=()=>{const t=this.element,i=this.container.actualOptions;if(t){this._fullScreen?(this._originalStyle=ks({},t.style),this._setFullScreenStyle()):this._resetOriginalStyle();for(const r in i.style){if(!r||!i.style)continue;const s=i.style[r];s&&t.style.setProperty(r,s,"important")}}},this._initTrail=async()=>{const t=this.container.actualOptions,i=t.particles.move.trail,r=i.fill;if(i.enable)if(r.color){const s=Ll(r.color);if(!s)return;const o=t.particles.move.trail;this._trailFill={color:{...s},opacity:1/o.length}}else await new Promise((s,o)=>{if(!r.image)return;const a=document.createElement("img");a.addEventListener("load",()=>{this._trailFill={image:a,opacity:1/i.length},s()}),a.addEventListener("error",l=>{o(l.error)}),a.src=r.image})},this._paintBase=t=>{this.draw(i=>aye(i,this.size,t))},this._paintImage=(t,i)=>{this.draw(r=>lye(r,this.size,t,i))},this._repairStyle=()=>{const t=this.element;t&&(this._safeMutationObserver(i=>i.disconnect()),this._initStyle(),this.initBackground(),this._safeMutationObserver(i=>i.observe(t,{attributes:!0})))},this._resetOriginalStyle=()=>{const t=this.element,i=this._originalStyle;if(!(t&&i))return;const r=t.style;r.position=i.position,r.zIndex=i.zIndex,r.top=i.top,r.left=i.left,r.width=i.width,r.height=i.height},this._safeMutationObserver=t=>{this._mutationObserver&&t(this._mutationObserver)},this._setFullScreenStyle=()=>{const t=this.element;if(!t)return;const i="important",r=t.style;r.setProperty("position","fixed",i),r.setProperty("z-index",this.container.actualOptions.fullScreen.zIndex.toString(10),i),r.setProperty("top","0",i),r.setProperty("left","0",i),r.setProperty("width","100%",i),r.setProperty("height","100%",i)},this.size={height:0,width:0},this._context=null,this._generated=!1,this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}get _fullScreen(){return this.container.actualOptions.fullScreen.enable}clear(){const e=this.container.actualOptions,t=e.particles.move.trail,i=this._trailFill;e.backgroundMask.enable?this.paint():t.enable&&t.length>0&&i?i.color?this._paintBase(Mc(i.color,i.opacity)):i.image&&this._paintImage(i.image,i.opacity):this.draw(r=>{CN(r,this.size)})}destroy(){if(this.stop(),this._generated){const e=this.element;e&&e.remove()}else this._resetOriginalStyle();this._preDrawUpdaters=[],this._postDrawUpdaters=[],this._resizePlugins=[],this._colorPlugins=[]}draw(e){const t=this._context;if(t)return e(t)}drawParticle(e,t){if(e.spawning||e.destroyed)return;const i=e.getRadius();if(i<=0)return;const r=e.getFillColor(),s=e.getStrokeColor()??r;let[o,a]=this._getPluginParticleColors(e);o||(o=r),a||(a=s),!(!o&&!a)&&this.draw(l=>{var w;const u=this.container,c=u.actualOptions,h=e.options.zIndex,d=(1-e.zIndexFactor)**h.opacityRate,p=e.bubble.opacity??((w=e.opacity)==null?void 0:w.value)??1,f=e.strokeOpacity??p,g=p*d,y=f*d,m={},v={fill:o?Ov(o,g):void 0};v.stroke=a?Ov(a,y):v.fill,this._applyPreDrawUpdaters(l,e,i,g,v,m),uye({container:u,context:l,particle:e,delta:t,colorStyles:v,backgroundMask:c.backgroundMask.enable,composite:c.backgroundMask.composite,radius:i*(1-e.zIndexFactor)**h.sizeRate,opacity:g,shadow:e.options.shadow,transform:m}),this._applyPostDrawUpdaters(e)})}drawParticlePlugin(e,t,i){this.draw(r=>pye(r,e,t,i))}drawPlugin(e,t){this.draw(i=>dye(i,e,t))}async init(){this._safeMutationObserver(e=>e.disconnect()),this._mutationObserver=Yge(e=>{for(const t of e)t.type==="attributes"&&t.attributeName==="style"&&this._repairStyle()}),this.resize(),this._initStyle(),this._initCover();try{await this._initTrail()}catch(e){wf().error(e)}this.initBackground(),this._safeMutationObserver(e=>{this.element&&e.observe(this.element,{attributes:!0})}),this.initUpdaters(),this.initPlugins(),this.paint()}initBackground(){const e=this.container.actualOptions,t=e.background,i=this.element;if(!i)return;const r=i.style;if(r){if(t.color){const s=Ll(t.color);r.backgroundColor=s?Mc(s,t.opacity):""}else r.backgroundColor="";r.backgroundImage=t.image||"",r.backgroundPosition=t.position||"",r.backgroundRepeat=t.repeat||"",r.backgroundSize=t.size||""}}initPlugins(){this._resizePlugins=[];for(const[,e]of this.container.plugins)e.resize&&this._resizePlugins.push(e),(e.particleFillColor||e.particleStrokeColor)&&this._colorPlugins.push(e)}initUpdaters(){this._preDrawUpdaters=[],this._postDrawUpdaters=[];for(const e of this.container.particles.updaters)e.afterDraw&&this._postDrawUpdaters.push(e),(e.getColorStyles||e.getTransformValues||e.beforeDraw)&&this._preDrawUpdaters.push(e)}loadCanvas(e){this._generated&&this.element&&this.element.remove(),this._generated=e.dataset&&sv in e.dataset?e.dataset[sv]==="true":this._generated,this.element=e,this.element.ariaHidden="true",this._originalStyle=ks({},this.element.style),this.size.height=e.offsetHeight,this.size.width=e.offsetWidth,this._context=this.element.getContext("2d"),this._safeMutationObserver(t=>{this.element&&t.observe(this.element,{attributes:!0})}),this.container.retina.init(),this.initBackground()}paint(){const e=this.container.actualOptions;this.draw(t=>{e.backgroundMask.enable&&e.backgroundMask.cover?(CN(t,this.size),this._paintBase(this._coverColorStyle)):this._paintBase()})}resize(){if(!this.element)return!1;const e=this.container,t=e.retina.pixelRatio,i=e.canvas.size,r={width:this.element.offsetWidth*t,height:this.element.offsetHeight*t};if(r.height===i.height&&r.width===i.width&&r.height===this.element.height&&r.width===this.element.width)return!1;const s={...i};return this.element.width=i.width=this.element.offsetWidth*t,this.element.height=i.height=this.element.offsetHeight*t,this.container.started&&(this.resizeFactor={width:i.width/s.width,height:i.height/s.height}),!0}stop(){this._safeMutationObserver(e=>e.disconnect()),this._mutationObserver=void 0,this.draw(e=>CN(e,this.size))}async windowResize(){if(!this.element||!this.resize())return;const e=this.container,t=e.updateActualOptions();e.particles.setDensity(),this._applyResizePlugins(),t&&await e.refresh()}};function Ra(n,e,t,i,r){if(i){let s={passive:!0};ed(r)?s.capture=r:r!==void 0&&(s=r),n.addEventListener(e,t,s)}else{const s=r;n.removeEventListener(e,t,s)}}class yye{constructor(e){this.container=e,this._doMouseTouchClick=t=>{const i=this.container,r=i.actualOptions;if(this._canPush){const s=i.interactivity.mouse,o=s.position;if(!o)return;s.clickPosition={...o},s.clickTime=new Date().getTime();const a=r.interactivity.events.onClick;Kr(a.mode,l=>this.container.handleClickMode(l))}t.type==="touchend"&&setTimeout(()=>this._mouseTouchFinish(),500)},this._handleThemeChange=t=>{const i=t,r=this.container,s=r.options,o=s.defaultThemes,a=i.matches?o.dark:o.light,l=s.themes.find(u=>u.name===a);l&&l.default.auto&&r.loadTheme(a)},this._handleVisibilityChange=()=>{const t=this.container,i=t.actualOptions;this._mouseTouchFinish(),i.pauseOnBlur&&(document&&document.hidden?(t.pageHidden=!0,t.pause()):(t.pageHidden=!1,t.getAnimationStatus()?t.play(!0):t.draw(!0)))},this._handleWindowResize=async()=>{this._resizeTimeout&&(clearTimeout(this._resizeTimeout),delete this._resizeTimeout),this._resizeTimeout=setTimeout(async()=>{const t=this.container.canvas;t&&await t.windowResize()},this.container.actualOptions.interactivity.events.resize.delay*1e3)},this._manageInteractivityListeners=(t,i)=>{const r=this._handlers,s=this.container,o=s.actualOptions,a=s.interactivity.element;if(!a)return;const l=a,u=s.canvas.element;u&&(u.style.pointerEvents=l===u?"initial":"none"),(o.interactivity.events.onHover.enable||o.interactivity.events.onClick.enable)&&(Ra(a,xf,r.mouseMove,i),Ra(a,Bge,r.touchStart,i),Ra(a,zge,r.touchMove,i),o.interactivity.events.onClick.enable?(Ra(a,U4,r.touchEndClick,i),Ra(a,Fge,r.mouseUp,i),Ra(a,Dge,r.mouseDown,i)):Ra(a,U4,r.touchEnd,i),Ra(a,t,r.mouseLeave,i),Ra(a,Gge,r.touchCancel,i))},this._manageListeners=t=>{const i=this._handlers,r=this.container,s=r.actualOptions,o=s.interactivity.detectsOn,a=r.canvas.element;let l=BD;o==="window"?(r.interactivity.element=window,l=Oge):o==="parent"&&a?r.interactivity.element=a.parentElement??a.parentNode:r.interactivity.element=a,this._manageMediaMatch(t),this._manageResize(t),this._manageInteractivityListeners(l,t),document&&Ra(document,Uge,i.visibilityChange,t,!1)},this._manageMediaMatch=t=>{const i=this._handlers,r=WJ("(prefers-color-scheme: dark)");if(r){if(r.addEventListener!==void 0){Ra(r,"change",i.themeChange,t);return}r.addListener!==void 0&&(t?r.addListener(i.oldThemeChange):r.removeListener(i.oldThemeChange))}},this._manageResize=t=>{const i=this._handlers,r=this.container;if(!r.actualOptions.interactivity.events.resize)return;if(typeof ResizeObserver>"u"){Ra(window,Vge,i.resize,t);return}const o=r.canvas.element;this._resizeObserver&&!t?(o&&this._resizeObserver.unobserve(o),this._resizeObserver.disconnect(),delete this._resizeObserver):!this._resizeObserver&&t&&o&&(this._resizeObserver=new ResizeObserver(async a=>{a.find(u=>u.target===o)&&await this._handleWindowResize()}),this._resizeObserver.observe(o))},this._mouseDown=()=>{const{interactivity:t}=this.container;if(!t)return;const{mouse:i}=t;i.clicking=!0,i.downPosition=i.position},this._mouseTouchClick=t=>{const i=this.container,r=i.actualOptions,{mouse:s}=i.interactivity;s.inside=!0;let o=!1;const a=s.position;if(!(!a||!r.interactivity.events.onClick.enable)){for(const[,l]of i.plugins)if(l.clickPositionValid&&(o=l.clickPositionValid(a),o))break;o||this._doMouseTouchClick(t),s.clicking=!1}},this._mouseTouchFinish=()=>{const t=this.container.interactivity;if(!t)return;const i=t.mouse;delete i.position,delete i.clickPosition,delete i.downPosition,t.status=BD,i.inside=!1,i.clicking=!1},this._mouseTouchMove=t=>{const i=this.container,r=i.actualOptions,s=i.interactivity,o=i.canvas.element;if(!s||!s.element)return;s.mouse.inside=!0;let a;if(t.type.startsWith("pointer")){this._canPush=!0;const u=t;if(s.element===window){if(o){const c=o.getBoundingClientRect();a={x:u.clientX-c.left,y:u.clientY-c.top}}}else if(r.interactivity.detectsOn==="parent"){const c=u.target,h=u.currentTarget;if(c&&h&&o){const d=c.getBoundingClientRect(),p=h.getBoundingClientRect(),f=o.getBoundingClientRect();a={x:u.offsetX+2*d.left-(p.left+f.left),y:u.offsetY+2*d.top-(p.top+f.top)}}else a={x:u.offsetX??u.clientX,y:u.offsetY??u.clientY}}else u.target===o&&(a={x:u.offsetX??u.clientX,y:u.offsetY??u.clientY})}else if(this._canPush=t.type!=="touchmove",o){const u=t,c=u.touches[u.touches.length-1],h=o.getBoundingClientRect();a={x:c.clientX-(h.left??0),y:c.clientY-(h.top??0)}}const l=i.retina.pixelRatio;a&&(a.x*=l,a.y*=l),s.mouse.position=a,s.status=xf},this._touchEnd=t=>{const i=t,r=Array.from(i.changedTouches);for(const s of r)this._touches.delete(s.identifier);this._mouseTouchFinish()},this._touchEndClick=t=>{const i=t,r=Array.from(i.changedTouches);for(const s of r)this._touches.delete(s.identifier);this._mouseTouchClick(t)},this._touchStart=t=>{const i=t,r=Array.from(i.changedTouches);for(const s of r)this._touches.set(s.identifier,performance.now());this._mouseTouchMove(t)},this._canPush=!0,this._touches=new Map,this._handlers={mouseDown:()=>this._mouseDown(),mouseLeave:()=>this._mouseTouchFinish(),mouseMove:t=>this._mouseTouchMove(t),mouseUp:t=>this._mouseTouchClick(t),touchStart:t=>this._touchStart(t),touchMove:t=>this._mouseTouchMove(t),touchEnd:t=>this._touchEnd(t),touchCancel:t=>this._touchEnd(t),touchEndClick:t=>this._touchEndClick(t),visibilityChange:()=>this._handleVisibilityChange(),themeChange:t=>this._handleThemeChange(t),oldThemeChange:t=>this._handleThemeChange(t),resize:()=>{this._handleWindowResize()}}}addListeners(){this._manageListeners(!0)}removeListeners(){this._manageListeners(!1)}}class hs{constructor(){this.value=""}static create(e,t){const i=new hs;return i.load(e),t!==void 0&&(Rl(t)||ra(t)?i.load({value:t}):i.load(t)),i}load(e){(e==null?void 0:e.value)!==void 0&&(this.value=e.value)}}let bye=class{constructor(){this.color=new hs,this.color.value="",this.image="",this.position="",this.repeat="",this.size="",this.opacity=1}load(e){e&&(e.color!==void 0&&(this.color=hs.create(this.color,e.color)),e.image!==void 0&&(this.image=e.image),e.position!==void 0&&(this.position=e.position),e.repeat!==void 0&&(this.repeat=e.repeat),e.size!==void 0&&(this.size=e.size),e.opacity!==void 0&&(this.opacity=e.opacity))}};class xye{constructor(){this.color=new hs,this.color.value="#fff",this.opacity=1}load(e){e&&(e.color!==void 0&&(this.color=hs.create(this.color,e.color)),e.opacity!==void 0&&(this.opacity=e.opacity))}}class vye{constructor(){this.composite="destination-out",this.cover=new xye,this.enable=!1}load(e){if(e){if(e.composite!==void 0&&(this.composite=e.composite),e.cover!==void 0){const t=e.cover,i=Rl(e.cover)?{color:e.cover}:e.cover;this.cover.load(t.color!==void 0?t:{color:i})}e.enable!==void 0&&(this.enable=e.enable)}}}class wye{constructor(){this.enable=!0,this.zIndex=0}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.zIndex!==void 0&&(this.zIndex=e.zIndex))}}class Sye{constructor(){this.enable=!1,this.mode=[]}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.mode!==void 0&&(this.mode=e.mode))}}class K4{constructor(){this.selectors=[],this.enable=!1,this.mode=[],this.type="circle"}get el(){return this.elementId}set el(e){this.elementId=e}get elementId(){return this.ids}set elementId(e){this.ids=e}get ids(){return Kr(this.selectors,e=>e.replace("#",""))}set ids(e){this.selectors=Kr(e,t=>`#${t}`)}load(e){if(!e)return;const t=e.ids??e.elementId??e.el;t!==void 0&&(this.ids=t),e.selectors!==void 0&&(this.selectors=e.selectors),e.enable!==void 0&&(this.enable=e.enable),e.mode!==void 0&&(this.mode=e.mode),e.type!==void 0&&(this.type=e.type)}}class Tye{constructor(){this.enable=!1,this.force=2,this.smooth=10}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.force!==void 0&&(this.force=e.force),e.smooth!==void 0&&(this.smooth=e.smooth))}}class Cye{constructor(){this.enable=!1,this.mode=[],this.parallax=new Tye}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.mode!==void 0&&(this.mode=e.mode),this.parallax.load(e.parallax))}}class _ye{constructor(){this.delay=.5,this.enable=!0}load(e){e!==void 0&&(e.delay!==void 0&&(this.delay=e.delay),e.enable!==void 0&&(this.enable=e.enable))}}class Mye{constructor(){this.onClick=new Sye,this.onDiv=new K4,this.onHover=new Cye,this.resize=new _ye}get onclick(){return this.onClick}set onclick(e){this.onClick=e}get ondiv(){return this.onDiv}set ondiv(e){this.onDiv=e}get onhover(){return this.onHover}set onhover(e){this.onHover=e}load(e){if(!e)return;this.onClick.load(e.onClick??e.onclick);const t=e.onDiv??e.ondiv;t!==void 0&&(this.onDiv=Kr(t,i=>{const r=new K4;return r.load(i),r})),this.onHover.load(e.onHover??e.onhover),ed(e.resize)?this.resize.enable=e.resize:this.resize.load(e.resize)}}class Aye{constructor(e,t){this._engine=e,this._container=t}load(e){if(!e||!this._container)return;const t=this._engine.plugins.interactors.get(this._container);if(t)for(const i of t)i.loadModeOptions&&i.loadModeOptions(this,e)}}class n7{constructor(e,t){this.detectsOn="window",this.events=new Mye,this.modes=new Aye(e,t)}get detect_on(){return this.detectsOn}set detect_on(e){this.detectsOn=e}load(e){if(!e)return;const t=e.detectsOn??e.detect_on;t!==void 0&&(this.detectsOn=t),this.events.load(e.events),this.modes.load(e.modes)}}class Eye{load(e){e&&(e.position&&(this.position={x:e.position.x??50,y:e.position.y??50,mode:e.position.mode??"percent"}),e.options&&(this.options=ks({},e.options)))}}class Iye{constructor(){this.maxWidth=1/0,this.options={},this.mode="canvas"}load(e){e&&(e.maxWidth!==void 0&&(this.maxWidth=e.maxWidth),e.mode!==void 0&&(e.mode==="screen"?this.mode="screen":this.mode="canvas"),e.options!==void 0&&(this.options=ks({},e.options)))}}class kye{constructor(){this.auto=!1,this.mode="any",this.value=!1}load(e){e&&(e.auto!==void 0&&(this.auto=e.auto),e.mode!==void 0&&(this.mode=e.mode),e.value!==void 0&&(this.value=e.value))}}class Rye{constructor(){this.name="",this.default=new kye}load(e){e&&(e.name!==void 0&&(this.name=e.name),this.default.load(e.default),e.options!==void 0&&(this.options=ks({},e.options)))}}class _N{constructor(){this.count=0,this.enable=!1,this.offset=0,this.speed=1,this.delay=0,this.decay=0,this.sync=!0}load(e){e&&(e.count!==void 0&&(this.count=dn(e.count)),e.enable!==void 0&&(this.enable=e.enable),e.offset!==void 0&&(this.offset=dn(e.offset)),e.speed!==void 0&&(this.speed=dn(e.speed)),e.decay!==void 0&&(this.decay=dn(e.decay)),e.delay!==void 0&&(this.delay=dn(e.delay)),e.sync!==void 0&&(this.sync=e.sync))}}class Nye{constructor(){this.h=new _N,this.s=new _N,this.l=new _N}load(e){e&&(this.h.load(e.h),this.s.load(e.s),this.l.load(e.l))}}class Bv extends hs{constructor(){super(),this.animation=new Nye}static create(e,t){const i=new Bv;return i.load(e),t!==void 0&&(Rl(t)||ra(t)?i.load({value:t}):i.load(t)),i}load(e){if(super.load(e),!e)return;const t=e.animation;t!==void 0&&(t.enable!==void 0?this.animation.h.load(t):this.animation.load(e.animation))}}class Lye{constructor(){this.speed=2}load(e){e&&e.speed!==void 0&&(this.speed=e.speed)}}class Pye{constructor(){this.enable=!0,this.retries=0}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.retries!==void 0&&(this.retries=e.retries))}}class Dye{constructor(){this.count=0,this.enable=!1,this.speed=1,this.decay=0,this.delay=0,this.sync=!1}load(e){e&&(e.count!==void 0&&(this.count=dn(e.count)),e.enable!==void 0&&(this.enable=e.enable),e.speed!==void 0&&(this.speed=dn(e.speed)),e.decay!==void 0&&(this.decay=dn(e.decay)),e.delay!==void 0&&(this.delay=dn(e.delay)),e.sync!==void 0&&(this.sync=e.sync))}}class i7 extends Dye{constructor(){super(),this.mode="auto",this.startValue="random"}load(e){super.load(e),e&&(e.minimumValue!==void 0&&(this.minimumValue=e.minimumValue),e.mode!==void 0&&(this.mode=e.mode),e.startValue!==void 0&&(this.startValue=e.startValue))}}class Fye{constructor(){this.enable=!1,this.minimumValue=0}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.minimumValue!==void 0&&(this.minimumValue=e.minimumValue))}}class Rd{constructor(){this.random=new Fye,this.value=0}load(e){e&&(ed(e.random)?this.random.enable=e.random:this.random.load(e.random),e.value!==void 0&&(this.value=dn(e.value,this.random.enable?this.random.minimumValue:void 0)))}}class Z4 extends Rd{constructor(){super(),this.random.minimumValue=.1,this.value=1}}class r7{constructor(){this.horizontal=new Z4,this.vertical=new Z4}load(e){e&&(this.horizontal.load(e.horizontal),this.vertical.load(e.vertical))}}class Oye{constructor(){this.absorb=new Lye,this.bounce=new r7,this.enable=!1,this.maxSpeed=50,this.mode="bounce",this.overlap=new Pye}load(e){e&&(this.absorb.load(e.absorb),this.bounce.load(e.bounce),e.enable!==void 0&&(this.enable=e.enable),e.maxSpeed!==void 0&&(this.maxSpeed=dn(e.maxSpeed)),e.mode!==void 0&&(this.mode=e.mode),this.overlap.load(e.overlap))}}class Bye{constructor(){this.offset=0,this.value=90}load(e){e&&(e.offset!==void 0&&(this.offset=dn(e.offset)),e.value!==void 0&&(this.value=dn(e.value)))}}class zye{constructor(){this.distance=200,this.enable=!1,this.rotate={x:3e3,y:3e3}}get rotateX(){return this.rotate.x}set rotateX(e){this.rotate.x=e}get rotateY(){return this.rotate.y}set rotateY(e){this.rotate.y=e}load(e){var r,s;if(!e)return;e.distance!==void 0&&(this.distance=dn(e.distance)),e.enable!==void 0&&(this.enable=e.enable);const t=((r=e.rotate)==null?void 0:r.x)??e.rotateX;t!==void 0&&(this.rotate.x=t);const i=((s=e.rotate)==null?void 0:s.y)??e.rotateY;i!==void 0&&(this.rotate.y=i)}}class Gye{constructor(){this.x=50,this.y=50,this.mode="percent",this.radius=0}load(e){e&&(e.x!==void 0&&(this.x=e.x),e.y!==void 0&&(this.y=e.y),e.mode!==void 0&&(this.mode=e.mode),e.radius!==void 0&&(this.radius=e.radius))}}class Vye{constructor(){this.acceleration=9.81,this.enable=!1,this.inverse=!1,this.maxSpeed=50}load(e){e&&(e.acceleration!==void 0&&(this.acceleration=dn(e.acceleration)),e.enable!==void 0&&(this.enable=e.enable),e.inverse!==void 0&&(this.inverse=e.inverse),e.maxSpeed!==void 0&&(this.maxSpeed=dn(e.maxSpeed)))}}class Uye{constructor(){this.clamp=!0,this.delay=new Rd,this.enable=!1,this.options={}}load(e){e&&(e.clamp!==void 0&&(this.clamp=e.clamp),this.delay.load(e.delay),e.enable!==void 0&&(this.enable=e.enable),this.generator=e.generator,e.options&&(this.options=ks(this.options,e.options)))}}class $ye{load(e){e&&(e.color!==void 0&&(this.color=hs.create(this.color,e.color)),e.image!==void 0&&(this.image=e.image))}}class Wye{constructor(){this.enable=!1,this.length=10,this.fill=new $ye}get fillColor(){return this.fill.color}set fillColor(e){this.fill.load({color:e})}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),(e.fill!==void 0||e.fillColor!==void 0)&&this.fill.load(e.fill||{color:e.fillColor}),e.length!==void 0&&(this.length=e.length))}}class Hye{constructor(){this.default="out"}load(e){e&&(e.default!==void 0&&(this.default=e.default),this.bottom=e.bottom??e.default,this.left=e.left??e.default,this.right=e.right??e.default,this.top=e.top??e.default)}}class Xye{constructor(){this.acceleration=0,this.enable=!1}load(e){e&&(e.acceleration!==void 0&&(this.acceleration=dn(e.acceleration)),e.enable!==void 0&&(this.enable=e.enable),e.position&&(this.position=ks({},e.position)))}}class Kye{constructor(){this.angle=new Bye,this.attract=new zye,this.center=new Gye,this.decay=0,this.distance={},this.direction="none",this.drift=0,this.enable=!1,this.gravity=new Vye,this.path=new Uye,this.outModes=new Hye,this.random=!1,this.size=!1,this.speed=2,this.spin=new Xye,this.straight=!1,this.trail=new Wye,this.vibrate=!1,this.warp=!1}get bounce(){return this.collisions}set bounce(e){this.collisions=e}get collisions(){return!1}set collisions(e){}get noise(){return this.path}set noise(e){this.path=e}get outMode(){return this.outModes.default}set outMode(e){this.outModes.default=e}get out_mode(){return this.outMode}set out_mode(e){this.outMode=e}load(e){if(!e)return;this.angle.load(Nl(e.angle)?{value:e.angle}:e.angle),this.attract.load(e.attract),this.center.load(e.center),e.decay!==void 0&&(this.decay=dn(e.decay)),e.direction!==void 0&&(this.direction=e.direction),e.distance!==void 0&&(this.distance=Nl(e.distance)?{horizontal:e.distance,vertical:e.distance}:{...e.distance}),e.drift!==void 0&&(this.drift=dn(e.drift)),e.enable!==void 0&&(this.enable=e.enable),this.gravity.load(e.gravity);const t=e.outModes??e.outMode??e.out_mode;t!==void 0&&(Gg(t)?this.outModes.load(t):this.outModes.load({default:t})),this.path.load(e.path??e.noise),e.random!==void 0&&(this.random=e.random),e.size!==void 0&&(this.size=e.size),e.speed!==void 0&&(this.speed=dn(e.speed)),this.spin.load(e.spin),e.straight!==void 0&&(this.straight=e.straight),this.trail.load(e.trail),e.vibrate!==void 0&&(this.vibrate=e.vibrate),e.warp!==void 0&&(this.warp=e.warp)}}class Zye extends i7{constructor(){super(),this.destroy="none",this.speed=2}get opacity_min(){return this.minimumValue}set opacity_min(e){this.minimumValue=e}load(e){(e==null?void 0:e.opacity_min)!==void 0&&e.minimumValue===void 0&&(e.minimumValue=e.opacity_min),super.load(e),e&&e.destroy!==void 0&&(this.destroy=e.destroy)}}class jye extends Rd{constructor(){super(),this.animation=new Zye,this.random.minimumValue=.1,this.value=1}get anim(){return this.animation}set anim(e){this.animation=e}load(e){if(!e)return;super.load(e);const t=e.animation??e.anim;t!==void 0&&(this.animation.load(t),this.value=dn(this.value,this.animation.enable?this.animation.minimumValue:void 0))}}class Yye{constructor(){this.enable=!1,this.width=1920,this.height=1080}get area(){return this.width}set area(e){this.width=e}get factor(){return this.height}set factor(e){this.height=e}get value_area(){return this.area}set value_area(e){this.area=e}load(e){if(!e)return;e.enable!==void 0&&(this.enable=e.enable);const t=e.width??e.area??e.value_area;t!==void 0&&(this.width=t);const i=e.height??e.factor;i!==void 0&&(this.height=i)}}class Jye{constructor(){this.density=new Yye,this.limit=0,this.value=0}get max(){return this.limit}set max(e){this.limit=e}load(e){if(!e)return;this.density.load(e.density);const t=e.limit??e.max;t!==void 0&&(this.limit=t),e.value!==void 0&&(this.value=e.value)}}class Qye{constructor(){this.blur=0,this.color=new hs,this.enable=!1,this.offset={x:0,y:0},this.color.value="#000"}load(e){e&&(e.blur!==void 0&&(this.blur=e.blur),this.color=hs.create(this.color,e.color),e.enable!==void 0&&(this.enable=e.enable),e.offset!==void 0&&(e.offset.x!==void 0&&(this.offset.x=e.offset.x),e.offset.y!==void 0&&(this.offset.y=e.offset.y)))}}const MN="character",AN="char",EN="image",IN="images",kN="polygon",RN="star";let qye=class{constructor(){this.loadShape=(e,t,i,r)=>{if(!e)return;const s=ra(e),o=s?[]:{},a=s!==ra(this.options[t]),l=s!==ra(this.options[i]);a&&(this.options[t]=o),l&&r&&(this.options[i]=o),this.options[t]=ks(this.options[t]??o,e),(!this.options[i]||r)&&(this.options[i]=ks(this.options[i]??o,e))},this.close=!0,this.fill=!0,this.options={},this.type="circle"}get character(){return this.options[MN]??this.options[AN]}set character(e){this.options[AN]=this.options[MN]=e}get custom(){return this.options}set custom(e){this.options=e}get image(){return this.options[EN]??this.options[IN]}set image(e){this.options[IN]=this.options[EN]=e}get images(){return this.image}set images(e){this.image=e}get polygon(){return this.options[kN]??this.options[RN]}set polygon(e){this.options[RN]=this.options[kN]=e}get stroke(){return[]}set stroke(e){}load(e){if(!e)return;const t=e.options??e.custom;if(t!==void 0)for(const i in t){const r=t[i];r&&(this.options[i]=ks(this.options[i]??{},r))}this.loadShape(e.character,MN,AN,!0),this.loadShape(e.polygon,kN,RN,!1),this.loadShape(e.image??e.images,EN,IN,!0),e.close!==void 0&&(this.close=e.close),e.fill!==void 0&&(this.fill=e.fill),e.type!==void 0&&(this.type=e.type)}};class e0e extends i7{constructor(){super(),this.destroy="none",this.speed=5}get size_min(){return this.minimumValue}set size_min(e){this.minimumValue=e}load(e){(e==null?void 0:e.size_min)!==void 0&&e.minimumValue===void 0&&(e.minimumValue=e.size_min),super.load(e),e&&e.destroy!==void 0&&(this.destroy=e.destroy)}}class t0e extends Rd{constructor(){super(),this.animation=new e0e,this.random.minimumValue=1,this.value=3}get anim(){return this.animation}set anim(e){this.animation=e}load(e){if(super.load(e),!e)return;const t=e.animation??e.anim;t!==void 0&&(this.animation.load(t),this.value=dn(this.value,this.animation.enable?this.animation.minimumValue:void 0))}}class j4{constructor(){this.width=0}load(e){e&&(e.color!==void 0&&(this.color=Bv.create(this.color,e.color)),e.width!==void 0&&(this.width=dn(e.width)),e.opacity!==void 0&&(this.opacity=dn(e.opacity)))}}class n0e extends Rd{constructor(){super(),this.opacityRate=1,this.sizeRate=1,this.velocityRate=1}load(e){super.load(e),e&&(e.opacityRate!==void 0&&(this.opacityRate=e.opacityRate),e.sizeRate!==void 0&&(this.sizeRate=e.sizeRate),e.velocityRate!==void 0&&(this.velocityRate=e.velocityRate))}}class i0e{constructor(e,t){this._engine=e,this._container=t,this.bounce=new r7,this.collisions=new Oye,this.color=new Bv,this.color.value="#fff",this.groups={},this.move=new Kye,this.number=new Jye,this.opacity=new jye,this.reduceDuplicates=!1,this.shadow=new Qye,this.shape=new qye,this.size=new t0e,this.stroke=new j4,this.zIndex=new n0e}load(e){var r,s,o;if(!e)return;if(this.bounce.load(e.bounce),this.color.load(Bv.create(this.color,e.color)),e.groups!==void 0)for(const a in e.groups){const l=e.groups[a];l!==void 0&&(this.groups[a]=ks(this.groups[a]??{},l))}this.move.load(e.move),this.number.load(e.number),this.opacity.load(e.opacity),e.reduceDuplicates!==void 0&&(this.reduceDuplicates=e.reduceDuplicates),this.shape.load(e.shape),this.size.load(e.size),this.shadow.load(e.shadow),this.zIndex.load(e.zIndex);const t=((r=e.move)==null?void 0:r.collisions)??((s=e.move)==null?void 0:s.bounce);t!==void 0&&(this.collisions.enable=t),this.collisions.load(e.collisions),e.interactivity!==void 0&&(this.interactivity=ks({},e.interactivity));const i=e.stroke??((o=e.shape)==null?void 0:o.stroke);if(i&&(this.stroke=Kr(i,a=>{const l=new j4;return l.load(a),l})),this._container){const a=this._engine.plugins.updaters.get(this._container);if(a)for(const u of a)u.loadOptions&&u.loadOptions(this,e);const l=this._engine.plugins.interactors.get(this._container);if(l)for(const u of l)u.loadParticlesOptions&&u.loadParticlesOptions(this,e)}}}function s7(n,...e){for(const t of e)n.load(t)}function o7(n,e,...t){const i=new i0e(n,e);return s7(i,...t),i}class r0e{constructor(e,t){this._findDefaultTheme=i=>this.themes.find(r=>r.default.value&&r.default.mode===i)??this.themes.find(r=>r.default.value&&r.default.mode==="any"),this._importPreset=i=>{this.load(this._engine.plugins.getPreset(i))},this._engine=e,this._container=t,this.autoPlay=!0,this.background=new bye,this.backgroundMask=new vye,this.defaultThemes={},this.delay=0,this.fullScreen=new wye,this.detectRetina=!0,this.duration=0,this.fpsLimit=120,this.interactivity=new n7(e,t),this.manualParticles=[],this.particles=o7(this._engine,this._container),this.pauseOnBlur=!0,this.pauseOnOutsideViewport=!0,this.responsive=[],this.smooth=!1,this.style={},this.themes=[],this.zLayers=100}get backgroundMode(){return this.fullScreen}set backgroundMode(e){this.fullScreen.load(e)}get fps_limit(){return this.fpsLimit}set fps_limit(e){this.fpsLimit=e}get retina_detect(){return this.detectRetina}set retina_detect(e){this.detectRetina=e}load(e){var o,a;if(!e)return;e.preset!==void 0&&Kr(e.preset,l=>this._importPreset(l)),e.autoPlay!==void 0&&(this.autoPlay=e.autoPlay),e.delay!==void 0&&(this.delay=dn(e.delay));const t=e.detectRetina??e.retina_detect;t!==void 0&&(this.detectRetina=t),e.duration!==void 0&&(this.duration=dn(e.duration));const i=e.fpsLimit??e.fps_limit;i!==void 0&&(this.fpsLimit=i),e.pauseOnBlur!==void 0&&(this.pauseOnBlur=e.pauseOnBlur),e.pauseOnOutsideViewport!==void 0&&(this.pauseOnOutsideViewport=e.pauseOnOutsideViewport),e.zLayers!==void 0&&(this.zLayers=e.zLayers),this.background.load(e.background);const r=e.fullScreen??e.backgroundMode;ed(r)?this.fullScreen.enable=r:this.fullScreen.load(r),this.backgroundMask.load(e.backgroundMask),this.interactivity.load(e.interactivity),e.manualParticles&&(this.manualParticles=e.manualParticles.map(l=>{const u=new Eye;return u.load(l),u})),this.particles.load(e.particles),this.style=ks(this.style,e.style),this._engine.plugins.loadOptions(this,e),e.smooth!==void 0&&(this.smooth=e.smooth);const s=this._engine.plugins.interactors.get(this._container);if(s)for(const l of s)l.loadOptions&&l.loadOptions(this,e);if(e.responsive!==void 0)for(const l of e.responsive){const u=new Iye;u.load(l),this.responsive.push(u)}if(this.responsive.sort((l,u)=>l.maxWidth-u.maxWidth),e.themes!==void 0)for(const l of e.themes){const u=this.themes.find(c=>c.name===l.name);if(u)u.load(l);else{const c=new Rye;c.load(l),this.themes.push(c)}}this.defaultThemes.dark=(o=this._findDefaultTheme("dark"))==null?void 0:o.name,this.defaultThemes.light=(a=this._findDefaultTheme("light"))==null?void 0:a.name}setResponsive(e,t,i){this.load(i);const r=this.responsive.find(s=>s.mode==="screen"&&screen?s.maxWidth>screen.availWidth:s.maxWidth*t>e);return this.load(r==null?void 0:r.options),r==null?void 0:r.maxWidth}setTheme(e){if(e){const t=this.themes.find(i=>i.name===e);t&&this.load(t.options)}else{const t=WJ("(prefers-color-scheme: dark)"),i=t&&t.matches,r=this._findDefaultTheme(i?"dark":"light");r&&this.load(r.options)}}}class s0e{constructor(e,t){this.container=t,this._engine=e,this._interactors=e.plugins.getInteractors(this.container,!0),this._externalInteractors=[],this._particleInteractors=[]}async externalInteract(e){for(const t of this._externalInteractors)t.isEnabled()&&await t.interact(e)}handleClickMode(e){for(const t of this._externalInteractors)t.handleClickMode&&t.handleClickMode(e)}init(){this._externalInteractors=[],this._particleInteractors=[];for(const e of this._interactors){switch(e.type){case"external":this._externalInteractors.push(e);break;case"particles":this._particleInteractors.push(e);break}e.init()}}async particlesInteract(e,t){for(const i of this._externalInteractors)i.clear(e,t);for(const i of this._particleInteractors)i.isEnabled(e)&&await i.interact(e,t)}async reset(e){for(const t of this._externalInteractors)t.isEnabled()&&t.reset(e);for(const t of this._particleInteractors)t.isEnabled(e)&&t.reset(e)}}const Y4=n=>{if(!nr(n.outMode,n.checkModes))return;const e=n.radius*2;n.coord>n.maxCoord-e?n.setCb(-n.radius):n.coord<e&&n.setCb(n.radius)};class o0e{constructor(e,t,i,r,s,o){this.container=i,this._calcPosition=(a,l,u,c=0)=>{for(const[,v]of a.plugins){const w=v.particlePosition!==void 0?v.particlePosition(l,this):void 0;if(w)return Xo.create(w.x,w.y,u)}const h=a.canvas.size,d=Xge({size:h,position:l}),p=Xo.create(d.x,d.y,u),f=this.getRadius(),g=this.options.move.outModes,y=v=>{Y4({outMode:v,checkModes:["bounce","bounce-horizontal"],coord:p.x,maxCoord:a.canvas.size.width,setCb:w=>p.x+=w,radius:f})},m=v=>{Y4({outMode:v,checkModes:["bounce","bounce-vertical"],coord:p.y,maxCoord:a.canvas.size.height,setCb:w=>p.y+=w,radius:f})};return y(g.left??g.default),y(g.right??g.default),m(g.top??g.default),m(g.bottom??g.default),this._checkOverlap(p,c)?this._calcPosition(a,void 0,u,c+1):p},this._calculateVelocity=()=>{const a=Hge(this.direction),l=a.copy(),u=this.options.move;if(u.direction==="inside"||u.direction==="outside")return l;const c=Math.PI/180*Vt(u.angle.value),h=Math.PI/180*Vt(u.angle.offset),d={left:h-c/2,right:h+c/2};return u.straight||(l.angle+=To(dn(d.left,d.right))),u.random&&typeof u.speed=="number"&&(l.length*=pi()),l},this._checkOverlap=(a,l=0)=>{const u=this.options.collisions,c=this.getRadius();if(!u.enable)return!1;const h=u.overlap;if(h.enable)return!1;const d=h.retries;if(d>=0&&l>d)throw new Error(`${Qa} particle is overlapping and can't be placed`);return!!this.container.particles.find(p=>ia(a,p.position)<c+p.getRadius())},this._getRollColor=a=>{if(!a||!this.roll||!this.backColor&&!this.roll.alter)return a;const l=this.roll.horizontal&&this.roll.vertical?2:1,u=this.roll.horizontal?Math.PI/2:0;return Math.floor(((this.roll.angle??0)+u)/(Math.PI/l))%2?this.backColor?this.backColor:this.roll.alter?fye(a,this.roll.alter.type,this.roll.alter.value):a:a},this._initPosition=a=>{const l=this.container,u=Vt(this.options.zIndex.value);this.position=this._calcPosition(l,a,zl(u,0,l.zLayers)),this.initialPosition=this.position.copy();const c=l.canvas.size;switch(this.moveCenter={...jJ(this.options.move.center,c),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=Wge(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside";break}this.offset=Xr.origin},this._loadShapeData=(a,l)=>{const u=a.options[this.shape];if(u)return ks({close:a.close,fill:a.fill},_c(u,this.id,l))},this._engine=e,this.init(t,r,s,o)}destroy(e){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const t=this.container,i=this.pathGenerator;for(const[,r]of t.plugins)r.particleDestroyed&&r.particleDestroyed(this,e);for(const r of t.particles.updaters)r.particleDestroyed&&r.particleDestroyed(this,e);i&&i.reset(this)}draw(e){const t=this.container;for(const[,i]of t.plugins)t.canvas.drawParticlePlugin(i,this,e);t.canvas.drawParticle(this,e)}getFillColor(){return this._getRollColor(this.bubble.color??X4(this.color))}getMass(){return this.getRadius()**2*Math.PI/2}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??X4(this.strokeColor))}init(e,t,i,r){const s=this.container,o=this._engine;this.id=e,this.group=r,this.fill=!0,this.pathRotation=!1,this.close=!0,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const a=s.retina.pixelRatio,l=s.actualOptions,u=o7(this._engine,s,l.particles),c=u.shape.type,{reduceDuplicates:h}=u;this.shape=_c(c,this.id,h);const d=u.shape;if(i&&i.shape&&i.shape.type){const w=i.shape.type,S=_c(w,this.id,h);S&&(this.shape=S,d.load(i.shape))}this.shapeData=this._loadShapeData(d,h),u.load(i);const p=this.shapeData;p&&u.load(p.particles);const f=new n7(o,s);f.load(s.actualOptions.interactivity),f.load(u.interactivity),this.interactivity=f,this.fill=(p==null?void 0:p.fill)??u.shape.fill,this.close=(p==null?void 0:p.close)??u.shape.close,this.options=u;const g=this.options.move.path;this.pathDelay=vf(g.delay)*1e3,g.generator&&(this.pathGenerator=this._engine.plugins.getPathGenerator(g.generator),this.pathGenerator&&s.addPath(g.generator,this.pathGenerator)&&this.pathGenerator.init(s)),s.retina.initParticle(this),this.size=ZJ(this.options.size,a),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(t),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy(),this.moveDecay=1-Vt(this.options.move.decay);const y=s.particles;y.needsSort=y.needsSort||y.lastZIndex<this.position.z,y.lastZIndex=this.position.z,this.zIndexFactor=this.position.z/s.zLayers,this.sides=24;let m=s.drawers.get(this.shape);m||(m=this._engine.plugins.getShapeDrawer(this.shape),m&&s.drawers.set(this.shape,m)),m&&m.loadShape&&m.loadShape(this);const v=m==null?void 0:m.getSidesCount;v&&(this.sides=v(this)),this.spawning=!1,this.shadowColor=Ll(this.options.shadow.color);for(const w of s.particles.updaters)w.init(this);for(const w of s.particles.movers)w.init&&w.init(this);m&&m.particleInit&&m.particleInit(s,this);for(const[,w]of s.plugins)w.particleCreated&&w.particleCreated(this)}isInsideCanvas(){const e=this.getRadius(),t=this.container.canvas.size,i=this.position;return i.x>=-e&&i.y>=-e&&i.y<=t.height+e&&i.x<=t.width+e}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const e of this.container.particles.updaters)e.reset&&e.reset(this)}}class a0e{constructor(e,t){this.position=e,this.particle=t}}class a7{constructor(e,t){this.position={x:e,y:t}}}class Gl extends a7{constructor(e,t,i,r){super(e,t),this.size={height:r,width:i}}contains(e){const t=this.size.width,i=this.size.height,r=this.position;return e.x>=r.x&&e.x<=r.x+t&&e.y>=r.y&&e.y<=r.y+i}intersects(e){e instanceof Rs&&e.intersects(this);const t=this.size.width,i=this.size.height,r=this.position,s=e.position,o=e instanceof Gl?e.size:{width:0,height:0},a=o.width,l=o.height;return s.x<r.x+t&&s.x+a>r.x&&s.y<r.y+i&&s.y+l>r.y}}class Rs extends a7{constructor(e,t,i){super(e,t),this.radius=i}contains(e){return ia(e,this.position)<=this.radius}intersects(e){const t=this.position,i=e.position,r={x:Math.abs(i.x-t.x),y:Math.abs(i.y-t.y)},s=this.radius;if(e instanceof Rs){const o=s+e.radius,a=Math.sqrt(r.x**2+r.y**2);return o>a}else if(e instanceof Gl){const{width:o,height:a}=e.size;return Math.pow(r.x-o,2)+Math.pow(r.y-a,2)<=s**2||r.x<=s+o&&r.y<=s+a||r.x<=o||r.y<=a}return!1}}class PM{constructor(e,t){this.rectangle=e,this.capacity=t,this._subdivide=()=>{const{x:i,y:r}=this.rectangle.position,{width:s,height:o}=this.rectangle.size,{capacity:a}=this;for(let l=0;l<4;l++)this._subs.push(new PM(new Gl(i+s/2*(l%2),r+o/2*(Math.round(l/2)-l%2),s/2,o/2),a));this._divided=!0},this._points=[],this._divided=!1,this._subs=[]}insert(e){return this.rectangle.contains(e.position)?this._points.length<this.capacity?(this._points.push(e),!0):(this._divided||this._subdivide(),this._subs.some(t=>t.insert(e))):!1}query(e,t,i){const r=i||[];if(!e.intersects(this.rectangle))return[];for(const s of this._points)!e.contains(s.position)&&ia(e.position,s.position)>s.particle.getRadius()&&(!t||t(s.particle))||r.push(s.particle);if(this._divided)for(const s of this._subs)s.query(e,t,r);return r}queryCircle(e,t,i){return this.query(new Rs(e.x,e.y,t),i)}queryRectangle(e,t,i){return this.query(new Gl(e.x,e.y,t.width,t.height),i)}}const J4=4,Q4=n=>new Gl(-n.width/4,-n.height/4,n.width*3/2,n.height*3/2);let l0e=class{constructor(e,t){this._applyDensity=(r,s,o)=>{var p;if(!((p=r.number.density)!=null&&p.enable))return;const a=r.number,l=this._initDensityFactor(a.density),u=a.value,c=a.limit>0?a.limit:u,h=Math.min(u,c)*l+s,d=Math.min(this.count,this.filter(f=>f.group===o).length);this.limit=a.limit*l,d<h?this.push(Math.abs(h-d),void 0,r,o):d>h&&this.removeQuantity(d-h,o)},this._initDensityFactor=r=>{const s=this._container;if(!s.canvas.element||!r.enable)return 1;const o=s.canvas.element,a=s.retina.pixelRatio;return o.width*o.height/(r.factor*a**2*r.area)},this._pushParticle=(r,s,o,a)=>{try{let l=this.pool.pop();l?l.init(this._nextId,r,s,o):l=new o0e(this._engine,this._nextId,this._container,r,s,o);let u=!0;return a&&(u=a(l)),u?(this._array.push(l),this._zArray.push(l),this._nextId++,this._engine.dispatchEvent("particleAdded",{container:this._container,data:{particle:l}}),l):void 0}catch(l){wf().warning(`${Qa} adding particle: ${l}`);return}},this._removeParticle=(r,s,o)=>{const a=this._array[r];if(!a||a.group!==s)return!1;a.destroy(o);const l=this._zArray.indexOf(a);return this._array.splice(r,1),this._zArray.splice(l,1),this.pool.push(a),this._engine.dispatchEvent("particleRemoved",{container:this._container,data:{particle:a}}),!0},this._engine=e,this._container=t,this._nextId=0,this._array=[],this._zArray=[],this.pool=[],this.limit=0,this.needsSort=!1,this.lastZIndex=0,this._interactionManager=new s0e(e,t);const i=t.canvas.size;this.quadTree=new PM(Q4(i),J4),this.movers=this._engine.plugins.getMovers(t,!0),this.updaters=this._engine.plugins.getUpdaters(t,!0)}get count(){return this._array.length}addManualParticles(){const e=this._container,t=e.actualOptions;for(const i of t.manualParticles)this.addParticle(i.position?jJ(i.position,e.canvas.size):void 0,i.options)}addParticle(e,t,i,r){const s=this._container,o=s.actualOptions,a=o.particles.number.limit;if(a>0){const l=this.count+1-a;l>0&&this.removeQuantity(l)}return this._pushParticle(e,t,i,r)}clear(){this._array=[],this._zArray=[]}destroy(){this._array=[],this._zArray=[],this.movers=[],this.updaters=[]}async draw(e){const t=this._container;t.canvas.clear(),await this.update(e);for(const[,i]of t.plugins)t.canvas.drawPlugin(i,e);for(const i of this._zArray)i.draw(e)}filter(e){return this._array.filter(e)}find(e){return this._array.find(e)}handleClickMode(e){this._interactionManager.handleClickMode(e)}init(){var r;const e=this._container,t=e.actualOptions;this.lastZIndex=0,this.needsSort=!1;let i=!1;this.updaters=this._engine.plugins.getUpdaters(e,!0),this._interactionManager.init();for(const[,s]of e.plugins)if(s.particlesInitialization!==void 0&&(i=s.particlesInitialization()),i)break;this._interactionManager.init();for(const[,s]of e.pathGenerators)s.init(e);if(this.addManualParticles(),!i){for(const s in t.particles.groups){const o=t.particles.groups[s];for(let a=this.count,l=0;l<((r=o.number)==null?void 0:r.value)&&a<t.particles.number.value;a++,l++)this.addParticle(void 0,o,s)}for(let s=this.count;s<t.particles.number.value;s++)this.addParticle()}}push(e,t,i,r){this.pushing=!0;for(let s=0;s<e;s++)this.addParticle(t==null?void 0:t.position,i,r);this.pushing=!1}async redraw(){this.clear(),this.init(),await this.draw({value:0,factor:0})}remove(e,t,i){this.removeAt(this._array.indexOf(e),void 0,t,i)}removeAt(e,t=1,i,r){if(e<0||e>this.count)return;let s=0;for(let o=e;s<t&&o<this.count;o++)this._removeParticle(o--,i,r)&&s++}removeQuantity(e,t){this.removeAt(0,e,t)}setDensity(){const e=this._container.actualOptions,t=e.particles.groups;for(const i in t)this._applyDensity(t[i],0,i);this._applyDensity(e.particles,e.manualParticles.length)}async update(e){const t=this._container,i=new Set;this.quadTree=new PM(Q4(t.canvas.size),J4);for(const[,r]of t.pathGenerators)r.update();for(const[,r]of t.plugins)r.update&&r.update(e);for(const r of this._array){const s=t.canvas.resizeFactor;s&&!r.ignoresResizeRatio&&(r.position.x*=s.width,r.position.y*=s.height,r.initialPosition.x*=s.width,r.initialPosition.y*=s.height),r.ignoresResizeRatio=!1,await this._interactionManager.reset(r);for(const[,o]of this._container.plugins){if(r.destroyed)break;o.particleUpdate&&o.particleUpdate(r,e)}for(const o of this.movers)o.isEnabled(r)&&o.move(r,e);if(r.destroyed){i.add(r);continue}this.quadTree.insert(new a0e(r.getPosition(),r))}if(i.size){const r=s=>!i.has(s);this._array=this.filter(r),this._zArray=this._zArray.filter(r),this.pool.push(...i)}await this._interactionManager.externalInteract(e);for(const r of this._array){for(const s of this.updaters)s.update(r,e);!r.destroyed&&!r.spawning&&await this._interactionManager.particlesInteract(r,e)}if(delete t.canvas.resizeFactor,this.needsSort){const r=this._zArray;r.sort((s,o)=>o.position.z-s.position.z||s.id-o.id),this.lastZIndex=r[r.length-1].position.z,this.needsSort=!1}}};class u0e{constructor(e){this.container=e,this.pixelRatio=1,this.reduceFactor=1}init(){const e=this.container,t=e.actualOptions;this.pixelRatio=!t.detectRetina||Sy()?1:window.devicePixelRatio,this.reduceFactor=1;const i=this.pixelRatio;if(e.canvas.element){const o=e.canvas.element;e.canvas.size.width=o.offsetWidth*i,e.canvas.size.height=o.offsetHeight*i}const r=t.particles,s=r.move;this.attractDistance=Vt(s.attract.distance)*i,this.maxSpeed=Vt(s.gravity.maxSpeed)*i,this.sizeAnimationSpeed=Vt(r.size.animation.speed)*i}initParticle(e){const t=e.options,i=this.pixelRatio,r=t.move,s=r.distance,o=e.retina;o.attractDistance=Vt(r.attract.distance)*i,o.moveDrift=Vt(r.drift)*i,o.moveSpeed=Vt(r.speed)*i,o.sizeAnimationSpeed=Vt(t.size.animation.speed)*i;const a=o.maxDistance;a.horizontal=s.horizontal!==void 0?s.horizontal*i:void 0,a.vertical=s.vertical!==void 0?s.vertical*i:void 0,o.maxSpeed=Vt(r.gravity.maxSpeed)*i}}function Mi(n){return n&&!n.destroyed}function c0e(n,e=60,t=!1){return{value:n,factor:t?60/e:60*n/1e3}}function Hm(n,e,...t){const i=new r0e(n,e);return s7(i,...t),i}const h0e="default",q4={generate:n=>n.velocity,init:()=>{},update:()=>{},reset:()=>{}};class d0e{constructor(e,t,i){this.id=t,this._intersectionManager=r=>{if(!(!Mi(this)||!this.actualOptions.pauseOnOutsideViewport))for(const s of r)s.target===this.interactivity.element&&(s.isIntersecting?this.play:this.pause)()},this._nextFrame=async r=>{try{if(!this.smooth&&this.lastFrameTime!==void 0&&r<this.lastFrameTime+1e3/this.fpsLimit){this.draw(!1);return}this.lastFrameTime??(this.lastFrameTime=r);const s=c0e(r-this.lastFrameTime,this.fpsLimit,this.smooth);if(this.addLifeTime(s.value),this.lastFrameTime=r,s.value>1e3){this.draw(!1);return}if(await this.particles.draw(s),!this.alive()){this.destroy();return}this.getAnimationStatus()&&this.draw(!1)}catch(s){wf().error(`${Qa} in animation loop`,s)}},this._engine=e,this.fpsLimit=120,this.smooth=!1,this._delay=0,this._duration=0,this._lifeTime=0,this._firstStart=!0,this.started=!1,this.destroyed=!1,this._paused=!0,this.lastFrameTime=0,this.zLayers=100,this.pageHidden=!1,this._sourceOptions=i,this._initialSourceOptions=i,this.retina=new u0e(this),this.canvas=new gye(this),this.particles=new l0e(this._engine,this),this.pathGenerators=new Map,this.interactivity={mouse:{clicking:!1,inside:!1}},this.plugins=new Map,this.drawers=new Map,this._options=Hm(this._engine,this),this.actualOptions=Hm(this._engine,this),this._eventListeners=new yye(this),typeof IntersectionObserver<"u"&&IntersectionObserver&&(this._intersectionObserver=new IntersectionObserver(r=>this._intersectionManager(r))),this._engine.dispatchEvent("containerBuilt",{container:this})}get options(){return this._options}get sourceOptions(){return this._sourceOptions}addClickHandler(e){if(!Mi(this))return;const t=this.interactivity.element;if(!t)return;const i=(h,d,p)=>{if(!Mi(this))return;const f=this.retina.pixelRatio,g={x:d.x*f,y:d.y*f},y=this.particles.quadTree.queryCircle(g,p*f);e(h,y)},r=h=>{if(!Mi(this))return;const d=h,p={x:d.offsetX||d.clientX,y:d.offsetY||d.clientY};i(h,p,1)},s=()=>{Mi(this)&&(u=!0,c=!1)},o=()=>{Mi(this)&&(c=!0)},a=h=>{if(Mi(this)){if(u&&!c){const d=h;let p=d.touches[d.touches.length-1];if(!p&&(p=d.changedTouches[d.changedTouches.length-1],!p))return;const f=this.canvas.element,g=f?f.getBoundingClientRect():void 0,y={x:p.clientX-(g?g.left:0),y:p.clientY-(g?g.top:0)};i(h,y,Math.max(p.radiusX,p.radiusY))}u=!1,c=!1}},l=()=>{Mi(this)&&(u=!1,c=!1)};let u=!1,c=!1;t.addEventListener("click",r),t.addEventListener("touchstart",s),t.addEventListener("touchmove",o),t.addEventListener("touchend",a),t.addEventListener("touchcancel",l)}addLifeTime(e){this._lifeTime+=e}addPath(e,t,i=!1){return!Mi(this)||!i&&this.pathGenerators.has(e)?!1:(this.pathGenerators.set(e,t??q4),!0)}alive(){return!this._duration||this._lifeTime<=this._duration}destroy(){if(!Mi(this))return;this.stop(),this.particles.destroy(),this.canvas.destroy();for(const[,i]of this.drawers)i.destroy&&i.destroy(this);for(const i of this.drawers.keys())this.drawers.delete(i);this._engine.plugins.destroy(this),this.destroyed=!0;const e=this._engine.dom(),t=e.findIndex(i=>i===this);t>=0&&e.splice(t,1),this._engine.dispatchEvent("containerDestroyed",{container:this})}draw(e){if(!Mi(this))return;let t=e;this._drawAnimationFrame=requestAnimationFrame(async i=>{t&&(this.lastFrameTime=void 0,t=!1),await this._nextFrame(i)})}async export(e,t={}){for(const[,i]of this.plugins){if(!i.export)continue;const r=await i.export(e,t);if(r.supported)return r.blob}wf().error(`${Qa} - Export plugin with type ${e} not found`)}getAnimationStatus(){return!this._paused&&!this.pageHidden&&Mi(this)}handleClickMode(e){if(Mi(this)){this.particles.handleClickMode(e);for(const[,t]of this.plugins)t.handleClickMode&&t.handleClickMode(e)}}async init(){if(!Mi(this))return;const e=this._engine.plugins.getSupportedShapes();for(const i of e){const r=this._engine.plugins.getShapeDrawer(i);r&&this.drawers.set(i,r)}this._options=Hm(this._engine,this,this._initialSourceOptions,this.sourceOptions),this.actualOptions=Hm(this._engine,this,this._options);const t=this._engine.plugins.getAvailablePlugins(this);for(const[i,r]of t)this.plugins.set(i,r);this.retina.init(),await this.canvas.init(),this.updateActualOptions(),this.canvas.initBackground(),this.canvas.resize(),this.zLayers=this.actualOptions.zLayers,this._duration=Vt(this.actualOptions.duration)*1e3,this._delay=Vt(this.actualOptions.delay)*1e3,this._lifeTime=0,this.fpsLimit=this.actualOptions.fpsLimit>0?this.actualOptions.fpsLimit:120,this.smooth=this.actualOptions.smooth;for(const[,i]of this.drawers)i.init&&await i.init(this);for(const[,i]of this.plugins)i.init&&await i.init();this._engine.dispatchEvent("containerInit",{container:this}),this.particles.init(),this.particles.setDensity();for(const[,i]of this.plugins)i.particlesSetup&&i.particlesSetup();this._engine.dispatchEvent("particlesSetup",{container:this})}async loadTheme(e){Mi(this)&&(this._currentTheme=e,await this.refresh())}pause(){if(Mi(this)&&(this._drawAnimationFrame!==void 0&&(cancelAnimationFrame(this._drawAnimationFrame),delete this._drawAnimationFrame),!this._paused)){for(const[,e]of this.plugins)e.pause&&e.pause();this.pageHidden||(this._paused=!0),this._engine.dispatchEvent("containerPaused",{container:this})}}play(e){if(!Mi(this))return;const t=this._paused||e;if(this._firstStart&&!this.actualOptions.autoPlay){this._firstStart=!1;return}if(this._paused&&(this._paused=!1),t)for(const[,i]of this.plugins)i.play&&i.play();this._engine.dispatchEvent("containerPlay",{container:this}),this.draw(t||!1)}async refresh(){if(Mi(this))return this.stop(),this.start()}async reset(){if(Mi(this))return this._initialSourceOptions=void 0,this._options=Hm(this._engine,this),this.actualOptions=Hm(this._engine,this,this._options),this.refresh()}setNoise(e,t,i){Mi(this)&&this.setPath(e,t,i)}setPath(e,t,i){if(!e||!Mi(this))return;const r={...q4};if(YJ(e))r.generate=e,t&&(r.init=t),i&&(r.update=i);else{const s=r;r.generate=e.generate||s.generate,r.init=e.init||s.init,r.update=e.update||s.update}this.addPath(h0e,r,!0)}async start(){!Mi(this)||this.started||(await this.init(),this.started=!0,await new Promise(e=>{this._delayTimeout=setTimeout(async()=>{this._eventListeners.addListeners(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.observe(this.interactivity.element);for(const[,t]of this.plugins)t.start&&await t.start();this._engine.dispatchEvent("containerStarted",{container:this}),this.play(),e()},this._delay)}))}stop(){if(!(!Mi(this)||!this.started)){this._delayTimeout&&(clearTimeout(this._delayTimeout),delete this._delayTimeout),this._firstStart=!0,this.started=!1,this._eventListeners.removeListeners(),this.pause(),this.particles.clear(),this.canvas.stop(),this.interactivity.element instanceof HTMLElement&&this._intersectionObserver&&this._intersectionObserver.unobserve(this.interactivity.element);for(const[,e]of this.plugins)e.stop&&e.stop();for(const e of this.plugins.keys())this.plugins.delete(e);this._sourceOptions=this._options,this._engine.dispatchEvent("containerStopped",{container:this})}}updateActualOptions(){this.actualOptions.responsive=[];const e=this.actualOptions.setResponsive(this.canvas.size.width,this.retina.pixelRatio,this._options);return this.actualOptions.setTheme(this._currentTheme),this.responsiveMaxWidth===e?!1:(this.responsiveMaxWidth=e,!0)}}let p0e=class{constructor(){this._listeners=new Map}addEventListener(e,t){this.removeEventListener(e,t);let i=this._listeners.get(e);i||(i=[],this._listeners.set(e,i)),i.push(t)}dispatchEvent(e,t){const i=this._listeners.get(e);i&&i.forEach(r=>r(t))}hasEventListener(e){return!!this._listeners.get(e)}removeAllEventListeners(e){e?this._listeners.delete(e):this._listeners=new Map}removeEventListener(e,t){const i=this._listeners.get(e);if(!i)return;const r=i.length,s=i.indexOf(t);s<0||(r===1?this._listeners.delete(e):i.splice(s,1))}};function NN(n,e,t,i=!1){let r=e.get(n);return(!r||i)&&(r=[...t.values()].map(s=>s(n)),e.set(n,r)),r}class f0e{constructor(e){this._engine=e,this.plugins=[],this._initializers={interactors:new Map,movers:new Map,updaters:new Map},this.interactors=new Map,this.movers=new Map,this.updaters=new Map,this.presets=new Map,this.drawers=new Map,this.pathGenerators=new Map}addInteractor(e,t){this._initializers.interactors.set(e,t)}addParticleMover(e,t){this._initializers.movers.set(e,t)}addParticleUpdater(e,t){this._initializers.updaters.set(e,t)}addPathGenerator(e,t){!this.getPathGenerator(e)&&this.pathGenerators.set(e,t)}addPlugin(e){!this.getPlugin(e.id)&&this.plugins.push(e)}addPreset(e,t,i=!1){(i||!this.getPreset(e))&&this.presets.set(e,t)}addShapeDrawer(e,t){Kr(e,i=>{!this.getShapeDrawer(i)&&this.drawers.set(i,t)})}destroy(e){this.updaters.delete(e),this.movers.delete(e),this.interactors.delete(e)}getAvailablePlugins(e){const t=new Map;for(const i of this.plugins)i.needsPlugin(e.actualOptions)&&t.set(i.id,i.getPlugin(e));return t}getInteractors(e,t=!1){return NN(e,this.interactors,this._initializers.interactors,t)}getMovers(e,t=!1){return NN(e,this.movers,this._initializers.movers,t)}getPathGenerator(e){return this.pathGenerators.get(e)}getPlugin(e){return this.plugins.find(t=>t.id===e)}getPreset(e){return this.presets.get(e)}getShapeDrawer(e){return this.drawers.get(e)}getSupportedShapes(){return this.drawers.keys()}getUpdaters(e,t=!1){return NN(e,this.updaters,this._initializers.updaters,t)}loadOptions(e,t){for(const i of this.plugins)i.loadOptions(e,t)}loadParticlesOptions(e,t,...i){const r=this.updaters.get(e);if(r)for(const s of r)s.loadOptions&&s.loadOptions(t,...i)}}async function m0e(n){const e=_c(n.url,n.index);if(!e)return n.fallback;const t=await fetch(e);return t.ok?t.json():(wf().error(`${Qa} ${t.status} while retrieving config file`),n.fallback)}function g0e(n){return!n.id&&!n.element&&!n.url&&!n.options}function y0e(n){return!g0e(n)}class b0e{constructor(){this._configs=new Map,this._domArray=[],this._eventDispatcher=new p0e,this._initialized=!1,this.plugins=new f0e(this)}get configs(){const e={};for(const[t,i]of this._configs)e[t]=i;return e}get version(){return"2.12.0"}addConfig(e,t){Rl(e)?t&&(t.name=e,this._configs.set(e,t)):this._configs.set(e.name??"default",e)}addEventListener(e,t){this._eventDispatcher.addEventListener(e,t)}async addInteractor(e,t,i=!0){this.plugins.addInteractor(e,t),await this.refresh(i)}async addMover(e,t,i=!0){this.plugins.addParticleMover(e,t),await this.refresh(i)}async addParticleUpdater(e,t,i=!0){this.plugins.addParticleUpdater(e,t),await this.refresh(i)}async addPathGenerator(e,t,i=!0){this.plugins.addPathGenerator(e,t),await this.refresh(i)}async addPlugin(e,t=!0){this.plugins.addPlugin(e),await this.refresh(t)}async addPreset(e,t,i=!1,r=!0){this.plugins.addPreset(e,t,i),await this.refresh(r)}async addShape(e,t,i,r,s,o=!0){let a,l=o,u,c,h;ed(i)?(l=i,u=void 0):u=i,ed(r)?(l=r,c=void 0):c=r,ed(s)?(l=s,h=void 0):h=s,YJ(t)?a={afterEffect:c,destroy:h,draw:t,init:u}:a=t,this.plugins.addShapeDrawer(e,a),await this.refresh(l)}dispatchEvent(e,t){this._eventDispatcher.dispatchEvent(e,t)}dom(){return this._domArray}domItem(e){const t=this.dom(),i=t[e];if(!i||i.destroyed){t.splice(e,1);return}return i}init(){this._initialized||(this._initialized=!0)}async load(e,t){return this.loadFromArray(e,t)}async loadFromArray(e,t,i){let r;return y0e(e)?r=e:(r={},Rl(e)?r.id=e:r.options=e,Nl(t)?r.index=t:r.options=t??r.options,r.index=i??r.index),this._loadParams(r)}async loadJSON(e,t,i){let r,s;return Nl(t)||t===void 0?r=e:(s=e,r=t),this._loadParams({id:s,url:r,index:i})}async refresh(e=!0){e&&this.dom().forEach(t=>t.refresh())}removeEventListener(e,t){this._eventDispatcher.removeEventListener(e,t)}async set(e,t,i,r){const s={index:r};return Rl(e)?s.id=e:s.element=e,t instanceof HTMLElement?s.element=t:s.options=t,Nl(i)?s.index=i:s.options=i??s.options,this._loadParams(s)}async setJSON(e,t,i,r){const s={};return e instanceof HTMLElement?(s.element=e,s.url=t,s.index=i):(s.id=e,s.element=t,s.url=i,s.index=r),this._loadParams(s)}setOnClickHandler(e){const t=this.dom();if(!t.length)throw new Error(`${Qa} can only set click handlers after calling tsParticles.load()`);for(const i of t)i.addClickHandler(e)}async _loadParams(e){const t=e.id??`tsparticles${Math.floor(pi()*1e4)}`,{index:i,url:r}=e,s=r?await m0e({fallback:e.options,url:r,index:i}):e.options;let o=e.element??document.getElementById(t);o||(o=document.createElement("div"),o.id=t,document.body.append(o));const a=_c(s,i),l=this.dom(),u=l.findIndex(d=>d.id===t);if(u>=0){const d=this.domItem(u);d&&!d.destroyed&&(d.destroy(),l.splice(u,1))}let c;if(o.tagName.toLowerCase()==="canvas")c=o,c.dataset[sv]="false";else{const d=o.getElementsByTagName("canvas");d.length?(c=d[0],c.dataset[sv]="false"):(c=document.createElement("canvas"),c.dataset[sv]="true",o.appendChild(c))}c.style.width||(c.style.width="100%"),c.style.height||(c.style.height="100%");const h=new d0e(this,t,a);return u>=0?l.splice(u,0,h):l.push(h),h.canvas.loadCanvas(c),await h.start(),h}}class x0e{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(e){const t=e.value,i=t.hsl??e.value;if(i.h!==void 0&&i.s!==void 0&&i.l!==void 0)return Ty(i)}handleRangeColor(e){const t=e.value,i=t.hsl??e.value;if(i.h!==void 0&&i.l!==void 0)return Ty({h:Vt(i.h),l:Vt(i.l),s:Vt(i.s)})}parseString(e){if(!e.startsWith("hsl"))return;const t=/hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i,i=t.exec(e);return i?sye({a:i.length>4?$J(i[5]):1,h:parseInt(i[1],10),l:parseInt(i[3],10),s:parseInt(i[2],10)}):void 0}}class v0e{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(e){const t=e.value,i=t.rgb??e.value;if(i.r!==void 0)return i}handleRangeColor(e){const t=e.value,i=t.rgb??e.value;if(i.r!==void 0)return{r:Vt(i.r),g:Vt(i.g),b:Vt(i.b)}}parseString(e){if(!e.startsWith(this.stringPrefix))return;const t=/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i,i=t.exec(e);return i?{a:i.length>4?$J(i[5]):1,b:parseInt(i[3],10),g:parseInt(i[2],10),r:parseInt(i[1],10)}:void 0}}function w0e(){const n=new v0e,e=new x0e;H4(n),H4(e);const t=new b0e;return t.init(),t}class Uu{constructor(e){this.container=e,this.type="external"}}class xB{constructor(e){this.container=e,this.type="particles"}}const DM=w0e();Sy()||(window.tsParticles=DM);const Vg=n=>typeof n=="object"&&n!==null;function FM(n,e,t=()=>!1){if(!Vg(n)||!Vg(e))return n===e;const i=Object.keys(n).filter(s=>!t(s)),r=Object.keys(e).filter(s=>!t(s));if(i.length!==r.length)return!1;for(const s of i){const o=n[s],a=e[s];if(Vg(o)&&Vg(a)){if(o===e&&a===n)continue;if(!FM(o,a,t))return!1}else if(Array.isArray(o)&&Array.isArray(a)){if(!l7(o,a,t))return!1}else if(o!==a)return!1}return!0}function l7(n,e,t){if(n.length!==e.length)return!1;for(let i=0;i<n.length;i++){const r=n[i],s=e[i];if(Array.isArray(r)&&Array.isArray(s)){if(!l7(r,s,t))return!1}else if(Vg(r)&&Vg(s)){if(!FM(r,s,t))return!1}else if(r!==s)return!1}return!0}const u7="tsparticles";let c7=class h7 extends K.Component{constructor(e){super(e),this.state={init:!1,library:void 0}}destroy(){this.state.library&&(this.state.library.destroy(),this.setState({library:void 0}))}shouldComponentUpdate(e){const t=e.options??e.params,i=this.props.options??this.props.params;return e.url!==this.props.url||e.id!==this.props.id||e.canvasClassName!==this.props.canvasClassName||e.className!==this.props.className||e.height!==this.props.height||e.width!==this.props.width||!FM(e.style,this.props.style)||e.init!==this.props.init||e.loaded!==this.props.loaded||!FM(t,i,r=>r.startsWith("_"))}componentDidUpdate(){this.refresh()}forceUpdate(){this.refresh().then(()=>{super.forceUpdate()})}componentDidMount(){(async()=>(this.props.init&&await this.props.init(DM),this.setState({init:!0},async()=>{await this.loadParticles()})))()}componentWillUnmount(){this.destroy()}render(){const{width:e,height:t,className:i,canvasClassName:r,id:s}=this.props;return Is.createElement("div",{className:i,id:s},Is.createElement("canvas",{className:r,style:{...this.props.style,width:e,height:t}}))}async refresh(){this.destroy(),await this.loadParticles()}async loadParticles(){if(!this.state.init)return;const e=this.props.id??h7.defaultProps.id??u7,t=await DM.load({url:this.props.url,id:e,options:this.props.options??this.props.params});this.props.container&&(this.props.container.current=t),this.setState({library:t}),this.props.loaded&&await this.props.loaded(t)}};c7.defaultProps={width:"100%",height:"100%",options:{},style:{},url:void 0,id:u7};class OM{static init(e){var s;const t=new OM,i=e.selector;if(!i)throw new Error("No selector provided");const r=document.querySelector(i);if(!r)throw new Error("No element found for selector");return DM.set(i.replace(".","").replace("!",""),r,{fullScreen:{enable:!1},particles:{color:{value:e.color??"!000000"},links:{color:"random",distance:e.minDistance??120,enable:e.connectParticles??!1},move:{enable:!0,speed:e.speed??.5},number:{value:e.maxParticles??100},size:{value:{min:1,max:e.sizeVariations??3}}},responsive:(s=e.responsive)==null?void 0:s.map(o=>{var a,l,u,c,h;return{maxWidth:o.breakpoint,options:{particles:{color:{value:(a=o.options)==null?void 0:a.color},links:{distance:(l=o.options)==null?void 0:l.minDistance,enable:(u=o.options)==null?void 0:u.connectParticles},number:{value:e.maxParticles},move:{enable:!0,speed:(c=o.options)==null?void 0:c.speed},size:{value:(h=o.options)==null?void 0:h.sizeVariations}}}}})}).then(o=>{t._container=o}),t}destroy(){const e=this._container;e&&e.destroy()}pauseAnimation(){const e=this._container;e&&e.pause()}resumeAnimation(){const e=this._container;e&&e.play()}}const S0e=n=>{const e=(i,r)=>n.load(i,r);e.load=(i,r,s)=>{n.loadJSON(i,r).then(o=>{o&&s(o)}).catch(()=>{s(void 0)})},e.setOnClickHandler=i=>{n.setOnClickHandler(i)};const t=n.dom();return{particlesJS:e,pJSDom:t}},T0e=n=>{const{particlesJS:e,pJSDom:t}=S0e(n);return window.particlesJS=e,window.pJSDom=t,window.Particles=OM,{particlesJS:e,pJSDom:t,Particles:OM}};function C0e(n){const e=n.initialPosition,{dx:t,dy:i}=js(e,n.position),r=Math.abs(t),s=Math.abs(i),{maxDistance:o}=n.retina,a=o.horizontal,l=o.vertical;if(!(!a&&!l)){if((a&&r>=a||l&&s>=l)&&!n.misplaced)n.misplaced=!!a&&r>a||!!l&&s>l,a&&(n.velocity.x=n.velocity.y/2-n.velocity.x),l&&(n.velocity.y=n.velocity.x/2-n.velocity.y);else if((!a||r<a)&&(!l||s<l)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const u=n.position,c=n.velocity;a&&(u.x<e.x&&c.x<0||u.x>e.x&&c.x>0)&&(c.x*=-pi()),l&&(u.y<e.y&&c.y<0||u.y>e.y&&c.y>0)&&(c.y*=-pi())}}}function _0e(n,e,t,i,r,s){A0e(n,s);const o=n.gravity,a=o!=null&&o.enable&&o.inverse?-1:1;r&&t&&(n.velocity.x+=r*s.factor/(60*t)),o!=null&&o.enable&&t&&(n.velocity.y+=a*(o.acceleration*s.factor)/(60*t));const l=n.moveDecay;n.velocity.multTo(l);const u=n.velocity.mult(t);o!=null&&o.enable&&i>0&&(!o.inverse&&u.y>=0&&u.y>=i||o.inverse&&u.y<=0&&u.y<=-i)&&(u.y=a*i,t&&(n.velocity.y=u.y/t));const c=n.options.zIndex,h=(1-n.zIndexFactor)**c.velocityRate;u.multTo(h);const{position:d}=n;d.addTo(u),e.vibrate&&(d.x+=Math.sin(d.x*Math.cos(d.y)),d.y+=Math.cos(d.y*Math.sin(d.x)))}function M0e(n,e){const t=n.container;if(!n.spin)return;const i={x:n.spin.direction==="clockwise"?Math.cos:Math.sin,y:n.spin.direction==="clockwise"?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*i.x(n.spin.angle),n.position.y=n.spin.center.y+n.spin.radius*i.y(n.spin.angle),n.spin.radius+=n.spin.acceleration;const r=Math.max(t.canvas.size.width,t.canvas.size.height);n.spin.radius>r/2?(n.spin.radius=r/2,n.spin.acceleration*=-1):n.spin.radius<0&&(n.spin.radius=0,n.spin.acceleration*=-1),n.spin.angle+=e/100*(1-n.spin.radius/r)}function A0e(n,e){var o;const t=n.options,i=t.move.path;if(!i.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=e.value;return}const s=(o=n.pathGenerator)==null?void 0:o.generate(n,e);s&&n.velocity.addTo(s),i.clamp&&(n.velocity.x=zl(n.velocity.x,-1,1),n.velocity.y=zl(n.velocity.y,-1,1)),n.lastPathTime-=n.pathDelay}function E0e(n){return n.slow.inRange?n.slow.factor:1}const I0e=2;class k0e{constructor(){this._initSpin=e=>{const t=e.container,i=e.options,r=i.move.spin;if(!r.enable)return;const s=r.position??{x:50,y:50},o={x:s.x/100*t.canvas.size.width,y:s.y/100*t.canvas.size.height},a=e.getPosition(),l=ia(a,o),u=Vt(r.acceleration);e.retina.spinAcceleration=u*t.retina.pixelRatio,e.spin={center:o,direction:e.velocity.x>=0?"clockwise":"counter-clockwise",angle:e.velocity.angle,radius:l,acceleration:e.retina.spinAcceleration}}}init(e){const t=e.options,i=t.move.gravity;e.gravity={enable:i.enable,acceleration:Vt(i.acceleration),inverse:i.inverse},this._initSpin(e)}isEnabled(e){return!e.destroyed&&e.options.move.enable}move(e,t){var f,g;const i=e.options,r=i.move;if(!r.enable)return;const s=e.container,o=s.retina.pixelRatio,a=E0e(e),l=((f=e.retina).moveSpeed??(f.moveSpeed=Vt(r.speed)*o))*s.retina.reduceFactor,u=(g=e.retina).moveDrift??(g.moveDrift=Vt(e.options.move.drift)*o),c=zh(i.size.value)*o,h=r.size?e.getRadius()/c:1,d=l*h*a*(t.factor||1)/I0e,p=e.retina.maxSpeed??s.retina.maxSpeed;r.spin.enable?M0e(e,d):_0e(e,r,d,p,u,t),C0e(e)}}async function R0e(n,e=!0){await n.addMover("base",()=>new k0e,e)}class N0e{draw(e,t,i){t.circleRange||(t.circleRange={min:0,max:Math.PI*2});const r=t.circleRange;e.arc(0,0,i,r.min,r.max,!1)}getSidesCount(){return 12}particleInit(e,t){const i=t.shapeData,r=(i==null?void 0:i.angle)??{max:360,min:0};t.circleRange=Gg(r)?{min:r.min*Math.PI/180,max:r.max*Math.PI/180}:{min:0,max:r*Math.PI/180}}}async function L0e(n,e=!0){await n.addShape("circle",new N0e,e)}function LN(n,e,t,i,r){if(!e||!t.enable||(e.maxLoops??0)>0&&(e.loops??0)>(e.maxLoops??0)||(e.time||(e.time=0),(e.delayTime??0)>0&&e.time<(e.delayTime??0)&&(e.time+=n.value),(e.delayTime??0)>0&&e.time<(e.delayTime??0)))return;const s=To(t.offset),o=(e.velocity??0)*n.factor+s*3.6,a=e.decay??1;!r||e.status==="increasing"?(e.value+=o,e.value>i&&(e.loops||(e.loops=0),e.loops++,r&&(e.status="decreasing",e.value-=e.value%i))):(e.value-=o,e.value<0&&(e.loops||(e.loops=0),e.loops++,e.status="increasing",e.value+=e.value)),e.velocity&&a!==1&&(e.velocity*=a),e.value>i&&(e.value%=i)}function P0e(n,e){const{h:t,s:i,l:r}=n.options.color.animation,{color:s}=n;if(!s)return;const{h:o,s:a,l}=s;o&&LN(e,o,t,360,!1),a&&LN(e,a,i,100,!0),l&&LN(e,l,r,100,!0)}class D0e{constructor(e){this.container=e}init(e){const t=Fv(e.options.color,e.id,e.options.reduceDuplicates);t&&(e.color=t7(t,e.options.color.animation,this.container.retina.reduceFactor))}isEnabled(e){const{h:t,s:i,l:r}=e.options.color.animation,{color:s}=e;return!e.destroyed&&!e.spawning&&((s==null?void 0:s.h.value)!==void 0&&t.enable||(s==null?void 0:s.s.value)!==void 0&&i.enable||(s==null?void 0:s.l.value)!==void 0&&r.enable)}update(e,t){P0e(e,t)}}async function F0e(n,e=!0){await n.addParticleUpdater("color",t=>new D0e(t),e)}function O0e(n,e,t,i){switch(n.options.opacity.animation.destroy){case"max":e>=i&&n.destroy();break;case"min":e<=t&&n.destroy();break}}function B0e(n,e){const t=n.opacity;if(n.destroyed||!(t!=null&&t.enable)||(t.maxLoops??0)>0&&(t.loops??0)>(t.maxLoops??0))return;const i=t.min,r=t.max,s=t.decay??1;if(t.time||(t.time=0),(t.delayTime??0)>0&&t.time<(t.delayTime??0)&&(t.time+=e.value),!((t.delayTime??0)>0&&t.time<(t.delayTime??0))){switch(t.status){case"increasing":t.value>=r?(t.status="decreasing",t.loops||(t.loops=0),t.loops++):t.value+=(t.velocity??0)*e.factor;break;case"decreasing":t.value<=i?(t.status="increasing",t.loops||(t.loops=0),t.loops++):t.value-=(t.velocity??0)*e.factor;break}t.velocity&&t.decay!==1&&(t.velocity*=s),O0e(n,t.value,i,r),n.destroyed||(t.value=zl(t.value,i,r))}}class z0e{constructor(e){this.container=e}init(e){const t=e.options.opacity;e.opacity=ZJ(t,1);const i=t.animation;i.enable&&(e.opacity.velocity=Vt(i.speed)/100*this.container.retina.reduceFactor,i.sync||(e.opacity.velocity*=pi()))}isEnabled(e){return!e.destroyed&&!e.spawning&&!!e.opacity&&e.opacity.enable&&((e.opacity.maxLoops??0)<=0||(e.opacity.maxLoops??0)>0&&(e.opacity.loops??0)<(e.opacity.maxLoops??0))}reset(e){e.opacity&&(e.opacity.time=0,e.opacity.loops=0)}update(e,t){this.isEnabled(e)&&B0e(e,t)}}async function G0e(n,e=!0){await n.addParticleUpdater("opacity",t=>new z0e(t),e)}function V0e(n){if(n.outMode!=="bounce"&&n.outMode!=="bounce-horizontal"&&n.outMode!=="bounceHorizontal"&&n.outMode!=="split"||n.direction!=="left"&&n.direction!=="right")return;n.bounds.right<0&&n.direction==="left"?n.particle.position.x=n.size+n.offset.x:n.bounds.left>n.canvasSize.width&&n.direction==="right"&&(n.particle.position.x=n.canvasSize.width-n.size-n.offset.x);const e=n.particle.velocity.x;let t=!1;if(n.direction==="right"&&n.bounds.right>=n.canvasSize.width&&e>0||n.direction==="left"&&n.bounds.left<=0&&e<0){const r=vf(n.particle.options.bounce.horizontal);n.particle.velocity.x*=-r,t=!0}if(!t)return;const i=n.offset.x+n.size;n.bounds.right>=n.canvasSize.width&&n.direction==="right"?n.particle.position.x=n.canvasSize.width-i:n.bounds.left<=0&&n.direction==="left"&&(n.particle.position.x=i),n.outMode==="split"&&n.particle.destroy()}function U0e(n){if(n.outMode!=="bounce"&&n.outMode!=="bounce-vertical"&&n.outMode!=="bounceVertical"&&n.outMode!=="split"||n.direction!=="bottom"&&n.direction!=="top")return;n.bounds.bottom<0&&n.direction==="top"?n.particle.position.y=n.size+n.offset.y:n.bounds.top>n.canvasSize.height&&n.direction==="bottom"&&(n.particle.position.y=n.canvasSize.height-n.size-n.offset.y);const e=n.particle.velocity.y;let t=!1;if(n.direction==="bottom"&&n.bounds.bottom>=n.canvasSize.height&&e>0||n.direction==="top"&&n.bounds.top<=0&&e<0){const r=vf(n.particle.options.bounce.vertical);n.particle.velocity.y*=-r,t=!0}if(!t)return;const i=n.offset.y+n.size;n.bounds.bottom>=n.canvasSize.height&&n.direction==="bottom"?n.particle.position.y=n.canvasSize.height-i:n.bounds.top<=0&&n.direction==="top"&&(n.particle.position.y=i),n.outMode==="split"&&n.particle.destroy()}class $0e{constructor(e){this.container=e,this.modes=["bounce","bounce-vertical","bounce-horizontal","bounceVertical","bounceHorizontal","split"]}update(e,t,i,r){if(!this.modes.includes(r))return;const s=this.container;let o=!1;for(const[,d]of s.plugins)if(d.particleBounce!==void 0&&(o=d.particleBounce(e,i,t)),o)break;if(o)return;const a=e.getPosition(),l=e.offset,u=e.getRadius(),c=F1(a,u),h=s.canvas.size;V0e({particle:e,outMode:r,direction:t,bounds:c,canvasSize:h,offset:l,size:u}),U0e({particle:e,outMode:r,direction:t,bounds:c,canvasSize:h,offset:l,size:u})}}class W0e{constructor(e){this.container=e,this.modes=["destroy"]}update(e,t,i,r){if(!this.modes.includes(r))return;const s=this.container;switch(e.outType){case"normal":case"outside":if(mB(e.position,s.canvas.size,Xr.origin,e.getRadius(),t))return;break;case"inside":{const{dx:o,dy:a}=js(e.position,e.moveCenter),{x:l,y:u}=e.velocity;if(l<0&&o>e.moveCenter.radius||u<0&&a>e.moveCenter.radius||l>=0&&o<-e.moveCenter.radius||u>=0&&a<-e.moveCenter.radius)return;break}}s.particles.remove(e,void 0,!0)}}class H0e{constructor(e){this.container=e,this.modes=["none"]}update(e,t,i,r){if(!this.modes.includes(r)||e.options.move.distance.horizontal&&(t==="left"||t==="right")||e.options.move.distance.vertical&&(t==="top"||t==="bottom"))return;const s=e.options.move.gravity,o=this.container,a=o.canvas.size,l=e.getRadius();if(s.enable){const u=e.position;(!s.inverse&&u.y>a.height+l&&t==="bottom"||s.inverse&&u.y<-l&&t==="top")&&o.particles.remove(e)}else{if(e.velocity.y>0&&e.position.y<=a.height+l||e.velocity.y<0&&e.position.y>=-l||e.velocity.x>0&&e.position.x<=a.width+l||e.velocity.x<0&&e.position.x>=-l)return;mB(e.position,o.canvas.size,Xr.origin,l,t)||o.particles.remove(e)}}}class X0e{constructor(e){this.container=e,this.modes=["out"]}update(e,t,i,r){if(!this.modes.includes(r))return;const s=this.container;switch(e.outType){case"inside":{const{x:o,y:a}=e.velocity,l=Xr.origin;l.length=e.moveCenter.radius,l.angle=e.velocity.angle+Math.PI,l.addTo(Xr.create(e.moveCenter));const{dx:u,dy:c}=js(e.position,l);if(o<=0&&u>=0||a<=0&&c>=0||o>=0&&u<=0||a>=0&&c<=0)return;e.position.x=Math.floor(To({min:0,max:s.canvas.size.width})),e.position.y=Math.floor(To({min:0,max:s.canvas.size.height}));const{dx:h,dy:d}=js(e.position,e.moveCenter);e.direction=Math.atan2(-d,-h),e.velocity.angle=e.direction;break}default:{if(mB(e.position,s.canvas.size,Xr.origin,e.getRadius(),t))return;switch(e.outType){case"outside":{e.position.x=Math.floor(To({min:-e.moveCenter.radius,max:e.moveCenter.radius}))+e.moveCenter.x,e.position.y=Math.floor(To({min:-e.moveCenter.radius,max:e.moveCenter.radius}))+e.moveCenter.y;const{dx:o,dy:a}=js(e.position,e.moveCenter);e.moveCenter.radius&&(e.direction=Math.atan2(a,o),e.velocity.angle=e.direction);break}case"normal":{const o=e.options.move.warp,a=s.canvas.size,l={bottom:a.height+e.getRadius()+e.offset.y,left:-e.getRadius()-e.offset.x,right:a.width+e.getRadius()+e.offset.x,top:-e.getRadius()-e.offset.y},u=e.getRadius(),c=F1(e.position,u);t==="right"&&c.left>a.width+e.offset.x?(e.position.x=l.left,e.initialPosition.x=e.position.x,o||(e.position.y=pi()*a.height,e.initialPosition.y=e.position.y)):t==="left"&&c.right<-e.offset.x&&(e.position.x=l.right,e.initialPosition.x=e.position.x,o||(e.position.y=pi()*a.height,e.initialPosition.y=e.position.y)),t==="bottom"&&c.top>a.height+e.offset.y?(o||(e.position.x=pi()*a.width,e.initialPosition.x=e.position.x),e.position.y=l.top,e.initialPosition.y=e.position.y):t==="top"&&c.bottom<-e.offset.y&&(o||(e.position.x=pi()*a.width,e.initialPosition.x=e.position.x),e.position.y=l.bottom,e.initialPosition.y=e.position.y);break}}break}}}}class K0e{constructor(e){this.container=e,this._updateOutMode=(t,i,r,s)=>{for(const o of this.updaters)o.update(t,s,i,r)},this.updaters=[new $0e(e),new W0e(e),new X0e(e),new H0e(e)]}init(){}isEnabled(e){return!e.destroyed&&!e.spawning}update(e,t){const i=e.options.move.outModes;this._updateOutMode(e,t,i.bottom??i.default,"bottom"),this._updateOutMode(e,t,i.left??i.default,"left"),this._updateOutMode(e,t,i.right??i.default,"right"),this._updateOutMode(e,t,i.top??i.default,"top")}}async function Z0e(n,e=!0){await n.addParticleUpdater("outModes",t=>new K0e(t),e)}function j0e(n,e,t,i){switch(n.options.size.animation.destroy){case"max":e>=i&&n.destroy();break;case"min":e<=t&&n.destroy();break}}function Y0e(n,e){const t=n.size;if(n.destroyed||!t||!t.enable||(t.maxLoops??0)>0&&(t.loops??0)>(t.maxLoops??0))return;const i=(t.velocity??0)*e.factor,r=t.min,s=t.max,o=t.decay??1;if(t.time||(t.time=0),(t.delayTime??0)>0&&t.time<(t.delayTime??0)&&(t.time+=e.value),!((t.delayTime??0)>0&&t.time<(t.delayTime??0))){switch(t.status){case"increasing":t.value>=s?(t.status="decreasing",t.loops||(t.loops=0),t.loops++):t.value+=i;break;case"decreasing":t.value<=r?(t.status="increasing",t.loops||(t.loops=0),t.loops++):t.value-=i}t.velocity&&o!==1&&(t.velocity*=o),j0e(n,t.value,r,s),n.destroyed||(t.value=zl(t.value,r,s))}}class J0e{init(e){const t=e.container,i=e.options.size,r=i.animation;r.enable&&(e.size.velocity=(e.retina.sizeAnimationSpeed??t.retina.sizeAnimationSpeed)/100*t.retina.reduceFactor,r.sync||(e.size.velocity*=pi()))}isEnabled(e){return!e.destroyed&&!e.spawning&&e.size.enable&&((e.size.maxLoops??0)<=0||(e.size.maxLoops??0)>0&&(e.size.loops??0)<(e.size.maxLoops??0))}reset(e){e.size.loops=0}update(e,t){this.isEnabled(e)&&Y0e(e,t)}}async function Q0e(n,e=!0){await n.addParticleUpdater("size",()=>new J0e,e)}async function q0e(n,e=!0){await R0e(n,!1),await L0e(n,!1),await F0e(n,!1),await G0e(n,!1),await Z0e(n,!1),await Q0e(n,!1),await n.refresh(e)}async function ebe(){vN("ease-in-quad",n=>n**2),vN("ease-out-quad",n=>1-(1-n)**2),vN("ease-in-out-quad",n=>n<.5?2*n**2:1-(-2*n+2)**2/2)}class tbe{constructor(){this.distance=200,this.duration=.4,this.easing="ease-out-quad",this.factor=1,this.maxSpeed=50,this.speed=1}load(e){e&&(e.distance!==void 0&&(this.distance=e.distance),e.duration!==void 0&&(this.duration=e.duration),e.easing!==void 0&&(this.easing=e.easing),e.factor!==void 0&&(this.factor=e.factor),e.maxSpeed!==void 0&&(this.maxSpeed=e.maxSpeed),e.speed!==void 0&&(this.speed=e.speed))}}let nbe=class extends Uu{constructor(e,t){super(t),this._clickAttract=()=>{const i=this.container;i.attract||(i.attract={particles:[]});const{attract:r}=i;if(r.finish||(r.count||(r.count=0),r.count++,r.count===i.particles.count&&(r.finish=!0)),r.clicking){const s=i.interactivity.mouse.clickPosition,o=i.retina.attractModeDistance;if(!o||o<0||!s)return;this._processAttract(s,o,new Rs(s.x,s.y,o))}else r.clicking===!1&&(r.particles=[])},this._hoverAttract=()=>{const i=this.container,r=i.interactivity.mouse.position,s=i.retina.attractModeDistance;!s||s<0||!r||this._processAttract(r,s,new Rs(r.x,r.y,s))},this._processAttract=(i,r,s)=>{const o=this.container,a=o.actualOptions.interactivity.modes.attract;if(!a)return;const l=o.particles.quadTree.query(s,u=>this.isEnabled(u));for(const u of l){const{dx:c,dy:h,distance:d}=js(u.position,i),p=a.speed*a.factor,f=zl(UJ(a.easing)(1-d/r)*p,0,a.maxSpeed),g=Xr.create(d===0?p:c/d*f,d===0?p:h/d*f);u.position.subFrom(g)}},this._engine=e,t.attract||(t.attract={particles:[]}),this.handleClickMode=i=>{const r=this.container.actualOptions,s=r.interactivity.modes.attract;if(!(!s||i!=="attract")){t.attract||(t.attract={particles:[]}),t.attract.clicking=!0,t.attract.count=0;for(const o of t.attract.particles)this.isEnabled(o)&&o.velocity.setTo(o.initialVelocity);t.attract.particles=[],t.attract.finish=!1,setTimeout(()=>{t.destroyed||(t.attract||(t.attract={particles:[]}),t.attract.clicking=!1)},s.duration*1e3)}}}clear(){}init(){const e=this.container,t=e.actualOptions.interactivity.modes.attract;t&&(e.retina.attractModeDistance=t.distance*e.retina.pixelRatio)}async interact(){const e=this.container,t=e.actualOptions,i=e.interactivity.status===xf,r=t.interactivity.events,s=r.onHover.enable,o=r.onHover.mode,a=r.onClick.enable,l=r.onClick.mode;i&&s&&nr("attract",o)?this._hoverAttract():a&&nr("attract",l)&&this._clickAttract()}isEnabled(e){const t=this.container,i=t.actualOptions,r=t.interactivity.mouse,s=((e==null?void 0:e.interactivity)??i.interactivity).events;if((!r.position||!s.onHover.enable)&&(!r.clickPosition||!s.onClick.enable))return!1;const o=s.onHover.mode,a=s.onClick.mode;return nr("attract",o)||nr("attract",a)}loadModeOptions(e,...t){e.attract||(e.attract=new tbe);for(const i of t)e.attract.load(i==null?void 0:i.attract)}reset(){}};async function ibe(n,e=!0){await n.addInteractor("externalAttract",t=>new nbe(n,t),e)}class rbe{constructor(){this.distance=200}load(e){e&&e.distance!==void 0&&(this.distance=e.distance)}}class sbe extends Uu{constructor(e){super(e),this._processBounce=(t,i,r)=>{const s=this.container.particles.quadTree.query(r,o=>this.isEnabled(o));for(const o of s)r instanceof Rs?XJ(GD(o),{position:t,radius:i,mass:i**2*Math.PI/2,velocity:Xr.origin,factor:Xr.origin}):r instanceof Gl&&tye(o,F1(t,i))},this._processMouseBounce=()=>{const t=this.container,i=t.retina.pixelRatio,r=10*i,s=t.interactivity.mouse.position,o=t.retina.bounceModeDistance;!o||o<0||!s||this._processBounce(s,o,new Rs(s.x,s.y,o+r))},this._singleSelectorBounce=(t,i)=>{const r=this.container,s=document.querySelectorAll(t);s.length&&s.forEach(o=>{const a=o,l=r.retina.pixelRatio,u={x:(a.offsetLeft+a.offsetWidth/2)*l,y:(a.offsetTop+a.offsetHeight/2)*l},c=a.offsetWidth/2*l,h=10*l,d=i.type==="circle"?new Rs(u.x,u.y,c+h):new Gl(a.offsetLeft*l-h,a.offsetTop*l-h,a.offsetWidth*l+h*2,a.offsetHeight*l+h*2);this._processBounce(u,c,d)})}}clear(){}init(){const e=this.container,t=e.actualOptions.interactivity.modes.bounce;t&&(e.retina.bounceModeDistance=t.distance*e.retina.pixelRatio)}async interact(){const e=this.container,t=e.actualOptions,i=t.interactivity.events,r=e.interactivity.status===xf,s=i.onHover.enable,o=i.onHover.mode,a=i.onDiv;r&&s&&nr("bounce",o)?this._processMouseBounce():yB("bounce",a,(l,u)=>this._singleSelectorBounce(l,u))}isEnabled(e){const t=this.container,i=t.actualOptions,r=t.interactivity.mouse,s=((e==null?void 0:e.interactivity)??i.interactivity).events,o=s.onDiv;return r.position&&s.onHover.enable&&nr("bounce",s.onHover.mode)||gB("bounce",o)}loadModeOptions(e,...t){e.bounce||(e.bounce=new rbe);for(const i of t)e.bounce.load(i==null?void 0:i.bounce)}reset(){}}async function obe(n,e=!0){await n.addInteractor("externalBounce",t=>new sbe(t),e)}class d7{constructor(){this.distance=200,this.duration=.4,this.mix=!1}load(e){if(e){if(e.distance!==void 0&&(this.distance=e.distance),e.duration!==void 0&&(this.duration=e.duration),e.mix!==void 0&&(this.mix=e.mix),e.opacity!==void 0&&(this.opacity=e.opacity),e.color!==void 0){const t=ra(this.color)?void 0:this.color;this.color=Kr(e.color,i=>hs.create(t,i))}e.size!==void 0&&(this.size=e.size)}}}class abe extends d7{constructor(){super(),this.selectors=[]}get ids(){return Kr(this.selectors,e=>e.replace("#",""))}set ids(e){this.selectors=Kr(e,t=>`#${t}`)}load(e){super.load(e),e&&(e.ids!==void 0&&(this.ids=e.ids),e.selectors!==void 0&&(this.selectors=e.selectors))}}class lbe extends d7{load(e){super.load(e),e&&(this.divs=Kr(e.divs,t=>{const i=new abe;return i.load(t),i}))}}function e9(n,e,t,i){if(e>=t){const r=n+(e-t)*i;return zl(r,n,e)}else if(e<t){const r=n-(t-e)*i;return zl(r,e,n)}}class ube extends Uu{constructor(e){super(e),this._clickBubble=()=>{var u;const t=this.container,i=t.actualOptions,r=t.interactivity.mouse.clickPosition,s=i.interactivity.modes.bubble;if(!s||!r)return;t.bubble||(t.bubble={});const o=t.retina.bubbleModeDistance;if(!o||o<0)return;const a=t.particles.quadTree.queryCircle(r,o,c=>this.isEnabled(c)),{bubble:l}=t;for(const c of a){if(!l.clicking)continue;c.bubble.inRange=!l.durationEnd;const h=c.getPosition(),d=ia(h,r),p=(new Date().getTime()-(t.interactivity.mouse.clickTime||0))/1e3;p>s.duration&&(l.durationEnd=!0),p>s.duration*2&&(l.clicking=!1,l.durationEnd=!1);const f={bubbleObj:{optValue:t.retina.bubbleModeSize,value:c.bubble.radius},particlesObj:{optValue:zh(c.options.size.value)*t.retina.pixelRatio,value:c.size.value},type:"size"};this._process(c,d,p,f);const g={bubbleObj:{optValue:s.opacity,value:c.bubble.opacity},particlesObj:{optValue:zh(c.options.opacity.value),value:((u=c.opacity)==null?void 0:u.value)??1},type:"opacity"};this._process(c,d,p,g),!l.durationEnd&&d<=o?this._hoverBubbleColor(c,d):delete c.bubble.color}},this._hoverBubble=()=>{const t=this.container,i=t.interactivity.mouse.position,r=t.retina.bubbleModeDistance;if(!r||r<0||i===void 0)return;const s=t.particles.quadTree.queryCircle(i,r,o=>this.isEnabled(o));for(const o of s){o.bubble.inRange=!0;const a=o.getPosition(),l=ia(a,i),u=1-l/r;l<=r?u>=0&&t.interactivity.status===xf&&(this._hoverBubbleSize(o,u),this._hoverBubbleOpacity(o,u),this._hoverBubbleColor(o,u)):this.reset(o),t.interactivity.status===BD&&this.reset(o)}},this._hoverBubbleColor=(t,i,r)=>{const s=this.container.actualOptions,o=r??s.interactivity.modes.bubble;if(o){if(!t.bubble.finalColor){const a=o.color;if(!a)return;const l=_c(a);t.bubble.finalColor=Fv(l)}if(t.bubble.finalColor)if(o.mix){t.bubble.color=void 0;const a=t.getFillColor();t.bubble.color=a?QJ(bB(a,t.bubble.finalColor,1-i,i)):t.bubble.finalColor}else t.bubble.color=t.bubble.finalColor}},this._hoverBubbleOpacity=(t,i,r)=>{var h,d;const s=this.container,o=s.actualOptions,a=(r==null?void 0:r.opacity)??((h=o.interactivity.modes.bubble)==null?void 0:h.opacity);if(!a)return;const l=t.options.opacity.value,u=((d=t.opacity)==null?void 0:d.value)??1,c=e9(u,a,zh(l),i);c!==void 0&&(t.bubble.opacity=c)},this._hoverBubbleSize=(t,i,r)=>{const s=this.container,o=r!=null&&r.size?r.size*s.retina.pixelRatio:s.retina.bubbleModeSize;if(o===void 0)return;const a=zh(t.options.size.value)*s.retina.pixelRatio,l=t.size.value,u=e9(l,o,a,i);u!==void 0&&(t.bubble.radius=u)},this._process=(t,i,r,s)=>{const o=this.container,a=s.bubbleObj.optValue,l=o.actualOptions,u=l.interactivity.modes.bubble;if(!u||a===void 0)return;const c=u.duration,h=o.retina.bubbleModeDistance,d=s.particlesObj.optValue,p=s.bubbleObj.value,f=s.particlesObj.value||0,g=s.type;if(!(!h||h<0||a===d))if(o.bubble||(o.bubble={}),o.bubble.durationEnd)p&&(g==="size"&&delete t.bubble.radius,g==="opacity"&&delete t.bubble.opacity);else if(i<=h){if((p??f)!==a){const m=f-r*(f-a)/c;g==="size"&&(t.bubble.radius=m),g==="opacity"&&(t.bubble.opacity=m)}}else g==="size"&&delete t.bubble.radius,g==="opacity"&&delete t.bubble.opacity},this._singleSelectorHover=(t,i,r)=>{const s=this.container,o=document.querySelectorAll(i),a=s.actualOptions.interactivity.modes.bubble;!a||!o.length||o.forEach(l=>{const u=l,c=s.retina.pixelRatio,h={x:(u.offsetLeft+u.offsetWidth/2)*c,y:(u.offsetTop+u.offsetHeight/2)*c},d=u.offsetWidth/2*c,p=r.type==="circle"?new Rs(h.x,h.y,d):new Gl(u.offsetLeft*c,u.offsetTop*c,u.offsetWidth*c,u.offsetHeight*c),f=s.particles.quadTree.query(p,g=>this.isEnabled(g));for(const g of f){if(!p.contains(g.getPosition()))continue;g.bubble.inRange=!0;const y=a.divs,m=HJ(y,u);(!g.bubble.div||g.bubble.div!==u)&&(this.clear(g,t,!0),g.bubble.div=u),this._hoverBubbleSize(g,1,m),this._hoverBubbleOpacity(g,1,m),this._hoverBubbleColor(g,1,m)}})},e.bubble||(e.bubble={}),this.handleClickMode=t=>{t==="bubble"&&(e.bubble||(e.bubble={}),e.bubble.clicking=!0)}}clear(e,t,i){e.bubble.inRange&&!i||(delete e.bubble.div,delete e.bubble.opacity,delete e.bubble.radius,delete e.bubble.color)}init(){const e=this.container,t=e.actualOptions.interactivity.modes.bubble;t&&(e.retina.bubbleModeDistance=t.distance*e.retina.pixelRatio,t.size!==void 0&&(e.retina.bubbleModeSize=t.size*e.retina.pixelRatio))}async interact(e){const t=this.container.actualOptions,i=t.interactivity.events,r=i.onHover,s=i.onClick,o=r.enable,a=r.mode,l=s.enable,u=s.mode,c=i.onDiv;o&&nr("bubble",a)?this._hoverBubble():l&&nr("bubble",u)?this._clickBubble():yB("bubble",c,(h,d)=>this._singleSelectorHover(e,h,d))}isEnabled(e){const t=this.container,i=t.actualOptions,r=t.interactivity.mouse,s=((e==null?void 0:e.interactivity)??i.interactivity).events,{onClick:o,onDiv:a,onHover:l}=s,u=gB("bubble",a);return u||l.enable&&r.position||o.enable&&r.clickPosition?nr("bubble",l.mode)||nr("bubble",o.mode)||u:!1}loadModeOptions(e,...t){e.bubble||(e.bubble=new lbe);for(const i of t)e.bubble.load(i==null?void 0:i.bubble)}reset(e){e.bubble.inRange=!1}}async function cbe(n,e=!0){await n.addInteractor("externalBubble",t=>new ube(t),e)}class hbe{constructor(){this.opacity=.5}load(e){e&&e.opacity!==void 0&&(this.opacity=e.opacity)}}class dbe{constructor(){this.distance=80,this.links=new hbe,this.radius=60}get lineLinked(){return this.links}set lineLinked(e){this.links=e}get line_linked(){return this.links}set line_linked(e){this.links=e}load(e){e&&(e.distance!==void 0&&(this.distance=e.distance),this.links.load(e.links??e.lineLinked??e.line_linked),e.radius!==void 0&&(this.radius=e.radius))}}function pbe(n,e,t,i){const r=Math.floor(t.getRadius()/e.getRadius()),s=e.getFillColor(),o=t.getFillColor();if(!s||!o)return;const a=e.getPosition(),l=t.getPosition(),u=bB(s,o,e.getRadius(),t.getRadius()),c=n.createLinearGradient(a.x,a.y,l.x,l.y);return c.addColorStop(0,Ov(s,i)),c.addColorStop(r>1?1:r,Mc(u,i)),c.addColorStop(1,Ov(o,i)),c}function fbe(n,e,t,i,r){ov(n,i,r),n.lineWidth=e,n.strokeStyle=t,n.stroke()}function mbe(n,e,t,i){const r=n.actualOptions,s=r.interactivity.modes.connect;if(s)return pbe(e,t,i,s.links.opacity)}function gbe(n,e,t){n.canvas.draw(i=>{const r=mbe(n,i,e,t);if(!r)return;const s=e.getPosition(),o=t.getPosition();fbe(i,e.retina.linksWidth??0,r,s,o)})}class ybe extends Uu{constructor(e){super(e)}clear(){}init(){const e=this.container,t=e.actualOptions.interactivity.modes.connect;t&&(e.retina.connectModeDistance=t.distance*e.retina.pixelRatio,e.retina.connectModeRadius=t.radius*e.retina.pixelRatio)}async interact(){const e=this.container;if(e.actualOptions.interactivity.events.onHover.enable&&e.interactivity.status==="pointermove"){const i=e.interactivity.mouse.position;if(!e.retina.connectModeDistance||e.retina.connectModeDistance<0||!e.retina.connectModeRadius||e.retina.connectModeRadius<0||!i)return;const r=Math.abs(e.retina.connectModeRadius),s=e.particles.quadTree.queryCircle(i,r,a=>this.isEnabled(a));let o=0;for(const a of s){const l=a.getPosition();for(const u of s.slice(o+1)){const c=u.getPosition(),h=Math.abs(e.retina.connectModeDistance),d=Math.abs(l.x-c.x),p=Math.abs(l.y-c.y);d<h&&p<h&&gbe(e,a,u)}++o}}}isEnabled(e){const t=this.container,i=t.interactivity.mouse,r=((e==null?void 0:e.interactivity)??t.actualOptions.interactivity).events;return r.onHover.enable&&i.position?nr("connect",r.onHover.mode):!1}loadModeOptions(e,...t){e.connect||(e.connect=new dbe);for(const i of t)e.connect.load(i==null?void 0:i.connect)}reset(){}}async function bbe(n,e=!0){await n.addInteractor("externalConnect",t=>new ybe(t),e)}class xbe{constructor(){this.blink=!1,this.consent=!1,this.opacity=1}load(e){e&&(e.blink!==void 0&&(this.blink=e.blink),e.color!==void 0&&(this.color=hs.create(this.color,e.color)),e.consent!==void 0&&(this.consent=e.consent),e.opacity!==void 0&&(this.opacity=e.opacity))}}class vbe{constructor(){this.distance=100,this.links=new xbe}get lineLinked(){return this.links}set lineLinked(e){this.links=e}get line_linked(){return this.links}set line_linked(e){this.links=e}load(e){e&&(e.distance!==void 0&&(this.distance=e.distance),this.links.load(e.links??e.lineLinked??e.line_linked))}}function wbe(n,e,t,i,r,s){ov(n,t,i),n.strokeStyle=Mc(r,s),n.lineWidth=e,n.stroke()}function Sbe(n,e,t,i,r){n.canvas.draw(s=>{const o=e.getPosition();wbe(s,e.retina.linksWidth??0,o,r,t,i)})}class Tbe extends Uu{constructor(e){super(e)}clear(){}init(){const e=this.container,t=e.actualOptions.interactivity.modes.grab;t&&(e.retina.grabModeDistance=t.distance*e.retina.pixelRatio)}async interact(){var a;const e=this.container,t=e.actualOptions,i=t.interactivity;if(!i.modes.grab||!i.events.onHover.enable||e.interactivity.status!==xf)return;const r=e.interactivity.mouse.position;if(!r)return;const s=e.retina.grabModeDistance;if(!s||s<0)return;const o=e.particles.quadTree.queryCircle(r,s,l=>this.isEnabled(l));for(const l of o){const u=l.getPosition(),c=ia(u,r);if(c>s)continue;const h=i.modes.grab.links,d=h.opacity,p=d-c*d/s;if(p<=0)continue;const f=h.color??((a=l.options.links)==null?void 0:a.color);if(!e.particles.grabLineColor&&f){const y=i.modes.grab.links;e.particles.grabLineColor=e7(f,y.blink,y.consent)}const g=VD(l,void 0,e.particles.grabLineColor);g&&Sbe(e,l,g,p,r)}}isEnabled(e){const t=this.container,i=t.interactivity.mouse,r=((e==null?void 0:e.interactivity)??t.actualOptions.interactivity).events;return r.onHover.enable&&!!i.position&&nr("grab",r.onHover.mode)}loadModeOptions(e,...t){e.grab||(e.grab=new vbe);for(const i of t)e.grab.load(i==null?void 0:i.grab)}reset(){}}async function Cbe(n,e=!0){await n.addInteractor("externalGrab",t=>new Tbe(t),e)}class _be extends Uu{constructor(e){super(e),this.handleClickMode=t=>{if(t!=="pause")return;const i=this.container;i.getAnimationStatus()?i.pause():i.play()}}clear(){}init(){}async interact(){}isEnabled(){return!0}reset(){}}async function Mbe(n,e=!0){await n.addInteractor("externalPause",t=>new _be(t),e)}class Abe{constructor(){this.default=!0,this.groups=[],this.quantity=4}get particles_nb(){return this.quantity}set particles_nb(e){this.quantity=dn(e)}load(e){if(!e)return;e.default!==void 0&&(this.default=e.default),e.groups!==void 0&&(this.groups=e.groups.map(i=>i)),this.groups.length||(this.default=!0);const t=e.quantity??e.particles_nb;t!==void 0&&(this.quantity=dn(t))}}class Ebe extends Uu{constructor(e){super(e),this.handleClickMode=t=>{if(t!=="push")return;const i=this.container,r=i.actualOptions,s=r.interactivity.modes.push;if(!s)return;const o=Vt(s.quantity);if(o<=0)return;const a=tE([void 0,...s.groups]),l=a!==void 0?i.actualOptions.particles.groups[a]:void 0;i.particles.push(o,i.interactivity.mouse,l,a)}}clear(){}init(){}async interact(){}isEnabled(){return!0}loadModeOptions(e,...t){e.push||(e.push=new Abe);for(const i of t)e.push.load(i==null?void 0:i.push)}reset(){}}async function Ibe(n,e=!0){await n.addInteractor("externalPush",t=>new Ebe(t),e)}class kbe{constructor(){this.quantity=2}get particles_nb(){return this.quantity}set particles_nb(e){this.quantity=dn(e)}load(e){if(!e)return;const t=e.quantity??e.particles_nb;t!==void 0&&(this.quantity=dn(t))}}class Rbe extends Uu{constructor(e){super(e),this.handleClickMode=t=>{const i=this.container,r=i.actualOptions;if(!r.interactivity.modes.remove||t!=="remove")return;const s=Vt(r.interactivity.modes.remove.quantity);i.particles.removeQuantity(s)}}clear(){}init(){}async interact(){}isEnabled(){return!0}loadModeOptions(e,...t){e.remove||(e.remove=new kbe);for(const i of t)e.remove.load(i==null?void 0:i.remove)}reset(){}}async function Nbe(n,e=!0){await n.addInteractor("externalRemove",t=>new Rbe(t),e)}class p7{constructor(){this.distance=200,this.duration=.4,this.factor=100,this.speed=1,this.maxSpeed=50,this.easing="ease-out-quad"}load(e){e&&(e.distance!==void 0&&(this.distance=e.distance),e.duration!==void 0&&(this.duration=e.duration),e.easing!==void 0&&(this.easing=e.easing),e.factor!==void 0&&(this.factor=e.factor),e.speed!==void 0&&(this.speed=e.speed),e.maxSpeed!==void 0&&(this.maxSpeed=e.maxSpeed))}}class Lbe extends p7{constructor(){super(),this.selectors=[]}get ids(){return Kr(this.selectors,e=>e.replace("#",""))}set ids(e){this.selectors=Kr(e,t=>`#${t}`)}load(e){super.load(e),e&&(e.ids!==void 0&&(this.ids=e.ids),e.selectors!==void 0&&(this.selectors=e.selectors))}}class Pbe extends p7{load(e){super.load(e),e&&(this.divs=Kr(e.divs,t=>{const i=new Lbe;return i.load(t),i}))}}class Dbe extends Uu{constructor(e,t){super(t),this._clickRepulse=()=>{const i=this.container,r=i.actualOptions.interactivity.modes.repulse;if(!r)return;const s=i.repulse||{particles:[]};if(s.finish||(s.count||(s.count=0),s.count++,s.count===i.particles.count&&(s.finish=!0)),s.clicking){const o=i.retina.repulseModeDistance;if(!o||o<0)return;const a=Math.pow(o/6,3),l=i.interactivity.mouse.clickPosition;if(l===void 0)return;const u=new Rs(l.x,l.y,a),c=i.particles.quadTree.query(u,h=>this.isEnabled(h));for(const h of c){const{dx:d,dy:p,distance:f}=js(l,h.position),g=f**2,y=r.speed,m=-a*y/g;if(g<=a){s.particles.push(h);const v=Xr.create(d,p);v.length=m,h.velocity.setTo(v)}}}else if(s.clicking===!1){for(const o of s.particles)o.velocity.setTo(o.initialVelocity);s.particles=[]}},this._hoverRepulse=()=>{const i=this.container,r=i.interactivity.mouse.position,s=i.retina.repulseModeDistance;!s||s<0||!r||this._processRepulse(r,s,new Rs(r.x,r.y,s))},this._processRepulse=(i,r,s,o)=>{const a=this.container,l=a.particles.quadTree.query(s,c=>this.isEnabled(c)),u=a.actualOptions.interactivity.modes.repulse;if(u)for(const c of l){const{dx:h,dy:d,distance:p}=js(c.position,i),f=((o==null?void 0:o.speed)??u.speed)*u.factor,g=zl(UJ(u.easing)(1-p/r)*f,0,u.maxSpeed),y=Xr.create(p===0?f:h/p*g,p===0?f:d/p*g);c.position.addTo(y)}},this._singleSelectorRepulse=(i,r)=>{const s=this.container,o=s.actualOptions.interactivity.modes.repulse;if(!o)return;const a=document.querySelectorAll(i);a.length&&a.forEach(l=>{const u=l,c=s.retina.pixelRatio,h={x:(u.offsetLeft+u.offsetWidth/2)*c,y:(u.offsetTop+u.offsetHeight/2)*c},d=u.offsetWidth/2*c,p=r.type==="circle"?new Rs(h.x,h.y,d):new Gl(u.offsetLeft*c,u.offsetTop*c,u.offsetWidth*c,u.offsetHeight*c),f=o.divs,g=HJ(f,u);this._processRepulse(h,d,p,g)})},this._engine=e,t.repulse||(t.repulse={particles:[]}),this.handleClickMode=i=>{const r=this.container.actualOptions,s=r.interactivity.modes.repulse;if(!s||i!=="repulse")return;t.repulse||(t.repulse={particles:[]});const o=t.repulse;o.clicking=!0,o.count=0;for(const a of t.repulse.particles)this.isEnabled(a)&&a.velocity.setTo(a.initialVelocity);o.particles=[],o.finish=!1,setTimeout(()=>{t.destroyed||(o.clicking=!1)},s.duration*1e3)}}clear(){}init(){const e=this.container,t=e.actualOptions.interactivity.modes.repulse;t&&(e.retina.repulseModeDistance=t.distance*e.retina.pixelRatio)}async interact(){const e=this.container,t=e.actualOptions,i=e.interactivity.status===xf,r=t.interactivity.events,s=r.onHover,o=s.enable,a=s.mode,l=r.onClick,u=l.enable,c=l.mode,h=r.onDiv;i&&o&&nr("repulse",a)?this._hoverRepulse():u&&nr("repulse",c)?this._clickRepulse():yB("repulse",h,(d,p)=>this._singleSelectorRepulse(d,p))}isEnabled(e){const t=this.container,i=t.actualOptions,r=t.interactivity.mouse,s=((e==null?void 0:e.interactivity)??i.interactivity).events,o=s.onDiv,a=s.onHover,l=s.onClick,u=gB("repulse",o);if(!(u||a.enable&&r.position||l.enable&&r.clickPosition))return!1;const c=a.mode,h=l.mode;return nr("repulse",c)||nr("repulse",h)||u}loadModeOptions(e,...t){e.repulse||(e.repulse=new Pbe);for(const i of t)e.repulse.load(i==null?void 0:i.repulse)}reset(){}}async function Fbe(n,e=!0){await n.addInteractor("externalRepulse",t=>new Dbe(n,t),e)}class Obe{constructor(){this.factor=3,this.radius=200}load(e){e&&(e.factor!==void 0&&(this.factor=e.factor),e.radius!==void 0&&(this.radius=e.radius))}}class Bbe extends Uu{constructor(e){super(e)}clear(e,t,i){e.slow.inRange&&!i||(e.slow.factor=1)}init(){const e=this.container,t=e.actualOptions.interactivity.modes.slow;t&&(e.retina.slowModeRadius=t.radius*e.retina.pixelRatio)}async interact(){}isEnabled(e){const t=this.container,i=t.interactivity.mouse,r=((e==null?void 0:e.interactivity)??t.actualOptions.interactivity).events;return r.onHover.enable&&!!i.position&&nr("slow",r.onHover.mode)}loadModeOptions(e,...t){e.slow||(e.slow=new Obe);for(const i of t)e.slow.load(i==null?void 0:i.slow)}reset(e){e.slow.inRange=!1;const t=this.container,i=t.actualOptions,r=t.interactivity.mouse.position,s=t.retina.slowModeRadius,o=i.interactivity.modes.slow;if(!o||!s||s<0||!r)return;const a=e.getPosition(),l=ia(r,a),u=l/s,c=o.factor,{slow:h}=e;l>s||(h.inRange=!0,h.factor=u/c)}}async function zbe(n,e=!0){await n.addInteractor("externalSlow",t=>new Bbe(t),e)}const PN=[0,4,2,1],t9=[8,8,4,2];class Gbe{constructor(e){this.pos=0,this.data=new Uint8ClampedArray(e)}getString(e){const t=this.data.slice(this.pos,this.pos+e);return this.pos+=t.length,t.reduce((i,r)=>i+String.fromCharCode(r),"")}nextByte(){return this.data[this.pos++]}nextTwoBytes(){return this.pos+=2,this.data[this.pos-2]+(this.data[this.pos-1]<<8)}readSubBlocks(){let e="",t=0;do{t=this.data[this.pos++];for(let i=t;--i>=0;e+=String.fromCharCode(this.data[this.pos++]));}while(t!==0);return e}readSubBlocksBin(){let e=0,t=0;for(let r=0;(e=this.data[this.pos+r])!==0;r+=e+1)t+=e;const i=new Uint8Array(t);for(let r=0;(e=this.data[this.pos++])!==0;)for(let s=e;--s>=0;i[r++]=this.data[this.pos++]);return i}skipSubBlocks(){for(;this.data[this.pos]!==0;this.pos+=this.data[this.pos]+1);this.pos++}}function f7(n,e){const t=[];for(let i=0;i<e;i++)t.push({r:n.data[n.pos],g:n.data[n.pos+1],b:n.data[n.pos+2]}),n.pos+=3;return t}async function Vbe(n,e,t,i){switch(n.nextByte()){case 249:{const r=e.frames[t(!1)];n.pos++;const s=n.nextByte();r.GCreserved=(s&224)>>>5,r.disposalMethod=(s&28)>>>2,r.userInputDelayFlag=(s&2)===2;const o=(s&1)===1;r.delayTime=n.nextTwoBytes()*10;const a=n.nextByte();o&&i(a),n.pos++;break}case 255:{n.pos++;const r={identifier:n.getString(8),authenticationCode:n.getString(3),data:n.readSubBlocksBin()};e.applicationExtensions.push(r);break}case 254:{e.comments.push([t(!1),n.readSubBlocks()]);break}case 1:{if(e.globalColorTable.length===0)throw new EvalError("plain text extension without global color table");n.pos++,e.frames[t(!1)].plainTextData={left:n.nextTwoBytes(),top:n.nextTwoBytes(),width:n.nextTwoBytes(),height:n.nextTwoBytes(),charSize:{width:n.nextTwoBytes(),height:n.nextTwoBytes()},foregroundColor:n.nextByte(),backgroundColor:n.nextByte(),text:n.readSubBlocks()};break}default:n.skipSubBlocks();break}}async function Ube(n,e,t,i,r,s){const o=e.frames[i(!0)];o.left=n.nextTwoBytes(),o.top=n.nextTwoBytes(),o.width=n.nextTwoBytes(),o.height=n.nextTwoBytes();const a=n.nextByte(),l=(a&128)===128,u=(a&64)===64;o.sortFlag=(a&32)===32,o.reserved=(a&24)>>>3;const c=1<<(a&7)+1;l&&(o.localColorTable=f7(n,c));const h=m=>{const{r:v,g:w,b:S}=(l?o.localColorTable:e.globalColorTable)[m];return{r:v,g:w,b:S,a:m===r(null)?t?~~((v+w+S)/3):0:255}},d=(()=>{try{return new ImageData(o.width,o.height,{colorSpace:"srgb"})}catch(m){if(m instanceof DOMException&&m.name==="IndexSizeError")return null;throw m}})();if(d==null)throw new EvalError("GIF frame size is to large");const p=n.nextByte(),f=n.readSubBlocksBin(),g=1<<p,y=(m,v)=>{const w=m>>>3,S=m&7;return(f[w]+(f[w+1]<<8)+(f[w+2]<<16)&(1<<v)-1<<S)>>>S};if(u){for(let m=0,v=p+1,w=0,S=[[0]],C=0;C<4;C++){if(PN[C]<o.height)for(let _=0,A=0;;){const I=m;if(m=y(w,v),w+=v+1,m===g){v=p+1,S.length=g+2;for(let E=0;E<S.length;E++)S[E]=E<g?[E]:[]}else{m>=S.length?S.push(S[I].concat(S[I][0])):I!==g&&S.push(S[I].concat(S[m][0]));for(let E=0;E<S[m].length;E++){const{r:k,g:P,b:V,a:U}=h(S[m][E]);d.data.set([k,P,V,U],PN[C]*o.width+t9[C]*A+_%(o.width*4)),_+=4}S.length===1<<v&&v<12&&v++}if(_===o.width*4*(A+1)&&(A++,PN[C]+t9[C]*A>=o.height))break}s==null||s(n.pos/(n.data.length-1),i(!1)+1,d,{x:o.left,y:o.top},{width:e.width,height:e.height})}o.image=d,o.bitmap=await createImageBitmap(d)}else{for(let m=0,v=p+1,w=0,S=[[0]],C=-4;;){const _=m;if(m=y(w,v),w+=v,m===g){v=p+1,S.length=g+2;for(let A=0;A<S.length;A++)S[A]=A<g?[A]:[]}else{if(m===g+1)break;m>=S.length?S.push(S[_].concat(S[_][0])):_!==g&&S.push(S[_].concat(S[m][0]));for(let A=0;A<S[m].length;A++){const{r:I,g:E,b:k,a:P}=h(S[m][A]);d.data.set([I,E,k,P],C+=4)}S.length>=1<<v&&v<12&&v++}}o.image=d,o.bitmap=await createImageBitmap(d),s==null||s((n.pos+1)/n.data.length,i(!1)+1,o.image,{x:o.left,y:o.top},{width:e.width,height:e.height})}}async function $be(n,e,t,i,r,s){switch(n.nextByte()){case 59:return!0;case 44:await Ube(n,e,t,i,r,s);break;case 33:await Vbe(n,e,i,r);break;default:throw new EvalError("undefined block found")}return!1}function Wbe(n){for(const e of n.applicationExtensions)if(e.identifier+e.authenticationCode==="NETSCAPE2.0")return e.data[1]+(e.data[2]<<8);return NaN}async function Hbe(n,e,t){t||(t=!1);const i=await fetch(n);if(!i.ok&&i.status===404)throw new EvalError("file not found");const r=await i.arrayBuffer(),s={width:0,height:0,totalTime:0,colorRes:0,pixelAspectRatio:0,frames:[],sortFlag:!1,globalColorTable:[],backgroundImage:new ImageData(1,1,{colorSpace:"srgb"}),comments:[],applicationExtensions:[]},o=new Gbe(new Uint8ClampedArray(r));if(o.getString(6)!=="GIF89a")throw new Error("not a supported GIF file");s.width=o.nextTwoBytes(),s.height=o.nextTwoBytes();const a=o.nextByte(),l=(a&128)===128;s.colorRes=(a&112)>>>4,s.sortFlag=(a&8)===8;const u=1<<(a&7)+1,c=o.nextByte();s.pixelAspectRatio=o.nextByte(),s.pixelAspectRatio!==0&&(s.pixelAspectRatio=(s.pixelAspectRatio+15)/64),l&&(s.globalColorTable=f7(o,u));const h=(()=>{try{return new ImageData(s.width,s.height,{colorSpace:"srgb"})}catch(S){if(S instanceof DOMException&&S.name==="IndexSizeError")return null;throw S}})();if(h==null)throw new Error("GIF frame size is to large");const{r:d,g:p,b:f}=s.globalColorTable[c];h.data.set(l?[d,p,f,255]:[0,0,0,0]);for(let S=4;S<h.data.length;S*=2)h.data.copyWithin(S,0,S);s.backgroundImage=h;let g=-1,y=!0,m=-1;const v=S=>(S&&(y=!0),g),w=S=>(S!=null&&(m=S),m);try{do y&&(s.frames.push({left:0,top:0,width:0,height:0,disposalMethod:0,image:new ImageData(1,1,{colorSpace:"srgb"}),plainTextData:null,userInputDelayFlag:!1,delayTime:0,sortFlag:!1,localColorTable:[],reserved:0,GCreserved:0}),g++,m=-1,y=!1);while(!await $be(o,s,t,v,w,e));s.frames.length--;for(const S of s.frames){if(S.userInputDelayFlag&&S.delayTime===0){s.totalTime=1/0;break}s.totalTime+=S.delayTime}return s}catch(S){throw S instanceof EvalError?new Error(`error while parsing frame ${g} "${S.message}"`):S}}const Xbe=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi;function Kbe(n,e,t){const{svgData:i}=n;if(!i)return"";const r=Ov(e,t);if(i.includes("fill"))return i.replace(Xbe,()=>r);const s=i.indexOf(">");return`${i.substring(0,s)} fill="${r}"${i.substring(s)}`}async function iE(n){return new Promise(e=>{n.loading=!0;const t=new Image;n.element=t,t.addEventListener("load",()=>{n.loading=!1,e()}),t.addEventListener("error",()=>{n.element=void 0,n.error=!0,n.loading=!1,wf().error(`${Qa} loading image: ${n.source}`),e()}),t.src=n.source})}async function Zbe(n){if(n.type!=="gif"){await iE(n);return}n.loading=!0;try{n.gifData=await Hbe(n.source),n.gifLoopCount=Wbe(n.gifData)??0,n.gifLoopCount===0&&(n.gifLoopCount=1/0)}catch{n.error=!0}n.loading=!1}async function jbe(n){if(n.type!=="svg"){await iE(n);return}n.loading=!0;const e=await fetch(n.source);e.ok?n.svgData=await e.text():(wf().error(`${Qa} Image not found`),n.error=!0),n.loading=!1}function Ybe(n,e,t,i){var o;const r=Kbe(n,t,((o=i.opacity)==null?void 0:o.value)??1),s={color:t,gif:e.gif,data:{...n,svgData:r},loaded:!1,ratio:e.width/e.height,replaceColor:e.replaceColor??e.replace_color,source:e.src};return new Promise(a=>{const l=new Blob([r],{type:"image/svg+xml"}),u=URL||window.URL||window.webkitURL||window,c=u.createObjectURL(l),h=new Image;h.addEventListener("load",()=>{s.loaded=!0,s.element=h,a(s),u.revokeObjectURL(c)}),h.addEventListener("error",async()=>{u.revokeObjectURL(c);const d={...n,error:!1,loading:!0};await iE(d),s.loaded=!0,s.element=d.element,a(s)}),h.src=c})}class Jbe{constructor(e){this.loadImageShape=async t=>{if(!this._engine.loadImage)throw new Error(`${Qa} image shape not initialized`);await this._engine.loadImage({gif:t.gif,name:t.name,replaceColor:t.replaceColor??t.replace_color??!1,src:t.src})},this._engine=e}addImage(e){this._engine.images||(this._engine.images=[]),this._engine.images.push(e)}draw(e,t,i,r,s){const o=t.image,a=o==null?void 0:o.element;if(o){if(e.globalAlpha=r,o.gif&&o.gifData){const l=new OffscreenCanvas(o.gifData.width,o.gifData.height),u=l.getContext("2d");if(!u)throw new Error("could not create offscreen canvas context");u.imageSmoothingQuality="low",u.imageSmoothingEnabled=!1,u.clearRect(0,0,l.width,l.height),t.gifLoopCount===void 0&&(t.gifLoopCount=o.gifLoopCount??0);let c=t.gifFrame??0;const h={x:-o.gifData.width*.5,y:-o.gifData.height*.5},d=o.gifData.frames[c];if(t.gifTime===void 0&&(t.gifTime=0),!d.bitmap)return;switch(e.scale(i/o.gifData.width,i/o.gifData.height),d.disposalMethod){case 4:case 5:case 6:case 7:case 0:u.drawImage(d.bitmap,d.left,d.top),e.drawImage(l,h.x,h.y),u.clearRect(0,0,l.width,l.height);break;case 1:u.drawImage(d.bitmap,d.left,d.top),e.drawImage(l,h.x,h.y);break;case 2:u.drawImage(d.bitmap,d.left,d.top),e.drawImage(l,h.x,h.y),u.clearRect(0,0,l.width,l.height),o.gifData.globalColorTable.length===0?u.putImageData(o.gifData.frames[0].image,h.x+d.left,h.y+d.top):u.putImageData(o.gifData.backgroundImage,h.x,h.y);break;case 3:{const p=u.getImageData(0,0,l.width,l.height);u.drawImage(d.bitmap,d.left,d.top),e.drawImage(l,h.x,h.y),u.clearRect(0,0,l.width,l.height),u.putImageData(p,0,0)}break}if(t.gifTime+=s.value,t.gifTime>d.delayTime){if(t.gifTime-=d.delayTime,++c>=o.gifData.frames.length){if(--t.gifLoopCount<=0)return;c=0,u.clearRect(0,0,l.width,l.height)}t.gifFrame=c}e.scale(o.gifData.width/i,o.gifData.height/i)}else if(a){const l=o.ratio,u={x:-i,y:-i};e.drawImage(a,u.x,u.y,i*2,i*2/l)}e.globalAlpha=1}}getSidesCount(){return 12}async init(e){const t=e.actualOptions;if(!(!t.preload||!this._engine.loadImage))for(const i of t.preload)await this._engine.loadImage(i)}loadShape(e){if(e.shape!=="image"&&e.shape!=="images")return;this._engine.images||(this._engine.images=[]);const t=e.shapeData;this._engine.images.find(r=>r.name===t.name||r.source===t.src)||this.loadImageShape(t).then(()=>{this.loadShape(e)})}particleInit(e,t){if(t.shape!=="image"&&t.shape!=="images")return;this._engine.images||(this._engine.images=[]);const i=this._engine.images,r=t.shapeData,s=t.getFillColor(),o=i.find(l=>l.name===r.name||l.source===r.src);if(!o)return;const a=r.replaceColor??r.replace_color??o.replaceColor;if(o.loading){setTimeout(()=>{this.particleInit(e,t)});return}(async()=>{let l;o.svgData&&s?l=await Ybe(o,r,s,t):l={color:s,data:o,element:o.element,gif:o.gif,gifData:o.gifData,gifLoopCount:o.gifLoopCount,loaded:!0,ratio:r.width&&r.height?r.width/r.height:o.ratio??1,replaceColor:a,source:r.src},l.ratio||(l.ratio=1);const u=r.fill??t.fill,c=r.close??t.close,h={image:l,fill:u,close:c};t.image=h.image,t.fill=h.fill,t.close=h.close})()}}class Qbe{constructor(){this.src="",this.gif=!1}load(e){e&&(e.gif!==void 0&&(this.gif=e.gif),e.height!==void 0&&(this.height=e.height),e.name!==void 0&&(this.name=e.name),e.replaceColor!==void 0&&(this.replaceColor=e.replaceColor),e.src!==void 0&&(this.src=e.src),e.width!==void 0&&(this.width=e.width))}}class qbe{constructor(e){this.id="imagePreloader",this._engine=e}getPlugin(){return{}}loadOptions(e,t){if(!t||!t.preload)return;e.preload||(e.preload=[]);const i=e.preload;for(const r of t.preload){const s=i.find(o=>o.name===r.name||o.src===r.src);if(s)s.load(r);else{const o=new Qbe;o.load(r),i.push(o)}}}needsPlugin(){return!0}}function exe(n){n.loadImage||(n.loadImage=async e=>{if(!e.name&&!e.src)throw new Error(`${Qa} no image source provided`);if(n.images||(n.images=[]),!n.images.find(t=>t.name===e.name||t.source===e.src))try{const t={gif:e.gif??!1,name:e.name??e.src,source:e.src,type:e.src.substring(e.src.length-3),error:!1,loading:!0,replaceColor:e.replaceColor,ratio:e.width&&e.height?e.width/e.height:void 0};n.images.push(t),await(e.gif?Zbe:e.replaceColor?jbe:iE)(t)}catch{throw new Error(`${Qa} ${e.name??e.src} not found`)}})}async function txe(n,e=!0){exe(n);const t=new qbe(n);await n.addPlugin(t,e),await n.addShape(["image","images"],new Jbe(n),e)}class nxe extends Rd{constructor(){super(),this.sync=!1}load(e){e&&(super.load(e),e.sync!==void 0&&(this.sync=e.sync))}}class ixe extends Rd{constructor(){super(),this.random.minimumValue=1e-4,this.sync=!1}load(e){e&&(super.load(e),e.sync!==void 0&&(this.sync=e.sync))}}class rxe{constructor(){this.count=0,this.delay=new nxe,this.duration=new ixe}load(e){e&&(e.count!==void 0&&(this.count=e.count),this.delay.load(e.delay),this.duration.load(e.duration))}}class sxe{constructor(e){this.container=e}init(e){const t=this.container,i=e.options,r=i.life;r&&(e.life={delay:t.retina.reduceFactor?Vt(r.delay.value)*(r.delay.sync?1:pi())/t.retina.reduceFactor*1e3:0,delayTime:0,duration:t.retina.reduceFactor?Vt(r.duration.value)*(r.duration.sync?1:pi())/t.retina.reduceFactor*1e3:0,time:0,count:r.count},e.life.duration<=0&&(e.life.duration=-1),e.life.count<=0&&(e.life.count=-1),e.life&&(e.spawning=e.life.delay>0))}isEnabled(e){return!e.destroyed}loadOptions(e,...t){e.life||(e.life=new rxe);for(const i of t)e.life.load(i==null?void 0:i.life)}update(e,t){if(!this.isEnabled(e)||!e.life)return;const i=e.life;let r=!1;if(e.spawning)if(i.delayTime+=t.value,i.delayTime>=e.life.delay)r=!0,e.spawning=!1,i.delayTime=0,i.time=0;else return;if(i.duration===-1||e.spawning||(r?i.time=0:i.time+=t.value,i.time<i.duration))return;if(i.time=0,e.life.count>0&&e.life.count--,e.life.count===0){e.destroy();return}const s=this.container.canvas.size,o=dn(0,s.width),a=dn(0,s.width);e.position.x=To(o),e.position.y=To(a),e.spawning=!0,i.delayTime=0,i.time=0,e.reset();const l=e.options.life;l&&(i.delay=Vt(l.delay.value)*1e3,i.duration=Vt(l.duration.value)*1e3)}}async function oxe(n,e=!0){await n.addParticleUpdater("life",t=>new sxe(t),e)}class axe{draw(e,t,i){const r=t.shapeData;e.moveTo(-i/2,0),e.lineTo(i/2,0),e.lineCap=(r==null?void 0:r.cap)??"butt"}getSidesCount(){return 1}}async function lxe(n,e=!0){await n.addShape("line",new axe,e)}class uxe{init(){}isEnabled(e){return!Sy()&&!e.destroyed&&e.container.actualOptions.interactivity.events.onHover.parallax.enable}move(e){const t=e.container,i=t.actualOptions,r=i.interactivity.events.onHover.parallax;if(Sy()||!r.enable)return;const s=r.force,o=t.interactivity.mouse.position;if(!o)return;const a=t.canvas.size,l={x:a.width/2,y:a.height/2},u=r.smooth,c=e.getRadius()/s,h={x:(o.x-l.x)*c,y:(o.y-l.y)*c},{offset:d}=e;d.x+=(h.x-d.x)/u,d.y+=(h.y-d.y)/u}}async function cxe(n,e=!0){await n.addMover("parallax",()=>new uxe,e)}class hxe extends xB{constructor(e){super(e)}clear(){}init(){}async interact(e){const t=this.container,i=e.retina.attractDistance??t.retina.attractDistance,r=e.getPosition(),s=t.particles.quadTree.queryCircle(r,i);for(const o of s){if(e===o||!o.options.move.attract.enable||o.destroyed||o.spawning)continue;const a=o.getPosition(),{dx:l,dy:u}=js(r,a),c=e.options.move.attract.rotate,h=l/(c.x*1e3),d=u/(c.y*1e3),p=o.size.value/e.size.value,f=1/p;e.velocity.x-=h*p,e.velocity.y-=d*p,o.velocity.x+=h*f,o.velocity.y+=d*f}}isEnabled(e){return e.options.move.attract.enable}reset(){}}async function dxe(n,e=!0){await n.addInteractor("particlesAttract",t=>new hxe(t),e)}function n9(n,e,t,i,r,s){const o=zl(n.options.collisions.absorb.speed*r.factor/10,0,i);n.size.value+=o/2,t.size.value-=o,i<=s&&(t.size.value=0,t.destroy())}function pxe(n,e,t,i){const r=n.getRadius(),s=e.getRadius();r===void 0&&s!==void 0?n.destroy():r!==void 0&&s===void 0?e.destroy():r!==void 0&&s!==void 0&&(r>=s?n9(n,r,e,s,t,i):n9(e,s,n,r,t,i))}const i9=n=>{n.collisionMaxSpeed===void 0&&(n.collisionMaxSpeed=Vt(n.options.collisions.maxSpeed)),n.velocity.length>n.collisionMaxSpeed&&(n.velocity.length=n.collisionMaxSpeed)};function m7(n,e){XJ(GD(n),GD(e)),i9(n),i9(e)}function fxe(n,e){!n.unbreakable&&!e.unbreakable&&m7(n,e),n.getRadius()===void 0&&e.getRadius()!==void 0?n.destroy():n.getRadius()!==void 0&&e.getRadius()===void 0?e.destroy():n.getRadius()!==void 0&&e.getRadius()!==void 0&&(n.getRadius()>=e.getRadius()?e:n).destroy()}function mxe(n,e,t,i){switch(n.options.collisions.mode){case"absorb":{pxe(n,e,t,i);break}case"bounce":{m7(n,e);break}case"destroy":{fxe(n,e);break}}}class gxe extends xB{constructor(e){super(e)}clear(){}init(){}async interact(e,t){if(e.destroyed||e.spawning)return;const i=this.container,r=e.getPosition(),s=e.getRadius(),o=i.particles.quadTree.queryCircle(r,s*2);for(const a of o){if(e===a||!a.options.collisions.enable||e.options.collisions.mode!==a.options.collisions.mode||a.destroyed||a.spawning)continue;const l=a.getPosition(),u=a.getRadius();if(Math.abs(Math.round(r.z)-Math.round(l.z))>s+u)continue;const c=ia(r,l),h=s+u;c>h||mxe(e,a,t,i.retina.pixelRatio)}}isEnabled(e){return e.options.collisions.enable}reset(){}}async function yxe(n,e=!0){await n.addInteractor("particlesCollisions",t=>new gxe(t),e)}class bxe extends Rs{constructor(e,t,i,r){super(e,t,i),this.canvasSize=r,this.canvasSize={...r}}contains(e){const{width:t,height:i}=this.canvasSize,{x:r,y:s}=e;return super.contains(e)||super.contains({x:r-t,y:s})||super.contains({x:r-t,y:s-i})||super.contains({x:r,y:s-i})}intersects(e){if(super.intersects(e))return!0;const t=e,i=e,r={x:e.position.x-this.canvasSize.width,y:e.position.y-this.canvasSize.height};if(i.radius!==void 0){const s=new Rs(r.x,r.y,i.radius*2);return super.intersects(s)}else if(t.size!==void 0){const s=new Gl(r.x,r.y,t.size.width*2,t.size.height*2);return super.intersects(s)}return!1}}class xxe{constructor(){this.blur=5,this.color=new hs,this.color.value="#000",this.enable=!1}load(e){e&&(e.blur!==void 0&&(this.blur=e.blur),this.color=hs.create(this.color,e.color),e.enable!==void 0&&(this.enable=e.enable))}}class vxe{constructor(){this.enable=!1,this.frequency=1}load(e){e&&(e.color!==void 0&&(this.color=hs.create(this.color,e.color)),e.enable!==void 0&&(this.enable=e.enable),e.frequency!==void 0&&(this.frequency=e.frequency),e.opacity!==void 0&&(this.opacity=e.opacity))}}class wxe{constructor(){this.blink=!1,this.color=new hs,this.color.value="#fff",this.consent=!1,this.distance=100,this.enable=!1,this.frequency=1,this.opacity=1,this.shadow=new xxe,this.triangles=new vxe,this.width=1,this.warp=!1}load(e){e&&(e.id!==void 0&&(this.id=e.id),e.blink!==void 0&&(this.blink=e.blink),this.color=hs.create(this.color,e.color),e.consent!==void 0&&(this.consent=e.consent),e.distance!==void 0&&(this.distance=e.distance),e.enable!==void 0&&(this.enable=e.enable),e.frequency!==void 0&&(this.frequency=e.frequency),e.opacity!==void 0&&(this.opacity=e.opacity),this.shadow.load(e.shadow),this.triangles.load(e.triangles),e.width!==void 0&&(this.width=e.width),e.warp!==void 0&&(this.warp=e.warp))}}function Sxe(n,e,t,i,r){const{dx:s,dy:o,distance:a}=js(n,e);if(!r||a<=t)return a;const l={x:Math.abs(s),y:Math.abs(o)},u={x:Math.min(l.x,i.width-l.x),y:Math.min(l.y,i.height-l.y)};return Math.sqrt(u.x**2+u.y**2)}class Txe extends xB{constructor(e){super(e),this._setColor=t=>{if(!t.options.links)return;const i=this.linkContainer,r=t.options.links;let s=r.id===void 0?i.particles.linksColor:i.particles.linksColors.get(r.id);if(s)return;const o=r.color;s=e7(o,r.blink,r.consent),r.id===void 0?i.particles.linksColor=s:i.particles.linksColors.set(r.id,s)},this.linkContainer=e}clear(){}init(){this.linkContainer.particles.linksColor=void 0,this.linkContainer.particles.linksColors=new Map}async interact(e){if(!e.options.links)return;e.links=[];const t=e.getPosition(),i=this.container,r=i.canvas.size;if(t.x<0||t.y<0||t.x>r.width||t.y>r.height)return;const s=e.options.links,o=s.opacity,a=e.retina.linksDistance??0,l=s.warp,u=l?new bxe(t.x,t.y,a,r):new Rs(t.x,t.y,a),c=i.particles.quadTree.query(u);for(const h of c){const d=h.options.links;if(e===h||!(d!=null&&d.enable)||s.id!==d.id||h.spawning||h.destroyed||!h.links||e.links.some(y=>y.destination===h)||h.links.some(y=>y.destination===e))continue;const p=h.getPosition();if(p.x<0||p.y<0||p.x>r.width||p.y>r.height)continue;const f=Sxe(t,p,a,r,l&&d.warp);if(f>a)continue;const g=(1-f/a)*o;this._setColor(e),e.links.push({destination:h,opacity:g})}}isEnabled(e){var t;return!!((t=e.options.links)!=null&&t.enable)}loadParticlesOptions(e,...t){e.links||(e.links=new wxe);for(const i of t)e.links.load((i==null?void 0:i.links)??(i==null?void 0:i.lineLinked)??(i==null?void 0:i.line_linked))}reset(){}}async function Cxe(n,e=!0){await n.addInteractor("particlesLinks",t=>new Txe(t),e)}function _xe(n){let e=!1;const{begin:t,end:i,maxDistance:r,context:s,canvasSize:o,width:a,backgroundMask:l,colorLine:u,opacity:c,links:h}=n;if(ia(t,i)<=r)ov(s,t,i),e=!0;else if(h.warp){let p,f;const g={x:i.x-o.width,y:i.y},y=js(t,g);if(y.distance<=r){const m=t.y-y.dy/y.dx*t.x;p={x:0,y:m},f={x:o.width,y:m}}else{const m={x:i.x,y:i.y-o.height},v=js(t,m);if(v.distance<=r){const S=-(t.y-v.dy/v.dx*t.x)/(v.dy/v.dx);p={x:S,y:0},f={x:S,y:o.height}}else{const w={x:i.x-o.width,y:i.y-o.height},S=js(t,w);if(S.distance<=r){const C=t.y-S.dy/S.dx*t.x;p={x:-C/(S.dy/S.dx),y:C},f={x:p.x+o.width,y:p.y+o.height}}}}p&&f&&(ov(s,t,p),ov(s,i,f),e=!0)}if(!e)return;s.lineWidth=a,l.enable&&(s.globalCompositeOperation=l.composite),s.strokeStyle=Mc(u,c);const{shadow:d}=h;if(d.enable){const p=Ll(d.color);p&&(s.shadowBlur=d.blur,s.shadowColor=Mc(p))}s.stroke()}function Mxe(n){const{context:e,pos1:t,pos2:i,pos3:r,backgroundMask:s,colorTriangle:o,opacityTriangle:a}=n;oye(e,t,i,r),s.enable&&(e.globalCompositeOperation=s.composite),e.fillStyle=Mc(o,a),e.fill()}function Axe(n){return n.sort((e,t)=>e-t),n.join("_")}function r9(n,e){const t=Axe(n.map(r=>r.id));let i=e.get(t);return i===void 0&&(i=pi(),e.set(t,i)),i}class Exe{constructor(e){this.container=e,this._drawLinkLine=(t,i)=>{const r=t.options.links;if(!(r!=null&&r.enable))return;const s=this.container,o=s.actualOptions,a=i.destination,l=t.getPosition(),u=a.getPosition();let c=i.opacity;s.canvas.draw(h=>{var m;let d;const p=(m=t.options.twinkle)==null?void 0:m.lines;if(p!=null&&p.enable){const v=p.frequency,w=Ll(p.color);pi()<v&&w&&(d=w,c=Vt(p.opacity))}if(!d){const v=r.id!==void 0?s.particles.linksColors.get(r.id):s.particles.linksColor;d=VD(t,a,v)}if(!d)return;const f=t.retina.linksWidth??0,g=t.retina.linksDistance??0,{backgroundMask:y}=o;_xe({context:h,width:f,begin:l,end:u,maxDistance:g,canvasSize:s.canvas.size,links:r,backgroundMask:y,colorLine:d,opacity:c})})},this._drawLinkTriangle=(t,i,r)=>{const s=t.options.links;if(!(s!=null&&s.enable))return;const o=s.triangles;if(!o.enable)return;const a=this.container,l=a.actualOptions,u=i.destination,c=r.destination,h=o.opacity??(i.opacity+r.opacity)/2;h<=0||a.canvas.draw(d=>{const p=t.getPosition(),f=u.getPosition(),g=c.getPosition(),y=t.retina.linksDistance??0;if(ia(p,f)>y||ia(g,f)>y||ia(g,p)>y)return;let m=Ll(o.color);if(!m){const v=s.id!==void 0?a.particles.linksColors.get(s.id):a.particles.linksColor;m=VD(t,u,v)}m&&Mxe({context:d,pos1:p,pos2:f,pos3:g,backgroundMask:l.backgroundMask,colorTriangle:m,opacityTriangle:h})})},this._drawTriangles=(t,i,r,s)=>{var l,u,c;const o=r.destination;if(!((l=t.links)!=null&&l.triangles.enable&&((u=o.options.links)!=null&&u.triangles.enable)))return;const a=(c=o.links)==null?void 0:c.filter(h=>{const d=this._getLinkFrequency(o,h.destination);return o.options.links&&d<=o.options.links.frequency&&s.findIndex(p=>p.destination===h.destination)>=0});if(a!=null&&a.length)for(const h of a){const d=h.destination;this._getTriangleFrequency(i,o,d)>t.links.triangles.frequency||this._drawLinkTriangle(i,r,h)}},this._getLinkFrequency=(t,i)=>r9([t,i],this._freqs.links),this._getTriangleFrequency=(t,i,r)=>r9([t,i,r],this._freqs.triangles),this._freqs={links:new Map,triangles:new Map}}drawParticle(e,t){const{links:i,options:r}=t;if(!i||i.length<=0)return;const s=i.filter(o=>r.links&&this._getLinkFrequency(t,o.destination)<=r.links.frequency);for(const o of s)this._drawTriangles(r,t,o,s),o.opacity>0&&(t.retina.linksWidth??0)>0&&this._drawLinkLine(t,o)}async init(){this._freqs.links=new Map,this._freqs.triangles=new Map}particleCreated(e){if(e.links=[],!e.options.links)return;const t=this.container.retina.pixelRatio,{retina:i}=e,{distance:r,width:s}=e.options.links;i.linksDistance=r*t,i.linksWidth=s*t}particleDestroyed(e){e.links=[]}}class Ixe{constructor(){this.id="links"}getPlugin(e){return new Exe(e)}loadOptions(){}needsPlugin(){return!0}}async function kxe(n,e=!0){const t=new Ixe;await n.addPlugin(t,e)}async function Rxe(n,e=!0){await Cxe(n,e),await kxe(n,e)}class g7{draw(e,t,i){const r=this.getCenter(t,i),s=this.getSidesData(t,i),o=s.count.numerator*s.count.denominator,a=s.count.numerator/s.count.denominator,l=180*(a-2)/a,u=Math.PI-Math.PI*l/180;if(e){e.beginPath(),e.translate(r.x,r.y),e.moveTo(0,0);for(let c=0;c<o;c++)e.lineTo(s.length,0),e.translate(s.length,0),e.rotate(u)}}getSidesCount(e){const t=e.shapeData;return Math.round(Vt((t==null?void 0:t.sides)??(t==null?void 0:t.nb_sides)??5))}}class Nxe extends g7{getCenter(e,t){return{x:-t/(e.sides/3.5),y:-t/(2.66/3.5)}}getSidesData(e,t){const i=e.sides;return{count:{denominator:1,numerator:i},length:t*2.66/(i/3)}}}class Lxe extends g7{getCenter(e,t){return{x:-t,y:t/1.66}}getSidesCount(){return 3}getSidesData(e,t){return{count:{denominator:2,numerator:3},length:t*2}}}async function Pxe(n,e=!0){await n.addShape("polygon",new Nxe,e)}async function Dxe(n,e=!0){await n.addShape("triangle",new Lxe,e)}async function Fxe(n,e=!0){await Pxe(n,e),await Dxe(n,e)}class Oxe{constructor(){this.enable=!1,this.speed=0,this.decay=0,this.sync=!1}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.speed!==void 0&&(this.speed=dn(e.speed)),e.decay!==void 0&&(this.decay=dn(e.decay)),e.sync!==void 0&&(this.sync=e.sync))}}class Bxe extends Rd{constructor(){super(),this.animation=new Oxe,this.direction="clockwise",this.path=!1,this.value=0}load(e){e&&(super.load(e),e.direction!==void 0&&(this.direction=e.direction),this.animation.load(e.animation),e.path!==void 0&&(this.path=e.path))}}function zxe(n,e){const t=n.rotate,i=n.options.rotate;if(!t||!i)return;const r=i.animation,s=(t.velocity??0)*e.factor,o=2*Math.PI,a=t.decay??1;if(r.enable){switch(t.status){case"increasing":t.value+=s,t.value>o&&(t.value-=o);break;case"decreasing":default:t.value-=s,t.value<0&&(t.value+=o);break}t.velocity&&a!==1&&(t.velocity*=a)}}class Gxe{constructor(e){this.container=e}init(e){const t=e.options.rotate;if(!t)return;e.rotate={enable:t.animation.enable,value:Vt(t.value)*Math.PI/180},e.pathRotation=t.path;let i=t.direction;switch(i==="random"&&(i=Math.floor(pi()*2)>0?"counter-clockwise":"clockwise"),i){case"counter-clockwise":case"counterClockwise":e.rotate.status="decreasing";break;case"clockwise":e.rotate.status="increasing";break}const r=t.animation;r.enable&&(e.rotate.decay=1-Vt(r.decay),e.rotate.velocity=Vt(r.speed)/360*this.container.retina.reduceFactor,r.sync||(e.rotate.velocity*=pi())),e.rotation=e.rotate.value}isEnabled(e){const t=e.options.rotate;return t?!e.destroyed&&!e.spawning&&t.animation.enable&&!t.path:!1}loadOptions(e,...t){e.rotate||(e.rotate=new Bxe);for(const i of t)e.rotate.load(i==null?void 0:i.rotate)}update(e,t){var i;this.isEnabled(e)&&(zxe(e,t),e.rotation=((i=e.rotate)==null?void 0:i.value)??0)}}async function Vxe(n,e=!0){await n.addParticleUpdater("rotate",t=>new Gxe(t),e)}const Uxe=Math.sqrt(2);class $xe{draw(e,t,i){const r=i/Uxe,s=r*2;e.rect(-r,-r,s,s)}getSidesCount(){return 4}}async function Wxe(n,e=!0){await n.addShape(["edge","square"],new $xe,e)}class Hxe{draw(e,t,i){const r=t.sides,s=t.starInset??2;e.moveTo(0,0-i);for(let o=0;o<r;o++)e.rotate(Math.PI/r),e.lineTo(0,0-i*s),e.rotate(Math.PI/r),e.lineTo(0,0-i)}getSidesCount(e){const t=e.shapeData;return Math.round(Vt((t==null?void 0:t.sides)??(t==null?void 0:t.nb_sides)??5))}particleInit(e,t){const i=t.shapeData,r=Vt((i==null?void 0:i.inset)??2);t.starInset=r}}async function Xxe(n,e=!0){await n.addShape("star",new Hxe,e)}function DN(n,e,t,i,r){if(!e||!t.enable||(e.maxLoops??0)>0&&(e.loops??0)>(e.maxLoops??0)||(e.time||(e.time=0),(e.delayTime??0)>0&&e.time<(e.delayTime??0)&&(e.time+=n.value),(e.delayTime??0)>0&&e.time<(e.delayTime??0)))return;const s=To(t.offset),o=(e.velocity??0)*n.factor+s*3.6,a=e.decay??1;!r||e.status==="increasing"?(e.value+=o,e.value>i&&(e.loops||(e.loops=0),e.loops++,r&&(e.status="decreasing",e.value-=e.value%i))):(e.value-=o,e.value<0&&(e.loops||(e.loops=0),e.loops++,e.status="increasing",e.value+=e.value)),e.velocity&&a!==1&&(e.velocity*=a),e.value>i&&(e.value%=i)}function Kxe(n,e){if(!n.strokeColor||!n.strokeAnimation)return;const{h:t,s:i,l:r}=n.strokeColor,{h:s,s:o,l:a}=n.strokeAnimation;t&&DN(e,t,s,360,!1),i&&DN(e,i,o,100,!0),r&&DN(e,r,a,100,!0)}class Zxe{constructor(e){this.container=e}init(e){var o;const t=this.container,i=e.options,r=_c(i.stroke,e.id,i.reduceDuplicates);e.strokeWidth=Vt(r.width)*t.retina.pixelRatio,e.strokeOpacity=Vt(r.opacity??1),e.strokeAnimation=(o=r.color)==null?void 0:o.animation;const s=Fv(r.color)??e.getFillColor();s&&(e.strokeColor=t7(s,e.strokeAnimation,t.retina.reduceFactor))}isEnabled(e){const t=e.strokeAnimation,{strokeColor:i}=e;return!e.destroyed&&!e.spawning&&!!t&&((i==null?void 0:i.h.value)!==void 0&&i.h.enable||(i==null?void 0:i.s.value)!==void 0&&i.s.enable||(i==null?void 0:i.l.value)!==void 0&&i.l.enable)}update(e,t){this.isEnabled(e)&&Kxe(e,t)}}async function jxe(n,e=!0){await n.addParticleUpdater("strokeColor",t=>new Zxe(t),e)}const P_=["text","character","char"];class Yxe{draw(e,t,i,r){const s=t.shapeData;if(s===void 0)return;const o=s.value;if(o===void 0)return;t.text===void 0&&(t.text=_c(o,t.randomIndexData));const a=t.text,l=s.style??"",u=s.weight??"400",c=Math.round(i)*2,h=s.font??"Verdana",d=t.fill,p=a.length*i/2;e.font=`${l} ${u} ${c}px "${h}"`;const f={x:-p,y:i/2};e.globalAlpha=r,d?e.fillText(a,f.x,f.y):e.strokeText(a,f.x,f.y),e.globalAlpha=1}getSidesCount(){return 12}async init(e){const t=e.actualOptions;if(P_.find(i=>nr(i,t.particles.shape.type))){const i=P_.map(s=>t.particles.shape.options[s]).find(s=>!!s),r=[];Kr(i,s=>{r.push(Jge(s.font,s.weight))}),await Promise.all(r)}}particleInit(e,t){if(!t.shape||!P_.includes(t.shape))return;const i=t.shapeData;if(i===void 0)return;const r=i.value;r!==void 0&&(t.text=_c(r,t.randomIndexData))}}async function Jxe(n,e=!0){await n.addShape(P_,new Yxe,e)}async function Qxe(n,e=!0){T0e(n),await cxe(n,!1),await ibe(n,!1),await obe(n,!1),await cbe(n,!1),await bbe(n,!1),await Cbe(n,!1),await Mbe(n,!1),await Ibe(n,!1),await Nbe(n,!1),await Fbe(n,!1),await zbe(n,!1),await dxe(n,!1),await yxe(n,!1),await Rxe(n,!1),await ebe(),await txe(n,!1),await lxe(n,!1),await Fxe(n,!1),await Wxe(n,!1),await Xxe(n,!1),await Jxe(n,!1),await oxe(n,!1),await Vxe(n,!1),await jxe(n,!1),await q0e(n,e)}function qxe(){const n=K.useCallback(async e=>{await Qxe(e)},[]);return se.jsx(c7,{options:{fullScreen:{zIndex:-1e3},particles:{number:{value:80,density:{enable:!0,value_area:800}},color:{value:"#00EEFF"},shape:{type:"circle",stroke:{width:0,color:"#00EEFF"},polygon:{nb_sides:5},image:{src:"img/github.svg",width:100,height:100}},opacity:{value:.2,random:!1,anim:{enable:!1,speed:1,opacity_min:.1,sync:!1}},size:{value:3,random:!0,anim:{enable:!1,speed:40,size_min:.1,sync:!1}},links:{enable:!0,distance:150,color:"#00EEFF",opacity:.2,width:1},move:{enable:!0,speed:1,direction:"none",random:!1,straight:!1,out_mode:"out",bounce:!1,attract:{enable:!1,rotateX:600,rotateY:1200}}},interactivity:{events:{onhover:{enable:!0,mode:"grab"},onclick:{enable:!0,mode:"push"},resize:!0},modes:{grab:{distance:200,line_linked:{opacity:.6}},bubble:{distance:400,size:40,duration:2,opacity:8,speed:3},repulse:{distance:200,duration:.4},push:{particles_nb:4},remove:{particles_nb:2}}},background:{color:"#1F232E"},preset:"links"},init:n})}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var UD=function(){return UD=Object.assign||function(e){for(var t,i=1,r=arguments.length;i<r;i++){t=arguments[i];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e},UD.apply(this,arguments)};function eve(n,e){var t={};for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&e.indexOf(i)<0&&(t[i]=n[i]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,i=Object.getOwnPropertySymbols(n);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(n,i[r])&&(t[i[r]]=n[i[r]]);return t}var ny="",av=null,D_=null,y7=null;function vB(){ny="",av!==null&&av.disconnect(),D_!==null&&(window.clearTimeout(D_),D_=null)}function s9(n){var e=["BUTTON","INPUT","SELECT","TEXTAREA"],t=["A","AREA"];return e.includes(n.tagName)&&!n.hasAttribute("disabled")||t.includes(n.tagName)&&n.hasAttribute("href")}function o9(){var n=null;if(ny==="#")n=document.body;else{var e=ny.replace("#","");n=document.getElementById(e),n===null&&ny==="#top"&&(n=document.body)}if(n!==null){y7(n);var t=n.getAttribute("tabindex");return t===null&&!s9(n)&&n.setAttribute("tabindex",-1),n.focus({preventScroll:!0}),t===null&&!s9(n)&&(n.blur(),n.removeAttribute("tabindex")),vB(),!0}return!1}function tve(n){window.setTimeout(function(){o9()===!1&&(av===null&&(av=new MutationObserver(o9)),av.observe(document,{attributes:!0,childList:!0,subtree:!0}),D_=window.setTimeout(function(){vB()},n||1e4))},0)}function b7(n){return Is.forwardRef(function(e,t){var i="";typeof e.to=="string"&&e.to.includes("#")?i="#"+e.to.split("#").slice(1).join("#"):typeof e.to=="object"&&typeof e.to.hash=="string"&&(i=e.to.hash);var r={};n===bY&&(r.isActive=function(a,l){return a&&a.isExact&&l.hash===i});function s(a){vB(),ny=e.elementId?"#"+e.elementId:i,e.onClick&&e.onClick(a),ny!==""&&!a.defaultPrevented&&a.button===0&&(!e.target||e.target==="_self")&&!(a.metaKey||a.altKey||a.ctrlKey||a.shiftKey)&&(y7=e.scroll||function(l){return e.smooth?l.scrollIntoView({behavior:"smooth"}):l.scrollIntoView()},tve(e.timeout))}var o=eve(e,["scroll","smooth","timeout","elementId"]);return Is.createElement(n,UD({},r,o,{onClick:s,ref:t}),e.children)})}var tC=b7(R1);b7(bY);var x7={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},a9=Is.createContext&&Is.createContext(x7),td=globalThis&&globalThis.__assign||function(){return td=Object.assign||function(n){for(var e,t=1,i=arguments.length;t<i;t++){e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r])}return n},td.apply(this,arguments)},nve=globalThis&&globalThis.__rest||function(n,e){var t={};for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&e.indexOf(i)<0&&(t[i]=n[i]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,i=Object.getOwnPropertySymbols(n);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(n,i[r])&&(t[i[r]]=n[i[r]]);return t};function v7(n){return n&&n.map(function(e,t){return Is.createElement(e.tag,td({key:t},e.attr),v7(e.child))})}function Nd(n){return function(e){return Is.createElement(ive,td({attr:td({},n.attr)},e),v7(n.child))}}function ive(n){var e=function(t){var i=n.attr,r=n.size,s=n.title,o=nve(n,["attr","size","title"]),a=r||t.size||"1em",l;return t.className&&(l=t.className),n.className&&(l=(l?l+" ":"")+n.className),Is.createElement("svg",td({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,i,o,{className:l,style:td(td({color:n.color||t.color},t.style),n.style),height:a,width:a,xmlns:"http://www.w3.org/2000/svg"}),s&&Is.createElement("title",null,s),n.children)};return a9!==void 0?Is.createElement(a9.Consumer,null,function(t){return e(t)}):e(x7)}function rve(n){return Nd({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"}}]})(n)}function sve(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"}}]})(n)}function ove(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"}}]})(n)}function iy(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 0 0 0-48.4z"}}]})(n)}function ave(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M868 545.5L536.1 163a31.96 31.96 0 0 0-48.3 0L156 545.5a7.97 7.97 0 0 0 6 13.2h81c4.6 0 9-2 12.1-5.5L474 300.9V864c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V300.9l218.9 252.3c3 3.5 7.4 5.5 12.1 5.5h81c6.8 0 10.5-8 6-13.2z"}}]})(n)}function lve(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024",fill:"currentColor",fillRule:"evenodd"},child:[{tag:"path",attr:{d:"M799.855 166.312c.023.007.043.018.084.059l57.69 57.69c.041.041.052.06.059.084a.118.118 0 0 1 0 .069c-.007.023-.018.042-.059.083L569.926 512l287.703 287.703c.041.04.052.06.059.083a.118.118 0 0 1 0 .07c-.007.022-.018.042-.059.083l-57.69 57.69c-.041.041-.06.052-.084.059a.118.118 0 0 1-.069 0c-.023-.007-.042-.018-.083-.059L512 569.926 224.297 857.629c-.04.041-.06.052-.083.059a.118.118 0 0 1-.07 0c-.022-.007-.042-.018-.083-.059l-57.69-57.69c-.041-.041-.052-.06-.059-.084a.118.118 0 0 1 0-.069c.007-.023.018-.042.059-.083L454.073 512 166.371 224.297c-.041-.04-.052-.06-.059-.083a.118.118 0 0 1 0-.07c.007-.022.018-.042.059-.083l57.69-57.69c.041-.041.06-.052.084-.059a.118.118 0 0 1 .069 0c.023.007.042.018.083.059L512 454.073l287.703-287.702c.04-.041.06-.052.083-.059a.118.118 0 0 1 .07 0Z"}}]})(n)}function uve(n){return Nd({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M531.3 574.4l.3-1.4c5.8-23.9 13.1-53.7 7.4-80.7-3.8-21.3-19.5-29.6-32.9-30.2-15.8-.7-29.9 8.3-33.4 21.4-6.6 24-.7 56.8 10.1 98.6-13.6 32.4-35.3 79.5-51.2 107.5-29.6 15.3-69.3 38.9-75.2 68.7-1.2 5.5.2 12.5 3.5 18.8 3.7 7 9.6 12.4 16.5 15 3 1.1 6.6 2 10.8 2 17.6 0 46.1-14.2 84.1-79.4 5.8-1.9 11.8-3.9 17.6-5.9 27.2-9.2 55.4-18.8 80.9-23.1 28.2 15.1 60.3 24.8 82.1 24.8 21.6 0 30.1-12.8 33.3-20.5 5.6-13.5 2.9-30.5-6.2-39.6-13.2-13-45.3-16.4-95.3-10.2-24.6-15-40.7-35.4-52.4-65.8zM421.6 726.3c-13.9 20.2-24.4 30.3-30.1 34.7 6.7-12.3 19.8-25.3 30.1-34.7zm87.6-235.5c5.2 8.9 4.5 35.8.5 49.4-4.9-19.9-5.6-48.1-2.7-51.4.8.1 1.5.7 2.2 2zm-1.6 120.5c10.7 18.5 24.2 34.4 39.1 46.2-21.6 4.9-41.3 13-58.9 20.2-4.2 1.7-8.3 3.4-12.3 5 13.3-24.1 24.4-51.4 32.1-71.4zm155.6 65.5c.1.2.2.5-.4.9h-.2l-.2.3c-.8.5-9 5.3-44.3-8.6 40.6-1.9 45 7.3 45.1 7.4zm191.4-388.2L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0 0 42 42h216v494z"}}]})(n)}const w7="/assets/logo-b59c9a0e.svg",cve="_container_1oxgy_3",hve="_containerDark_1oxgy_25 _container_1oxgy_3",dve="_navbar_1oxgy_37",pve="_logoLink_1oxgy_55",fve="_navLinks_1oxgy_77",mve="_navLink_1oxgy_77",gve="_menu_1oxgy_137",yve="_menuMobile_1oxgy_149 _menu_1oxgy_137 _menu_1oxgy_137",bve="_hamburgerCheckbox_1oxgy_169",xve="_hamburger_1oxgy_169",vve="_scrollButton_1oxgy_197",co={container:cve,containerDark:hve,navbar:dve,logoLink:pve,navLinks:fve,navLink:mve,menu:gve,menuMobile:yve,hamburgerCheckbox:bve,hamburger:xve,scrollButton:vve};function wve(){const[n,e]=K.useState(!1),[t,i]=K.useState(!1),r=K.useCallback(()=>{var c=document.documentElement,h=document.body,d="scrollTop",p="scrollHeight";return(c[d]||h[d])/((c[p]||h[p])-c.clientHeight)*100},[]),s=K.useCallback(()=>{e(r())},[e,r]);K.useEffect(()=>(document.addEventListener("scroll",s,{passive:!0}),()=>{document.removeEventListener("scroll",s)}),[s]);const o=n>1,a=2*3.14*20,l=a*((100-n)/100),u=se.jsxs(se.Fragment,{children:[se.jsx(On.li,{initial:{opacity:0,y:-20,height:0},whileInView:{opacity:1,y:0,height:"auto"},exit:{opacity:0,y:-20,height:0,transition:{delay:.3}},children:se.jsx(tC,{smooth:!0,to:"/#about",className:co.navLink,children:"About"})}),se.jsx(On.li,{initial:{opacity:0,y:-20,height:0},whileInView:{opacity:1,y:0,height:"auto",transition:{delay:.1}},exit:{opacity:0,y:-20,height:0,transition:{delay:.2}},children:se.jsx(tC,{smooth:!0,to:"/#projects",className:co.navLink,children:"Projects"})}),se.jsx(On.li,{initial:{opacity:0,y:-20,height:0},whileInView:{opacity:1,y:0,height:"auto",transition:{delay:.2}},exit:{opacity:0,y:-20,height:0,transition:{delay:.1}},children:se.jsx(tC,{smooth:!0,to:"/#testimonials",className:co.navLink,children:"Testimonials"})}),se.jsx(On.li,{initial:{opacity:0,y:-20,height:0},whileInView:{opacity:1,y:0,height:"auto",transition:{delay:.3}},exit:{opacity:0,y:-20,height:0},children:se.jsx(tC,{smooth:!0,to:"/#contact",className:co.navLink,children:"Contact"})})]});return se.jsxs(se.Fragment,{children:[se.jsx("div",{className:o||t?co.containerDark:co.container,children:se.jsxs("nav",{className:co.navbar,children:[se.jsx(R1,{to:"/",className:co.logoLink,children:se.jsx("img",{src:w7,alt:"logo"})}),se.jsxs("ul",{className:co.navLinks,children:[se.jsx("input",{className:co.hamburgerCheckbox,type:"checkbox",id:"checkbox_toggle",onChange:c=>{i(c.target.checked)}}),se.jsx("label",{htmlFor:"checkbox_toggle",className:co.hamburger,children:t?se.jsx(lve,{}):se.jsx(rve,{})}),se.jsx("div",{className:co.menu,children:u}),se.jsx(OD,{children:t&&se.jsx("div",{className:co.menuMobile,children:u})})]})]})}),se.jsx(OD,{initial:!1,children:o&&se.jsxs(On.button,{className:co.scrollButton,onClick:()=>{window.scrollTo({top:0,behavior:"smooth"})},initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},exit:{opacity:0,y:20},transition:{duration:.5},children:[se.jsxs("svg",{width:"60",height:"60",viewBox:"-7.5 -7.5 75 75",version:"1.1",xmlns:"http://www.w3.org/2000/svg",style:{transform:"rotate(-90deg)"},children:[se.jsx("circle",{r:"20",cx:"30",cy:"30",fill:"transparent",stroke:"#1e1e1e",strokeWidth:"2",strokeDasharray:a,strokeDashoffset:"0"}),se.jsx("circle",{r:"20",cx:"30",cy:"30",stroke:"#00eeff",strokeWidth:"2",strokeLinecap:"round",strokeDashoffset:l,fill:"transparent",strokeDasharray:a})]}),se.jsx(ave,{})]})})]})}const Sve="_container_1tfib_1",Tve="_loading_1tfib_13",S7={container:Sve,loading:Tve};var Cve=function(e){return _ve(e)&&!Mve(e)};function _ve(n){return!!n&&typeof n=="object"}function Mve(n){var e=Object.prototype.toString.call(n);return e==="[object RegExp]"||e==="[object Date]"||Ive(n)}var Ave=typeof Symbol=="function"&&Symbol.for,Eve=Ave?Symbol.for("react.element"):60103;function Ive(n){return n.$$typeof===Eve}function kve(n){return Array.isArray(n)?[]:{}}function BM(n,e){return e.clone!==!1&&e.isMergeableObject(n)?zv(kve(n),n,e):n}function Rve(n,e,t){return n.concat(e).map(function(i){return BM(i,t)})}function Nve(n,e,t){var i={};return t.isMergeableObject(n)&&Object.keys(n).forEach(function(r){i[r]=BM(n[r],t)}),Object.keys(e).forEach(function(r){!t.isMergeableObject(e[r])||!n[r]?i[r]=BM(e[r],t):i[r]=zv(n[r],e[r],t)}),i}function zv(n,e,t){t=t||{},t.arrayMerge=t.arrayMerge||Rve,t.isMergeableObject=t.isMergeableObject||Cve;var i=Array.isArray(e),r=Array.isArray(n),s=i===r;return s?i?t.arrayMerge(n,e,t):Nve(n,e,t):BM(e,t)}zv.all=function(e,t){if(!Array.isArray(e))throw new Error("first argument should be an array");return e.reduce(function(i,r){return zv(i,r,t)},{})};var $D=zv,Lve=typeof global=="object"&&global&&global.Object===Object&&global;const T7=Lve;var Pve=typeof self=="object"&&self&&self.Object===Object&&self,Dve=T7||Pve||Function("return this")();const $u=Dve;var Fve=$u.Symbol;const fd=Fve;var C7=Object.prototype,Ove=C7.hasOwnProperty,Bve=C7.toString,ox=fd?fd.toStringTag:void 0;function zve(n){var e=Ove.call(n,ox),t=n[ox];try{n[ox]=void 0;var i=!0}catch{}var r=Bve.call(n);return i&&(e?n[ox]=t:delete n[ox]),r}var Gve=Object.prototype,Vve=Gve.toString;function Uve(n){return Vve.call(n)}var $ve="[object Null]",Wve="[object Undefined]",l9=fd?fd.toStringTag:void 0;function qf(n){return n==null?n===void 0?Wve:$ve:l9&&l9 in Object(n)?zve(n):Uve(n)}function _7(n,e){return function(t){return n(e(t))}}var Hve=_7(Object.getPrototypeOf,Object);const wB=Hve;function em(n){return n!=null&&typeof n=="object"}var Xve="[object Object]",Kve=Function.prototype,Zve=Object.prototype,M7=Kve.toString,jve=Zve.hasOwnProperty,Yve=M7.call(Object);function u9(n){if(!em(n)||qf(n)!=Xve)return!1;var e=wB(n);if(e===null)return!0;var t=jve.call(e,"constructor")&&e.constructor;return typeof t=="function"&&t instanceof t&&M7.call(t)==Yve}var c9=Array.isArray,h9=Object.keys,Jve=Object.prototype.hasOwnProperty,Qve=typeof Element<"u";function WD(n,e){if(n===e)return!0;if(n&&e&&typeof n=="object"&&typeof e=="object"){var t=c9(n),i=c9(e),r,s,o;if(t&&i){if(s=n.length,s!=e.length)return!1;for(r=s;r--!==0;)if(!WD(n[r],e[r]))return!1;return!0}if(t!=i)return!1;var a=n instanceof Date,l=e instanceof Date;if(a!=l)return!1;if(a&&l)return n.getTime()==e.getTime();var u=n instanceof RegExp,c=e instanceof RegExp;if(u!=c)return!1;if(u&&c)return n.toString()==e.toString();var h=h9(n);if(s=h.length,s!==h9(e).length)return!1;for(r=s;r--!==0;)if(!Jve.call(e,h[r]))return!1;if(Qve&&n instanceof Element&&e instanceof Element)return n===e;for(r=s;r--!==0;)if(o=h[r],!(o==="_owner"&&n.$$typeof)&&!WD(n[o],e[o]))return!1;return!0}return n!==n&&e!==e}var qve=function(e,t){try{return WD(e,t)}catch(i){if(i.message&&i.message.match(/stack|recursion/i)||i.number===-2146828260)return console.warn("Warning: react-fast-compare does not handle circular references.",i.name,i.message),!1;throw i}};const Sp=Zy(qve);var e1e=!0;function t1e(n,e){if(!e1e){if(n)return;var t="Warning: "+e;typeof console<"u"&&console.warn(t);try{throw Error(t)}catch{}}}function n1e(){this.__data__=[],this.size=0}function A7(n,e){return n===e||n!==n&&e!==e}function rE(n,e){for(var t=n.length;t--;)if(A7(n[t][0],e))return t;return-1}var i1e=Array.prototype,r1e=i1e.splice;function s1e(n){var e=this.__data__,t=rE(e,n);if(t<0)return!1;var i=e.length-1;return t==i?e.pop():r1e.call(e,t,1),--this.size,!0}function o1e(n){var e=this.__data__,t=rE(e,n);return t<0?void 0:e[t][1]}function a1e(n){return rE(this.__data__,n)>-1}function l1e(n,e){var t=this.__data__,i=rE(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}function Zc(n){var e=-1,t=n==null?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}Zc.prototype.clear=n1e;Zc.prototype.delete=s1e;Zc.prototype.get=o1e;Zc.prototype.has=a1e;Zc.prototype.set=l1e;function u1e(){this.__data__=new Zc,this.size=0}function c1e(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}function h1e(n){return this.__data__.get(n)}function d1e(n){return this.__data__.has(n)}function O1(n){var e=typeof n;return n!=null&&(e=="object"||e=="function")}var p1e="[object AsyncFunction]",f1e="[object Function]",m1e="[object GeneratorFunction]",g1e="[object Proxy]";function E7(n){if(!O1(n))return!1;var e=qf(n);return e==f1e||e==m1e||e==p1e||e==g1e}var y1e=$u["__core-js_shared__"];const FN=y1e;var d9=function(){var n=/[^.]+$/.exec(FN&&FN.keys&&FN.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}();function b1e(n){return!!d9&&d9 in n}var x1e=Function.prototype,v1e=x1e.toString;function tm(n){if(n!=null){try{return v1e.call(n)}catch{}try{return n+""}catch{}}return""}var w1e=/[\\^$.*+?()[\]{}|]/g,S1e=/^\[object .+?Constructor\]$/,T1e=Function.prototype,C1e=Object.prototype,_1e=T1e.toString,M1e=C1e.hasOwnProperty,A1e=RegExp("^"+_1e.call(M1e).replace(w1e,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function E1e(n){if(!O1(n)||b1e(n))return!1;var e=E7(n)?A1e:S1e;return e.test(tm(n))}function I1e(n,e){return n==null?void 0:n[e]}function nm(n,e){var t=I1e(n,e);return E1e(t)?t:void 0}var k1e=nm($u,"Map");const Gv=k1e;var R1e=nm(Object,"create");const Vv=R1e;function N1e(){this.__data__=Vv?Vv(null):{},this.size=0}function L1e(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}var P1e="__lodash_hash_undefined__",D1e=Object.prototype,F1e=D1e.hasOwnProperty;function O1e(n){var e=this.__data__;if(Vv){var t=e[n];return t===P1e?void 0:t}return F1e.call(e,n)?e[n]:void 0}var B1e=Object.prototype,z1e=B1e.hasOwnProperty;function G1e(n){var e=this.__data__;return Vv?e[n]!==void 0:z1e.call(e,n)}var V1e="__lodash_hash_undefined__";function U1e(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=Vv&&e===void 0?V1e:e,this}function Sf(n){var e=-1,t=n==null?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}Sf.prototype.clear=N1e;Sf.prototype.delete=L1e;Sf.prototype.get=O1e;Sf.prototype.has=G1e;Sf.prototype.set=U1e;function $1e(){this.size=0,this.__data__={hash:new Sf,map:new(Gv||Zc),string:new Sf}}function W1e(n){var e=typeof n;return e=="string"||e=="number"||e=="symbol"||e=="boolean"?n!=="__proto__":n===null}function sE(n,e){var t=n.__data__;return W1e(e)?t[typeof e=="string"?"string":"hash"]:t.map}function H1e(n){var e=sE(this,n).delete(n);return this.size-=e?1:0,e}function X1e(n){return sE(this,n).get(n)}function K1e(n){return sE(this,n).has(n)}function Z1e(n,e){var t=sE(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}function Ld(n){var e=-1,t=n==null?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}Ld.prototype.clear=$1e;Ld.prototype.delete=H1e;Ld.prototype.get=X1e;Ld.prototype.has=K1e;Ld.prototype.set=Z1e;var j1e=200;function Y1e(n,e){var t=this.__data__;if(t instanceof Zc){var i=t.__data__;if(!Gv||i.length<j1e-1)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new Ld(i)}return t.set(n,e),this.size=t.size,this}function Qy(n){var e=this.__data__=new Zc(n);this.size=e.size}Qy.prototype.clear=u1e;Qy.prototype.delete=c1e;Qy.prototype.get=h1e;Qy.prototype.has=d1e;Qy.prototype.set=Y1e;function J1e(n,e){for(var t=-1,i=n==null?0:n.length;++t<i&&e(n[t],t,n)!==!1;);return n}var Q1e=function(){try{var n=nm(Object,"defineProperty");return n({},"",{}),n}catch{}}();const p9=Q1e;function I7(n,e,t){e=="__proto__"&&p9?p9(n,e,{configurable:!0,enumerable:!0,value:t,writable:!0}):n[e]=t}var q1e=Object.prototype,ewe=q1e.hasOwnProperty;function k7(n,e,t){var i=n[e];(!(ewe.call(n,e)&&A7(i,t))||t===void 0&&!(e in n))&&I7(n,e,t)}function oE(n,e,t,i){var r=!t;t||(t={});for(var s=-1,o=e.length;++s<o;){var a=e[s],l=i?i(t[a],n[a],a,t,n):void 0;l===void 0&&(l=n[a]),r?I7(t,a,l):k7(t,a,l)}return t}function twe(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}var nwe="[object Arguments]";function f9(n){return em(n)&&qf(n)==nwe}var R7=Object.prototype,iwe=R7.hasOwnProperty,rwe=R7.propertyIsEnumerable,swe=f9(function(){return arguments}())?f9:function(n){return em(n)&&iwe.call(n,"callee")&&!rwe.call(n,"callee")};const owe=swe;var awe=Array.isArray;const B1=awe;function lwe(){return!1}var N7=typeof ea=="object"&&ea&&!ea.nodeType&&ea,m9=N7&&typeof ta=="object"&&ta&&!ta.nodeType&&ta,uwe=m9&&m9.exports===N7,g9=uwe?$u.Buffer:void 0,cwe=g9?g9.isBuffer:void 0,hwe=cwe||lwe;const L7=hwe;var dwe=9007199254740991,pwe=/^(?:0|[1-9]\d*)$/;function fwe(n,e){var t=typeof n;return e=e??dwe,!!e&&(t=="number"||t!="symbol"&&pwe.test(n))&&n>-1&&n%1==0&&n<e}var mwe=9007199254740991;function P7(n){return typeof n=="number"&&n>-1&&n%1==0&&n<=mwe}var gwe="[object Arguments]",ywe="[object Array]",bwe="[object Boolean]",xwe="[object Date]",vwe="[object Error]",wwe="[object Function]",Swe="[object Map]",Twe="[object Number]",Cwe="[object Object]",_we="[object RegExp]",Mwe="[object Set]",Awe="[object String]",Ewe="[object WeakMap]",Iwe="[object ArrayBuffer]",kwe="[object DataView]",Rwe="[object Float32Array]",Nwe="[object Float64Array]",Lwe="[object Int8Array]",Pwe="[object Int16Array]",Dwe="[object Int32Array]",Fwe="[object Uint8Array]",Owe="[object Uint8ClampedArray]",Bwe="[object Uint16Array]",zwe="[object Uint32Array]",li={};li[Rwe]=li[Nwe]=li[Lwe]=li[Pwe]=li[Dwe]=li[Fwe]=li[Owe]=li[Bwe]=li[zwe]=!0;li[gwe]=li[ywe]=li[Iwe]=li[bwe]=li[kwe]=li[xwe]=li[vwe]=li[wwe]=li[Swe]=li[Twe]=li[Cwe]=li[_we]=li[Mwe]=li[Awe]=li[Ewe]=!1;function Gwe(n){return em(n)&&P7(n.length)&&!!li[qf(n)]}function SB(n){return function(e){return n(e)}}var D7=typeof ea=="object"&&ea&&!ea.nodeType&&ea,lv=D7&&typeof ta=="object"&&ta&&!ta.nodeType&&ta,Vwe=lv&&lv.exports===D7,ON=Vwe&&T7.process,Uwe=function(){try{var n=lv&&lv.require&&lv.require("util").types;return n||ON&&ON.binding&&ON.binding("util")}catch{}}();const Cy=Uwe;var y9=Cy&&Cy.isTypedArray,$we=y9?SB(y9):Gwe;const Wwe=$we;var Hwe=Object.prototype,Xwe=Hwe.hasOwnProperty;function F7(n,e){var t=B1(n),i=!t&&owe(n),r=!t&&!i&&L7(n),s=!t&&!i&&!r&&Wwe(n),o=t||i||r||s,a=o?twe(n.length,String):[],l=a.length;for(var u in n)(e||Xwe.call(n,u))&&!(o&&(u=="length"||r&&(u=="offset"||u=="parent")||s&&(u=="buffer"||u=="byteLength"||u=="byteOffset")||fwe(u,l)))&&a.push(u);return a}var Kwe=Object.prototype;function TB(n){var e=n&&n.constructor,t=typeof e=="function"&&e.prototype||Kwe;return n===t}var Zwe=_7(Object.keys,Object);const jwe=Zwe;var Ywe=Object.prototype,Jwe=Ywe.hasOwnProperty;function Qwe(n){if(!TB(n))return jwe(n);var e=[];for(var t in Object(n))Jwe.call(n,t)&&t!="constructor"&&e.push(t);return e}function O7(n){return n!=null&&P7(n.length)&&!E7(n)}function CB(n){return O7(n)?F7(n):Qwe(n)}function qwe(n,e){return n&&oE(e,CB(e),n)}function eSe(n){var e=[];if(n!=null)for(var t in Object(n))e.push(t);return e}var tSe=Object.prototype,nSe=tSe.hasOwnProperty;function iSe(n){if(!O1(n))return eSe(n);var e=TB(n),t=[];for(var i in n)i=="constructor"&&(e||!nSe.call(n,i))||t.push(i);return t}function _B(n){return O7(n)?F7(n,!0):iSe(n)}function rSe(n,e){return n&&oE(e,_B(e),n)}var B7=typeof ea=="object"&&ea&&!ea.nodeType&&ea,b9=B7&&typeof ta=="object"&&ta&&!ta.nodeType&&ta,sSe=b9&&b9.exports===B7,x9=sSe?$u.Buffer:void 0,v9=x9?x9.allocUnsafe:void 0;function oSe(n,e){if(e)return n.slice();var t=n.length,i=v9?v9(t):new n.constructor(t);return n.copy(i),i}function z7(n,e){var t=-1,i=n.length;for(e||(e=Array(i));++t<i;)e[t]=n[t];return e}function aSe(n,e){for(var t=-1,i=n==null?0:n.length,r=0,s=[];++t<i;){var o=n[t];e(o,t,n)&&(s[r++]=o)}return s}function G7(){return[]}var lSe=Object.prototype,uSe=lSe.propertyIsEnumerable,w9=Object.getOwnPropertySymbols,cSe=w9?function(n){return n==null?[]:(n=Object(n),aSe(w9(n),function(e){return uSe.call(n,e)}))}:G7;const MB=cSe;function hSe(n,e){return oE(n,MB(n),e)}function V7(n,e){for(var t=-1,i=e.length,r=n.length;++t<i;)n[r+t]=e[t];return n}var dSe=Object.getOwnPropertySymbols,pSe=dSe?function(n){for(var e=[];n;)V7(e,MB(n)),n=wB(n);return e}:G7;const U7=pSe;function fSe(n,e){return oE(n,U7(n),e)}function $7(n,e,t){var i=e(n);return B1(n)?i:V7(i,t(n))}function mSe(n){return $7(n,CB,MB)}function gSe(n){return $7(n,_B,U7)}var ySe=nm($u,"DataView");const HD=ySe;var bSe=nm($u,"Promise");const XD=bSe;var xSe=nm($u,"Set");const KD=xSe;var vSe=nm($u,"WeakMap");const ZD=vSe;var S9="[object Map]",wSe="[object Object]",T9="[object Promise]",C9="[object Set]",_9="[object WeakMap]",M9="[object DataView]",SSe=tm(HD),TSe=tm(Gv),CSe=tm(XD),_Se=tm(KD),MSe=tm(ZD),Tp=qf;(HD&&Tp(new HD(new ArrayBuffer(1)))!=M9||Gv&&Tp(new Gv)!=S9||XD&&Tp(XD.resolve())!=T9||KD&&Tp(new KD)!=C9||ZD&&Tp(new ZD)!=_9)&&(Tp=function(n){var e=qf(n),t=e==wSe?n.constructor:void 0,i=t?tm(t):"";if(i)switch(i){case SSe:return M9;case TSe:return S9;case CSe:return T9;case _Se:return C9;case MSe:return _9}return e});const AB=Tp;var ASe=Object.prototype,ESe=ASe.hasOwnProperty;function ISe(n){var e=n.length,t=new n.constructor(e);return e&&typeof n[0]=="string"&&ESe.call(n,"index")&&(t.index=n.index,t.input=n.input),t}var kSe=$u.Uint8Array;const A9=kSe;function EB(n){var e=new n.constructor(n.byteLength);return new A9(e).set(new A9(n)),e}function RSe(n,e){var t=e?EB(n.buffer):n.buffer;return new n.constructor(t,n.byteOffset,n.byteLength)}var NSe=/\w*$/;function LSe(n){var e=new n.constructor(n.source,NSe.exec(n));return e.lastIndex=n.lastIndex,e}var E9=fd?fd.prototype:void 0,I9=E9?E9.valueOf:void 0;function PSe(n){return I9?Object(I9.call(n)):{}}function DSe(n,e){var t=e?EB(n.buffer):n.buffer;return new n.constructor(t,n.byteOffset,n.length)}var FSe="[object Boolean]",OSe="[object Date]",BSe="[object Map]",zSe="[object Number]",GSe="[object RegExp]",VSe="[object Set]",USe="[object String]",$Se="[object Symbol]",WSe="[object ArrayBuffer]",HSe="[object DataView]",XSe="[object Float32Array]",KSe="[object Float64Array]",ZSe="[object Int8Array]",jSe="[object Int16Array]",YSe="[object Int32Array]",JSe="[object Uint8Array]",QSe="[object Uint8ClampedArray]",qSe="[object Uint16Array]",eTe="[object Uint32Array]";function tTe(n,e,t){var i=n.constructor;switch(e){case WSe:return EB(n);case FSe:case OSe:return new i(+n);case HSe:return RSe(n,t);case XSe:case KSe:case ZSe:case jSe:case YSe:case JSe:case QSe:case qSe:case eTe:return DSe(n,t);case BSe:return new i;case zSe:case USe:return new i(n);case GSe:return LSe(n);case VSe:return new i;case $Se:return PSe(n)}}var k9=Object.create,nTe=function(){function n(){}return function(e){if(!O1(e))return{};if(k9)return k9(e);n.prototype=e;var t=new n;return n.prototype=void 0,t}}();const iTe=nTe;function rTe(n){return typeof n.constructor=="function"&&!TB(n)?iTe(wB(n)):{}}var sTe="[object Map]";function oTe(n){return em(n)&&AB(n)==sTe}var R9=Cy&&Cy.isMap,aTe=R9?SB(R9):oTe;const lTe=aTe;var uTe="[object Set]";function cTe(n){return em(n)&&AB(n)==uTe}var N9=Cy&&Cy.isSet,hTe=N9?SB(N9):cTe;const dTe=hTe;var pTe=1,fTe=2,mTe=4,W7="[object Arguments]",gTe="[object Array]",yTe="[object Boolean]",bTe="[object Date]",xTe="[object Error]",H7="[object Function]",vTe="[object GeneratorFunction]",wTe="[object Map]",STe="[object Number]",X7="[object Object]",TTe="[object RegExp]",CTe="[object Set]",_Te="[object String]",MTe="[object Symbol]",ATe="[object WeakMap]",ETe="[object ArrayBuffer]",ITe="[object DataView]",kTe="[object Float32Array]",RTe="[object Float64Array]",NTe="[object Int8Array]",LTe="[object Int16Array]",PTe="[object Int32Array]",DTe="[object Uint8Array]",FTe="[object Uint8ClampedArray]",OTe="[object Uint16Array]",BTe="[object Uint32Array]",Jn={};Jn[W7]=Jn[gTe]=Jn[ETe]=Jn[ITe]=Jn[yTe]=Jn[bTe]=Jn[kTe]=Jn[RTe]=Jn[NTe]=Jn[LTe]=Jn[PTe]=Jn[wTe]=Jn[STe]=Jn[X7]=Jn[TTe]=Jn[CTe]=Jn[_Te]=Jn[MTe]=Jn[DTe]=Jn[FTe]=Jn[OTe]=Jn[BTe]=!0;Jn[xTe]=Jn[H7]=Jn[ATe]=!1;function F_(n,e,t,i,r,s){var o,a=e&pTe,l=e&fTe,u=e&mTe;if(t&&(o=r?t(n,i,r,s):t(n)),o!==void 0)return o;if(!O1(n))return n;var c=B1(n);if(c){if(o=ISe(n),!a)return z7(n,o)}else{var h=AB(n),d=h==H7||h==vTe;if(L7(n))return oSe(n,a);if(h==X7||h==W7||d&&!r){if(o=l||d?{}:rTe(n),!a)return l?fSe(n,rSe(o,n)):hSe(n,qwe(o,n))}else{if(!Jn[h])return r?n:{};o=tTe(n,h,a)}}s||(s=new Qy);var p=s.get(n);if(p)return p;s.set(n,o),dTe(n)?n.forEach(function(y){o.add(F_(y,e,t,y,n,s))}):lTe(n)&&n.forEach(function(y,m){o.set(m,F_(y,e,t,m,n,s))});var f=u?l?gSe:mSe:l?_B:CB,g=c?void 0:f(n);return J1e(g||n,function(y,m){g&&(m=y,y=n[m]),k7(o,m,F_(y,e,t,m,n,s))}),o}var zTe=4;function L9(n){return F_(n,zTe)}function K7(n,e){for(var t=-1,i=n==null?0:n.length,r=Array(i);++t<i;)r[t]=e(n[t],t,n);return r}var GTe="[object Symbol]";function IB(n){return typeof n=="symbol"||em(n)&&qf(n)==GTe}var VTe="Expected a function";function kB(n,e){if(typeof n!="function"||e!=null&&typeof e!="function")throw new TypeError(VTe);var t=function(){var i=arguments,r=e?e.apply(this,i):i[0],s=t.cache;if(s.has(r))return s.get(r);var o=n.apply(this,i);return t.cache=s.set(r,o)||s,o};return t.cache=new(kB.Cache||Ld),t}kB.Cache=Ld;var UTe=500;function $Te(n){var e=kB(n,function(i){return t.size===UTe&&t.clear(),i}),t=e.cache;return e}var WTe=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,HTe=/\\(\\)?/g,XTe=$Te(function(n){var e=[];return n.charCodeAt(0)===46&&e.push(""),n.replace(WTe,function(t,i,r,s){e.push(r?s.replace(HTe,"$1"):i||t)}),e});const KTe=XTe;var ZTe=1/0;function jTe(n){if(typeof n=="string"||IB(n))return n;var e=n+"";return e=="0"&&1/n==-ZTe?"-0":e}var YTe=1/0,P9=fd?fd.prototype:void 0,D9=P9?P9.toString:void 0;function Z7(n){if(typeof n=="string")return n;if(B1(n))return K7(n,Z7)+"";if(IB(n))return D9?D9.call(n):"";var e=n+"";return e=="0"&&1/n==-YTe?"-0":e}function JTe(n){return n==null?"":Z7(n)}function j7(n){return B1(n)?K7(n,jTe):IB(n)?[n]:z7(KTe(JTe(n)))}var Y7={exports:{}},$n={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Jr=typeof Symbol=="function"&&Symbol.for,RB=Jr?Symbol.for("react.element"):60103,NB=Jr?Symbol.for("react.portal"):60106,aE=Jr?Symbol.for("react.fragment"):60107,lE=Jr?Symbol.for("react.strict_mode"):60108,uE=Jr?Symbol.for("react.profiler"):60114,cE=Jr?Symbol.for("react.provider"):60109,hE=Jr?Symbol.for("react.context"):60110,LB=Jr?Symbol.for("react.async_mode"):60111,dE=Jr?Symbol.for("react.concurrent_mode"):60111,pE=Jr?Symbol.for("react.forward_ref"):60112,fE=Jr?Symbol.for("react.suspense"):60113,QTe=Jr?Symbol.for("react.suspense_list"):60120,mE=Jr?Symbol.for("react.memo"):60115,gE=Jr?Symbol.for("react.lazy"):60116,qTe=Jr?Symbol.for("react.block"):60121,eCe=Jr?Symbol.for("react.fundamental"):60117,tCe=Jr?Symbol.for("react.responder"):60118,nCe=Jr?Symbol.for("react.scope"):60119;function ga(n){if(typeof n=="object"&&n!==null){var e=n.$$typeof;switch(e){case RB:switch(n=n.type,n){case LB:case dE:case aE:case uE:case lE:case fE:return n;default:switch(n=n&&n.$$typeof,n){case hE:case pE:case gE:case mE:case cE:return n;default:return e}}case NB:return e}}}function J7(n){return ga(n)===dE}$n.AsyncMode=LB;$n.ConcurrentMode=dE;$n.ContextConsumer=hE;$n.ContextProvider=cE;$n.Element=RB;$n.ForwardRef=pE;$n.Fragment=aE;$n.Lazy=gE;$n.Memo=mE;$n.Portal=NB;$n.Profiler=uE;$n.StrictMode=lE;$n.Suspense=fE;$n.isAsyncMode=function(n){return J7(n)||ga(n)===LB};$n.isConcurrentMode=J7;$n.isContextConsumer=function(n){return ga(n)===hE};$n.isContextProvider=function(n){return ga(n)===cE};$n.isElement=function(n){return typeof n=="object"&&n!==null&&n.$$typeof===RB};$n.isForwardRef=function(n){return ga(n)===pE};$n.isFragment=function(n){return ga(n)===aE};$n.isLazy=function(n){return ga(n)===gE};$n.isMemo=function(n){return ga(n)===mE};$n.isPortal=function(n){return ga(n)===NB};$n.isProfiler=function(n){return ga(n)===uE};$n.isStrictMode=function(n){return ga(n)===lE};$n.isSuspense=function(n){return ga(n)===fE};$n.isValidElementType=function(n){return typeof n=="string"||typeof n=="function"||n===aE||n===dE||n===uE||n===lE||n===fE||n===QTe||typeof n=="object"&&n!==null&&(n.$$typeof===gE||n.$$typeof===mE||n.$$typeof===cE||n.$$typeof===hE||n.$$typeof===pE||n.$$typeof===eCe||n.$$typeof===tCe||n.$$typeof===nCe||n.$$typeof===qTe)};$n.typeOf=ga;Y7.exports=$n;var iCe=Y7.exports,Q7=iCe,rCe={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},sCe={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},q7={};q7[Q7.ForwardRef]=rCe;q7[Q7.Memo]=sCe;function zr(){return zr=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},zr.apply(this,arguments)}function eQ(n,e){if(n==null)return{};var t={},i=Object.keys(n),r,s;for(s=0;s<i.length;s++)r=i[s],!(e.indexOf(r)>=0)&&(t[r]=n[r]);return t}var yE=K.createContext(void 0);yE.displayName="FormikContext";yE.Provider;yE.Consumer;function oCe(){var n=K.useContext(yE);return n||t1e(!1),n}var gl=function(e){return typeof e=="function"},bE=function(e){return e!==null&&typeof e=="object"},aCe=function(e){return String(Math.floor(Number(e)))===e},BN=function(e){return Object.prototype.toString.call(e)==="[object String]"},zN=function(e){return bE(e)&&gl(e.then)};function Ho(n,e,t,i){i===void 0&&(i=0);for(var r=j7(e);n&&i<r.length;)n=n[r[i++]];return i!==r.length&&!n||n===void 0?t:n}function qp(n,e,t){for(var i=L9(n),r=i,s=0,o=j7(e);s<o.length-1;s++){var a=o[s],l=Ho(n,o.slice(0,s+1));if(l&&(bE(l)||Array.isArray(l)))r=r[a]=L9(l);else{var u=o[s+1];r=r[a]=aCe(u)&&Number(u)>=0?[]:{}}}return(s===0?n:r)[o[s]]===t?n:(t===void 0?delete r[o[s]]:r[o[s]]=t,s===0&&t===void 0&&delete i[o[s]],i)}function tQ(n,e,t,i){t===void 0&&(t=new WeakMap),i===void 0&&(i={});for(var r=0,s=Object.keys(n);r<s.length;r++){var o=s[r],a=n[o];bE(a)?t.get(a)||(t.set(a,!0),i[o]=Array.isArray(a)?[]:{},tQ(a,e,t,i[o])):i[o]=e}return i}function lCe(n,e){switch(e.type){case"SET_VALUES":return zr({},n,{values:e.payload});case"SET_TOUCHED":return zr({},n,{touched:e.payload});case"SET_ERRORS":return Sp(n.errors,e.payload)?n:zr({},n,{errors:e.payload});case"SET_STATUS":return zr({},n,{status:e.payload});case"SET_ISSUBMITTING":return zr({},n,{isSubmitting:e.payload});case"SET_ISVALIDATING":return zr({},n,{isValidating:e.payload});case"SET_FIELD_VALUE":return zr({},n,{values:qp(n.values,e.payload.field,e.payload.value)});case"SET_FIELD_TOUCHED":return zr({},n,{touched:qp(n.touched,e.payload.field,e.payload.value)});case"SET_FIELD_ERROR":return zr({},n,{errors:qp(n.errors,e.payload.field,e.payload.value)});case"RESET_FORM":return zr({},n,e.payload);case"SET_FORMIK_STATE":return e.payload(n);case"SUBMIT_ATTEMPT":return zr({},n,{touched:tQ(n.values,!0),isSubmitting:!0,submitCount:n.submitCount+1});case"SUBMIT_FAILURE":return zr({},n,{isSubmitting:!1});case"SUBMIT_SUCCESS":return zr({},n,{isSubmitting:!1});default:return n}}var np={},nC={};function uCe(n){var e=n.validateOnChange,t=e===void 0?!0:e,i=n.validateOnBlur,r=i===void 0?!0:i,s=n.validateOnMount,o=s===void 0?!1:s,a=n.isInitialValid,l=n.enableReinitialize,u=l===void 0?!1:l,c=n.onSubmit,h=eQ(n,["validateOnChange","validateOnBlur","validateOnMount","isInitialValid","enableReinitialize","onSubmit"]),d=zr({validateOnChange:t,validateOnBlur:r,validateOnMount:o,onSubmit:c},h),p=K.useRef(d.initialValues),f=K.useRef(d.initialErrors||np),g=K.useRef(d.initialTouched||nC),y=K.useRef(d.initialStatus),m=K.useRef(!1),v=K.useRef({});K.useEffect(function(){return m.current=!0,function(){m.current=!1}},[]);var w=K.useState(0),S=w[1],C=K.useRef({values:d.initialValues,errors:d.initialErrors||np,touched:d.initialTouched||nC,status:d.initialStatus,isSubmitting:!1,isValidating:!1,submitCount:0}),_=C.current,A=K.useCallback(function(ye){var H=C.current;C.current=lCe(H,ye),H!==C.current&&S(function(D){return D+1})},[]),I=K.useCallback(function(ye,H){return new Promise(function(D,oe){var Ie=d.validate(ye,H);Ie==null?D(np):zN(Ie)?Ie.then(function(Me){D(Me||np)},function(Me){oe(Me)}):D(Ie)})},[d.validate]),E=K.useCallback(function(ye,H){var D=d.validationSchema,oe=gl(D)?D(H):D,Ie=H&&oe.validateAt?oe.validateAt(H,ye):hCe(ye,oe);return new Promise(function(Me,Ve){Ie.then(function(){Me(np)},function(ct){ct.name==="ValidationError"?Me(cCe(ct)):Ve(ct)})})},[d.validationSchema]),k=K.useCallback(function(ye,H){return new Promise(function(D){return D(v.current[ye].validate(H))})},[]),P=K.useCallback(function(ye){var H=Object.keys(v.current).filter(function(oe){return gl(v.current[oe].validate)}),D=H.length>0?H.map(function(oe){return k(oe,Ho(ye,oe))}):[Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];return Promise.all(D).then(function(oe){return oe.reduce(function(Ie,Me,Ve){return Me==="DO_NOT_DELETE_YOU_WILL_BE_FIRED"||Me&&(Ie=qp(Ie,H[Ve],Me)),Ie},{})})},[k]),V=K.useCallback(function(ye){return Promise.all([P(ye),d.validationSchema?E(ye):{},d.validate?I(ye):{}]).then(function(H){var D=H[0],oe=H[1],Ie=H[2],Me=$D.all([D,oe,Ie],{arrayMerge:dCe});return Me})},[d.validate,d.validationSchema,P,I,E]),U=Na(function(ye){return ye===void 0&&(ye=_.values),A({type:"SET_ISVALIDATING",payload:!0}),V(ye).then(function(H){return m.current&&(A({type:"SET_ISVALIDATING",payload:!1}),A({type:"SET_ERRORS",payload:H})),H})});K.useEffect(function(){o&&m.current===!0&&Sp(p.current,d.initialValues)&&U(p.current)},[o,U]);var F=K.useCallback(function(ye){var H=ye&&ye.values?ye.values:p.current,D=ye&&ye.errors?ye.errors:f.current?f.current:d.initialErrors||{},oe=ye&&ye.touched?ye.touched:g.current?g.current:d.initialTouched||{},Ie=ye&&ye.status?ye.status:y.current?y.current:d.initialStatus;p.current=H,f.current=D,g.current=oe,y.current=Ie;var Me=function(){A({type:"RESET_FORM",payload:{isSubmitting:!!ye&&!!ye.isSubmitting,errors:D,touched:oe,status:Ie,values:H,isValidating:!!ye&&!!ye.isValidating,submitCount:ye&&ye.submitCount&&typeof ye.submitCount=="number"?ye.submitCount:0}})};if(d.onReset){var Ve=d.onReset(_.values,De);zN(Ve)?Ve.then(Me):Me()}else Me()},[d.initialErrors,d.initialStatus,d.initialTouched,d.onReset]);K.useEffect(function(){m.current===!0&&!Sp(p.current,d.initialValues)&&u&&(p.current=d.initialValues,F(),o&&U(p.current))},[u,d.initialValues,F,o,U]),K.useEffect(function(){u&&m.current===!0&&!Sp(f.current,d.initialErrors)&&(f.current=d.initialErrors||np,A({type:"SET_ERRORS",payload:d.initialErrors||np}))},[u,d.initialErrors]),K.useEffect(function(){u&&m.current===!0&&!Sp(g.current,d.initialTouched)&&(g.current=d.initialTouched||nC,A({type:"SET_TOUCHED",payload:d.initialTouched||nC}))},[u,d.initialTouched]),K.useEffect(function(){u&&m.current===!0&&!Sp(y.current,d.initialStatus)&&(y.current=d.initialStatus,A({type:"SET_STATUS",payload:d.initialStatus}))},[u,d.initialStatus,d.initialTouched]);var $=Na(function(ye){if(v.current[ye]&&gl(v.current[ye].validate)){var H=Ho(_.values,ye),D=v.current[ye].validate(H);return zN(D)?(A({type:"SET_ISVALIDATING",payload:!0}),D.then(function(oe){return oe}).then(function(oe){A({type:"SET_FIELD_ERROR",payload:{field:ye,value:oe}}),A({type:"SET_ISVALIDATING",payload:!1})})):(A({type:"SET_FIELD_ERROR",payload:{field:ye,value:D}}),Promise.resolve(D))}else if(d.validationSchema)return A({type:"SET_ISVALIDATING",payload:!0}),E(_.values,ye).then(function(oe){return oe}).then(function(oe){A({type:"SET_FIELD_ERROR",payload:{field:ye,value:Ho(oe,ye)}}),A({type:"SET_ISVALIDATING",payload:!1})});return Promise.resolve()}),J=K.useCallback(function(ye,H){var D=H.validate;v.current[ye]={validate:D}},[]),q=K.useCallback(function(ye){delete v.current[ye]},[]),O=Na(function(ye,H){A({type:"SET_TOUCHED",payload:ye});var D=H===void 0?r:H;return D?U(_.values):Promise.resolve()}),X=K.useCallback(function(ye){A({type:"SET_ERRORS",payload:ye})},[]),j=Na(function(ye,H){var D=gl(ye)?ye(_.values):ye;A({type:"SET_VALUES",payload:D});var oe=H===void 0?t:H;return oe?U(D):Promise.resolve()}),z=K.useCallback(function(ye,H){A({type:"SET_FIELD_ERROR",payload:{field:ye,value:H}})},[]),Z=Na(function(ye,H,D){A({type:"SET_FIELD_VALUE",payload:{field:ye,value:H}});var oe=D===void 0?t:D;return oe?U(qp(_.values,ye,H)):Promise.resolve()}),ce=K.useCallback(function(ye,H){var D=H,oe=ye,Ie;if(!BN(ye)){ye.persist&&ye.persist();var Me=ye.target?ye.target:ye.currentTarget,Ve=Me.type,ct=Me.name,qe=Me.id,at=Me.value,Ot=Me.checked,Xt=Me.outerHTML,Qe=Me.options,sn=Me.multiple;D=H||ct||qe,oe=/number|range/.test(Ve)?(Ie=parseFloat(at),isNaN(Ie)?"":Ie):/checkbox/.test(Ve)?fCe(Ho(_.values,D),Ot,at):Qe&&sn?pCe(Qe):at}D&&Z(D,oe)},[Z,_.values]),fe=Na(function(ye){if(BN(ye))return function(H){return ce(H,ye)};ce(ye)}),ge=Na(function(ye,H,D){H===void 0&&(H=!0),A({type:"SET_FIELD_TOUCHED",payload:{field:ye,value:H}});var oe=D===void 0?r:D;return oe?U(_.values):Promise.resolve()}),Ne=K.useCallback(function(ye,H){ye.persist&&ye.persist();var D=ye.target,oe=D.name,Ie=D.id,Me=D.outerHTML,Ve=H||oe||Ie;ge(Ve,!0)},[ge]),Fe=Na(function(ye){if(BN(ye))return function(H){return Ne(H,ye)};Ne(ye)}),We=K.useCallback(function(ye){gl(ye)?A({type:"SET_FORMIK_STATE",payload:ye}):A({type:"SET_FORMIK_STATE",payload:function(){return ye}})},[]),Ue=K.useCallback(function(ye){A({type:"SET_STATUS",payload:ye})},[]),Ye=K.useCallback(function(ye){A({type:"SET_ISSUBMITTING",payload:ye})},[]),$e=Na(function(){return A({type:"SUBMIT_ATTEMPT"}),U().then(function(ye){var H=ye instanceof Error,D=!H&&Object.keys(ye).length===0;if(D){var oe;try{if(oe=_e(),oe===void 0)return}catch(Ie){throw Ie}return Promise.resolve(oe).then(function(Ie){return m.current&&A({type:"SUBMIT_SUCCESS"}),Ie}).catch(function(Ie){if(m.current)throw A({type:"SUBMIT_FAILURE"}),Ie})}else if(m.current&&(A({type:"SUBMIT_FAILURE"}),H))throw ye})}),ee=Na(function(ye){ye&&ye.preventDefault&&gl(ye.preventDefault)&&ye.preventDefault(),ye&&ye.stopPropagation&&gl(ye.stopPropagation)&&ye.stopPropagation(),$e().catch(function(H){console.warn("Warning: An unhandled error was caught from submitForm()",H)})}),De={resetForm:F,validateForm:U,validateField:$,setErrors:X,setFieldError:z,setFieldTouched:ge,setFieldValue:Z,setStatus:Ue,setSubmitting:Ye,setTouched:O,setValues:j,setFormikState:We,submitForm:$e},_e=Na(function(){return c(_.values,De)}),ze=Na(function(ye){ye&&ye.preventDefault&&gl(ye.preventDefault)&&ye.preventDefault(),ye&&ye.stopPropagation&&gl(ye.stopPropagation)&&ye.stopPropagation(),F()}),Re=K.useCallback(function(ye){return{value:Ho(_.values,ye),error:Ho(_.errors,ye),touched:!!Ho(_.touched,ye),initialValue:Ho(p.current,ye),initialTouched:!!Ho(g.current,ye),initialError:Ho(f.current,ye)}},[_.errors,_.touched,_.values]),nt=K.useCallback(function(ye){return{setValue:function(D,oe){return Z(ye,D,oe)},setTouched:function(D,oe){return ge(ye,D,oe)},setError:function(D){return z(ye,D)}}},[Z,ge,z]),Ze=K.useCallback(function(ye){var H=bE(ye),D=H?ye.name:ye,oe=Ho(_.values,D),Ie={name:D,value:oe,onChange:fe,onBlur:Fe};if(H){var Me=ye.type,Ve=ye.value,ct=ye.as,qe=ye.multiple;Me==="checkbox"?Ve===void 0?Ie.checked=!!oe:(Ie.checked=!!(Array.isArray(oe)&&~oe.indexOf(Ve)),Ie.value=Ve):Me==="radio"?(Ie.checked=oe===Ve,Ie.value=Ve):ct==="select"&&qe&&(Ie.value=Ie.value||[],Ie.multiple=!0)}return Ie},[Fe,fe,_.values]),st=K.useMemo(function(){return!Sp(p.current,_.values)},[p.current,_.values]),yt=K.useMemo(function(){return typeof a<"u"?st?_.errors&&Object.keys(_.errors).length===0:a!==!1&&gl(a)?a(d):a:_.errors&&Object.keys(_.errors).length===0},[a,st,_.errors,d]),Lt=zr({},_,{initialValues:p.current,initialErrors:f.current,initialTouched:g.current,initialStatus:y.current,handleBlur:Fe,handleChange:fe,handleReset:ze,handleSubmit:ee,resetForm:F,setErrors:X,setFormikState:We,setFieldTouched:ge,setFieldValue:Z,setFieldError:z,setStatus:Ue,setSubmitting:Ye,setTouched:O,setValues:j,submitForm:$e,validateForm:U,validateField:$,isValid:yt,dirty:st,unregisterField:q,registerField:J,getFieldProps:Ze,getFieldMeta:Re,getFieldHelpers:nt,validateOnBlur:r,validateOnChange:t,validateOnMount:o});return Lt}function cCe(n){var e={};if(n.inner){if(n.inner.length===0)return qp(e,n.path,n.message);for(var r=n.inner,t=Array.isArray(r),i=0,r=t?r:r[Symbol.iterator]();;){var s;if(t){if(i>=r.length)break;s=r[i++]}else{if(i=r.next(),i.done)break;s=i.value}var o=s;Ho(e,o.path)||(e=qp(e,o.path,o.message))}}return e}function hCe(n,e,t,i){t===void 0&&(t=!1);var r=jD(n);return e[t?"validateSync":"validate"](r,{abortEarly:!1,context:i||r})}function jD(n){var e=Array.isArray(n)?[]:{};for(var t in n)if(Object.prototype.hasOwnProperty.call(n,t)){var i=String(t);Array.isArray(n[i])===!0?e[i]=n[i].map(function(r){return Array.isArray(r)===!0||u9(r)?jD(r):r!==""?r:void 0}):u9(n[i])?e[i]=jD(n[i]):e[i]=n[i]!==""?n[i]:void 0}return e}function dCe(n,e,t){var i=n.slice();return e.forEach(function(s,o){if(typeof i[o]>"u"){var a=t.clone!==!1,l=a&&t.isMergeableObject(s);i[o]=l?$D(Array.isArray(s)?[]:{},s,t):s}else t.isMergeableObject(s)?i[o]=$D(n[o],s,t):n.indexOf(s)===-1&&i.push(s)}),i}function pCe(n){return Array.from(n).filter(function(e){return e.selected}).map(function(e){return e.value})}function fCe(n,e,t){if(typeof n=="boolean")return!!e;var i=[],r=!1,s=-1;if(Array.isArray(n))i=n,s=n.indexOf(t),r=s>=0;else if(!t||t=="true"||t=="false")return!!e;return e&&t&&!r?i.concat(t):r?i.slice(0,s).concat(i.slice(s+1)):i}var mCe=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u"?K.useLayoutEffect:K.useEffect;function Na(n){var e=K.useRef(n);return mCe(function(){e.current=n}),K.useCallback(function(){for(var t=arguments.length,i=new Array(t),r=0;r<t;r++)i[r]=arguments[r];return e.current.apply(void 0,i)},[])}var gCe=K.forwardRef(function(n,e){var t=n.action,i=eQ(n,["action"]),r=t??"#",s=oCe(),o=s.handleReset,a=s.handleSubmit;return K.createElement("form",zr({onSubmit:a,ref:e,onReset:o,action:r},i))});gCe.displayName="Form";function im(n){this._maxSize=n,this.clear()}im.prototype.clear=function(){this._size=0,this._values=Object.create(null)};im.prototype.get=function(n){return this._values[n]};im.prototype.set=function(n,e){return this._size>=this._maxSize&&this.clear(),n in this._values||this._size++,this._values[n]=e};var yCe=/[^.^\]^[]+|(?=\[\]|\.\.)/g,nQ=/^\d+$/,bCe=/^\d/,xCe=/[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,vCe=/^\s*(['"]?)(.*?)(\1)\s*$/,PB=512,F9=new im(PB),O9=new im(PB),B9=new im(PB),ef={Cache:im,split:YD,normalizePath:GN,setter:function(n){var e=GN(n);return O9.get(n)||O9.set(n,function(i,r){for(var s=0,o=e.length,a=i;s<o-1;){var l=e[s];if(l==="__proto__"||l==="constructor"||l==="prototype")return i;a=a[e[s++]]}a[e[s]]=r})},getter:function(n,e){var t=GN(n);return B9.get(n)||B9.set(n,function(r){for(var s=0,o=t.length;s<o;)if(r!=null||!e)r=r[t[s++]];else return;return r})},join:function(n){return n.reduce(function(e,t){return e+(DB(t)||nQ.test(t)?"["+t+"]":(e?".":"")+t)},"")},forEach:function(n,e,t){wCe(Array.isArray(n)?n:YD(n),e,t)}};function GN(n){return F9.get(n)||F9.set(n,YD(n).map(function(e){return e.replace(vCe,"$2")}))}function YD(n){return n.match(yCe)||[""]}function wCe(n,e,t){var i=n.length,r,s,o,a;for(s=0;s<i;s++)r=n[s],r&&(CCe(r)&&(r='"'+r+'"'),a=DB(r),o=!a&&/^\d+$/.test(r),e.call(t,r,a,o,s,n))}function DB(n){return typeof n=="string"&&n&&["'",'"'].indexOf(n.charAt(0))!==-1}function SCe(n){return n.match(bCe)&&!n.match(nQ)}function TCe(n){return xCe.test(n)}function CCe(n){return!DB(n)&&(SCe(n)||TCe(n))}const _Ce=/[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,xE=n=>n.match(_Ce)||[],vE=n=>n[0].toUpperCase()+n.slice(1),FB=(n,e)=>xE(n).join(e).toLowerCase(),iQ=n=>xE(n).reduce((e,t)=>`${e}${e?t[0].toUpperCase()+t.slice(1).toLowerCase():t.toLowerCase()}`,""),MCe=n=>vE(iQ(n)),ACe=n=>FB(n,"_"),ECe=n=>FB(n,"-"),ICe=n=>vE(FB(n," ")),kCe=n=>xE(n).map(vE).join(" ");var VN={words:xE,upperFirst:vE,camelCase:iQ,pascalCase:MCe,snakeCase:ACe,kebabCase:ECe,sentenceCase:ICe,titleCase:kCe},OB={exports:{}};OB.exports=function(n){return rQ(RCe(n),n)};OB.exports.array=rQ;function rQ(n,e){var t=n.length,i=new Array(t),r={},s=t,o=NCe(e),a=LCe(n);for(e.forEach(function(u){if(!a.has(u[0])||!a.has(u[1]))throw new Error("Unknown node. There is an unknown node in the supplied edges.")});s--;)r[s]||l(n[s],s,new Set);return i;function l(u,c,h){if(h.has(u)){var d;try{d=", node was:"+JSON.stringify(u)}catch{d=""}throw new Error("Cyclic dependency"+d)}if(!a.has(u))throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: "+JSON.stringify(u));if(!r[c]){r[c]=!0;var p=o.get(u)||new Set;if(p=Array.from(p),c=p.length){h.add(u);do{var f=p[--c];l(f,a.get(f),h)}while(c);h.delete(u)}i[--t]=u}}}function RCe(n){for(var e=new Set,t=0,i=n.length;t<i;t++){var r=n[t];e.add(r[0]),e.add(r[1])}return Array.from(e)}function NCe(n){for(var e=new Map,t=0,i=n.length;t<i;t++){var r=n[t];e.has(r[0])||e.set(r[0],new Set),e.has(r[1])||e.set(r[1],new Set),e.get(r[0]).add(r[1])}return e}function LCe(n){for(var e=new Map,t=0,i=n.length;t<i;t++)e.set(n[t],t);return e}var PCe=OB.exports;const DCe=Zy(PCe),FCe=Object.prototype.toString,OCe=Error.prototype.toString,BCe=RegExp.prototype.toString,zCe=typeof Symbol<"u"?Symbol.prototype.toString:()=>"",GCe=/^Symbol\((.*)\)(.*)$/;function VCe(n){return n!=+n?"NaN":n===0&&1/n<0?"-0":""+n}function z9(n,e=!1){if(n==null||n===!0||n===!1)return""+n;const t=typeof n;if(t==="number")return VCe(n);if(t==="string")return e?`"${n}"`:n;if(t==="function")return"[Function "+(n.name||"anonymous")+"]";if(t==="symbol")return zCe.call(n).replace(GCe,"Symbol($1)");const i=FCe.call(n).slice(8,-1);return i==="Date"?isNaN(n.getTime())?""+n:n.toISOString(n):i==="Error"||n instanceof Error?"["+OCe.call(n)+"]":i==="RegExp"?BCe.call(n):null}function nd(n,e){let t=z9(n,e);return t!==null?t:JSON.stringify(n,function(i,r){let s=z9(this[i],e);return s!==null?s:r},2)}function sQ(n){return n==null?[]:[].concat(n)}let oQ,UCe=/\$\{\s*(\w+)\s*\}/g;oQ=Symbol.toStringTag;class yo extends Error{static formatError(e,t){const i=t.label||t.path||"this";return i!==t.path&&(t=Object.assign({},t,{path:i})),typeof e=="string"?e.replace(UCe,(r,s)=>nd(t[s])):typeof e=="function"?e(t):e}static isError(e){return e&&e.name==="ValidationError"}constructor(e,t,i,r,s){super(),this.value=void 0,this.path=void 0,this.type=void 0,this.errors=void 0,this.params=void 0,this.inner=void 0,this[oQ]="Error",this.name="ValidationError",this.value=t,this.path=i,this.type=r,this.errors=[],this.inner=[],sQ(e).forEach(o=>{if(yo.isError(o)){this.errors.push(...o.errors);const a=o.inner.length?o.inner:[o];this.inner.push(...a)}else this.errors.push(o)}),this.message=this.errors.length>1?`${this.errors.length} errors occurred`:this.errors[0],!s&&Error.captureStackTrace&&Error.captureStackTrace(this,yo)}}let mu={default:"${path} is invalid",required:"${path} is a required field",defined:"${path} must be defined",notNull:"${path} cannot be null",oneOf:"${path} must be one of the following values: ${values}",notOneOf:"${path} must not be one of the following values: ${values}",notType:({path:n,type:e,value:t,originalValue:i})=>{const r=i!=null&&i!==t?` (cast from the value \`${nd(i,!0)}\`).`:".";return e!=="mixed"?`${n} must be a \`${e}\` type, but the final value was: \`${nd(t,!0)}\``+r:`${n} must match the configured type. The validated value was: \`${nd(t,!0)}\``+r}},yl={length:"${path} must be exactly ${length} characters",min:"${path} must be at least ${min} characters",max:"${path} must be at most ${max} characters",matches:'${path} must match the following: "${regex}"',email:"${path} must be a valid email",url:"${path} must be a valid URL",uuid:"${path} must be a valid UUID",trim:"${path} must be a trimmed string",lowercase:"${path} must be a lowercase string",uppercase:"${path} must be a upper case string"},$Ce={min:"${path} must be greater than or equal to ${min}",max:"${path} must be less than or equal to ${max}",lessThan:"${path} must be less than ${less}",moreThan:"${path} must be greater than ${more}",positive:"${path} must be a positive number",negative:"${path} must be a negative number",integer:"${path} must be an integer"},JD={min:"${path} field must be later than ${min}",max:"${path} field must be at earlier than ${max}"},WCe={isValue:"${path} field must be ${value}"},QD={noUnknown:"${path} field has unspecified keys: ${unknown}"},HCe={min:"${path} field must have at least ${min} items",max:"${path} field must have less than or equal to ${max} items",length:"${path} must have ${length} items"},XCe={notType:n=>{const{path:e,value:t,spec:i}=n,r=i.types.length;if(Array.isArray(t)){if(t.length<r)return`${e} tuple value has too few items, expected a length of ${r} but got ${t.length} for value: \`${nd(t,!0)}\``;if(t.length>r)return`${e} tuple value has too many items, expected a length of ${r} but got ${t.length} for value: \`${nd(t,!0)}\``}return yo.formatError(mu.notType,n)}};Object.assign(Object.create(null),{mixed:mu,string:yl,number:$Ce,date:JD,object:QD,array:HCe,boolean:WCe,tuple:XCe});const BB=n=>n&&n.__isYupSchema__;class zM{static fromOptions(e,t){if(!t.then&&!t.otherwise)throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");let{is:i,then:r,otherwise:s}=t,o=typeof i=="function"?i:(...a)=>a.every(l=>l===i);return new zM(e,(a,l)=>{var u;let c=o(...a)?r:s;return(u=c==null?void 0:c(l))!=null?u:l})}constructor(e,t){this.fn=void 0,this.refs=e,this.refs=e,this.fn=t}resolve(e,t){let i=this.refs.map(s=>s.getValue(t==null?void 0:t.value,t==null?void 0:t.parent,t==null?void 0:t.context)),r=this.fn(i,e,t);if(r===void 0||r===e)return e;if(!BB(r))throw new TypeError("conditions must return a schema object");return r.resolve(t)}}const iC={context:"$",value:"."};class rm{constructor(e,t={}){if(this.key=void 0,this.isContext=void 0,this.isValue=void 0,this.isSibling=void 0,this.path=void 0,this.getter=void 0,this.map=void 0,typeof e!="string")throw new TypeError("ref must be a string, got: "+e);if(this.key=e.trim(),e==="")throw new TypeError("ref must be a non-empty string");this.isContext=this.key[0]===iC.context,this.isValue=this.key[0]===iC.value,this.isSibling=!this.isContext&&!this.isValue;let i=this.isContext?iC.context:this.isValue?iC.value:"";this.path=this.key.slice(i.length),this.getter=this.path&&ef.getter(this.path,!0),this.map=t.map}getValue(e,t,i){let r=this.isContext?i:this.isValue?e:t;return this.getter&&(r=this.getter(r||{})),this.map&&(r=this.map(r)),r}cast(e,t){return this.getValue(e,t==null?void 0:t.parent,t==null?void 0:t.context)}resolve(){return this}describe(){return{type:"ref",key:this.key}}toString(){return`Ref(${this.key})`}static isRef(e){return e&&e.__isYupRef}}rm.prototype.__isYupRef=!0;const Vp=n=>n==null;function Xm(n){function e({value:t,path:i="",options:r,originalValue:s,schema:o},a,l){const{name:u,test:c,params:h,message:d,skipAbsent:p}=n;let{parent:f,context:g,abortEarly:y=o.spec.abortEarly,disableStackTrace:m=o.spec.disableStackTrace}=r;function v(P){return rm.isRef(P)?P.getValue(t,f,g):P}function w(P={}){var V;const U=Object.assign({value:t,originalValue:s,label:o.spec.label,path:P.path||i,spec:o.spec},h,P.params);for(const $ of Object.keys(U))U[$]=v(U[$]);const F=new yo(yo.formatError(P.message||d,U),t,U.path,P.type||u,(V=P.disableStackTrace)!=null?V:m);return F.params=U,F}const S=y?a:l;let C={path:i,parent:f,type:u,from:r.from,createError:w,resolve:v,options:r,originalValue:s,schema:o};const _=P=>{yo.isError(P)?S(P):P?l(null):S(w())},A=P=>{yo.isError(P)?S(P):a(P)};if(p&&Vp(t))return _(!0);let E;try{var k;if(E=c.call(C,t,C),typeof((k=E)==null?void 0:k.then)=="function"){if(r.sync)throw new Error(`Validation test of type: "${C.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);return Promise.resolve(E).then(_,A)}}catch(P){A(P);return}_(E)}return e.OPTIONS=n,e}function KCe(n,e,t,i=t){let r,s,o;return e?(ef.forEach(e,(a,l,u)=>{let c=l?a.slice(1,a.length-1):a;n=n.resolve({context:i,parent:r,value:t});let h=n.type==="tuple",d=u?parseInt(c,10):0;if(n.innerType||h){if(h&&!u)throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${o}" must contain an index to the tuple element, e.g. "${o}[0]"`);if(t&&d>=t.length)throw new Error(`Yup.reach cannot resolve an array item at index: ${a}, in the path: ${e}. because there is no value at that index. `);r=t,t=t&&t[d],n=h?n.spec.types[d]:n.innerType}if(!u){if(!n.fields||!n.fields[c])throw new Error(`The schema does not contain the path: ${e}. (failed at: ${o} which is a type: "${n.type}")`);r=t,t=t&&t[c],n=n.fields[c]}s=c,o=l?"["+a+"]":"."+a}),{schema:n,parent:r,parentPath:s}):{parent:r,parentPath:e,schema:n}}class GM extends Set{describe(){const e=[];for(const t of this.values())e.push(rm.isRef(t)?t.describe():t);return e}resolveAll(e){let t=[];for(const i of this.values())t.push(e(i));return t}clone(){return new GM(this.values())}merge(e,t){const i=this.clone();return e.forEach(r=>i.add(r)),t.forEach(r=>i.delete(r)),i}}function Ug(n,e=new Map){if(BB(n)||!n||typeof n!="object")return n;if(e.has(n))return e.get(n);let t;if(n instanceof Date)t=new Date(n.getTime()),e.set(n,t);else if(n instanceof RegExp)t=new RegExp(n),e.set(n,t);else if(Array.isArray(n)){t=new Array(n.length),e.set(n,t);for(let i=0;i<n.length;i++)t[i]=Ug(n[i],e)}else if(n instanceof Map){t=new Map,e.set(n,t);for(const[i,r]of n.entries())t.set(i,Ug(r,e))}else if(n instanceof Set){t=new Set,e.set(n,t);for(const i of n)t.add(Ug(i,e))}else if(n instanceof Object){t={},e.set(n,t);for(const[i,r]of Object.entries(n))t[i]=Ug(r,e)}else throw Error(`Unable to clone ${n}`);return t}class Pu{constructor(e){this.type=void 0,this.deps=[],this.tests=void 0,this.transforms=void 0,this.conditions=[],this._mutate=void 0,this.internalTests={},this._whitelist=new GM,this._blacklist=new GM,this.exclusiveTests=Object.create(null),this._typeCheck=void 0,this.spec=void 0,this.tests=[],this.transforms=[],this.withMutation(()=>{this.typeError(mu.notType)}),this.type=e.type,this._typeCheck=e.check,this.spec=Object.assign({strip:!1,strict:!1,abortEarly:!0,recursive:!0,disableStackTrace:!1,nullable:!1,optional:!0,coerce:!0},e==null?void 0:e.spec),this.withMutation(t=>{t.nonNullable()})}get _type(){return this.type}clone(e){if(this._mutate)return e&&Object.assign(this.spec,e),this;const t=Object.create(Object.getPrototypeOf(this));return t.type=this.type,t._typeCheck=this._typeCheck,t._whitelist=this._whitelist.clone(),t._blacklist=this._blacklist.clone(),t.internalTests=Object.assign({},this.internalTests),t.exclusiveTests=Object.assign({},this.exclusiveTests),t.deps=[...this.deps],t.conditions=[...this.conditions],t.tests=[...this.tests],t.transforms=[...this.transforms],t.spec=Ug(Object.assign({},this.spec,e)),t}label(e){let t=this.clone();return t.spec.label=e,t}meta(...e){if(e.length===0)return this.spec.meta;let t=this.clone();return t.spec.meta=Object.assign(t.spec.meta||{},e[0]),t}withMutation(e){let t=this._mutate;this._mutate=!0;let i=e(this);return this._mutate=t,i}concat(e){if(!e||e===this)return this;if(e.type!==this.type&&this.type!=="mixed")throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`);let t=this,i=e.clone();const r=Object.assign({},t.spec,i.spec);return i.spec=r,i.internalTests=Object.assign({},t.internalTests,i.internalTests),i._whitelist=t._whitelist.merge(e._whitelist,e._blacklist),i._blacklist=t._blacklist.merge(e._blacklist,e._whitelist),i.tests=t.tests,i.exclusiveTests=t.exclusiveTests,i.withMutation(s=>{e.tests.forEach(o=>{s.test(o.OPTIONS)})}),i.transforms=[...t.transforms,...i.transforms],i}isType(e){return e==null?!!(this.spec.nullable&&e===null||this.spec.optional&&e===void 0):this._typeCheck(e)}resolve(e){let t=this;if(t.conditions.length){let i=t.conditions;t=t.clone(),t.conditions=[],t=i.reduce((r,s)=>s.resolve(r,e),t),t=t.resolve(e)}return t}resolveOptions(e){var t,i,r,s;return Object.assign({},e,{from:e.from||[],strict:(t=e.strict)!=null?t:this.spec.strict,abortEarly:(i=e.abortEarly)!=null?i:this.spec.abortEarly,recursive:(r=e.recursive)!=null?r:this.spec.recursive,disableStackTrace:(s=e.disableStackTrace)!=null?s:this.spec.disableStackTrace})}cast(e,t={}){let i=this.resolve(Object.assign({value:e},t)),r=t.assert==="ignore-optionality",s=i._cast(e,t);if(t.assert!==!1&&!i.isType(s)){if(r&&Vp(s))return s;let o=nd(e),a=nd(s);throw new TypeError(`The value of ${t.path||"field"} could not be cast to a value that satisfies the schema type: "${i.type}". 

attempted value: ${o} 
`+(a!==o?`result of cast: ${a}`:""))}return s}_cast(e,t){let i=e===void 0?e:this.transforms.reduce((r,s)=>s.call(this,r,e,this),e);return i===void 0&&(i=this.getDefault(t)),i}_validate(e,t={},i,r){let{path:s,originalValue:o=e,strict:a=this.spec.strict}=t,l=e;a||(l=this._cast(l,Object.assign({assert:!1},t)));let u=[];for(let c of Object.values(this.internalTests))c&&u.push(c);this.runTests({path:s,value:l,originalValue:o,options:t,tests:u},i,c=>{if(c.length)return r(c,l);this.runTests({path:s,value:l,originalValue:o,options:t,tests:this.tests},i,r)})}runTests(e,t,i){let r=!1,{tests:s,value:o,originalValue:a,path:l,options:u}=e,c=g=>{r||(r=!0,t(g,o))},h=g=>{r||(r=!0,i(g,o))},d=s.length,p=[];if(!d)return h([]);let f={value:o,originalValue:a,path:l,options:u,schema:this};for(let g=0;g<s.length;g++){const y=s[g];y(f,c,function(v){v&&(Array.isArray(v)?p.push(...v):p.push(v)),--d<=0&&h(p)})}}asNestedTest({key:e,index:t,parent:i,parentPath:r,originalParent:s,options:o}){const a=e??t;if(a==null)throw TypeError("Must include `key` or `index` for nested validations");const l=typeof a=="number";let u=i[a];const c=Object.assign({},o,{strict:!0,parent:i,value:u,originalValue:s[a],key:void 0,[l?"index":"key"]:a,path:l||a.includes(".")?`${r||""}[${u?a:`"${a}"`}]`:(r?`${r}.`:"")+e});return(h,d,p)=>this.resolve(c)._validate(u,c,d,p)}validate(e,t){var i;let r=this.resolve(Object.assign({},t,{value:e})),s=(i=t==null?void 0:t.disableStackTrace)!=null?i:r.spec.disableStackTrace;return new Promise((o,a)=>r._validate(e,t,(l,u)=>{yo.isError(l)&&(l.value=u),a(l)},(l,u)=>{l.length?a(new yo(l,u,void 0,void 0,s)):o(u)}))}validateSync(e,t){var i;let r=this.resolve(Object.assign({},t,{value:e})),s,o=(i=t==null?void 0:t.disableStackTrace)!=null?i:r.spec.disableStackTrace;return r._validate(e,Object.assign({},t,{sync:!0}),(a,l)=>{throw yo.isError(a)&&(a.value=l),a},(a,l)=>{if(a.length)throw new yo(a,e,void 0,void 0,o);s=l}),s}isValid(e,t){return this.validate(e,t).then(()=>!0,i=>{if(yo.isError(i))return!1;throw i})}isValidSync(e,t){try{return this.validateSync(e,t),!0}catch(i){if(yo.isError(i))return!1;throw i}}_getDefault(e){let t=this.spec.default;return t==null?t:typeof t=="function"?t.call(this,e):Ug(t)}getDefault(e){return this.resolve(e||{})._getDefault(e)}default(e){return arguments.length===0?this._getDefault():this.clone({default:e})}strict(e=!0){return this.clone({strict:e})}nullability(e,t){const i=this.clone({nullable:e});return i.internalTests.nullable=Xm({message:t,name:"nullable",test(r){return r===null?this.schema.spec.nullable:!0}}),i}optionality(e,t){const i=this.clone({optional:e});return i.internalTests.optionality=Xm({message:t,name:"optionality",test(r){return r===void 0?this.schema.spec.optional:!0}}),i}optional(){return this.optionality(!0)}defined(e=mu.defined){return this.optionality(!1,e)}nullable(){return this.nullability(!0)}nonNullable(e=mu.notNull){return this.nullability(!1,e)}required(e=mu.required){return this.clone().withMutation(t=>t.nonNullable(e).defined(e))}notRequired(){return this.clone().withMutation(e=>e.nullable().optional())}transform(e){let t=this.clone();return t.transforms.push(e),t}test(...e){let t;if(e.length===1?typeof e[0]=="function"?t={test:e[0]}:t=e[0]:e.length===2?t={name:e[0],test:e[1]}:t={name:e[0],message:e[1],test:e[2]},t.message===void 0&&(t.message=mu.default),typeof t.test!="function")throw new TypeError("`test` is a required parameters");let i=this.clone(),r=Xm(t),s=t.exclusive||t.name&&i.exclusiveTests[t.name]===!0;if(t.exclusive&&!t.name)throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");return t.name&&(i.exclusiveTests[t.name]=!!t.exclusive),i.tests=i.tests.filter(o=>!(o.OPTIONS.name===t.name&&(s||o.OPTIONS.test===r.OPTIONS.test))),i.tests.push(r),i}when(e,t){!Array.isArray(e)&&typeof e!="string"&&(t=e,e=".");let i=this.clone(),r=sQ(e).map(s=>new rm(s));return r.forEach(s=>{s.isSibling&&i.deps.push(s.key)}),i.conditions.push(typeof t=="function"?new zM(r,t):zM.fromOptions(r,t)),i}typeError(e){let t=this.clone();return t.internalTests.typeError=Xm({message:e,name:"typeError",skipAbsent:!0,test(i){return this.schema._typeCheck(i)?!0:this.createError({params:{type:this.schema.type}})}}),t}oneOf(e,t=mu.oneOf){let i=this.clone();return e.forEach(r=>{i._whitelist.add(r),i._blacklist.delete(r)}),i.internalTests.whiteList=Xm({message:t,name:"oneOf",skipAbsent:!0,test(r){let s=this.schema._whitelist,o=s.resolveAll(this.resolve);return o.includes(r)?!0:this.createError({params:{values:Array.from(s).join(", "),resolved:o}})}}),i}notOneOf(e,t=mu.notOneOf){let i=this.clone();return e.forEach(r=>{i._blacklist.add(r),i._whitelist.delete(r)}),i.internalTests.blacklist=Xm({message:t,name:"notOneOf",test(r){let s=this.schema._blacklist,o=s.resolveAll(this.resolve);return o.includes(r)?this.createError({params:{values:Array.from(s).join(", "),resolved:o}}):!0}}),i}strip(e=!0){let t=this.clone();return t.spec.strip=e,t}describe(e){const t=(e?this.resolve(e):this).clone(),{label:i,meta:r,optional:s,nullable:o}=t.spec;return{meta:r,label:i,optional:s,nullable:o,default:t.getDefault(e),type:t.type,oneOf:t._whitelist.describe(),notOneOf:t._blacklist.describe(),tests:t.tests.map(l=>({name:l.OPTIONS.name,params:l.OPTIONS.params})).filter((l,u,c)=>c.findIndex(h=>h.name===l.name)===u)}}}Pu.prototype.__isYupSchema__=!0;for(const n of["validate","validateSync"])Pu.prototype[`${n}At`]=function(e,t,i={}){const{parent:r,parentPath:s,schema:o}=KCe(this,e,t,i.context);return o[n](r&&r[s],Object.assign({},i,{parent:r,path:e}))};for(const n of["equals","is"])Pu.prototype[n]=Pu.prototype.oneOf;for(const n of["not","nope"])Pu.prototype[n]=Pu.prototype.notOneOf;let ZCe=/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,jCe=/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,YCe=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,JCe=n=>Vp(n)||n===n.trim(),QCe={}.toString();function O_(){return new aQ}class aQ extends Pu{constructor(){super({type:"string",check(e){return e instanceof String&&(e=e.valueOf()),typeof e=="string"}}),this.withMutation(()=>{this.transform((e,t,i)=>{if(!i.spec.coerce||i.isType(e)||Array.isArray(e))return e;const r=e!=null&&e.toString?e.toString():e;return r===QCe?e:r})})}required(e){return super.required(e).withMutation(t=>t.test({message:e||mu.required,name:"required",skipAbsent:!0,test:i=>!!i.length}))}notRequired(){return super.notRequired().withMutation(e=>(e.tests=e.tests.filter(t=>t.OPTIONS.name!=="required"),e))}length(e,t=yl.length){return this.test({message:t,name:"length",exclusive:!0,params:{length:e},skipAbsent:!0,test(i){return i.length===this.resolve(e)}})}min(e,t=yl.min){return this.test({message:t,name:"min",exclusive:!0,params:{min:e},skipAbsent:!0,test(i){return i.length>=this.resolve(e)}})}max(e,t=yl.max){return this.test({name:"max",exclusive:!0,message:t,params:{max:e},skipAbsent:!0,test(i){return i.length<=this.resolve(e)}})}matches(e,t){let i=!1,r,s;return t&&(typeof t=="object"?{excludeEmptyString:i=!1,message:r,name:s}=t:r=t),this.test({name:s||"matches",message:r||yl.matches,params:{regex:e},skipAbsent:!0,test:o=>o===""&&i||o.search(e)!==-1})}email(e=yl.email){return this.matches(ZCe,{name:"email",message:e,excludeEmptyString:!0})}url(e=yl.url){return this.matches(jCe,{name:"url",message:e,excludeEmptyString:!0})}uuid(e=yl.uuid){return this.matches(YCe,{name:"uuid",message:e,excludeEmptyString:!1})}ensure(){return this.default("").transform(e=>e===null?"":e)}trim(e=yl.trim){return this.transform(t=>t!=null?t.trim():t).test({message:e,name:"trim",test:JCe})}lowercase(e=yl.lowercase){return this.transform(t=>Vp(t)?t:t.toLowerCase()).test({message:e,name:"string_case",exclusive:!0,skipAbsent:!0,test:t=>Vp(t)||t===t.toLowerCase()})}uppercase(e=yl.uppercase){return this.transform(t=>Vp(t)?t:t.toUpperCase()).test({message:e,name:"string_case",exclusive:!0,skipAbsent:!0,test:t=>Vp(t)||t===t.toUpperCase()})}}O_.prototype=aQ.prototype;const qCe=/^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;function Qu(n,e=0){return Number(n)||e}function e_e(n){const e=qCe.exec(n);if(!e)return Date.parse?Date.parse(n):Number.NaN;const t={year:Qu(e[1]),month:Qu(e[2],1)-1,day:Qu(e[3],1),hour:Qu(e[4]),minute:Qu(e[5]),second:Qu(e[6]),millisecond:e[7]?Qu(e[7].substring(0,3)):0,z:e[8]||void 0,plusMinus:e[9]||void 0,hourOffset:Qu(e[10]),minuteOffset:Qu(e[11])};if(t.z===void 0&&t.plusMinus===void 0)return new Date(t.year,t.month,t.day,t.hour,t.minute,t.second,t.millisecond).valueOf();let i=0;return t.z!=="Z"&&t.plusMinus!==void 0&&(i=t.hourOffset*60+t.minuteOffset,t.plusMinus==="+"&&(i=0-i)),Date.UTC(t.year,t.month,t.day,t.hour,t.minute+i,t.second,t.millisecond)}let t_e=new Date(""),n_e=n=>Object.prototype.toString.call(n)==="[object Date]";class wE extends Pu{constructor(){super({type:"date",check(e){return n_e(e)&&!isNaN(e.getTime())}}),this.withMutation(()=>{this.transform((e,t,i)=>!i.spec.coerce||i.isType(e)||e===null?e:(e=e_e(e),isNaN(e)?wE.INVALID_DATE:new Date(e)))})}prepareParam(e,t){let i;if(rm.isRef(e))i=e;else{let r=this.cast(e);if(!this._typeCheck(r))throw new TypeError(`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`);i=r}return i}min(e,t=JD.min){let i=this.prepareParam(e,"min");return this.test({message:t,name:"min",exclusive:!0,params:{min:e},skipAbsent:!0,test(r){return r>=this.resolve(i)}})}max(e,t=JD.max){let i=this.prepareParam(e,"max");return this.test({message:t,name:"max",exclusive:!0,params:{max:e},skipAbsent:!0,test(r){return r<=this.resolve(i)}})}}wE.INVALID_DATE=t_e;wE.prototype;function i_e(n,e=[]){let t=[],i=new Set,r=new Set(e.map(([o,a])=>`${o}-${a}`));function s(o,a){let l=ef.split(o)[0];i.add(l),r.has(`${a}-${l}`)||t.push([a,l])}for(const o of Object.keys(n)){let a=n[o];i.add(o),rm.isRef(a)&&a.isSibling?s(a.path,o):BB(a)&&"deps"in a&&a.deps.forEach(l=>s(l,o))}return DCe.array(Array.from(i),t).reverse()}function G9(n,e){let t=1/0;return n.some((i,r)=>{var s;if((s=e.path)!=null&&s.includes(i))return t=r,!0}),t}function lQ(n){return(e,t)=>G9(n,e)-G9(n,t)}const r_e=(n,e,t)=>{if(typeof n!="string")return n;let i=n;try{i=JSON.parse(n)}catch{}return t.isType(i)?i:n};function B_(n){if("fields"in n){const e={};for(const[t,i]of Object.entries(n.fields))e[t]=B_(i);return n.setFields(e)}if(n.type==="array"){const e=n.optional();return e.innerType&&(e.innerType=B_(e.innerType)),e}return n.type==="tuple"?n.optional().clone({types:n.spec.types.map(B_)}):"optional"in n?n.optional():n}const s_e=(n,e)=>{const t=[...ef.normalizePath(e)];if(t.length===1)return t[0]in n;let i=t.pop(),r=ef.getter(ef.join(t),!0)(n);return!!(r&&i in r)};let V9=n=>Object.prototype.toString.call(n)==="[object Object]";function o_e(n,e){let t=Object.keys(n.fields);return Object.keys(e).filter(i=>t.indexOf(i)===-1)}const a_e=lQ([]);function uQ(n){return new cQ(n)}class cQ extends Pu{constructor(e){super({type:"object",check(t){return V9(t)||typeof t=="function"}}),this.fields=Object.create(null),this._sortErrors=a_e,this._nodes=[],this._excludedEdges=[],this.withMutation(()=>{e&&this.shape(e)})}_cast(e,t={}){var i;let r=super._cast(e,t);if(r===void 0)return this.getDefault(t);if(!this._typeCheck(r))return r;let s=this.fields,o=(i=t.stripUnknown)!=null?i:this.spec.noUnknown,a=[].concat(this._nodes,Object.keys(r).filter(h=>!this._nodes.includes(h))),l={},u=Object.assign({},t,{parent:l,__validating:t.__validating||!1}),c=!1;for(const h of a){let d=s[h],p=h in r;if(d){let f,g=r[h];u.path=(t.path?`${t.path}.`:"")+h,d=d.resolve({value:g,context:t.context,parent:l});let y=d instanceof Pu?d.spec:void 0,m=y==null?void 0:y.strict;if(y!=null&&y.strip){c=c||h in r;continue}f=!t.__validating||!m?d.cast(r[h],u):r[h],f!==void 0&&(l[h]=f)}else p&&!o&&(l[h]=r[h]);(p!==h in l||l[h]!==r[h])&&(c=!0)}return c?l:r}_validate(e,t={},i,r){let{from:s=[],originalValue:o=e,recursive:a=this.spec.recursive}=t;t.from=[{schema:this,value:o},...s],t.__validating=!0,t.originalValue=o,super._validate(e,t,i,(l,u)=>{if(!a||!V9(u)){r(l,u);return}o=o||u;let c=[];for(let h of this._nodes){let d=this.fields[h];!d||rm.isRef(d)||c.push(d.asNestedTest({options:t,key:h,parent:u,parentPath:t.path,originalParent:o}))}this.runTests({tests:c,value:u,originalValue:o,options:t},i,h=>{r(h.sort(this._sortErrors).concat(l),u)})})}clone(e){const t=super.clone(e);return t.fields=Object.assign({},this.fields),t._nodes=this._nodes,t._excludedEdges=this._excludedEdges,t._sortErrors=this._sortErrors,t}concat(e){let t=super.concat(e),i=t.fields;for(let[r,s]of Object.entries(this.fields)){const o=i[r];i[r]=o===void 0?s:o}return t.withMutation(r=>r.setFields(i,[...this._excludedEdges,...e._excludedEdges]))}_getDefault(e){if("default"in this.spec)return super._getDefault(e);if(!this._nodes.length)return;let t={};return this._nodes.forEach(i=>{var r;const s=this.fields[i];let o=e;(r=o)!=null&&r.value&&(o=Object.assign({},o,{parent:o.value,value:o.value[i]})),t[i]=s&&"getDefault"in s?s.getDefault(o):void 0}),t}setFields(e,t){let i=this.clone();return i.fields=e,i._nodes=i_e(e,t),i._sortErrors=lQ(Object.keys(e)),t&&(i._excludedEdges=t),i}shape(e,t=[]){return this.clone().withMutation(i=>{let r=i._excludedEdges;return t.length&&(Array.isArray(t[0])||(t=[t]),r=[...i._excludedEdges,...t]),i.setFields(Object.assign(i.fields,e),r)})}partial(){const e={};for(const[t,i]of Object.entries(this.fields))e[t]="optional"in i&&i.optional instanceof Function?i.optional():i;return this.setFields(e)}deepPartial(){return B_(this)}pick(e){const t={};for(const i of e)this.fields[i]&&(t[i]=this.fields[i]);return this.setFields(t,this._excludedEdges.filter(([i,r])=>e.includes(i)&&e.includes(r)))}omit(e){const t=[];for(const i of Object.keys(this.fields))e.includes(i)||t.push(i);return this.pick(t)}from(e,t,i){let r=ef.getter(e,!0);return this.transform(s=>{if(!s)return s;let o=s;return s_e(s,e)&&(o=Object.assign({},s),i||delete o[e],o[t]=r(s)),o})}json(){return this.transform(r_e)}noUnknown(e=!0,t=QD.noUnknown){typeof e!="boolean"&&(t=e,e=!0);let i=this.test({name:"noUnknown",exclusive:!0,message:t,test(r){if(r==null)return!0;const s=o_e(this.schema,r);return!e||s.length===0||this.createError({params:{unknown:s.join(", ")}})}});return i.spec.noUnknown=e,i}unknown(e=!0,t=QD.noUnknown){return this.noUnknown(!e,t)}transformKeys(e){return this.transform(t=>{if(!t)return t;const i={};for(const r of Object.keys(t))i[e(r)]=t[r];return i})}camelCase(){return this.transformKeys(VN.camelCase)}snakeCase(){return this.transformKeys(VN.snakeCase)}constantCase(){return this.transformKeys(e=>VN.snakeCase(e).toUpperCase())}describe(e){const t=(e?this.resolve(e):this).clone(),i=super.describe(e);i.fields={};for(const[s,o]of Object.entries(t.fields)){var r;let a=e;(r=a)!=null&&r.value&&(a=Object.assign({},a,{parent:a.value,value:a.value[s]})),i.fields[s]=o.describe(a)}return i}}uQ.prototype=cQ.prototype;const Uv={_origin:"https://api.emailjs.com"},l_e=(n,e="https://api.emailjs.com")=>{Uv._userID=n,Uv._origin=e},hQ=(n,e,t)=>{if(!n)throw"The public key is required. Visit https://dashboard.emailjs.com/admin/account";if(!e)throw"The service ID is required. Visit https://dashboard.emailjs.com/admin";if(!t)throw"The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";return!0};class U9{constructor(e){this.status=e?e.status:0,this.text=e?e.responseText:"Network Error"}}const dQ=(n,e,t={})=>new Promise((i,r)=>{const s=new XMLHttpRequest;s.addEventListener("load",({target:o})=>{const a=new U9(o);a.status===200||a.text==="OK"?i(a):r(a)}),s.addEventListener("error",({target:o})=>{r(new U9(o))}),s.open("POST",Uv._origin+n,!0),Object.keys(t).forEach(o=>{s.setRequestHeader(o,t[o])}),s.send(e)}),u_e=(n,e,t,i)=>{const r=i||Uv._userID;return hQ(r,n,e),dQ("/api/v1.0/email/send",JSON.stringify({lib_version:"3.11.0",user_id:r,service_id:n,template_id:e,template_params:t}),{"Content-type":"application/json"})},c_e=n=>{let e;if(typeof n=="string"?e=document.querySelector(n):e=n,!e||e.nodeName!=="FORM")throw"The 3rd parameter is expected to be the HTML form element or the style selector of form";return e},h_e=(n,e,t,i)=>{const r=i||Uv._userID,s=c_e(t);hQ(r,n,e);const o=new FormData(s);return o.append("lib_version","3.11.0"),o.append("service_id",n),o.append("template_id",e),o.append("user_id",r),dQ("/api/v1.0/email/send-form",o)},d_e={init:l_e,send:u_e,sendForm:h_e},p_e="_container_1gv8h_1",f_e="_hero_1gv8h_19",m_e="_form_1gv8h_89",g_e="_formGroup_1gv8h_97",y_e="_error_1gv8h_169",b_e="_formButton_1gv8h_185 _primaryButton_s2sxs_1",hl={container:p_e,hero:f_e,form:m_e,formGroup:g_e,error:y_e,formButton:b_e};/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const z1="158",Cp={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},_p={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},pQ=0,qD=1,fQ=2,x_e=3,mQ=0,SE=1,uv=2,xl=3,Vl=0,Ys=1,$a=2,v_e=2,Ac=0,tf=1,e3=2,t3=3,n3=4,gQ=5,Fh=100,yQ=101,bQ=102,i3=103,r3=104,xQ=200,vQ=201,wQ=202,SQ=203,VM=204,UM=205,TQ=206,CQ=207,_Q=208,MQ=209,AQ=210,EQ=211,IQ=212,kQ=213,RQ=214,NQ=0,LQ=1,PQ=2,$v=3,DQ=4,FQ=5,OQ=6,BQ=7,G1=0,zQ=1,GQ=2,Au=0,VQ=1,UQ=2,$Q=3,zB=4,WQ=5,s3="attached",HQ="detached",TE=300,Dc=301,md=302,Wv=303,Hv=304,qy=306,Ul=1e3,$r=1001,Tf=1002,Ei=1003,_y=1004,w_e=1004,nf=1005,S_e=1005,Zn=1006,V1=1007,T_e=1007,qa=1008,C_e=1008,Eu=1009,XQ=1010,KQ=1011,CE=1012,GB=1013,xc=1014,Ml=1015,Cf=1016,VB=1017,UB=1018,id=1020,ZQ=1021,xo=1023,jQ=1024,YQ=1025,rd=1026,_f=1027,JQ=1028,$B=1029,QQ=1030,WB=1031,HB=1033,z_=33776,G_=33777,V_=33778,U_=33779,o3=35840,a3=35841,l3=35842,u3=35843,qQ=36196,c3=37492,h3=37496,d3=37808,p3=37809,f3=37810,m3=37811,g3=37812,y3=37813,b3=37814,x3=37815,v3=37816,w3=37817,S3=37818,T3=37819,C3=37820,_3=37821,$_=36492,M3=36494,A3=36495,eq=36283,E3=36284,I3=36285,k3=36286,tq=2200,nq=2201,iq=2202,Mf=2300,Fc=2301,W_=2302,Up=2400,$p=2401,Xv=2402,_E=2500,XB=2501,KB=0,U1=1,Af=2,ZB=3e3,Ec=3001,rq=3200,sq=3201,Pd=0,oq=1,jo="",bi="srgb",Zr="srgb-linear",ME="display-p3",$1="display-p3-linear",Kv="linear",Qn="srgb",Zv="rec709",jv="p3",__e=0,Mp=7680,M_e=7681,A_e=7682,E_e=7683,I_e=34055,k_e=34056,R_e=5386,N_e=512,L_e=513,P_e=514,D_e=515,F_e=516,O_e=517,B_e=518,R3=519,aq=512,lq=513,uq=514,cq=515,hq=516,dq=517,pq=518,fq=519,Yv=35044,z_e=35048,G_e=35040,V_e=35045,U_e=35049,$_e=35041,W_e=35046,H_e=35050,X_e=35042,K_e="100",N3="300 es",$M=1035,xu=2e3,Jv=2001;class Wu{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}const ws=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let $9=1234567;const rf=Math.PI/180,My=180/Math.PI;function sa(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(ws[n&255]+ws[n>>8&255]+ws[n>>16&255]+ws[n>>24&255]+"-"+ws[e&255]+ws[e>>8&255]+"-"+ws[e>>16&15|64]+ws[e>>24&255]+"-"+ws[t&63|128]+ws[t>>8&255]+"-"+ws[t>>16&255]+ws[t>>24&255]+ws[i&255]+ws[i>>8&255]+ws[i>>16&255]+ws[i>>24&255]).toLowerCase()}function Ui(n,e,t){return Math.max(e,Math.min(t,n))}function jB(n,e){return(n%e+e)%e}function Z_e(n,e,t,i,r){return i+(n-e)*(r-i)/(t-e)}function j_e(n,e,t){return n!==e?(t-n)/(e-n):0}function cv(n,e,t){return(1-t)*n+t*e}function Y_e(n,e,t,i){return cv(n,e,1-Math.exp(-t*i))}function J_e(n,e=1){return e-Math.abs(jB(n,e*2)-e)}function Q_e(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function q_e(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function eMe(n,e){return n+Math.floor(Math.random()*(e-n+1))}function tMe(n,e){return n+Math.random()*(e-n)}function nMe(n){return n*(.5-Math.random())}function iMe(n){n!==void 0&&($9=n);let e=$9+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function rMe(n){return n*rf}function sMe(n){return n*My}function L3(n){return(n&n-1)===0&&n!==0}function mq(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function WM(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function oMe(n,e,t,i,r){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),u=s((e+i)/2),c=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":n.set(a*c,l*h,l*d,a*u);break;case"YZY":n.set(l*d,a*c,l*h,a*u);break;case"ZXZ":n.set(l*h,l*d,a*c,a*u);break;case"XZX":n.set(a*c,l*f,l*p,a*u);break;case"YXY":n.set(l*p,a*c,l*f,a*u);break;case"ZYZ":n.set(l*f,l*p,a*c,a*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function vo(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function an(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const Wp={DEG2RAD:rf,RAD2DEG:My,generateUUID:sa,clamp:Ui,euclideanModulo:jB,mapLinear:Z_e,inverseLerp:j_e,lerp:cv,damp:Y_e,pingpong:J_e,smoothstep:Q_e,smootherstep:q_e,randInt:eMe,randFloat:tMe,randFloatSpread:nMe,seededRandom:iMe,degToRad:rMe,radToDeg:sMe,isPowerOfTwo:L3,ceilPowerOfTwo:mq,floorPowerOfTwo:WM,setQuaternionFromProperEuler:oMe,normalize:an,denormalize:vo};class Ge{constructor(e=0,t=0){Ge.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Ui(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class hn{constructor(e,t,i,r,s,o,a,l,u){hn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,u)}set(e,t,i,r,s,o,a,l,u){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=s,c[5]=l,c[6]=i,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],u=i[1],c=i[4],h=i[7],d=i[2],p=i[5],f=i[8],g=r[0],y=r[3],m=r[6],v=r[1],w=r[4],S=r[7],C=r[2],_=r[5],A=r[8];return s[0]=o*g+a*v+l*C,s[3]=o*y+a*w+l*_,s[6]=o*m+a*S+l*A,s[1]=u*g+c*v+h*C,s[4]=u*y+c*w+h*_,s[7]=u*m+c*S+h*A,s[2]=d*g+p*v+f*C,s[5]=d*y+p*w+f*_,s[8]=d*m+p*S+f*A,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8];return t*o*c-t*a*u-i*s*c+i*a*l+r*s*u-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=c*o-a*u,d=a*l-c*s,p=u*s-o*l,f=t*h+i*d+r*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/f;return e[0]=h*g,e[1]=(r*u-c*i)*g,e[2]=(a*i-r*o)*g,e[3]=d*g,e[4]=(c*t-r*l)*g,e[5]=(r*s-a*t)*g,e[6]=p*g,e[7]=(i*l-u*t)*g,e[8]=(o*t-i*s)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),u=Math.sin(s);return this.set(i*l,i*u,-i*(l*o+u*a)+o+e,-r*u,r*l,-r*(-u*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(UN.makeScale(e,t)),this}rotate(e){return this.premultiply(UN.makeRotation(-e)),this}translate(e,t){return this.premultiply(UN.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,i,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const UN=new hn;function gq(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const aMe={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function $g(n,e){return new aMe[n](e)}function Qv(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function yq(){const n=Qv("canvas");return n.style.display="block",n}const W9={};function hv(n){n in W9||(W9[n]=!0,console.warn(n))}const H9=new hn().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),X9=new hn().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),rC={[Zr]:{transfer:Kv,primaries:Zv,toReference:n=>n,fromReference:n=>n},[bi]:{transfer:Qn,primaries:Zv,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[$1]:{transfer:Kv,primaries:jv,toReference:n=>n.applyMatrix3(X9),fromReference:n=>n.applyMatrix3(H9)},[ME]:{transfer:Qn,primaries:jv,toReference:n=>n.convertSRGBToLinear().applyMatrix3(X9),fromReference:n=>n.applyMatrix3(H9).convertLinearToSRGB()}},lMe=new Set([Zr,$1]),Fn={enabled:!0,_workingColorSpace:Zr,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(n){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!n},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!lMe.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const i=rC[e].toReference,r=rC[t].fromReference;return r(i(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return rC[n].primaries},getTransfer:function(n){return n===jo?Kv:rC[n].transfer}};function ry(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function $N(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let Km;class YB{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Km===void 0&&(Km=Qv("canvas")),Km.width=e.width,Km.height=e.height;const i=Km.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Km}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Qv("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=ry(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(ry(t[i]/255)*255):t[i]=ry(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let uMe=0;class Hp{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:uMe++}),this.uuid=sa(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(WN(r[o].image)):s.push(WN(r[o]))}else s=WN(r);i.url=s}return t||(e.images[this.uuid]=i),i}}function WN(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?YB.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let cMe=0;class ni extends Wu{constructor(e=ni.DEFAULT_IMAGE,t=ni.DEFAULT_MAPPING,i=$r,r=$r,s=Zn,o=qa,a=xo,l=Eu,u=ni.DEFAULT_ANISOTROPY,c=jo){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:cMe++}),this.uuid=sa(),this.name="",this.source=new Hp(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Ge(0,0),this.repeat=new Ge(1,1),this.center=new Ge(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new hn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof c=="string"?this.colorSpace=c:(hv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===Ec?bi:jo),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==TE)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ul:e.x=e.x-Math.floor(e.x);break;case $r:e.x=e.x<0?0:1;break;case Tf:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Ul:e.y=e.y-Math.floor(e.y);break;case $r:e.y=e.y<0?0:1;break;case Tf:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return hv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===bi?Ec:ZB}set encoding(e){hv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===Ec?bi:jo}}ni.DEFAULT_IMAGE=null;ni.DEFAULT_MAPPING=TE;ni.DEFAULT_ANISOTROPY=1;class Gn{constructor(e=0,t=0,i=0,r=1){Gn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,u=l[0],c=l[4],h=l[8],d=l[1],p=l[5],f=l[9],g=l[2],y=l[6],m=l[10];if(Math.abs(c-d)<.01&&Math.abs(h-g)<.01&&Math.abs(f-y)<.01){if(Math.abs(c+d)<.1&&Math.abs(h+g)<.1&&Math.abs(f+y)<.1&&Math.abs(u+p+m-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const w=(u+1)/2,S=(p+1)/2,C=(m+1)/2,_=(c+d)/4,A=(h+g)/4,I=(f+y)/4;return w>S&&w>C?w<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(w),r=_/i,s=A/i):S>C?S<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(S),i=_/r,s=I/r):C<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(C),i=A/s,r=I/s),this.set(i,r,s,t),this}let v=Math.sqrt((y-f)*(y-f)+(h-g)*(h-g)+(d-c)*(d-c));return Math.abs(v)<.001&&(v=1),this.x=(y-f)/v,this.y=(h-g)/v,this.z=(d-c)/v,this.w=Math.acos((u+p+m-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class bq extends Wu{constructor(e=1,t=1,i={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Gn(0,0,e,t),this.scissorTest=!1,this.viewport=new Gn(0,0,e,t);const r={width:e,height:t,depth:1};i.encoding!==void 0&&(hv("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),i.colorSpace=i.encoding===Ec?bi:jo),i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Zn,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},i),this.texture=new ni(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps,this.texture.internalFormat=i.internalFormat,this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.depthTexture=i.depthTexture,this.samples=i.samples}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Hp(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class el extends bq{constructor(e=1,t=1,i={}){super(e,t,i),this.isWebGLRenderTarget=!0}}class AE extends ni{constructor(e=null,t=1,i=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=Ei,this.minFilter=Ei,this.wrapR=$r,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class hMe extends el{constructor(e=1,t=1,i=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new AE(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class JB extends ni{constructor(e=null,t=1,i=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=Ei,this.minFilter=Ei,this.wrapR=$r,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class dMe extends el{constructor(e=1,t=1,i=1){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new JB(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class pMe extends el{constructor(e=1,t=1,i=1,r={}){super(e,t,r),this.isWebGLMultipleRenderTargets=!0;const s=this.texture;this.texture=[];for(let o=0;o<i;o++)this.texture[o]=s.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=i;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,i=e.texture.length;t<i;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Li{constructor(e=0,t=0,i=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=r}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],u=i[r+1],c=i[r+2],h=i[r+3];const d=s[o+0],p=s[o+1],f=s[o+2],g=s[o+3];if(a===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=f,e[t+3]=g;return}if(h!==g||l!==d||u!==p||c!==f){let y=1-a;const m=l*d+u*p+c*f+h*g,v=m>=0?1:-1,w=1-m*m;if(w>Number.EPSILON){const C=Math.sqrt(w),_=Math.atan2(C,m*v);y=Math.sin(y*_)/C,a=Math.sin(a*_)/C}const S=a*v;if(l=l*y+d*S,u=u*y+p*S,c=c*y+f*S,h=h*y+g*S,y===1-a){const C=1/Math.sqrt(l*l+u*u+c*c+h*h);l*=C,u*=C,c*=C,h*=C}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],u=i[r+2],c=i[r+3],h=s[o],d=s[o+1],p=s[o+2],f=s[o+3];return e[t]=a*f+c*h+l*p-u*d,e[t+1]=l*f+c*d+u*h-a*p,e[t+2]=u*f+c*p+a*d-l*h,e[t+3]=c*f-a*h-l*d-u*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,u=a(i/2),c=a(r/2),h=a(s/2),d=l(i/2),p=l(r/2),f=l(s/2);switch(o){case"XYZ":this._x=d*c*h+u*p*f,this._y=u*p*h-d*c*f,this._z=u*c*f+d*p*h,this._w=u*c*h-d*p*f;break;case"YXZ":this._x=d*c*h+u*p*f,this._y=u*p*h-d*c*f,this._z=u*c*f-d*p*h,this._w=u*c*h+d*p*f;break;case"ZXY":this._x=d*c*h-u*p*f,this._y=u*p*h+d*c*f,this._z=u*c*f+d*p*h,this._w=u*c*h-d*p*f;break;case"ZYX":this._x=d*c*h-u*p*f,this._y=u*p*h+d*c*f,this._z=u*c*f-d*p*h,this._w=u*c*h+d*p*f;break;case"YZX":this._x=d*c*h+u*p*f,this._y=u*p*h+d*c*f,this._z=u*c*f-d*p*h,this._w=u*c*h-d*p*f;break;case"XZY":this._x=d*c*h-u*p*f,this._y=u*p*h-d*c*f,this._z=u*c*f+d*p*h,this._w=u*c*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],u=t[2],c=t[6],h=t[10],d=i+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(c-l)*p,this._y=(s-u)*p,this._z=(o-r)*p}else if(i>a&&i>h){const p=2*Math.sqrt(1+i-a-h);this._w=(c-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(s+u)/p}else if(a>h){const p=2*Math.sqrt(1+a-i-h);this._w=(s-u)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+h-i-a);this._w=(o-r)/p,this._x=(s+u)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ui(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,u=t._z,c=t._w;return this._x=i*c+o*a+r*u-s*l,this._y=r*c+o*l+s*a-i*u,this._z=s*c+o*u+i*l-r*a,this._w=o*c-i*a-r*l-s*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*i+t*this._x,this._y=p*r+t*this._y,this._z=p*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const u=Math.sqrt(l),c=Math.atan2(u,a),h=Math.sin((1-t)*c)/u,d=Math.sin(t*c)/u;return this._w=o*h+this._w*d,this._x=i*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),i*Math.sin(s),i*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Y{constructor(e=0,t=0,i=0){Y.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(K9.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(K9.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,u=2*(o*r-a*i),c=2*(a*t-s*r),h=2*(s*i-o*t);return this.x=t+l*u+o*h-a*c,this.y=i+l*c+a*u-s*h,this.z=r+l*h+s*c-o*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return HN.copy(this).projectOnVector(e),this.sub(HN)}reflect(e){return this.sub(HN.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Ui(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const HN=new Y,K9=new Li;class nl{constructor(e=new Y(1/0,1/0,1/0),t=new Y(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t+=3)this.expandByPoint(dl.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,i=e.count;t<i;t++)this.expandByPoint(dl.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=dl.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0){const s=i.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,dl):dl.fromBufferAttribute(s,o),dl.applyMatrix4(e.matrixWorld),this.expandByPoint(dl);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),sC.copy(e.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),sC.copy(i.boundingBox)),sC.applyMatrix4(e.matrixWorld),this.union(sC)}const r=e.children;for(let s=0,o=r.length;s<o;s++)this.expandByObject(r[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,dl),dl.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ax),oC.subVectors(this.max,ax),Zm.subVectors(e.a,ax),jm.subVectors(e.b,ax),Ym.subVectors(e.c,ax),mh.subVectors(jm,Zm),gh.subVectors(Ym,jm),ip.subVectors(Zm,Ym);let t=[0,-mh.z,mh.y,0,-gh.z,gh.y,0,-ip.z,ip.y,mh.z,0,-mh.x,gh.z,0,-gh.x,ip.z,0,-ip.x,-mh.y,mh.x,0,-gh.y,gh.x,0,-ip.y,ip.x,0];return!XN(t,Zm,jm,Ym,oC)||(t=[1,0,0,0,1,0,0,0,1],!XN(t,Zm,jm,Ym,oC))?!1:(aC.crossVectors(mh,gh),t=[aC.x,aC.y,aC.z],XN(t,Zm,jm,Ym,oC))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,dl).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(dl).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(qu[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),qu[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),qu[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),qu[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),qu[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),qu[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),qu[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),qu[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(qu),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const qu=[new Y,new Y,new Y,new Y,new Y,new Y,new Y,new Y],dl=new Y,sC=new nl,Zm=new Y,jm=new Y,Ym=new Y,mh=new Y,gh=new Y,ip=new Y,ax=new Y,oC=new Y,aC=new Y,rp=new Y;function XN(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){rp.fromArray(n,s);const a=r.x*Math.abs(rp.x)+r.y*Math.abs(rp.y)+r.z*Math.abs(rp.z),l=e.dot(rp),u=t.dot(rp),c=i.dot(rp);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>a)return!1}return!0}const fMe=new nl,lx=new Y,KN=new Y;class ya{constructor(e=new Y,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):fMe.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;lx.subVectors(e,this.center);const t=lx.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),r=(i-this.radius)*.5;this.center.addScaledVector(lx,r/i),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(KN.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(lx.copy(e.center).add(KN)),this.expandByPoint(lx.copy(e.center).sub(KN))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ec=new Y,ZN=new Y,lC=new Y,yh=new Y,jN=new Y,uC=new Y,YN=new Y;class sm{constructor(e=new Y,t=new Y(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ec)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=ec.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ec.copy(this.origin).addScaledVector(this.direction,t),ec.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){ZN.copy(e).add(t).multiplyScalar(.5),lC.copy(t).sub(e).normalize(),yh.copy(this.origin).sub(ZN);const s=e.distanceTo(t)*.5,o=-this.direction.dot(lC),a=yh.dot(this.direction),l=-yh.dot(lC),u=yh.lengthSq(),c=Math.abs(1-o*o);let h,d,p,f;if(c>0)if(h=o*l-a,d=o*a-l,f=s*c,h>=0)if(d>=-f)if(d<=f){const g=1/c;h*=g,d*=g,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+u}else d=s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;else d=-s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;else d<=-f?(h=Math.max(0,-(-o*s+a)),d=h>0?-s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+u):d<=f?(h=0,d=Math.min(Math.max(-s,-l),s),p=d*(d+2*l)+u):(h=Math.max(0,-(o*s+a)),d=h>0?s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+u);else d=o>0?-s:s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;return i&&i.copy(this.origin).addScaledVector(this.direction,h),r&&r.copy(ZN).addScaledVector(lC,d),p}intersectSphere(e,t){ec.subVectors(e.center,this.origin);const i=ec.dot(this.direction),r=ec.dot(ec)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const u=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,d=this.origin;return u>=0?(i=(e.min.x-d.x)*u,r=(e.max.x-d.x)*u):(i=(e.max.x-d.x)*u,r=(e.min.x-d.x)*u),c>=0?(s=(e.min.y-d.y)*c,o=(e.max.y-d.y)*c):(s=(e.max.y-d.y)*c,o=(e.min.y-d.y)*c),i>o||s>r||((s>i||isNaN(i))&&(i=s),(o<r||isNaN(r))&&(r=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,ec)!==null}intersectTriangle(e,t,i,r,s){jN.subVectors(t,e),uC.subVectors(i,e),YN.crossVectors(jN,uC);let o=this.direction.dot(YN),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;yh.subVectors(this.origin,e);const l=a*this.direction.dot(uC.crossVectors(yh,uC));if(l<0)return null;const u=a*this.direction.dot(jN.cross(yh));if(u<0||l+u>o)return null;const c=-a*yh.dot(YN);return c<0?null:this.at(c/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ft{constructor(e,t,i,r,s,o,a,l,u,c,h,d,p,f,g,y){Ft.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,u,c,h,d,p,f,g,y)}set(e,t,i,r,s,o,a,l,u,c,h,d,p,f,g,y){const m=this.elements;return m[0]=e,m[4]=t,m[8]=i,m[12]=r,m[1]=s,m[5]=o,m[9]=a,m[13]=l,m[2]=u,m[6]=c,m[10]=h,m[14]=d,m[3]=p,m[7]=f,m[11]=g,m[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ft().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/Jm.setFromMatrixColumn(e,0).length(),s=1/Jm.setFromMatrixColumn(e,1).length(),o=1/Jm.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),u=Math.sin(r),c=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*c,p=o*h,f=a*c,g=a*h;t[0]=l*c,t[4]=-l*h,t[8]=u,t[1]=p+f*u,t[5]=d-g*u,t[9]=-a*l,t[2]=g-d*u,t[6]=f+p*u,t[10]=o*l}else if(e.order==="YXZ"){const d=l*c,p=l*h,f=u*c,g=u*h;t[0]=d+g*a,t[4]=f*a-p,t[8]=o*u,t[1]=o*h,t[5]=o*c,t[9]=-a,t[2]=p*a-f,t[6]=g+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*c,p=l*h,f=u*c,g=u*h;t[0]=d-g*a,t[4]=-o*h,t[8]=f+p*a,t[1]=p+f*a,t[5]=o*c,t[9]=g-d*a,t[2]=-o*u,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*c,p=o*h,f=a*c,g=a*h;t[0]=l*c,t[4]=f*u-p,t[8]=d*u+g,t[1]=l*h,t[5]=g*u+d,t[9]=p*u-f,t[2]=-u,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*u,f=a*l,g=a*u;t[0]=l*c,t[4]=g-d*h,t[8]=f*h+p,t[1]=h,t[5]=o*c,t[9]=-a*c,t[2]=-u*c,t[6]=p*h+f,t[10]=d-g*h}else if(e.order==="XZY"){const d=o*l,p=o*u,f=a*l,g=a*u;t[0]=l*c,t[4]=-h,t[8]=u*c,t[1]=d*h+g,t[5]=o*c,t[9]=p*h-f,t[2]=f*h-p,t[6]=a*c,t[10]=g*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(mMe,e,gMe)}lookAt(e,t,i){const r=this.elements;return Uo.subVectors(e,t),Uo.lengthSq()===0&&(Uo.z=1),Uo.normalize(),bh.crossVectors(i,Uo),bh.lengthSq()===0&&(Math.abs(i.z)===1?Uo.x+=1e-4:Uo.z+=1e-4,Uo.normalize(),bh.crossVectors(i,Uo)),bh.normalize(),cC.crossVectors(Uo,bh),r[0]=bh.x,r[4]=cC.x,r[8]=Uo.x,r[1]=bh.y,r[5]=cC.y,r[9]=Uo.y,r[2]=bh.z,r[6]=cC.z,r[10]=Uo.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],u=i[12],c=i[1],h=i[5],d=i[9],p=i[13],f=i[2],g=i[6],y=i[10],m=i[14],v=i[3],w=i[7],S=i[11],C=i[15],_=r[0],A=r[4],I=r[8],E=r[12],k=r[1],P=r[5],V=r[9],U=r[13],F=r[2],$=r[6],J=r[10],q=r[14],O=r[3],X=r[7],j=r[11],z=r[15];return s[0]=o*_+a*k+l*F+u*O,s[4]=o*A+a*P+l*$+u*X,s[8]=o*I+a*V+l*J+u*j,s[12]=o*E+a*U+l*q+u*z,s[1]=c*_+h*k+d*F+p*O,s[5]=c*A+h*P+d*$+p*X,s[9]=c*I+h*V+d*J+p*j,s[13]=c*E+h*U+d*q+p*z,s[2]=f*_+g*k+y*F+m*O,s[6]=f*A+g*P+y*$+m*X,s[10]=f*I+g*V+y*J+m*j,s[14]=f*E+g*U+y*q+m*z,s[3]=v*_+w*k+S*F+C*O,s[7]=v*A+w*P+S*$+C*X,s[11]=v*I+w*V+S*J+C*j,s[15]=v*E+w*U+S*q+C*z,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],u=e[13],c=e[2],h=e[6],d=e[10],p=e[14],f=e[3],g=e[7],y=e[11],m=e[15];return f*(+s*l*h-r*u*h-s*a*d+i*u*d+r*a*p-i*l*p)+g*(+t*l*p-t*u*d+s*o*d-r*o*p+r*u*c-s*l*c)+y*(+t*u*h-t*a*p-s*o*h+i*o*p+s*a*c-i*u*c)+m*(-r*a*c-t*l*h+t*a*d+r*o*h-i*o*d+i*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=e[9],d=e[10],p=e[11],f=e[12],g=e[13],y=e[14],m=e[15],v=h*y*u-g*d*u+g*l*p-a*y*p-h*l*m+a*d*m,w=f*d*u-c*y*u-f*l*p+o*y*p+c*l*m-o*d*m,S=c*g*u-f*h*u+f*a*p-o*g*p-c*a*m+o*h*m,C=f*h*l-c*g*l-f*a*d+o*g*d+c*a*y-o*h*y,_=t*v+i*w+r*S+s*C;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const A=1/_;return e[0]=v*A,e[1]=(g*d*s-h*y*s-g*r*p+i*y*p+h*r*m-i*d*m)*A,e[2]=(a*y*s-g*l*s+g*r*u-i*y*u-a*r*m+i*l*m)*A,e[3]=(h*l*s-a*d*s-h*r*u+i*d*u+a*r*p-i*l*p)*A,e[4]=w*A,e[5]=(c*y*s-f*d*s+f*r*p-t*y*p-c*r*m+t*d*m)*A,e[6]=(f*l*s-o*y*s-f*r*u+t*y*u+o*r*m-t*l*m)*A,e[7]=(o*d*s-c*l*s+c*r*u-t*d*u-o*r*p+t*l*p)*A,e[8]=S*A,e[9]=(f*h*s-c*g*s-f*i*p+t*g*p+c*i*m-t*h*m)*A,e[10]=(o*g*s-f*a*s+f*i*u-t*g*u-o*i*m+t*a*m)*A,e[11]=(c*a*s-o*h*s-c*i*u+t*h*u+o*i*p-t*a*p)*A,e[12]=C*A,e[13]=(c*g*r-f*h*r+f*i*d-t*g*d-c*i*y+t*h*y)*A,e[14]=(f*a*r-o*g*r-f*i*l+t*g*l+o*i*y-t*a*y)*A,e[15]=(o*h*r-c*a*r+c*i*l-t*h*l-o*i*d+t*a*d)*A,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,u=s*o,c=s*a;return this.set(u*o+i,u*a-r*l,u*l+r*a,0,u*a+r*l,c*a+i,c*l-r*o,0,u*l-r*a,c*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,u=s+s,c=o+o,h=a+a,d=s*u,p=s*c,f=s*h,g=o*c,y=o*h,m=a*h,v=l*u,w=l*c,S=l*h,C=i.x,_=i.y,A=i.z;return r[0]=(1-(g+m))*C,r[1]=(p+S)*C,r[2]=(f-w)*C,r[3]=0,r[4]=(p-S)*_,r[5]=(1-(d+m))*_,r[6]=(y+v)*_,r[7]=0,r[8]=(f+w)*A,r[9]=(y-v)*A,r[10]=(1-(d+g))*A,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=Jm.set(r[0],r[1],r[2]).length();const o=Jm.set(r[4],r[5],r[6]).length(),a=Jm.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],pl.copy(this);const u=1/s,c=1/o,h=1/a;return pl.elements[0]*=u,pl.elements[1]*=u,pl.elements[2]*=u,pl.elements[4]*=c,pl.elements[5]*=c,pl.elements[6]*=c,pl.elements[8]*=h,pl.elements[9]*=h,pl.elements[10]*=h,t.setFromRotationMatrix(pl),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o,a=xu){const l=this.elements,u=2*s/(t-e),c=2*s/(i-r),h=(t+e)/(t-e),d=(i+r)/(i-r);let p,f;if(a===xu)p=-(o+s)/(o-s),f=-2*o*s/(o-s);else if(a===Jv)p=-o/(o-s),f=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=u,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=c,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,i,r,s,o,a=xu){const l=this.elements,u=1/(t-e),c=1/(i-r),h=1/(o-s),d=(t+e)*u,p=(i+r)*c;let f,g;if(a===xu)f=(o+s)*h,g=-2*h;else if(a===Jv)f=s*h,g=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=g,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const Jm=new Y,pl=new Ft,mMe=new Y(0,0,0),gMe=new Y(1,1,1),bh=new Y,cC=new Y,Uo=new Y,Z9=new Ft,j9=new Li;class W1{constructor(e=0,t=0,i=0,r=W1.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],u=r[5],c=r[9],h=r[2],d=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(Ui(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-Ui(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ui(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Ui(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(Ui(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Ui(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return Z9.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Z9,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return j9.setFromEuler(this),this.setFromQuaternion(j9,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}W1.DEFAULT_ORDER="XYZ";class sf{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let yMe=0;const Y9=new Y,Qm=new Li,tc=new Ft,hC=new Y,ux=new Y,bMe=new Y,xMe=new Li,J9=new Y(1,0,0),Q9=new Y(0,1,0),q9=new Y(0,0,1),vMe={type:"added"},wMe={type:"removed"};class yn extends Wu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:yMe++}),this.uuid=sa(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=yn.DEFAULT_UP.clone();const e=new Y,t=new W1,i=new Li,r=new Y(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Ft},normalMatrix:{value:new hn}}),this.matrix=new Ft,this.matrixWorld=new Ft,this.matrixAutoUpdate=yn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=yn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new sf,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Qm.setFromAxisAngle(e,t),this.quaternion.multiply(Qm),this}rotateOnWorldAxis(e,t){return Qm.setFromAxisAngle(e,t),this.quaternion.premultiply(Qm),this}rotateX(e){return this.rotateOnAxis(J9,e)}rotateY(e){return this.rotateOnAxis(Q9,e)}rotateZ(e){return this.rotateOnAxis(q9,e)}translateOnAxis(e,t){return Y9.copy(e).applyQuaternion(this.quaternion),this.position.add(Y9.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(J9,e)}translateY(e){return this.translateOnAxis(Q9,e)}translateZ(e){return this.translateOnAxis(q9,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(tc.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?hC.copy(e):hC.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),ux.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?tc.lookAt(ux,hC,this.up):tc.lookAt(hC,ux,this.up),this.quaternion.setFromRotationMatrix(tc),r&&(tc.extractRotation(r.matrixWorld),Qm.setFromRotationMatrix(tc),this.quaternion.premultiply(Qm.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(vMe)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(wMe)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),tc.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),tc.multiply(e.parent.matrixWorld)),e.applyMatrix4(tc),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t){let i=[];this[e]===t&&i.push(this);for(let r=0,s=this.children.length;r<s;r++){const o=this.children[r].getObjectsByProperty(e,t);o.length>0&&(i=i.concat(o))}return i}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ux,e,bMe),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ux,xMe,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++){const s=t[i];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.matrixWorldAutoUpdate===!0&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++){const a=r[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const h=l[u];s(e.shapes,h)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,u=this.material.length;l<u;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),u=o(e.textures),c=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations),f=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),u.length>0&&(i.textures=u),c.length>0&&(i.images=c),h.length>0&&(i.shapes=h),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),f.length>0&&(i.nodes=f)}return i.object=r,i;function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}}yn.DEFAULT_UP=new Y(0,1,0);yn.DEFAULT_MATRIX_AUTO_UPDATE=!0;yn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const fl=new Y,nc=new Y,JN=new Y,ic=new Y,qm=new Y,eg=new Y,e5=new Y,QN=new Y,qN=new Y,eL=new Y;let dC=!1;class bo{constructor(e=new Y,t=new Y,i=new Y){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),fl.subVectors(e,t),r.cross(fl);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){fl.subVectors(r,t),nc.subVectors(i,t),JN.subVectors(e,t);const o=fl.dot(fl),a=fl.dot(nc),l=fl.dot(JN),u=nc.dot(nc),c=nc.dot(JN),h=o*u-a*a;if(h===0)return s.set(-2,-1,-1);const d=1/h,p=(u*l-a*c)*d,f=(o*c-a*l)*d;return s.set(1-p-f,f,p)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,ic),ic.x>=0&&ic.y>=0&&ic.x+ic.y<=1}static getUV(e,t,i,r,s,o,a,l){return dC===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),dC=!0),this.getInterpolation(e,t,i,r,s,o,a,l)}static getInterpolation(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,ic),l.setScalar(0),l.addScaledVector(s,ic.x),l.addScaledVector(o,ic.y),l.addScaledVector(a,ic.z),l}static isFrontFacing(e,t,i,r){return fl.subVectors(i,t),nc.subVectors(e,t),fl.cross(nc).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return fl.subVectors(this.c,this.b),nc.subVectors(this.a,this.b),fl.cross(nc).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return bo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return bo.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,s){return dC===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),dC=!0),bo.getInterpolation(e,this.a,this.b,this.c,t,i,r,s)}getInterpolation(e,t,i,r,s){return bo.getInterpolation(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return bo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return bo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;qm.subVectors(r,i),eg.subVectors(s,i),QN.subVectors(e,i);const l=qm.dot(QN),u=eg.dot(QN);if(l<=0&&u<=0)return t.copy(i);qN.subVectors(e,r);const c=qm.dot(qN),h=eg.dot(qN);if(c>=0&&h<=c)return t.copy(r);const d=l*h-c*u;if(d<=0&&l>=0&&c<=0)return o=l/(l-c),t.copy(i).addScaledVector(qm,o);eL.subVectors(e,s);const p=qm.dot(eL),f=eg.dot(eL);if(f>=0&&p<=f)return t.copy(s);const g=p*u-l*f;if(g<=0&&u>=0&&f<=0)return a=u/(u-f),t.copy(i).addScaledVector(eg,a);const y=c*f-p*h;if(y<=0&&h-c>=0&&p-f>=0)return e5.subVectors(s,r),a=(h-c)/(h-c+(p-f)),t.copy(r).addScaledVector(e5,a);const m=1/(y+g+d);return o=g*m,a=d*m,t.copy(i).addScaledVector(qm,o).addScaledVector(eg,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const xq={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xh={h:0,s:0,l:0},pC={h:0,s:0,l:0};function tL(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class lt{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,i)}set(e,t,i){if(t===void 0&&i===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,i);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=bi){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Fn.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=Fn.workingColorSpace){return this.r=e,this.g=t,this.b=i,Fn.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=Fn.workingColorSpace){if(e=jB(e,1),t=Ui(t,0,1),i=Ui(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=tL(o,s,e+1/3),this.g=tL(o,s,e),this.b=tL(o,s,e-1/3)}return Fn.toWorkingColorSpace(this,r),this}setStyle(e,t=bi){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=bi){const i=xq[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=ry(e.r),this.g=ry(e.g),this.b=ry(e.b),this}copyLinearToSRGB(e){return this.r=$N(e.r),this.g=$N(e.g),this.b=$N(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=bi){return Fn.fromWorkingColorSpace(Ss.copy(this),e),Math.round(Ui(Ss.r*255,0,255))*65536+Math.round(Ui(Ss.g*255,0,255))*256+Math.round(Ui(Ss.b*255,0,255))}getHexString(e=bi){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Fn.workingColorSpace){Fn.fromWorkingColorSpace(Ss.copy(this),t);const i=Ss.r,r=Ss.g,s=Ss.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,u;const c=(a+o)/2;if(a===o)l=0,u=0;else{const h=o-a;switch(u=c<=.5?h/(o+a):h/(2-o-a),o){case i:l=(r-s)/h+(r<s?6:0);break;case r:l=(s-i)/h+2;break;case s:l=(i-r)/h+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=Fn.workingColorSpace){return Fn.fromWorkingColorSpace(Ss.copy(this),t),e.r=Ss.r,e.g=Ss.g,e.b=Ss.b,e}getStyle(e=bi){Fn.fromWorkingColorSpace(Ss.copy(this),e);const t=Ss.r,i=Ss.g,r=Ss.b;return e!==bi?`color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(r*255)})`}offsetHSL(e,t,i){return this.getHSL(xh),this.setHSL(xh.h+e,xh.s+t,xh.l+i)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(xh),e.getHSL(pC);const i=cv(xh.h,pC.h,t),r=cv(xh.s,pC.s,t),s=cv(xh.l,pC.l,t);return this.setHSL(i,r,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,i=this.g,r=this.b,s=e.elements;return this.r=s[0]*t+s[3]*i+s[6]*r,this.g=s[1]*t+s[4]*i+s[7]*r,this.b=s[2]*t+s[5]*i+s[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ss=new lt;lt.NAMES=xq;let SMe=0;class Pi extends Wu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:SMe++}),this.uuid=sa(),this.name="",this.type="Material",this.blending=tf,this.side=Vl,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=VM,this.blendDst=UM,this.blendEquation=Fh,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new lt(0,0,0),this.blendAlpha=0,this.depthFunc=$v,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=R3,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Mp,this.stencilZFail=Mp,this.stencilZPass=Mp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==tf&&(i.blending=this.blending),this.side!==Vl&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==VM&&(i.blendSrc=this.blendSrc),this.blendDst!==UM&&(i.blendDst=this.blendDst),this.blendEquation!==Fh&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==$v&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==R3&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Mp&&(i.stencilFail=this.stencilFail),this.stencilZFail!==Mp&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==Mp&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class dr extends Pi{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=G1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const pc=TMe();function TMe(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),i=new Uint32Array(512),r=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(i[l]=0,i[l|256]=32768,r[l]=24,r[l|256]=24):u<-14?(i[l]=1024>>-u-14,i[l|256]=1024>>-u-14|32768,r[l]=-u-1,r[l|256]=-u-1):u<=15?(i[l]=u+15<<10,i[l|256]=u+15<<10|32768,r[l]=13,r[l|256]=13):u<128?(i[l]=31744,i[l|256]=64512,r[l]=24,r[l|256]=24):(i[l]=31744,i[l|256]=64512,r[l]=13,r[l|256]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;!(u&8388608);)u<<=1,c-=8388608;u&=-8388609,c+=947912704,s[l]=u|c}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:i,shiftTable:r,mantissaTable:s,exponentTable:o,offsetTable:a}}function po(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Ui(n,-65504,65504),pc.floatView[0]=n;const e=pc.uint32View[0],t=e>>23&511;return pc.baseTable[t]+((e&8388607)>>pc.shiftTable[t])}function Px(n){const e=n>>10;return pc.uint32View[0]=pc.mantissaTable[pc.offsetTable[e]+(n&1023)]+pc.exponentTable[e],pc.floatView[0]}const CMe={toHalfFloat:po,fromHalfFloat:Px},ur=new Y,fC=new Ge;class En{constructor(e,t,i=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i,this.usage=Yv,this.updateRange={offset:0,count:-1},this.gpuType=Ml,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)fC.fromBufferAttribute(this,t),fC.applyMatrix3(e),this.setXY(t,fC.x,fC.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)ur.fromBufferAttribute(this,t),ur.applyMatrix3(e),this.setXYZ(t,ur.x,ur.y,ur.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)ur.fromBufferAttribute(this,t),ur.applyMatrix4(e),this.setXYZ(t,ur.x,ur.y,ur.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)ur.fromBufferAttribute(this,t),ur.applyNormalMatrix(e),this.setXYZ(t,ur.x,ur.y,ur.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)ur.fromBufferAttribute(this,t),ur.transformDirection(e),this.setXYZ(t,ur.x,ur.y,ur.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let i=this.array[e*this.itemSize+t];return this.normalized&&(i=vo(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=an(i,this.array)),this.array[e*this.itemSize+t]=i,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=vo(t,this.array)),t}setX(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=vo(t,this.array)),t}setY(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=vo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=vo(t,this.array)),t}setW(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array)),this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array),s=an(s,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Yv&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}class _Me extends En{constructor(e,t,i){super(new Int8Array(e),t,i)}}class MMe extends En{constructor(e,t,i){super(new Uint8Array(e),t,i)}}class AMe extends En{constructor(e,t,i){super(new Uint8ClampedArray(e),t,i)}}class EMe extends En{constructor(e,t,i){super(new Int16Array(e),t,i)}}class QB extends En{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class IMe extends En{constructor(e,t,i){super(new Int32Array(e),t,i)}}class qB extends En{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class kMe extends En{constructor(e,t,i){super(new Uint16Array(e),t,i),this.isFloat16BufferAttribute=!0}getX(e){let t=Px(this.array[e*this.itemSize]);return this.normalized&&(t=vo(t,this.array)),t}setX(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize]=po(t),this}getY(e){let t=Px(this.array[e*this.itemSize+1]);return this.normalized&&(t=vo(t,this.array)),t}setY(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+1]=po(t),this}getZ(e){let t=Px(this.array[e*this.itemSize+2]);return this.normalized&&(t=vo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+2]=po(t),this}getW(e){let t=Px(this.array[e*this.itemSize+3]);return this.normalized&&(t=vo(t,this.array)),t}setW(e,t){return this.normalized&&(t=an(t,this.array)),this.array[e*this.itemSize+3]=po(t),this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array)),this.array[e+0]=po(t),this.array[e+1]=po(i),this}setXYZ(e,t,i,r){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array)),this.array[e+0]=po(t),this.array[e+1]=po(i),this.array[e+2]=po(r),this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array),s=an(s,this.array)),this.array[e+0]=po(t),this.array[e+1]=po(i),this.array[e+2]=po(r),this.array[e+3]=po(s),this}}class It extends En{constructor(e,t,i){super(new Float32Array(e),t,i)}}class RMe extends En{constructor(e,t,i){super(new Float64Array(e),t,i)}}let NMe=0;const La=new Ft,nL=new yn,tg=new Y,$o=new nl,cx=new nl,Br=new Y;class rn extends Wu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:NMe++}),this.uuid=sa(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(gq(e)?qB:QB)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const s=new hn().getNormalMatrix(e);i.applyNormalMatrix(s),i.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return La.makeRotationFromQuaternion(e),this.applyMatrix4(La),this}rotateX(e){return La.makeRotationX(e),this.applyMatrix4(La),this}rotateY(e){return La.makeRotationY(e),this.applyMatrix4(La),this}rotateZ(e){return La.makeRotationZ(e),this.applyMatrix4(La),this}translate(e,t,i){return La.makeTranslation(e,t,i),this.applyMatrix4(La),this}scale(e,t,i){return La.makeScale(e,t,i),this.applyMatrix4(La),this}lookAt(e){return nL.lookAt(e),nL.updateMatrix(),this.applyMatrix4(nL.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(tg).negate(),this.translate(tg.x,tg.y,tg.z),this}setFromPoints(e){const t=[];for(let i=0,r=e.length;i<r;i++){const s=e[i];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new It(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new nl);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Y(-1/0,-1/0,-1/0),new Y(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const s=t[i];$o.setFromBufferAttribute(s),this.morphTargetsRelative?(Br.addVectors(this.boundingBox.min,$o.min),this.boundingBox.expandByPoint(Br),Br.addVectors(this.boundingBox.max,$o.max),this.boundingBox.expandByPoint(Br)):(this.boundingBox.expandByPoint($o.min),this.boundingBox.expandByPoint($o.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ya);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Y,1/0);return}if(e){const i=this.boundingSphere.center;if($o.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];cx.setFromBufferAttribute(a),this.morphTargetsRelative?(Br.addVectors($o.min,cx.min),$o.expandByPoint(Br),Br.addVectors($o.max,cx.max),$o.expandByPoint(Br)):($o.expandByPoint(cx.min),$o.expandByPoint(cx.max))}$o.getCenter(i);let r=0;for(let s=0,o=e.count;s<o;s++)Br.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(Br));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Br.fromBufferAttribute(a,u),l&&(tg.fromBufferAttribute(e,u),Br.add(tg)),r=Math.max(r,i.distanceToSquared(Br))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,r=t.position.array,s=t.normal.array,o=t.uv.array,a=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new En(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,u=[],c=[];for(let k=0;k<a;k++)u[k]=new Y,c[k]=new Y;const h=new Y,d=new Y,p=new Y,f=new Ge,g=new Ge,y=new Ge,m=new Y,v=new Y;function w(k,P,V){h.fromArray(r,k*3),d.fromArray(r,P*3),p.fromArray(r,V*3),f.fromArray(o,k*2),g.fromArray(o,P*2),y.fromArray(o,V*2),d.sub(h),p.sub(h),g.sub(f),y.sub(f);const U=1/(g.x*y.y-y.x*g.y);isFinite(U)&&(m.copy(d).multiplyScalar(y.y).addScaledVector(p,-g.y).multiplyScalar(U),v.copy(p).multiplyScalar(g.x).addScaledVector(d,-y.x).multiplyScalar(U),u[k].add(m),u[P].add(m),u[V].add(m),c[k].add(v),c[P].add(v),c[V].add(v))}let S=this.groups;S.length===0&&(S=[{start:0,count:i.length}]);for(let k=0,P=S.length;k<P;++k){const V=S[k],U=V.start,F=V.count;for(let $=U,J=U+F;$<J;$+=3)w(i[$+0],i[$+1],i[$+2])}const C=new Y,_=new Y,A=new Y,I=new Y;function E(k){A.fromArray(s,k*3),I.copy(A);const P=u[k];C.copy(P),C.sub(A.multiplyScalar(A.dot(P))).normalize(),_.crossVectors(I,P);const U=_.dot(c[k])<0?-1:1;l[k*4]=C.x,l[k*4+1]=C.y,l[k*4+2]=C.z,l[k*4+3]=U}for(let k=0,P=S.length;k<P;++k){const V=S[k],U=V.start,F=V.count;for(let $=U,J=U+F;$<J;$+=3)E(i[$+0]),E(i[$+1]),E(i[$+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new En(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const r=new Y,s=new Y,o=new Y,a=new Y,l=new Y,u=new Y,c=new Y,h=new Y;if(e)for(let d=0,p=e.count;d<p;d+=3){const f=e.getX(d+0),g=e.getX(d+1),y=e.getX(d+2);r.fromBufferAttribute(t,f),s.fromBufferAttribute(t,g),o.fromBufferAttribute(t,y),c.subVectors(o,s),h.subVectors(r,s),c.cross(h),a.fromBufferAttribute(i,f),l.fromBufferAttribute(i,g),u.fromBufferAttribute(i,y),a.add(c),l.add(c),u.add(c),i.setXYZ(f,a.x,a.y,a.z),i.setXYZ(g,l.x,l.y,l.z),i.setXYZ(y,u.x,u.y,u.z)}else for(let d=0,p=t.count;d<p;d+=3)r.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),c.subVectors(o,s),h.subVectors(r,s),c.cross(h),i.setXYZ(d+0,c.x,c.y,c.z),i.setXYZ(d+1,c.x,c.y,c.z),i.setXYZ(d+2,c.x,c.y,c.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)Br.fromBufferAttribute(e,t),Br.normalize(),e.setXYZ(t,Br.x,Br.y,Br.z)}toNonIndexed(){function e(a,l){const u=a.array,c=a.itemSize,h=a.normalized,d=new u.constructor(l.length*c);let p=0,f=0;for(let g=0,y=l.length;g<y;g++){a.isInterleavedBufferAttribute?p=l[g]*a.data.stride+a.offset:p=l[g]*c;for(let m=0;m<c;m++)d[f++]=u[p++]}return new En(d,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new rn,i=this.index.array,r=this.attributes;for(const a in r){const l=r[a],u=e(l,i);t.setAttribute(a,u)}const s=this.morphAttributes;for(const a in s){const l=[],u=s[a];for(let c=0,h=u.length;c<h;c++){const d=u[c],p=e(d,i);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const u=o[a];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const u=i[l];e.data.attributes[l]=u.toJSON(e.data)}const r={};let s=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let h=0,d=u.length;h<d;h++){const p=u[h];c.push(p.toJSON(e.data))}c.length>0&&(r[l]=c,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const r=e.attributes;for(const u in r){const c=r[u];this.setAttribute(u,c.clone(t))}const s=e.morphAttributes;for(const u in s){const c=[],h=s[u];for(let d=0,p=h.length;d<p;d++)c.push(h[d].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let u=0,c=o.length;u<c;u++){const h=o[u];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const t5=new Ft,sp=new sm,mC=new ya,n5=new Y,ng=new Y,ig=new Y,rg=new Y,iL=new Y,gC=new Y,yC=new Ge,bC=new Ge,xC=new Ge,i5=new Y,r5=new Y,s5=new Y,vC=new Y,wC=new Y;class pr extends yn{constructor(e=new rn,t=new dr){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const i=this.geometry,r=i.attributes.position,s=i.morphAttributes.position,o=i.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(s&&a){gC.set(0,0,0);for(let l=0,u=s.length;l<u;l++){const c=a[l],h=s[l];c!==0&&(iL.fromBufferAttribute(h,e),o?gC.addScaledVector(iL,c):gC.addScaledVector(iL.sub(t),c))}t.add(gC)}return t}raycast(e,t){const i=this.geometry,r=this.material,s=this.matrixWorld;r!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),mC.copy(i.boundingSphere),mC.applyMatrix4(s),sp.copy(e.ray).recast(e.near),!(mC.containsPoint(sp.origin)===!1&&(sp.intersectSphere(mC,n5)===null||sp.origin.distanceToSquared(n5)>(e.far-e.near)**2))&&(t5.copy(s).invert(),sp.copy(e.ray).applyMatrix4(t5),!(i.boundingBox!==null&&sp.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(e,t,sp)))}_computeIntersections(e,t,i){let r;const s=this.geometry,o=this.material,a=s.index,l=s.attributes.position,u=s.attributes.uv,c=s.attributes.uv1,h=s.attributes.normal,d=s.groups,p=s.drawRange;if(a!==null)if(Array.isArray(o))for(let f=0,g=d.length;f<g;f++){const y=d[f],m=o[y.materialIndex],v=Math.max(y.start,p.start),w=Math.min(a.count,Math.min(y.start+y.count,p.start+p.count));for(let S=v,C=w;S<C;S+=3){const _=a.getX(S),A=a.getX(S+1),I=a.getX(S+2);r=SC(this,m,e,i,u,c,h,_,A,I),r&&(r.faceIndex=Math.floor(S/3),r.face.materialIndex=y.materialIndex,t.push(r))}}else{const f=Math.max(0,p.start),g=Math.min(a.count,p.start+p.count);for(let y=f,m=g;y<m;y+=3){const v=a.getX(y),w=a.getX(y+1),S=a.getX(y+2);r=SC(this,o,e,i,u,c,h,v,w,S),r&&(r.faceIndex=Math.floor(y/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let f=0,g=d.length;f<g;f++){const y=d[f],m=o[y.materialIndex],v=Math.max(y.start,p.start),w=Math.min(l.count,Math.min(y.start+y.count,p.start+p.count));for(let S=v,C=w;S<C;S+=3){const _=S,A=S+1,I=S+2;r=SC(this,m,e,i,u,c,h,_,A,I),r&&(r.faceIndex=Math.floor(S/3),r.face.materialIndex=y.materialIndex,t.push(r))}}else{const f=Math.max(0,p.start),g=Math.min(l.count,p.start+p.count);for(let y=f,m=g;y<m;y+=3){const v=y,w=y+1,S=y+2;r=SC(this,o,e,i,u,c,h,v,w,S),r&&(r.faceIndex=Math.floor(y/3),t.push(r))}}}}function LMe(n,e,t,i,r,s,o,a){let l;if(e.side===Ys?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side===Vl,a),l===null)return null;wC.copy(a),wC.applyMatrix4(n.matrixWorld);const u=t.ray.origin.distanceTo(wC);return u<t.near||u>t.far?null:{distance:u,point:wC.clone(),object:n}}function SC(n,e,t,i,r,s,o,a,l,u){n.getVertexPosition(a,ng),n.getVertexPosition(l,ig),n.getVertexPosition(u,rg);const c=LMe(n,e,t,i,ng,ig,rg,vC);if(c){r&&(yC.fromBufferAttribute(r,a),bC.fromBufferAttribute(r,l),xC.fromBufferAttribute(r,u),c.uv=bo.getInterpolation(vC,ng,ig,rg,yC,bC,xC,new Ge)),s&&(yC.fromBufferAttribute(s,a),bC.fromBufferAttribute(s,l),xC.fromBufferAttribute(s,u),c.uv1=bo.getInterpolation(vC,ng,ig,rg,yC,bC,xC,new Ge),c.uv2=c.uv1),o&&(i5.fromBufferAttribute(o,a),r5.fromBufferAttribute(o,l),s5.fromBufferAttribute(o,u),c.normal=bo.getInterpolation(vC,ng,ig,rg,i5,r5,s5,new Y),c.normal.dot(i.direction)>0&&c.normal.multiplyScalar(-1));const h={a,b:l,c:u,normal:new Y,materialIndex:0};bo.getNormal(ng,ig,rg,h.normal),c.face=h}return c}class om extends rn{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],u=[],c=[],h=[];let d=0,p=0;f("z","y","x",-1,-1,i,t,e,o,s,0),f("z","y","x",1,-1,i,t,-e,o,s,1),f("x","z","y",1,1,e,i,t,r,o,2),f("x","z","y",1,-1,e,i,-t,r,o,3),f("x","y","z",1,-1,e,t,i,r,s,4),f("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new It(u,3)),this.setAttribute("normal",new It(c,3)),this.setAttribute("uv",new It(h,2));function f(g,y,m,v,w,S,C,_,A,I,E){const k=S/A,P=C/I,V=S/2,U=C/2,F=_/2,$=A+1,J=I+1;let q=0,O=0;const X=new Y;for(let j=0;j<J;j++){const z=j*P-U;for(let Z=0;Z<$;Z++){const ce=Z*k-V;X[g]=ce*v,X[y]=z*w,X[m]=F,u.push(X.x,X.y,X.z),X[g]=0,X[y]=0,X[m]=_>0?1:-1,c.push(X.x,X.y,X.z),h.push(Z/A),h.push(1-j/I),q+=1}}for(let j=0;j<I;j++)for(let z=0;z<A;z++){const Z=d+z+$*j,ce=d+z+$*(j+1),fe=d+(z+1)+$*(j+1),ge=d+(z+1)+$*j;l.push(Z,ce,ge),l.push(ce,fe,ge),O+=6}a.addGroup(p,O,E),p+=O,d+=q}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new om(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Ay(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][i]=null):e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function $s(n){const e={};for(let t=0;t<n.length;t++){const i=Ay(n[t]);for(const r in i)e[r]=i[r]}return e}function PMe(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function vq(n){return n.getRenderTarget()===null?n.outputColorSpace:Fn.workingColorSpace}const wq={clone:Ay,merge:$s};var DMe=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,FMe=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Du extends Pi{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=DMe,this.fragmentShader=FMe,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ay(e.uniforms),this.uniformsGroups=PMe(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}class H1 extends yn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Ft,this.projectionMatrix=new Ft,this.projectionMatrixInverse=new Ft,this.coordinateSystem=xu}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}let ci=class extends H1{constructor(e=50,t=1,i=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=My*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(rf*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return My*2*Math.atan(Math.tan(rf*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(rf*.5*this.fov)/this.zoom,i=2*t,r=this.aspect*i,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,u=o.fullHeight;s+=o.offsetX*r/l,t-=o.offsetY*i/u,r*=o.width/l,i*=o.height/u}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-i,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}};const sg=-90,og=1;class Sq extends yn{constructor(e,t,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new ci(sg,og,e,t);r.layers=this.layers,this.add(r);const s=new ci(sg,og,e,t);s.layers=this.layers,this.add(s);const o=new ci(sg,og,e,t);o.layers=this.layers,this.add(o);const a=new ci(sg,og,e,t);a.layers=this.layers,this.add(a);const l=new ci(sg,og,e,t);l.layers=this.layers,this.add(l);const u=new ci(sg,og,e,t);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[i,r,s,o,a,l]=t;for(const u of t)this.remove(u);if(e===xu)i.up.set(0,1,0),i.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===Jv)i.up.set(0,-1,0),i.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of t)this.add(u),u.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,l,u,c]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),f=e.xr.enabled;e.xr.enabled=!1;const g=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0,r),e.render(t,s),e.setRenderTarget(i,1,r),e.render(t,o),e.setRenderTarget(i,2,r),e.render(t,a),e.setRenderTarget(i,3,r),e.render(t,l),e.setRenderTarget(i,4,r),e.render(t,u),i.texture.generateMipmaps=g,e.setRenderTarget(i,5,r),e.render(t,c),e.setRenderTarget(h,d,p),e.xr.enabled=f,i.texture.needsPMREMUpdate=!0}}class X1 extends ni{constructor(e,t,i,r,s,o,a,l,u,c){e=e!==void 0?e:[],t=t!==void 0?t:Dc,super(e,t,i,r,s,o,a,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class Tq extends el{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];t.encoding!==void 0&&(hv("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===Ec?bi:jo),this.texture=new X1(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Zn}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new om(5,5,5),s=new Du({name:"CubemapFromEquirect",uniforms:Ay(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:Ys,blending:Ac});s.uniforms.tEquirect.value=t;const o=new pr(r,s),a=t.minFilter;return t.minFilter===qa&&(t.minFilter=Zn),new Sq(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}}const rL=new Y,OMe=new Y,BMe=new hn;class uc{constructor(e=new Y(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=rL.subVectors(i,t).cross(OMe.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const i=e.delta(rL),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(e.start).addScaledVector(i,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||BMe.getNormalMatrix(e),r=this.coplanarPoint(rL).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const op=new ya,TC=new Y;class EE{constructor(e=new uc,t=new uc,i=new uc,r=new uc,s=new uc,o=new uc){this.planes=[e,t,i,r,s,o]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e,t=xu){const i=this.planes,r=e.elements,s=r[0],o=r[1],a=r[2],l=r[3],u=r[4],c=r[5],h=r[6],d=r[7],p=r[8],f=r[9],g=r[10],y=r[11],m=r[12],v=r[13],w=r[14],S=r[15];if(i[0].setComponents(l-s,d-u,y-p,S-m).normalize(),i[1].setComponents(l+s,d+u,y+p,S+m).normalize(),i[2].setComponents(l+o,d+c,y+f,S+v).normalize(),i[3].setComponents(l-o,d-c,y-f,S-v).normalize(),i[4].setComponents(l-a,d-h,y-g,S-w).normalize(),t===xu)i[5].setComponents(l+a,d+h,y+g,S+w).normalize();else if(t===Jv)i[5].setComponents(a,h,g,w).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),op.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),op.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(op)}intersectsSprite(e){return op.center.set(0,0,0),op.radius=.7071067811865476,op.applyMatrix4(e.matrixWorld),this.intersectsSphere(op)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(TC.x=r.normal.x>0?e.max.x:e.min.x,TC.y=r.normal.y>0?e.max.y:e.min.y,TC.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(TC)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Cq(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function zMe(n,e){const t=e.isWebGL2,i=new WeakMap;function r(u,c){const h=u.array,d=u.usage,p=n.createBuffer();n.bindBuffer(c,p),n.bufferData(c,h,d),u.onUploadCallback();let f;if(h instanceof Float32Array)f=n.FLOAT;else if(h instanceof Uint16Array)if(u.isFloat16BufferAttribute)if(t)f=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else f=n.UNSIGNED_SHORT;else if(h instanceof Int16Array)f=n.SHORT;else if(h instanceof Uint32Array)f=n.UNSIGNED_INT;else if(h instanceof Int32Array)f=n.INT;else if(h instanceof Int8Array)f=n.BYTE;else if(h instanceof Uint8Array)f=n.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)f=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:p,type:f,bytesPerElement:h.BYTES_PER_ELEMENT,version:u.version}}function s(u,c,h){const d=c.array,p=c.updateRange;n.bindBuffer(h,u),p.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1),c.onUploadCallback()}function o(u){return u.isInterleavedBufferAttribute&&(u=u.data),i.get(u)}function a(u){u.isInterleavedBufferAttribute&&(u=u.data);const c=i.get(u);c&&(n.deleteBuffer(c.buffer),i.delete(u))}function l(u,c){if(u.isGLBufferAttribute){const d=i.get(u);(!d||d.version<u.version)&&i.set(u,{buffer:u.buffer,type:u.type,bytesPerElement:u.elementSize,version:u.version});return}u.isInterleavedBufferAttribute&&(u=u.data);const h=i.get(u);h===void 0?i.set(u,r(u,c)):h.version<u.version&&(s(h.buffer,u,c),h.version=u.version)}return{get:o,remove:a,update:l}}class e0 extends rn{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),u=a+1,c=l+1,h=e/a,d=t/l,p=[],f=[],g=[],y=[];for(let m=0;m<c;m++){const v=m*d-o;for(let w=0;w<u;w++){const S=w*h-s;f.push(S,-v,0),g.push(0,0,1),y.push(w/a),y.push(1-m/l)}}for(let m=0;m<l;m++)for(let v=0;v<a;v++){const w=v+u*m,S=v+u*(m+1),C=v+1+u*(m+1),_=v+1+u*m;p.push(w,S,_),p.push(S,C,_)}this.setIndex(p),this.setAttribute("position",new It(f,3)),this.setAttribute("normal",new It(g,3)),this.setAttribute("uv",new It(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new e0(e.width,e.height,e.widthSegments,e.heightSegments)}}var GMe=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,VMe=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,UMe=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,$Me=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,WMe=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,HMe=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,XMe=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,KMe=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,ZMe=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,jMe=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,YMe=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,JMe=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,QMe=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,qMe=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,eAe=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,tAe=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,nAe=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,iAe=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,rAe=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,sAe=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,oAe=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,aAe=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,lAe=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,uAe=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,cAe=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,hAe=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,dAe=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,pAe=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,fAe="gl_FragColor = linearToOutputTexel( gl_FragColor );",mAe=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,gAe=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,yAe=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,bAe=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,xAe=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,vAe=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,wAe=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,SAe=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,TAe=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,CAe=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,_Ae=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,MAe=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,AAe=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,EAe=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,IAe=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,kAe=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,RAe=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,NAe=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,LAe=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,PAe=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,DAe=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,FAe=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,OAe=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,BAe=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,zAe=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,GAe=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,VAe=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,UAe=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,$Ae=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,WAe=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,HAe=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,XAe=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,KAe=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ZAe=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,jAe=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,YAe=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,JAe=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,QAe=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,qAe=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,eEe=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,tEe=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,nEe=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,iEe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,rEe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,sEe=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,oEe=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,aEe=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,lEe=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,uEe=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,cEe=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,hEe=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,dEe=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,pEe=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,fEe=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,mEe=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,gEe=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,yEe=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,bEe=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,xEe=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,vEe=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,wEe=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,SEe=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,TEe=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,CEe=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,_Ee=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,MEe=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,AEe=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,EEe=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,IEe=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,kEe=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,REe=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,NEe=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,LEe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,PEe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,DEe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,FEe=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const OEe=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,BEe=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,zEe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,GEe=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,VEe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,UEe=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,$Ee=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,WEe=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,HEe=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,XEe=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,KEe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ZEe=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,jEe=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,YEe=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,JEe=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,QEe=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,qEe=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,e2e=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,t2e=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,n2e=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,i2e=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,r2e=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,s2e=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,o2e=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,a2e=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,l2e=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,u2e=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,c2e=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,h2e=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,d2e=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,p2e=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,f2e=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,m2e=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,g2e=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,on={alphahash_fragment:GMe,alphahash_pars_fragment:VMe,alphamap_fragment:UMe,alphamap_pars_fragment:$Me,alphatest_fragment:WMe,alphatest_pars_fragment:HMe,aomap_fragment:XMe,aomap_pars_fragment:KMe,begin_vertex:ZMe,beginnormal_vertex:jMe,bsdfs:YMe,iridescence_fragment:JMe,bumpmap_pars_fragment:QMe,clipping_planes_fragment:qMe,clipping_planes_pars_fragment:eAe,clipping_planes_pars_vertex:tAe,clipping_planes_vertex:nAe,color_fragment:iAe,color_pars_fragment:rAe,color_pars_vertex:sAe,color_vertex:oAe,common:aAe,cube_uv_reflection_fragment:lAe,defaultnormal_vertex:uAe,displacementmap_pars_vertex:cAe,displacementmap_vertex:hAe,emissivemap_fragment:dAe,emissivemap_pars_fragment:pAe,colorspace_fragment:fAe,colorspace_pars_fragment:mAe,envmap_fragment:gAe,envmap_common_pars_fragment:yAe,envmap_pars_fragment:bAe,envmap_pars_vertex:xAe,envmap_physical_pars_fragment:RAe,envmap_vertex:vAe,fog_vertex:wAe,fog_pars_vertex:SAe,fog_fragment:TAe,fog_pars_fragment:CAe,gradientmap_pars_fragment:_Ae,lightmap_fragment:MAe,lightmap_pars_fragment:AAe,lights_lambert_fragment:EAe,lights_lambert_pars_fragment:IAe,lights_pars_begin:kAe,lights_toon_fragment:NAe,lights_toon_pars_fragment:LAe,lights_phong_fragment:PAe,lights_phong_pars_fragment:DAe,lights_physical_fragment:FAe,lights_physical_pars_fragment:OAe,lights_fragment_begin:BAe,lights_fragment_maps:zAe,lights_fragment_end:GAe,logdepthbuf_fragment:VAe,logdepthbuf_pars_fragment:UAe,logdepthbuf_pars_vertex:$Ae,logdepthbuf_vertex:WAe,map_fragment:HAe,map_pars_fragment:XAe,map_particle_fragment:KAe,map_particle_pars_fragment:ZAe,metalnessmap_fragment:jAe,metalnessmap_pars_fragment:YAe,morphcolor_vertex:JAe,morphnormal_vertex:QAe,morphtarget_pars_vertex:qAe,morphtarget_vertex:eEe,normal_fragment_begin:tEe,normal_fragment_maps:nEe,normal_pars_fragment:iEe,normal_pars_vertex:rEe,normal_vertex:sEe,normalmap_pars_fragment:oEe,clearcoat_normal_fragment_begin:aEe,clearcoat_normal_fragment_maps:lEe,clearcoat_pars_fragment:uEe,iridescence_pars_fragment:cEe,opaque_fragment:hEe,packing:dEe,premultiplied_alpha_fragment:pEe,project_vertex:fEe,dithering_fragment:mEe,dithering_pars_fragment:gEe,roughnessmap_fragment:yEe,roughnessmap_pars_fragment:bEe,shadowmap_pars_fragment:xEe,shadowmap_pars_vertex:vEe,shadowmap_vertex:wEe,shadowmask_pars_fragment:SEe,skinbase_vertex:TEe,skinning_pars_vertex:CEe,skinning_vertex:_Ee,skinnormal_vertex:MEe,specularmap_fragment:AEe,specularmap_pars_fragment:EEe,tonemapping_fragment:IEe,tonemapping_pars_fragment:kEe,transmission_fragment:REe,transmission_pars_fragment:NEe,uv_pars_fragment:LEe,uv_pars_vertex:PEe,uv_vertex:DEe,worldpos_vertex:FEe,background_vert:OEe,background_frag:BEe,backgroundCube_vert:zEe,backgroundCube_frag:GEe,cube_vert:VEe,cube_frag:UEe,depth_vert:$Ee,depth_frag:WEe,distanceRGBA_vert:HEe,distanceRGBA_frag:XEe,equirect_vert:KEe,equirect_frag:ZEe,linedashed_vert:jEe,linedashed_frag:YEe,meshbasic_vert:JEe,meshbasic_frag:QEe,meshlambert_vert:qEe,meshlambert_frag:e2e,meshmatcap_vert:t2e,meshmatcap_frag:n2e,meshnormal_vert:i2e,meshnormal_frag:r2e,meshphong_vert:s2e,meshphong_frag:o2e,meshphysical_vert:a2e,meshphysical_frag:l2e,meshtoon_vert:u2e,meshtoon_frag:c2e,points_vert:h2e,points_frag:d2e,shadow_vert:p2e,shadow_frag:f2e,sprite_vert:m2e,sprite_frag:g2e},dt={common:{diffuse:{value:new lt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new hn},alphaMap:{value:null},alphaMapTransform:{value:new hn},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new hn}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new hn}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new hn}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new hn},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new hn},normalScale:{value:new Ge(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new hn},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new hn}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new hn}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new hn}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new lt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new lt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new hn},alphaTest:{value:0},uvTransform:{value:new hn}},sprite:{diffuse:{value:new lt(16777215)},opacity:{value:1},center:{value:new Ge(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new hn},alphaMap:{value:null},alphaMapTransform:{value:new hn},alphaTest:{value:0}}},Tl={basic:{uniforms:$s([dt.common,dt.specularmap,dt.envmap,dt.aomap,dt.lightmap,dt.fog]),vertexShader:on.meshbasic_vert,fragmentShader:on.meshbasic_frag},lambert:{uniforms:$s([dt.common,dt.specularmap,dt.envmap,dt.aomap,dt.lightmap,dt.emissivemap,dt.bumpmap,dt.normalmap,dt.displacementmap,dt.fog,dt.lights,{emissive:{value:new lt(0)}}]),vertexShader:on.meshlambert_vert,fragmentShader:on.meshlambert_frag},phong:{uniforms:$s([dt.common,dt.specularmap,dt.envmap,dt.aomap,dt.lightmap,dt.emissivemap,dt.bumpmap,dt.normalmap,dt.displacementmap,dt.fog,dt.lights,{emissive:{value:new lt(0)},specular:{value:new lt(1118481)},shininess:{value:30}}]),vertexShader:on.meshphong_vert,fragmentShader:on.meshphong_frag},standard:{uniforms:$s([dt.common,dt.envmap,dt.aomap,dt.lightmap,dt.emissivemap,dt.bumpmap,dt.normalmap,dt.displacementmap,dt.roughnessmap,dt.metalnessmap,dt.fog,dt.lights,{emissive:{value:new lt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:on.meshphysical_vert,fragmentShader:on.meshphysical_frag},toon:{uniforms:$s([dt.common,dt.aomap,dt.lightmap,dt.emissivemap,dt.bumpmap,dt.normalmap,dt.displacementmap,dt.gradientmap,dt.fog,dt.lights,{emissive:{value:new lt(0)}}]),vertexShader:on.meshtoon_vert,fragmentShader:on.meshtoon_frag},matcap:{uniforms:$s([dt.common,dt.bumpmap,dt.normalmap,dt.displacementmap,dt.fog,{matcap:{value:null}}]),vertexShader:on.meshmatcap_vert,fragmentShader:on.meshmatcap_frag},points:{uniforms:$s([dt.points,dt.fog]),vertexShader:on.points_vert,fragmentShader:on.points_frag},dashed:{uniforms:$s([dt.common,dt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:on.linedashed_vert,fragmentShader:on.linedashed_frag},depth:{uniforms:$s([dt.common,dt.displacementmap]),vertexShader:on.depth_vert,fragmentShader:on.depth_frag},normal:{uniforms:$s([dt.common,dt.bumpmap,dt.normalmap,dt.displacementmap,{opacity:{value:1}}]),vertexShader:on.meshnormal_vert,fragmentShader:on.meshnormal_frag},sprite:{uniforms:$s([dt.sprite,dt.fog]),vertexShader:on.sprite_vert,fragmentShader:on.sprite_frag},background:{uniforms:{uvTransform:{value:new hn},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:on.background_vert,fragmentShader:on.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:on.backgroundCube_vert,fragmentShader:on.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:on.cube_vert,fragmentShader:on.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:on.equirect_vert,fragmentShader:on.equirect_frag},distanceRGBA:{uniforms:$s([dt.common,dt.displacementmap,{referencePosition:{value:new Y},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:on.distanceRGBA_vert,fragmentShader:on.distanceRGBA_frag},shadow:{uniforms:$s([dt.lights,dt.fog,{color:{value:new lt(0)},opacity:{value:1}}]),vertexShader:on.shadow_vert,fragmentShader:on.shadow_frag}};Tl.physical={uniforms:$s([Tl.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new hn},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new hn},clearcoatNormalScale:{value:new Ge(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new hn},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new hn},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new hn},sheen:{value:0},sheenColor:{value:new lt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new hn},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new hn},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new hn},transmissionSamplerSize:{value:new Ge},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new hn},attenuationDistance:{value:0},attenuationColor:{value:new lt(0)},specularColor:{value:new lt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new hn},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new hn},anisotropyVector:{value:new Ge},anisotropyMap:{value:null},anisotropyMapTransform:{value:new hn}}]),vertexShader:on.meshphysical_vert,fragmentShader:on.meshphysical_frag};const CC={r:0,b:0,g:0};function y2e(n,e,t,i,r,s,o){const a=new lt(0);let l=s===!0?0:1,u,c,h=null,d=0,p=null;function f(y,m){let v=!1,w=m.isScene===!0?m.background:null;w&&w.isTexture&&(w=(m.backgroundBlurriness>0?t:e).get(w)),w===null?g(a,l):w&&w.isColor&&(g(w,1),v=!0);const S=n.xr.getEnvironmentBlendMode();S==="additive"?i.buffers.color.setClear(0,0,0,1,o):S==="alpha-blend"&&i.buffers.color.setClear(0,0,0,0,o),(n.autoClear||v)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),w&&(w.isCubeTexture||w.mapping===qy)?(c===void 0&&(c=new pr(new om(1,1,1),new Du({name:"BackgroundCubeMaterial",uniforms:Ay(Tl.backgroundCube.uniforms),vertexShader:Tl.backgroundCube.vertexShader,fragmentShader:Tl.backgroundCube.fragmentShader,side:Ys,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(C,_,A){this.matrixWorld.copyPosition(A.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=w,c.material.uniforms.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=m.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,c.material.toneMapped=Fn.getTransfer(w.colorSpace)!==Qn,(h!==w||d!==w.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,h=w,d=w.version,p=n.toneMapping),c.layers.enableAll(),y.unshift(c,c.geometry,c.material,0,0,null)):w&&w.isTexture&&(u===void 0&&(u=new pr(new e0(2,2),new Du({name:"BackgroundMaterial",uniforms:Ay(Tl.background.uniforms),vertexShader:Tl.background.vertexShader,fragmentShader:Tl.background.fragmentShader,side:Vl,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(u)),u.material.uniforms.t2D.value=w,u.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,u.material.toneMapped=Fn.getTransfer(w.colorSpace)!==Qn,w.matrixAutoUpdate===!0&&w.updateMatrix(),u.material.uniforms.uvTransform.value.copy(w.matrix),(h!==w||d!==w.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,h=w,d=w.version,p=n.toneMapping),u.layers.enableAll(),y.unshift(u,u.geometry,u.material,0,0,null))}function g(y,m){y.getRGB(CC,vq(n)),i.buffers.color.setClear(CC.r,CC.g,CC.b,m,o)}return{getClearColor:function(){return a},setClearColor:function(y,m=1){a.set(y),l=m,g(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(y){l=y,g(a,l)},render:f}}function b2e(n,e,t,i){const r=n.getParameter(n.MAX_VERTEX_ATTRIBS),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=y(null);let u=l,c=!1;function h(F,$,J,q,O){let X=!1;if(o){const j=g(q,J,$);u!==j&&(u=j,p(u.object)),X=m(F,q,J,O),X&&v(F,q,J,O)}else{const j=$.wireframe===!0;(u.geometry!==q.id||u.program!==J.id||u.wireframe!==j)&&(u.geometry=q.id,u.program=J.id,u.wireframe=j,X=!0)}O!==null&&t.update(O,n.ELEMENT_ARRAY_BUFFER),(X||c)&&(c=!1,I(F,$,J,q),O!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(O).buffer))}function d(){return i.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function p(F){return i.isWebGL2?n.bindVertexArray(F):s.bindVertexArrayOES(F)}function f(F){return i.isWebGL2?n.deleteVertexArray(F):s.deleteVertexArrayOES(F)}function g(F,$,J){const q=J.wireframe===!0;let O=a[F.id];O===void 0&&(O={},a[F.id]=O);let X=O[$.id];X===void 0&&(X={},O[$.id]=X);let j=X[q];return j===void 0&&(j=y(d()),X[q]=j),j}function y(F){const $=[],J=[],q=[];for(let O=0;O<r;O++)$[O]=0,J[O]=0,q[O]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:$,enabledAttributes:J,attributeDivisors:q,object:F,attributes:{},index:null}}function m(F,$,J,q){const O=u.attributes,X=$.attributes;let j=0;const z=J.getAttributes();for(const Z in z)if(z[Z].location>=0){const fe=O[Z];let ge=X[Z];if(ge===void 0&&(Z==="instanceMatrix"&&F.instanceMatrix&&(ge=F.instanceMatrix),Z==="instanceColor"&&F.instanceColor&&(ge=F.instanceColor)),fe===void 0||fe.attribute!==ge||ge&&fe.data!==ge.data)return!0;j++}return u.attributesNum!==j||u.index!==q}function v(F,$,J,q){const O={},X=$.attributes;let j=0;const z=J.getAttributes();for(const Z in z)if(z[Z].location>=0){let fe=X[Z];fe===void 0&&(Z==="instanceMatrix"&&F.instanceMatrix&&(fe=F.instanceMatrix),Z==="instanceColor"&&F.instanceColor&&(fe=F.instanceColor));const ge={};ge.attribute=fe,fe&&fe.data&&(ge.data=fe.data),O[Z]=ge,j++}u.attributes=O,u.attributesNum=j,u.index=q}function w(){const F=u.newAttributes;for(let $=0,J=F.length;$<J;$++)F[$]=0}function S(F){C(F,0)}function C(F,$){const J=u.newAttributes,q=u.enabledAttributes,O=u.attributeDivisors;J[F]=1,q[F]===0&&(n.enableVertexAttribArray(F),q[F]=1),O[F]!==$&&((i.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](F,$),O[F]=$)}function _(){const F=u.newAttributes,$=u.enabledAttributes;for(let J=0,q=$.length;J<q;J++)$[J]!==F[J]&&(n.disableVertexAttribArray(J),$[J]=0)}function A(F,$,J,q,O,X,j){j===!0?n.vertexAttribIPointer(F,$,J,O,X):n.vertexAttribPointer(F,$,J,q,O,X)}function I(F,$,J,q){if(i.isWebGL2===!1&&(F.isInstancedMesh||q.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;w();const O=q.attributes,X=J.getAttributes(),j=$.defaultAttributeValues;for(const z in X){const Z=X[z];if(Z.location>=0){let ce=O[z];if(ce===void 0&&(z==="instanceMatrix"&&F.instanceMatrix&&(ce=F.instanceMatrix),z==="instanceColor"&&F.instanceColor&&(ce=F.instanceColor)),ce!==void 0){const fe=ce.normalized,ge=ce.itemSize,Ne=t.get(ce);if(Ne===void 0)continue;const Fe=Ne.buffer,We=Ne.type,Ue=Ne.bytesPerElement,Ye=i.isWebGL2===!0&&(We===n.INT||We===n.UNSIGNED_INT||ce.gpuType===GB);if(ce.isInterleavedBufferAttribute){const $e=ce.data,ee=$e.stride,De=ce.offset;if($e.isInstancedInterleavedBuffer){for(let _e=0;_e<Z.locationSize;_e++)C(Z.location+_e,$e.meshPerAttribute);F.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=$e.meshPerAttribute*$e.count)}else for(let _e=0;_e<Z.locationSize;_e++)S(Z.location+_e);n.bindBuffer(n.ARRAY_BUFFER,Fe);for(let _e=0;_e<Z.locationSize;_e++)A(Z.location+_e,ge/Z.locationSize,We,fe,ee*Ue,(De+ge/Z.locationSize*_e)*Ue,Ye)}else{if(ce.isInstancedBufferAttribute){for(let $e=0;$e<Z.locationSize;$e++)C(Z.location+$e,ce.meshPerAttribute);F.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=ce.meshPerAttribute*ce.count)}else for(let $e=0;$e<Z.locationSize;$e++)S(Z.location+$e);n.bindBuffer(n.ARRAY_BUFFER,Fe);for(let $e=0;$e<Z.locationSize;$e++)A(Z.location+$e,ge/Z.locationSize,We,fe,ge*Ue,ge/Z.locationSize*$e*Ue,Ye)}}else if(j!==void 0){const fe=j[z];if(fe!==void 0)switch(fe.length){case 2:n.vertexAttrib2fv(Z.location,fe);break;case 3:n.vertexAttrib3fv(Z.location,fe);break;case 4:n.vertexAttrib4fv(Z.location,fe);break;default:n.vertexAttrib1fv(Z.location,fe)}}}}_()}function E(){V();for(const F in a){const $=a[F];for(const J in $){const q=$[J];for(const O in q)f(q[O].object),delete q[O];delete $[J]}delete a[F]}}function k(F){if(a[F.id]===void 0)return;const $=a[F.id];for(const J in $){const q=$[J];for(const O in q)f(q[O].object),delete q[O];delete $[J]}delete a[F.id]}function P(F){for(const $ in a){const J=a[$];if(J[F.id]===void 0)continue;const q=J[F.id];for(const O in q)f(q[O].object),delete q[O];delete J[F.id]}}function V(){U(),c=!0,u!==l&&(u=l,p(u.object))}function U(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:V,resetDefaultState:U,dispose:E,releaseStatesOfGeometry:k,releaseStatesOfProgram:P,initAttributes:w,enableAttribute:S,disableUnusedAttributes:_}}function x2e(n,e,t,i){const r=i.isWebGL2;let s;function o(u){s=u}function a(u,c){n.drawArrays(s,u,c),t.update(c,s,1)}function l(u,c,h){if(h===0)return;let d,p;if(r)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](s,u,c,h),t.update(c,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function v2e(n,e,t){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const A=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function s(A){if(A==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";A="mediump"}return A==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const u=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),d=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),f=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),g=n.getParameter(n.MAX_VERTEX_ATTRIBS),y=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),m=n.getParameter(n.MAX_VARYING_VECTORS),v=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),w=d>0,S=o||e.has("OES_texture_float"),C=w&&S,_=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:u,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:g,maxVertexUniforms:y,maxVaryings:m,maxFragmentUniforms:v,vertexTextures:w,floatFragmentTextures:S,floatVertexTextures:C,maxSamples:_}}function w2e(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new uc,a=new hn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d){const p=h.length!==0||d||i!==0||r;return r=d,i=h.length,p},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(h,d){t=c(h,d,0)},this.setState=function(h,d,p){const f=h.clippingPlanes,g=h.clipIntersection,y=h.clipShadows,m=n.get(h);if(!r||f===null||f.length===0||s&&!y)s?c(null):u();else{const v=s?0:i,w=v*4;let S=m.clippingState||null;l.value=S,S=c(f,d,w,p);for(let C=0;C!==w;++C)S[C]=t[C];m.clippingState=S,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=v}};function u(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function c(h,d,p,f){const g=h!==null?h.length:0;let y=null;if(g!==0){if(y=l.value,f!==!0||y===null){const m=p+g*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(y===null||y.length<m)&&(y=new Float32Array(m));for(let w=0,S=p;w!==g;++w,S+=4)o.copy(h[w]).applyMatrix4(v,a),o.normal.toArray(y,S),y[S+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,y}}function S2e(n){let e=new WeakMap;function t(o,a){return a===Wv?o.mapping=Dc:a===Hv&&(o.mapping=md),o}function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Wv||a===Hv)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const u=new Tq(l.height/2);return u.fromEquirectangularTexture(n,o),e.set(o,u),o.addEventListener("dispose",r),t(u.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}class Al extends H1{constructor(e=-1,t=1,i=1,r=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-e,o=i+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=u*this.view.offsetX,o=s+u*this.view.width,a-=c*this.view.offsetY,l=a-c*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Wg=4,o5=[.125,.215,.35,.446,.526,.582],Rp=20,sL=new Al,a5=new lt;let oL=null,aL=0,lL=0;const Ap=(1+Math.sqrt(5))/2,ag=1/Ap,l5=[new Y(1,1,1),new Y(-1,1,1),new Y(1,1,-1),new Y(-1,1,-1),new Y(0,Ap,ag),new Y(0,Ap,-ag),new Y(ag,0,Ap),new Y(-ag,0,Ap),new Y(Ap,ag,0),new Y(-Ap,ag,0)];class P3{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){oL=this._renderer.getRenderTarget(),aL=this._renderer.getActiveCubeFace(),lL=this._renderer.getActiveMipmapLevel(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,i,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=h5(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=c5(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(oL,aL,lL),e.scissorTest=!1,_C(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Dc||e.mapping===md?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),oL=this._renderer.getRenderTarget(),aL=this._renderer.getActiveCubeFace(),lL=this._renderer.getActiveMipmapLevel();const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:Zn,minFilter:Zn,generateMipmaps:!1,type:Cf,format:xo,colorSpace:Zr,depthBuffer:!1},r=u5(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=u5(e,t,i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=T2e(s)),this._blurMaterial=C2e(s,e,t)}return r}_compileMaterial(e){const t=new pr(this._lodPlanes[0],e);this._renderer.compile(t,sL)}_sceneToCubeUV(e,t,i,r){const a=new ci(90,1,t,i),l=[1,-1,1,1,1,1],u=[1,1,1,-1,-1,-1],c=this._renderer,h=c.autoClear,d=c.toneMapping;c.getClearColor(a5),c.toneMapping=Au,c.autoClear=!1;const p=new dr({name:"PMREM.Background",side:Ys,depthWrite:!1,depthTest:!1}),f=new pr(new om,p);let g=!1;const y=e.background;y?y.isColor&&(p.color.copy(y),e.background=null,g=!0):(p.color.copy(a5),g=!0);for(let m=0;m<6;m++){const v=m%3;v===0?(a.up.set(0,l[m],0),a.lookAt(u[m],0,0)):v===1?(a.up.set(0,0,l[m]),a.lookAt(0,u[m],0)):(a.up.set(0,l[m],0),a.lookAt(0,0,u[m]));const w=this._cubeSize;_C(r,v*w,m>2?w:0,w,w),c.setRenderTarget(r),g&&c.render(f,a),c.render(e,a)}f.geometry.dispose(),f.material.dispose(),c.toneMapping=d,c.autoClear=h,e.background=y}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===Dc||e.mapping===md;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=h5()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=c5());const s=r?this._cubemapMaterial:this._equirectMaterial,o=new pr(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;_C(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,sL)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const s=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),o=l5[(r-1)%l5.length];this._blur(e,r-1,r,s,o)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,u=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,h=new pr(this._lodPlanes[r],u),d=u.uniforms,p=this._sizeLods[i]-1,f=isFinite(s)?Math.PI/(2*p):2*Math.PI/(2*Rp-1),g=s/f,y=isFinite(s)?1+Math.floor(c*g):Rp;y>Rp&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Rp}`);const m=[];let v=0;for(let A=0;A<Rp;++A){const I=A/g,E=Math.exp(-I*I/2);m.push(E),A===0?v+=E:A<y&&(v+=2*E)}for(let A=0;A<m.length;A++)m[A]=m[A]/v;d.envMap.value=e.texture,d.samples.value=y,d.weights.value=m,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:w}=this;d.dTheta.value=f,d.mipInt.value=w-i;const S=this._sizeLods[r],C=3*S*(r>w-Wg?r-w+Wg:0),_=4*(this._cubeSize-S);_C(t,C,_,3*S,2*S),l.setRenderTarget(t),l.render(h,sL)}}function T2e(n){const e=[],t=[],i=[];let r=n;const s=n-Wg+1+o5.length;for(let o=0;o<s;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-Wg?l=o5[o-n+Wg-1]:o===0&&(l=0),i.push(l);const u=1/(a-2),c=-u,h=1+u,d=[c,c,h,c,h,h,c,c,h,h,c,h],p=6,f=6,g=3,y=2,m=1,v=new Float32Array(g*f*p),w=new Float32Array(y*f*p),S=new Float32Array(m*f*p);for(let _=0;_<p;_++){const A=_%3*2/3-1,I=_>2?0:-1,E=[A,I,0,A+2/3,I,0,A+2/3,I+1,0,A,I,0,A+2/3,I+1,0,A,I+1,0];v.set(E,g*f*_),w.set(d,y*f*_);const k=[_,_,_,_,_,_];S.set(k,m*f*_)}const C=new rn;C.setAttribute("position",new En(v,g)),C.setAttribute("uv",new En(w,y)),C.setAttribute("faceIndex",new En(S,m)),e.push(C),r>Wg&&r--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function u5(n,e,t){const i=new el(n,e,t);return i.texture.mapping=qy,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function _C(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function C2e(n,e,t){const i=new Float32Array(Rp),r=new Y(0,1,0);return new Du({name:"SphericalGaussianBlur",defines:{n:Rp,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:ez(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Ac,depthTest:!1,depthWrite:!1})}function c5(){return new Du({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:ez(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Ac,depthTest:!1,depthWrite:!1})}function h5(){return new Du({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:ez(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Ac,depthTest:!1,depthWrite:!1})}function ez(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function _2e(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,u=l===Wv||l===Hv,c=l===Dc||l===md;if(u||c)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new P3(n)),h=u?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(u&&h&&h.height>0||c&&h&&r(h)){t===null&&(t=new P3(n));const d=u?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function r(a){let l=0;const u=6;for(let c=0;c<u;c++)a[c]!==void 0&&l++;return l===u}function s(a){const l=a.target;l.removeEventListener("dispose",s);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function M2e(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(i){const r=t(i);return r===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function A2e(n,e,t,i){const r={},s=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const f in d.attributes)e.remove(d.attributes[f]);for(const f in d.morphAttributes){const g=d.morphAttributes[f];for(let y=0,m=g.length;y<m;y++)e.remove(g[y])}d.removeEventListener("dispose",o),delete r[d.id];const p=s.get(d);p&&(e.remove(p),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const f in d)e.update(d[f],n.ARRAY_BUFFER);const p=h.morphAttributes;for(const f in p){const g=p[f];for(let y=0,m=g.length;y<m;y++)e.update(g[y],n.ARRAY_BUFFER)}}function u(h){const d=[],p=h.index,f=h.attributes.position;let g=0;if(p!==null){const v=p.array;g=p.version;for(let w=0,S=v.length;w<S;w+=3){const C=v[w+0],_=v[w+1],A=v[w+2];d.push(C,_,_,A,A,C)}}else if(f!==void 0){const v=f.array;g=f.version;for(let w=0,S=v.length/3-1;w<S;w+=3){const C=w+0,_=w+1,A=w+2;d.push(C,_,_,A,A,C)}}else return;const y=new(gq(d)?qB:QB)(d,1);y.version=g;const m=s.get(h);m&&e.remove(m),s.set(h,y)}function c(h){const d=s.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&u(h)}else u(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:c}}function E2e(n,e,t,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function u(d){a=d.type,l=d.bytesPerElement}function c(d,p){n.drawElements(s,p,a,d*l),t.update(p,s,1)}function h(d,p,f){if(f===0)return;let g,y;if(r)g=n,y="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[y](s,p,a,d*l,f),t.update(p,s,f)}this.setMode=o,this.setIndex=u,this.render=c,this.renderInstances=h}function I2e(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(s/3);break;case n.LINES:t.lines+=a*(s/2);break;case n.LINE_STRIP:t.lines+=a*(s-1);break;case n.LINE_LOOP:t.lines+=a*s;break;case n.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}function k2e(n,e){return n[0]-e[0]}function R2e(n,e){return Math.abs(e[1])-Math.abs(n[1])}function N2e(n,e,t){const i={},r=new Float32Array(8),s=new WeakMap,o=new Gn,a=[];for(let u=0;u<8;u++)a[u]=[u,0];function l(u,c,h){const d=u.morphTargetInfluences;if(e.isWebGL2===!0){const f=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,g=f!==void 0?f.length:0;let y=s.get(c);if(y===void 0||y.count!==g){let $=function(){U.dispose(),s.delete(c),c.removeEventListener("dispose",$)};var p=$;y!==void 0&&y.texture.dispose();const w=c.morphAttributes.position!==void 0,S=c.morphAttributes.normal!==void 0,C=c.morphAttributes.color!==void 0,_=c.morphAttributes.position||[],A=c.morphAttributes.normal||[],I=c.morphAttributes.color||[];let E=0;w===!0&&(E=1),S===!0&&(E=2),C===!0&&(E=3);let k=c.attributes.position.count*E,P=1;k>e.maxTextureSize&&(P=Math.ceil(k/e.maxTextureSize),k=e.maxTextureSize);const V=new Float32Array(k*P*4*g),U=new AE(V,k,P,g);U.type=Ml,U.needsUpdate=!0;const F=E*4;for(let J=0;J<g;J++){const q=_[J],O=A[J],X=I[J],j=k*P*4*J;for(let z=0;z<q.count;z++){const Z=z*F;w===!0&&(o.fromBufferAttribute(q,z),V[j+Z+0]=o.x,V[j+Z+1]=o.y,V[j+Z+2]=o.z,V[j+Z+3]=0),S===!0&&(o.fromBufferAttribute(O,z),V[j+Z+4]=o.x,V[j+Z+5]=o.y,V[j+Z+6]=o.z,V[j+Z+7]=0),C===!0&&(o.fromBufferAttribute(X,z),V[j+Z+8]=o.x,V[j+Z+9]=o.y,V[j+Z+10]=o.z,V[j+Z+11]=X.itemSize===4?o.w:1)}}y={count:g,texture:U,size:new Ge(k,P)},s.set(c,y),c.addEventListener("dispose",$)}let m=0;for(let w=0;w<d.length;w++)m+=d[w];const v=c.morphTargetsRelative?1:1-m;h.getUniforms().setValue(n,"morphTargetBaseInfluence",v),h.getUniforms().setValue(n,"morphTargetInfluences",d),h.getUniforms().setValue(n,"morphTargetsTexture",y.texture,t),h.getUniforms().setValue(n,"morphTargetsTextureSize",y.size)}else{const f=d===void 0?0:d.length;let g=i[c.id];if(g===void 0||g.length!==f){g=[];for(let S=0;S<f;S++)g[S]=[S,0];i[c.id]=g}for(let S=0;S<f;S++){const C=g[S];C[0]=S,C[1]=d[S]}g.sort(R2e);for(let S=0;S<8;S++)S<f&&g[S][1]?(a[S][0]=g[S][0],a[S][1]=g[S][1]):(a[S][0]=Number.MAX_SAFE_INTEGER,a[S][1]=0);a.sort(k2e);const y=c.morphAttributes.position,m=c.morphAttributes.normal;let v=0;for(let S=0;S<8;S++){const C=a[S],_=C[0],A=C[1];_!==Number.MAX_SAFE_INTEGER&&A?(y&&c.getAttribute("morphTarget"+S)!==y[_]&&c.setAttribute("morphTarget"+S,y[_]),m&&c.getAttribute("morphNormal"+S)!==m[_]&&c.setAttribute("morphNormal"+S,m[_]),r[S]=A,v+=A):(y&&c.hasAttribute("morphTarget"+S)===!0&&c.deleteAttribute("morphTarget"+S),m&&c.hasAttribute("morphNormal"+S)===!0&&c.deleteAttribute("morphNormal"+S),r[S]=0)}const w=c.morphTargetsRelative?1:1-v;h.getUniforms().setValue(n,"morphTargetBaseInfluence",w),h.getUniforms().setValue(n,"morphTargetInfluences",r)}}return{update:l}}function L2e(n,e,t,i){let r=new WeakMap;function s(l){const u=i.render.frame,c=l.geometry,h=e.get(l,c);if(r.get(h)!==u&&(e.update(h),r.set(h,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),r.get(l)!==u&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),r.set(l,u))),l.isSkinnedMesh){const d=l.skeleton;r.get(d)!==u&&(d.update(),r.set(d,u))}return h}function o(){r=new WeakMap}function a(l){const u=l.target;u.removeEventListener("dispose",a),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:s,dispose:o}}const _q=new ni,Mq=new AE,Aq=new JB,Eq=new X1,d5=[],p5=[],f5=new Float32Array(16),m5=new Float32Array(9),g5=new Float32Array(4);function t0(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=d5[r];if(s===void 0&&(s=new Float32Array(r),d5[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function Mr(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function Ar(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function IE(n,e){let t=p5[e];t===void 0&&(t=new Int32Array(e),p5[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function P2e(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function D2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Mr(t,e))return;n.uniform2fv(this.addr,e),Ar(t,e)}}function F2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Mr(t,e))return;n.uniform3fv(this.addr,e),Ar(t,e)}}function O2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Mr(t,e))return;n.uniform4fv(this.addr,e),Ar(t,e)}}function B2e(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Mr(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ar(t,e)}else{if(Mr(t,i))return;g5.set(i),n.uniformMatrix2fv(this.addr,!1,g5),Ar(t,i)}}function z2e(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Mr(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ar(t,e)}else{if(Mr(t,i))return;m5.set(i),n.uniformMatrix3fv(this.addr,!1,m5),Ar(t,i)}}function G2e(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Mr(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ar(t,e)}else{if(Mr(t,i))return;f5.set(i),n.uniformMatrix4fv(this.addr,!1,f5),Ar(t,i)}}function V2e(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function U2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Mr(t,e))return;n.uniform2iv(this.addr,e),Ar(t,e)}}function $2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Mr(t,e))return;n.uniform3iv(this.addr,e),Ar(t,e)}}function W2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Mr(t,e))return;n.uniform4iv(this.addr,e),Ar(t,e)}}function H2e(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function X2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Mr(t,e))return;n.uniform2uiv(this.addr,e),Ar(t,e)}}function K2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Mr(t,e))return;n.uniform3uiv(this.addr,e),Ar(t,e)}}function Z2e(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Mr(t,e))return;n.uniform4uiv(this.addr,e),Ar(t,e)}}function j2e(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2D(e||_q,r)}function Y2e(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||Aq,r)}function J2e(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTextureCube(e||Eq,r)}function Q2e(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||Mq,r)}function q2e(n){switch(n){case 5126:return P2e;case 35664:return D2e;case 35665:return F2e;case 35666:return O2e;case 35674:return B2e;case 35675:return z2e;case 35676:return G2e;case 5124:case 35670:return V2e;case 35667:case 35671:return U2e;case 35668:case 35672:return $2e;case 35669:case 35673:return W2e;case 5125:return H2e;case 36294:return X2e;case 36295:return K2e;case 36296:return Z2e;case 35678:case 36198:case 36298:case 36306:case 35682:return j2e;case 35679:case 36299:case 36307:return Y2e;case 35680:case 36300:case 36308:case 36293:return J2e;case 36289:case 36303:case 36311:case 36292:return Q2e}}function eIe(n,e){n.uniform1fv(this.addr,e)}function tIe(n,e){const t=t0(e,this.size,2);n.uniform2fv(this.addr,t)}function nIe(n,e){const t=t0(e,this.size,3);n.uniform3fv(this.addr,t)}function iIe(n,e){const t=t0(e,this.size,4);n.uniform4fv(this.addr,t)}function rIe(n,e){const t=t0(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function sIe(n,e){const t=t0(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function oIe(n,e){const t=t0(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function aIe(n,e){n.uniform1iv(this.addr,e)}function lIe(n,e){n.uniform2iv(this.addr,e)}function uIe(n,e){n.uniform3iv(this.addr,e)}function cIe(n,e){n.uniform4iv(this.addr,e)}function hIe(n,e){n.uniform1uiv(this.addr,e)}function dIe(n,e){n.uniform2uiv(this.addr,e)}function pIe(n,e){n.uniform3uiv(this.addr,e)}function fIe(n,e){n.uniform4uiv(this.addr,e)}function mIe(n,e,t){const i=this.cache,r=e.length,s=IE(t,r);Mr(i,s)||(n.uniform1iv(this.addr,s),Ar(i,s));for(let o=0;o!==r;++o)t.setTexture2D(e[o]||_q,s[o])}function gIe(n,e,t){const i=this.cache,r=e.length,s=IE(t,r);Mr(i,s)||(n.uniform1iv(this.addr,s),Ar(i,s));for(let o=0;o!==r;++o)t.setTexture3D(e[o]||Aq,s[o])}function yIe(n,e,t){const i=this.cache,r=e.length,s=IE(t,r);Mr(i,s)||(n.uniform1iv(this.addr,s),Ar(i,s));for(let o=0;o!==r;++o)t.setTextureCube(e[o]||Eq,s[o])}function bIe(n,e,t){const i=this.cache,r=e.length,s=IE(t,r);Mr(i,s)||(n.uniform1iv(this.addr,s),Ar(i,s));for(let o=0;o!==r;++o)t.setTexture2DArray(e[o]||Mq,s[o])}function xIe(n){switch(n){case 5126:return eIe;case 35664:return tIe;case 35665:return nIe;case 35666:return iIe;case 35674:return rIe;case 35675:return sIe;case 35676:return oIe;case 5124:case 35670:return aIe;case 35667:case 35671:return lIe;case 35668:case 35672:return uIe;case 35669:case 35673:return cIe;case 5125:return hIe;case 36294:return dIe;case 36295:return pIe;case 36296:return fIe;case 35678:case 36198:case 36298:case 36306:case 35682:return mIe;case 35679:case 36299:case 36307:return gIe;case 35680:case 36300:case 36308:case 36293:return yIe;case 36289:case 36303:case 36311:case 36292:return bIe}}class vIe{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.setValue=q2e(t.type)}}class wIe{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.size=t.size,this.setValue=xIe(t.type)}}class SIe{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const r=this.seq;for(let s=0,o=r.length;s!==o;++s){const a=r[s];a.setValue(e,t[a.id],i)}}}const uL=/(\w+)(\])?(\[|\.)?/g;function y5(n,e){n.seq.push(e),n.map[e.id]=e}function TIe(n,e,t){const i=n.name,r=i.length;for(uL.lastIndex=0;;){const s=uL.exec(i),o=uL.lastIndex;let a=s[1];const l=s[2]==="]",u=s[3];if(l&&(a=a|0),u===void 0||u==="["&&o+2===r){y5(t,u===void 0?new vIe(a,n,e):new wIe(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new SIe(a),y5(t,h)),t=h}}}class H_{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<i;++r){const s=e.getActiveUniform(t,r),o=e.getUniformLocation(t,s.name);TIe(s,o,this)}}setValue(e,t,i,r){const s=this.map[t];s!==void 0&&s.setValue(e,i,r)}setOptional(e,t,i){const r=t[i];r!==void 0&&this.setValue(e,i,r)}static upload(e,t,i,r){for(let s=0,o=t.length;s!==o;++s){const a=t[s],l=i[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,r)}}static seqWithValue(e,t){const i=[];for(let r=0,s=e.length;r!==s;++r){const o=e[r];o.id in t&&i.push(o)}return i}}function b5(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}const CIe=37297;let _Ie=0;function MIe(n,e){const t=n.split(`
`),i=[],r=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=r;o<s;o++){const a=o+1;i.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return i.join(`
`)}function AIe(n){const e=Fn.getPrimaries(Fn.workingColorSpace),t=Fn.getPrimaries(n);let i;switch(e===t?i="":e===jv&&t===Zv?i="LinearDisplayP3ToLinearSRGB":e===Zv&&t===jv&&(i="LinearSRGBToLinearDisplayP3"),n){case Zr:case $1:return[i,"LinearTransferOETF"];case bi:case ME:return[i,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[i,"LinearTransferOETF"]}}function x5(n,e,t){const i=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+r+`

`+MIe(n.getShaderSource(e),o)}else return r}function EIe(n,e){const t=AIe(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function IIe(n,e){let t;switch(e){case VQ:t="Linear";break;case UQ:t="Reinhard";break;case $Q:t="OptimizedCineon";break;case zB:t="ACESFilmic";break;case WQ:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function kIe(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Dx).join(`
`)}function RIe(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function NIe(n,e){const t={},i=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const s=n.getActiveAttrib(e,r),o=s.name;let a=1;s.type===n.FLOAT_MAT2&&(a=2),s.type===n.FLOAT_MAT3&&(a=3),s.type===n.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Dx(n){return n!==""}function v5(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function w5(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const LIe=/^[ \t]*#include +<([\w\d./]+)>/gm;function D3(n){return n.replace(LIe,DIe)}const PIe=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function DIe(n,e){let t=on[e];if(t===void 0){const i=PIe.get(e);if(i!==void 0)t=on[i],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,i);else throw new Error("Can not resolve #include <"+e+">")}return D3(t)}const FIe=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function S5(n){return n.replace(FIe,OIe)}function OIe(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function T5(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function BIe(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===SE?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===uv?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===xl&&(e="SHADOWMAP_TYPE_VSM"),e}function zIe(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Dc:case md:e="ENVMAP_TYPE_CUBE";break;case qy:e="ENVMAP_TYPE_CUBE_UV";break}return e}function GIe(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case md:e="ENVMAP_MODE_REFRACTION";break}return e}function VIe(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case G1:e="ENVMAP_BLENDING_MULTIPLY";break;case zQ:e="ENVMAP_BLENDING_MIX";break;case GQ:e="ENVMAP_BLENDING_ADD";break}return e}function UIe(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}function $Ie(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=BIe(t),u=zIe(t),c=GIe(t),h=VIe(t),d=UIe(t),p=t.isWebGL2?"":kIe(t),f=RIe(s),g=r.createProgram();let y,m,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(Dx).join(`
`),y.length>0&&(y+=`
`),m=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(Dx).join(`
`),m.length>0&&(m+=`
`)):(y=[T5(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Dx).join(`
`),m=[p,T5(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Au?"#define TONE_MAPPING":"",t.toneMapping!==Au?on.tonemapping_pars_fragment:"",t.toneMapping!==Au?IIe("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",on.colorspace_pars_fragment,EIe("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Dx).join(`
`)),o=D3(o),o=v5(o,t),o=w5(o,t),a=D3(a),a=v5(a,t),a=w5(a,t),o=S5(o),a=S5(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,y=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,m=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===N3?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===N3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+m);const w=v+y+o,S=v+m+a,C=b5(r,r.VERTEX_SHADER,w),_=b5(r,r.FRAGMENT_SHADER,S);r.attachShader(g,C),r.attachShader(g,_),t.index0AttributeName!==void 0?r.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(g,0,"position"),r.linkProgram(g);function A(P){if(n.debug.checkShaderErrors){const V=r.getProgramInfoLog(g).trim(),U=r.getShaderInfoLog(C).trim(),F=r.getShaderInfoLog(_).trim();let $=!0,J=!0;if(r.getProgramParameter(g,r.LINK_STATUS)===!1)if($=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(r,g,C,_);else{const q=x5(r,C,"vertex"),O=x5(r,_,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(g,r.VALIDATE_STATUS)+`

Program Info Log: `+V+`
`+q+`
`+O)}else V!==""?console.warn("THREE.WebGLProgram: Program Info Log:",V):(U===""||F==="")&&(J=!1);J&&(P.diagnostics={runnable:$,programLog:V,vertexShader:{log:U,prefix:y},fragmentShader:{log:F,prefix:m}})}r.deleteShader(C),r.deleteShader(_),I=new H_(r,g),E=NIe(r,g)}let I;this.getUniforms=function(){return I===void 0&&A(this),I};let E;this.getAttributes=function(){return E===void 0&&A(this),E};let k=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return k===!1&&(k=r.getProgramParameter(g,CIe)),k},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=_Ie++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=C,this.fragmentShader=_,this}let WIe=0;class HIe{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let i=t.get(e);return i===void 0&&(i=new Set,t.set(e,i)),i}_getShaderStage(e){const t=this.shaderCache;let i=t.get(e);return i===void 0&&(i=new XIe(e),t.set(e,i)),i}}class XIe{constructor(e){this.id=WIe++,this.code=e,this.usedTimes=0}}function KIe(n,e,t,i,r,s,o){const a=new sf,l=new HIe,u=[],c=r.isWebGL2,h=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(E){return E===0?"uv":`uv${E}`}function y(E,k,P,V,U){const F=V.fog,$=U.geometry,J=E.isMeshStandardMaterial?V.environment:null,q=(E.isMeshStandardMaterial?t:e).get(E.envMap||J),O=q&&q.mapping===qy?q.image.height:null,X=f[E.type];E.precision!==null&&(p=r.getMaxPrecision(E.precision),p!==E.precision&&console.warn("THREE.WebGLProgram.getParameters:",E.precision,"not supported, using",p,"instead."));const j=$.morphAttributes.position||$.morphAttributes.normal||$.morphAttributes.color,z=j!==void 0?j.length:0;let Z=0;$.morphAttributes.position!==void 0&&(Z=1),$.morphAttributes.normal!==void 0&&(Z=2),$.morphAttributes.color!==void 0&&(Z=3);let ce,fe,ge,Ne;if(X){const ht=Tl[X];ce=ht.vertexShader,fe=ht.fragmentShader}else ce=E.vertexShader,fe=E.fragmentShader,l.update(E),ge=l.getVertexShaderID(E),Ne=l.getFragmentShaderID(E);const Fe=n.getRenderTarget(),We=U.isInstancedMesh===!0,Ue=!!E.map,Ye=!!E.matcap,$e=!!q,ee=!!E.aoMap,De=!!E.lightMap,_e=!!E.bumpMap,ze=!!E.normalMap,Re=!!E.displacementMap,nt=!!E.emissiveMap,Ze=!!E.metalnessMap,st=!!E.roughnessMap,yt=E.anisotropy>0,Lt=E.clearcoat>0,ye=E.iridescence>0,H=E.sheen>0,D=E.transmission>0,oe=yt&&!!E.anisotropyMap,Ie=Lt&&!!E.clearcoatMap,Me=Lt&&!!E.clearcoatNormalMap,Ve=Lt&&!!E.clearcoatRoughnessMap,ct=ye&&!!E.iridescenceMap,qe=ye&&!!E.iridescenceThicknessMap,at=H&&!!E.sheenColorMap,Ot=H&&!!E.sheenRoughnessMap,Xt=!!E.specularMap,Qe=!!E.specularColorMap,sn=!!E.specularIntensityMap,le=D&&!!E.transmissionMap,Oe=D&&!!E.thicknessMap,je=!!E.gradientMap,Ke=!!E.alphaMap,Pt=E.alphaTest>0,G=!!E.alphaHash,re=!!E.extensions,pe=!!$.attributes.uv1,de=!!$.attributes.uv2,Te=!!$.attributes.uv3;let Je=Au;return E.toneMapped&&(Fe===null||Fe.isXRRenderTarget===!0)&&(Je=n.toneMapping),{isWebGL2:c,shaderID:X,shaderType:E.type,shaderName:E.name,vertexShader:ce,fragmentShader:fe,defines:E.defines,customVertexShaderID:ge,customFragmentShaderID:Ne,isRawShaderMaterial:E.isRawShaderMaterial===!0,glslVersion:E.glslVersion,precision:p,instancing:We,instancingColor:We&&U.instanceColor!==null,supportsVertexTextures:d,outputColorSpace:Fe===null?n.outputColorSpace:Fe.isXRRenderTarget===!0?Fe.texture.colorSpace:Zr,map:Ue,matcap:Ye,envMap:$e,envMapMode:$e&&q.mapping,envMapCubeUVHeight:O,aoMap:ee,lightMap:De,bumpMap:_e,normalMap:ze,displacementMap:d&&Re,emissiveMap:nt,normalMapObjectSpace:ze&&E.normalMapType===oq,normalMapTangentSpace:ze&&E.normalMapType===Pd,metalnessMap:Ze,roughnessMap:st,anisotropy:yt,anisotropyMap:oe,clearcoat:Lt,clearcoatMap:Ie,clearcoatNormalMap:Me,clearcoatRoughnessMap:Ve,iridescence:ye,iridescenceMap:ct,iridescenceThicknessMap:qe,sheen:H,sheenColorMap:at,sheenRoughnessMap:Ot,specularMap:Xt,specularColorMap:Qe,specularIntensityMap:sn,transmission:D,transmissionMap:le,thicknessMap:Oe,gradientMap:je,opaque:E.transparent===!1&&E.blending===tf,alphaMap:Ke,alphaTest:Pt,alphaHash:G,combine:E.combine,mapUv:Ue&&g(E.map.channel),aoMapUv:ee&&g(E.aoMap.channel),lightMapUv:De&&g(E.lightMap.channel),bumpMapUv:_e&&g(E.bumpMap.channel),normalMapUv:ze&&g(E.normalMap.channel),displacementMapUv:Re&&g(E.displacementMap.channel),emissiveMapUv:nt&&g(E.emissiveMap.channel),metalnessMapUv:Ze&&g(E.metalnessMap.channel),roughnessMapUv:st&&g(E.roughnessMap.channel),anisotropyMapUv:oe&&g(E.anisotropyMap.channel),clearcoatMapUv:Ie&&g(E.clearcoatMap.channel),clearcoatNormalMapUv:Me&&g(E.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Ve&&g(E.clearcoatRoughnessMap.channel),iridescenceMapUv:ct&&g(E.iridescenceMap.channel),iridescenceThicknessMapUv:qe&&g(E.iridescenceThicknessMap.channel),sheenColorMapUv:at&&g(E.sheenColorMap.channel),sheenRoughnessMapUv:Ot&&g(E.sheenRoughnessMap.channel),specularMapUv:Xt&&g(E.specularMap.channel),specularColorMapUv:Qe&&g(E.specularColorMap.channel),specularIntensityMapUv:sn&&g(E.specularIntensityMap.channel),transmissionMapUv:le&&g(E.transmissionMap.channel),thicknessMapUv:Oe&&g(E.thicknessMap.channel),alphaMapUv:Ke&&g(E.alphaMap.channel),vertexTangents:!!$.attributes.tangent&&(ze||yt),vertexColors:E.vertexColors,vertexAlphas:E.vertexColors===!0&&!!$.attributes.color&&$.attributes.color.itemSize===4,vertexUv1s:pe,vertexUv2s:de,vertexUv3s:Te,pointsUvs:U.isPoints===!0&&!!$.attributes.uv&&(Ue||Ke),fog:!!F,useFog:E.fog===!0,fogExp2:F&&F.isFogExp2,flatShading:E.flatShading===!0,sizeAttenuation:E.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:U.isSkinnedMesh===!0,morphTargets:$.morphAttributes.position!==void 0,morphNormals:$.morphAttributes.normal!==void 0,morphColors:$.morphAttributes.color!==void 0,morphTargetsCount:z,morphTextureStride:Z,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numSpotLightMaps:k.spotLightMap.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numSpotLightShadowsWithMaps:k.numSpotLightShadowsWithMaps,numLightProbes:k.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:E.dithering,shadowMapEnabled:n.shadowMap.enabled&&P.length>0,shadowMapType:n.shadowMap.type,toneMapping:Je,useLegacyLights:n._useLegacyLights,decodeVideoTexture:Ue&&E.map.isVideoTexture===!0&&Fn.getTransfer(E.map.colorSpace)===Qn,premultipliedAlpha:E.premultipliedAlpha,doubleSided:E.side===$a,flipSided:E.side===Ys,useDepthPacking:E.depthPacking>=0,depthPacking:E.depthPacking||0,index0AttributeName:E.index0AttributeName,extensionDerivatives:re&&E.extensions.derivatives===!0,extensionFragDepth:re&&E.extensions.fragDepth===!0,extensionDrawBuffers:re&&E.extensions.drawBuffers===!0,extensionShaderTextureLOD:re&&E.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:c||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||i.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:E.customProgramCacheKey()}}function m(E){const k=[];if(E.shaderID?k.push(E.shaderID):(k.push(E.customVertexShaderID),k.push(E.customFragmentShaderID)),E.defines!==void 0)for(const P in E.defines)k.push(P),k.push(E.defines[P]);return E.isRawShaderMaterial===!1&&(v(k,E),w(k,E),k.push(n.outputColorSpace)),k.push(E.customProgramCacheKey),k.join()}function v(E,k){E.push(k.precision),E.push(k.outputColorSpace),E.push(k.envMapMode),E.push(k.envMapCubeUVHeight),E.push(k.mapUv),E.push(k.alphaMapUv),E.push(k.lightMapUv),E.push(k.aoMapUv),E.push(k.bumpMapUv),E.push(k.normalMapUv),E.push(k.displacementMapUv),E.push(k.emissiveMapUv),E.push(k.metalnessMapUv),E.push(k.roughnessMapUv),E.push(k.anisotropyMapUv),E.push(k.clearcoatMapUv),E.push(k.clearcoatNormalMapUv),E.push(k.clearcoatRoughnessMapUv),E.push(k.iridescenceMapUv),E.push(k.iridescenceThicknessMapUv),E.push(k.sheenColorMapUv),E.push(k.sheenRoughnessMapUv),E.push(k.specularMapUv),E.push(k.specularColorMapUv),E.push(k.specularIntensityMapUv),E.push(k.transmissionMapUv),E.push(k.thicknessMapUv),E.push(k.combine),E.push(k.fogExp2),E.push(k.sizeAttenuation),E.push(k.morphTargetsCount),E.push(k.morphAttributeCount),E.push(k.numDirLights),E.push(k.numPointLights),E.push(k.numSpotLights),E.push(k.numSpotLightMaps),E.push(k.numHemiLights),E.push(k.numRectAreaLights),E.push(k.numDirLightShadows),E.push(k.numPointLightShadows),E.push(k.numSpotLightShadows),E.push(k.numSpotLightShadowsWithMaps),E.push(k.numLightProbes),E.push(k.shadowMapType),E.push(k.toneMapping),E.push(k.numClippingPlanes),E.push(k.numClipIntersection),E.push(k.depthPacking)}function w(E,k){a.disableAll(),k.isWebGL2&&a.enable(0),k.supportsVertexTextures&&a.enable(1),k.instancing&&a.enable(2),k.instancingColor&&a.enable(3),k.matcap&&a.enable(4),k.envMap&&a.enable(5),k.normalMapObjectSpace&&a.enable(6),k.normalMapTangentSpace&&a.enable(7),k.clearcoat&&a.enable(8),k.iridescence&&a.enable(9),k.alphaTest&&a.enable(10),k.vertexColors&&a.enable(11),k.vertexAlphas&&a.enable(12),k.vertexUv1s&&a.enable(13),k.vertexUv2s&&a.enable(14),k.vertexUv3s&&a.enable(15),k.vertexTangents&&a.enable(16),k.anisotropy&&a.enable(17),k.alphaHash&&a.enable(18),E.push(a.mask),a.disableAll(),k.fog&&a.enable(0),k.useFog&&a.enable(1),k.flatShading&&a.enable(2),k.logarithmicDepthBuffer&&a.enable(3),k.skinning&&a.enable(4),k.morphTargets&&a.enable(5),k.morphNormals&&a.enable(6),k.morphColors&&a.enable(7),k.premultipliedAlpha&&a.enable(8),k.shadowMapEnabled&&a.enable(9),k.useLegacyLights&&a.enable(10),k.doubleSided&&a.enable(11),k.flipSided&&a.enable(12),k.useDepthPacking&&a.enable(13),k.dithering&&a.enable(14),k.transmission&&a.enable(15),k.sheen&&a.enable(16),k.opaque&&a.enable(17),k.pointsUvs&&a.enable(18),k.decodeVideoTexture&&a.enable(19),E.push(a.mask)}function S(E){const k=f[E.type];let P;if(k){const V=Tl[k];P=wq.clone(V.uniforms)}else P=E.uniforms;return P}function C(E,k){let P;for(let V=0,U=u.length;V<U;V++){const F=u[V];if(F.cacheKey===k){P=F,++P.usedTimes;break}}return P===void 0&&(P=new $Ie(n,k,E,s),u.push(P)),P}function _(E){if(--E.usedTimes===0){const k=u.indexOf(E);u[k]=u[u.length-1],u.pop(),E.destroy()}}function A(E){l.remove(E)}function I(){l.dispose()}return{getParameters:y,getProgramCacheKey:m,getUniforms:S,acquireProgram:C,releaseProgram:_,releaseShaderCache:A,programs:u,dispose:I}}function ZIe(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function i(s,o,a){n.get(s)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:i,dispose:r}}function jIe(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function C5(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function _5(){const n=[];let e=0;const t=[],i=[],r=[];function s(){e=0,t.length=0,i.length=0,r.length=0}function o(h,d,p,f,g,y){let m=n[e];return m===void 0?(m={id:h.id,object:h,geometry:d,material:p,groupOrder:f,renderOrder:h.renderOrder,z:g,group:y},n[e]=m):(m.id=h.id,m.object=h,m.geometry=d,m.material=p,m.groupOrder=f,m.renderOrder=h.renderOrder,m.z=g,m.group=y),e++,m}function a(h,d,p,f,g,y){const m=o(h,d,p,f,g,y);p.transmission>0?i.push(m):p.transparent===!0?r.push(m):t.push(m)}function l(h,d,p,f,g,y){const m=o(h,d,p,f,g,y);p.transmission>0?i.unshift(m):p.transparent===!0?r.unshift(m):t.unshift(m)}function u(h,d){t.length>1&&t.sort(h||jIe),i.length>1&&i.sort(d||C5),r.length>1&&r.sort(d||C5)}function c(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:i,transparent:r,init:s,push:a,unshift:l,finish:c,sort:u}}function YIe(){let n=new WeakMap;function e(i,r){const s=n.get(i);let o;return s===void 0?(o=new _5,n.set(i,[o])):r>=s.length?(o=new _5,s.push(o)):o=s[r],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function JIe(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Y,color:new lt};break;case"SpotLight":t={position:new Y,direction:new Y,color:new lt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Y,color:new lt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Y,skyColor:new lt,groundColor:new lt};break;case"RectAreaLight":t={color:new lt,position:new Y,halfWidth:new Y,halfHeight:new Y};break}return n[e.id]=t,t}}}function QIe(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ge};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ge};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ge,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let qIe=0;function eke(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function tke(n,e){const t=new JIe,i=QIe(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)r.probe.push(new Y);const s=new Y,o=new Ft,a=new Ft;function l(c,h){let d=0,p=0,f=0;for(let V=0;V<9;V++)r.probe[V].set(0,0,0);let g=0,y=0,m=0,v=0,w=0,S=0,C=0,_=0,A=0,I=0,E=0;c.sort(eke);const k=h===!0?Math.PI:1;for(let V=0,U=c.length;V<U;V++){const F=c[V],$=F.color,J=F.intensity,q=F.distance,O=F.shadow&&F.shadow.map?F.shadow.map.texture:null;if(F.isAmbientLight)d+=$.r*J*k,p+=$.g*J*k,f+=$.b*J*k;else if(F.isLightProbe){for(let X=0;X<9;X++)r.probe[X].addScaledVector(F.sh.coefficients[X],J);E++}else if(F.isDirectionalLight){const X=t.get(F);if(X.color.copy(F.color).multiplyScalar(F.intensity*k),F.castShadow){const j=F.shadow,z=i.get(F);z.shadowBias=j.bias,z.shadowNormalBias=j.normalBias,z.shadowRadius=j.radius,z.shadowMapSize=j.mapSize,r.directionalShadow[g]=z,r.directionalShadowMap[g]=O,r.directionalShadowMatrix[g]=F.shadow.matrix,S++}r.directional[g]=X,g++}else if(F.isSpotLight){const X=t.get(F);X.position.setFromMatrixPosition(F.matrixWorld),X.color.copy($).multiplyScalar(J*k),X.distance=q,X.coneCos=Math.cos(F.angle),X.penumbraCos=Math.cos(F.angle*(1-F.penumbra)),X.decay=F.decay,r.spot[m]=X;const j=F.shadow;if(F.map&&(r.spotLightMap[A]=F.map,A++,j.updateMatrices(F),F.castShadow&&I++),r.spotLightMatrix[m]=j.matrix,F.castShadow){const z=i.get(F);z.shadowBias=j.bias,z.shadowNormalBias=j.normalBias,z.shadowRadius=j.radius,z.shadowMapSize=j.mapSize,r.spotShadow[m]=z,r.spotShadowMap[m]=O,_++}m++}else if(F.isRectAreaLight){const X=t.get(F);X.color.copy($).multiplyScalar(J),X.halfWidth.set(F.width*.5,0,0),X.halfHeight.set(0,F.height*.5,0),r.rectArea[v]=X,v++}else if(F.isPointLight){const X=t.get(F);if(X.color.copy(F.color).multiplyScalar(F.intensity*k),X.distance=F.distance,X.decay=F.decay,F.castShadow){const j=F.shadow,z=i.get(F);z.shadowBias=j.bias,z.shadowNormalBias=j.normalBias,z.shadowRadius=j.radius,z.shadowMapSize=j.mapSize,z.shadowCameraNear=j.camera.near,z.shadowCameraFar=j.camera.far,r.pointShadow[y]=z,r.pointShadowMap[y]=O,r.pointShadowMatrix[y]=F.shadow.matrix,C++}r.point[y]=X,y++}else if(F.isHemisphereLight){const X=t.get(F);X.skyColor.copy(F.color).multiplyScalar(J*k),X.groundColor.copy(F.groundColor).multiplyScalar(J*k),r.hemi[w]=X,w++}}v>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=dt.LTC_FLOAT_1,r.rectAreaLTC2=dt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=dt.LTC_HALF_1,r.rectAreaLTC2=dt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=p,r.ambient[2]=f;const P=r.hash;(P.directionalLength!==g||P.pointLength!==y||P.spotLength!==m||P.rectAreaLength!==v||P.hemiLength!==w||P.numDirectionalShadows!==S||P.numPointShadows!==C||P.numSpotShadows!==_||P.numSpotMaps!==A||P.numLightProbes!==E)&&(r.directional.length=g,r.spot.length=m,r.rectArea.length=v,r.point.length=y,r.hemi.length=w,r.directionalShadow.length=S,r.directionalShadowMap.length=S,r.pointShadow.length=C,r.pointShadowMap.length=C,r.spotShadow.length=_,r.spotShadowMap.length=_,r.directionalShadowMatrix.length=S,r.pointShadowMatrix.length=C,r.spotLightMatrix.length=_+A-I,r.spotLightMap.length=A,r.numSpotLightShadowsWithMaps=I,r.numLightProbes=E,P.directionalLength=g,P.pointLength=y,P.spotLength=m,P.rectAreaLength=v,P.hemiLength=w,P.numDirectionalShadows=S,P.numPointShadows=C,P.numSpotShadows=_,P.numSpotMaps=A,P.numLightProbes=E,r.version=qIe++)}function u(c,h){let d=0,p=0,f=0,g=0,y=0;const m=h.matrixWorldInverse;for(let v=0,w=c.length;v<w;v++){const S=c[v];if(S.isDirectionalLight){const C=r.directional[d];C.direction.setFromMatrixPosition(S.matrixWorld),s.setFromMatrixPosition(S.target.matrixWorld),C.direction.sub(s),C.direction.transformDirection(m),d++}else if(S.isSpotLight){const C=r.spot[f];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(m),C.direction.setFromMatrixPosition(S.matrixWorld),s.setFromMatrixPosition(S.target.matrixWorld),C.direction.sub(s),C.direction.transformDirection(m),f++}else if(S.isRectAreaLight){const C=r.rectArea[g];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(m),a.identity(),o.copy(S.matrixWorld),o.premultiply(m),a.extractRotation(o),C.halfWidth.set(S.width*.5,0,0),C.halfHeight.set(0,S.height*.5,0),C.halfWidth.applyMatrix4(a),C.halfHeight.applyMatrix4(a),g++}else if(S.isPointLight){const C=r.point[p];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(m),p++}else if(S.isHemisphereLight){const C=r.hemi[y];C.direction.setFromMatrixPosition(S.matrixWorld),C.direction.transformDirection(m),y++}}}return{setup:l,setupView:u,state:r}}function M5(n,e){const t=new tke(n,e),i=[],r=[];function s(){i.length=0,r.length=0}function o(h){i.push(h)}function a(h){r.push(h)}function l(h){t.setup(i,h)}function u(h){t.setupView(i,h)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:t},setupLights:l,setupLightsView:u,pushLight:o,pushShadow:a}}function nke(n,e){let t=new WeakMap;function i(s,o=0){const a=t.get(s);let l;return a===void 0?(l=new M5(n,e),t.set(s,[l])):o>=a.length?(l=new M5(n,e),a.push(l)):l=a[o],l}function r(){t=new WeakMap}return{get:i,dispose:r}}class tz extends Pi{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=rq,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class nz extends Pi{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const ike=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,rke=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function ske(n,e,t){let i=new EE;const r=new Ge,s=new Ge,o=new Gn,a=new tz({depthPacking:sq}),l=new nz,u={},c=t.maxTextureSize,h={[Vl]:Ys,[Ys]:Vl,[$a]:$a},d=new Du({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ge},radius:{value:4}},vertexShader:ike,fragmentShader:rke}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new rn;f.setAttribute("position",new En(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new pr(f,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=SE;let m=this.type;this.render=function(C,_,A){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||C.length===0)return;const I=n.getRenderTarget(),E=n.getActiveCubeFace(),k=n.getActiveMipmapLevel(),P=n.state;P.setBlending(Ac),P.buffers.color.setClear(1,1,1,1),P.buffers.depth.setTest(!0),P.setScissorTest(!1);const V=m!==xl&&this.type===xl,U=m===xl&&this.type!==xl;for(let F=0,$=C.length;F<$;F++){const J=C[F],q=J.shadow;if(q===void 0){console.warn("THREE.WebGLShadowMap:",J,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;r.copy(q.mapSize);const O=q.getFrameExtents();if(r.multiply(O),s.copy(q.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(s.x=Math.floor(c/O.x),r.x=s.x*O.x,q.mapSize.x=s.x),r.y>c&&(s.y=Math.floor(c/O.y),r.y=s.y*O.y,q.mapSize.y=s.y)),q.map===null||V===!0||U===!0){const j=this.type!==xl?{minFilter:Ei,magFilter:Ei}:{};q.map!==null&&q.map.dispose(),q.map=new el(r.x,r.y,j),q.map.texture.name=J.name+".shadowMap",q.camera.updateProjectionMatrix()}n.setRenderTarget(q.map),n.clear();const X=q.getViewportCount();for(let j=0;j<X;j++){const z=q.getViewport(j);o.set(s.x*z.x,s.y*z.y,s.x*z.z,s.y*z.w),P.viewport(o),q.updateMatrices(J,j),i=q.getFrustum(),S(_,A,q.camera,J,this.type)}q.isPointLightShadow!==!0&&this.type===xl&&v(q,A),q.needsUpdate=!1}m=this.type,y.needsUpdate=!1,n.setRenderTarget(I,E,k)};function v(C,_){const A=e.update(g);d.defines.VSM_SAMPLES!==C.blurSamples&&(d.defines.VSM_SAMPLES=C.blurSamples,p.defines.VSM_SAMPLES=C.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),C.mapPass===null&&(C.mapPass=new el(r.x,r.y)),d.uniforms.shadow_pass.value=C.map.texture,d.uniforms.resolution.value=C.mapSize,d.uniforms.radius.value=C.radius,n.setRenderTarget(C.mapPass),n.clear(),n.renderBufferDirect(_,null,A,d,g,null),p.uniforms.shadow_pass.value=C.mapPass.texture,p.uniforms.resolution.value=C.mapSize,p.uniforms.radius.value=C.radius,n.setRenderTarget(C.map),n.clear(),n.renderBufferDirect(_,null,A,p,g,null)}function w(C,_,A,I){let E=null;const k=A.isPointLight===!0?C.customDistanceMaterial:C.customDepthMaterial;if(k!==void 0)E=k;else if(E=A.isPointLight===!0?l:a,n.localClippingEnabled&&_.clipShadows===!0&&Array.isArray(_.clippingPlanes)&&_.clippingPlanes.length!==0||_.displacementMap&&_.displacementScale!==0||_.alphaMap&&_.alphaTest>0||_.map&&_.alphaTest>0){const P=E.uuid,V=_.uuid;let U=u[P];U===void 0&&(U={},u[P]=U);let F=U[V];F===void 0&&(F=E.clone(),U[V]=F),E=F}if(E.visible=_.visible,E.wireframe=_.wireframe,I===xl?E.side=_.shadowSide!==null?_.shadowSide:_.side:E.side=_.shadowSide!==null?_.shadowSide:h[_.side],E.alphaMap=_.alphaMap,E.alphaTest=_.alphaTest,E.map=_.map,E.clipShadows=_.clipShadows,E.clippingPlanes=_.clippingPlanes,E.clipIntersection=_.clipIntersection,E.displacementMap=_.displacementMap,E.displacementScale=_.displacementScale,E.displacementBias=_.displacementBias,E.wireframeLinewidth=_.wireframeLinewidth,E.linewidth=_.linewidth,A.isPointLight===!0&&E.isMeshDistanceMaterial===!0){const P=n.properties.get(E);P.light=A}return E}function S(C,_,A,I,E){if(C.visible===!1)return;if(C.layers.test(_.layers)&&(C.isMesh||C.isLine||C.isPoints)&&(C.castShadow||C.receiveShadow&&E===xl)&&(!C.frustumCulled||i.intersectsObject(C))){C.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse,C.matrixWorld);const V=e.update(C),U=C.material;if(Array.isArray(U)){const F=V.groups;for(let $=0,J=F.length;$<J;$++){const q=F[$],O=U[q.materialIndex];if(O&&O.visible){const X=w(C,O,I,E);n.renderBufferDirect(A,null,V,X,C,q)}}}else if(U.visible){const F=w(C,U,I,E);n.renderBufferDirect(A,null,V,F,C,null)}}const P=C.children;for(let V=0,U=P.length;V<U;V++)S(P[V],_,A,I,E)}}function oke(n,e,t){const i=t.isWebGL2;function r(){let G=!1;const re=new Gn;let pe=null;const de=new Gn(0,0,0,0);return{setMask:function(Te){pe!==Te&&!G&&(n.colorMask(Te,Te,Te,Te),pe=Te)},setLocked:function(Te){G=Te},setClear:function(Te,Je,rt,ht,pt){pt===!0&&(Te*=ht,Je*=ht,rt*=ht),re.set(Te,Je,rt,ht),de.equals(re)===!1&&(n.clearColor(Te,Je,rt,ht),de.copy(re))},reset:function(){G=!1,pe=null,de.set(-1,0,0,0)}}}function s(){let G=!1,re=null,pe=null,de=null;return{setTest:function(Te){Te?Ue(n.DEPTH_TEST):Ye(n.DEPTH_TEST)},setMask:function(Te){re!==Te&&!G&&(n.depthMask(Te),re=Te)},setFunc:function(Te){if(pe!==Te){switch(Te){case NQ:n.depthFunc(n.NEVER);break;case LQ:n.depthFunc(n.ALWAYS);break;case PQ:n.depthFunc(n.LESS);break;case $v:n.depthFunc(n.LEQUAL);break;case DQ:n.depthFunc(n.EQUAL);break;case FQ:n.depthFunc(n.GEQUAL);break;case OQ:n.depthFunc(n.GREATER);break;case BQ:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}pe=Te}},setLocked:function(Te){G=Te},setClear:function(Te){de!==Te&&(n.clearDepth(Te),de=Te)},reset:function(){G=!1,re=null,pe=null,de=null}}}function o(){let G=!1,re=null,pe=null,de=null,Te=null,Je=null,rt=null,ht=null,pt=null;return{setTest:function(vt){G||(vt?Ue(n.STENCIL_TEST):Ye(n.STENCIL_TEST))},setMask:function(vt){re!==vt&&!G&&(n.stencilMask(vt),re=vt)},setFunc:function(vt,Tn,Ut){(pe!==vt||de!==Tn||Te!==Ut)&&(n.stencilFunc(vt,Tn,Ut),pe=vt,de=Tn,Te=Ut)},setOp:function(vt,Tn,Ut){(Je!==vt||rt!==Tn||ht!==Ut)&&(n.stencilOp(vt,Tn,Ut),Je=vt,rt=Tn,ht=Ut)},setLocked:function(vt){G=vt},setClear:function(vt){pt!==vt&&(n.clearStencil(vt),pt=vt)},reset:function(){G=!1,re=null,pe=null,de=null,Te=null,Je=null,rt=null,ht=null,pt=null}}}const a=new r,l=new s,u=new o,c=new WeakMap,h=new WeakMap;let d={},p={},f=new WeakMap,g=[],y=null,m=!1,v=null,w=null,S=null,C=null,_=null,A=null,I=null,E=new lt(0,0,0),k=0,P=!1,V=null,U=null,F=null,$=null,J=null;const q=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let O=!1,X=0;const j=n.getParameter(n.VERSION);j.indexOf("WebGL")!==-1?(X=parseFloat(/^WebGL (\d)/.exec(j)[1]),O=X>=1):j.indexOf("OpenGL ES")!==-1&&(X=parseFloat(/^OpenGL ES (\d)/.exec(j)[1]),O=X>=2);let z=null,Z={};const ce=n.getParameter(n.SCISSOR_BOX),fe=n.getParameter(n.VIEWPORT),ge=new Gn().fromArray(ce),Ne=new Gn().fromArray(fe);function Fe(G,re,pe,de){const Te=new Uint8Array(4),Je=n.createTexture();n.bindTexture(G,Je),n.texParameteri(G,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(G,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let rt=0;rt<pe;rt++)i&&(G===n.TEXTURE_3D||G===n.TEXTURE_2D_ARRAY)?n.texImage3D(re,0,n.RGBA,1,1,de,0,n.RGBA,n.UNSIGNED_BYTE,Te):n.texImage2D(re+rt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Te);return Je}const We={};We[n.TEXTURE_2D]=Fe(n.TEXTURE_2D,n.TEXTURE_2D,1),We[n.TEXTURE_CUBE_MAP]=Fe(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),i&&(We[n.TEXTURE_2D_ARRAY]=Fe(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),We[n.TEXTURE_3D]=Fe(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),l.setClear(1),u.setClear(0),Ue(n.DEPTH_TEST),l.setFunc($v),Ze(!1),st(qD),Ue(n.CULL_FACE),Re(Ac);function Ue(G){d[G]!==!0&&(n.enable(G),d[G]=!0)}function Ye(G){d[G]!==!1&&(n.disable(G),d[G]=!1)}function $e(G,re){return p[G]!==re?(n.bindFramebuffer(G,re),p[G]=re,i&&(G===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=re),G===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=re)),!0):!1}function ee(G,re){let pe=g,de=!1;if(G)if(pe=f.get(re),pe===void 0&&(pe=[],f.set(re,pe)),G.isWebGLMultipleRenderTargets){const Te=G.texture;if(pe.length!==Te.length||pe[0]!==n.COLOR_ATTACHMENT0){for(let Je=0,rt=Te.length;Je<rt;Je++)pe[Je]=n.COLOR_ATTACHMENT0+Je;pe.length=Te.length,de=!0}}else pe[0]!==n.COLOR_ATTACHMENT0&&(pe[0]=n.COLOR_ATTACHMENT0,de=!0);else pe[0]!==n.BACK&&(pe[0]=n.BACK,de=!0);de&&(t.isWebGL2?n.drawBuffers(pe):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(pe))}function De(G){return y!==G?(n.useProgram(G),y=G,!0):!1}const _e={[Fh]:n.FUNC_ADD,[yQ]:n.FUNC_SUBTRACT,[bQ]:n.FUNC_REVERSE_SUBTRACT};if(i)_e[i3]=n.MIN,_e[r3]=n.MAX;else{const G=e.get("EXT_blend_minmax");G!==null&&(_e[i3]=G.MIN_EXT,_e[r3]=G.MAX_EXT)}const ze={[xQ]:n.ZERO,[vQ]:n.ONE,[wQ]:n.SRC_COLOR,[VM]:n.SRC_ALPHA,[AQ]:n.SRC_ALPHA_SATURATE,[_Q]:n.DST_COLOR,[TQ]:n.DST_ALPHA,[SQ]:n.ONE_MINUS_SRC_COLOR,[UM]:n.ONE_MINUS_SRC_ALPHA,[MQ]:n.ONE_MINUS_DST_COLOR,[CQ]:n.ONE_MINUS_DST_ALPHA,[EQ]:n.CONSTANT_COLOR,[IQ]:n.ONE_MINUS_CONSTANT_COLOR,[kQ]:n.CONSTANT_ALPHA,[RQ]:n.ONE_MINUS_CONSTANT_ALPHA};function Re(G,re,pe,de,Te,Je,rt,ht,pt,vt){if(G===Ac){m===!0&&(Ye(n.BLEND),m=!1);return}if(m===!1&&(Ue(n.BLEND),m=!0),G!==gQ){if(G!==v||vt!==P){if((w!==Fh||_!==Fh)&&(n.blendEquation(n.FUNC_ADD),w=Fh,_=Fh),vt)switch(G){case tf:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case e3:n.blendFunc(n.ONE,n.ONE);break;case t3:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case n3:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",G);break}else switch(G){case tf:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case e3:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case t3:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case n3:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",G);break}S=null,C=null,A=null,I=null,E.set(0,0,0),k=0,v=G,P=vt}return}Te=Te||re,Je=Je||pe,rt=rt||de,(re!==w||Te!==_)&&(n.blendEquationSeparate(_e[re],_e[Te]),w=re,_=Te),(pe!==S||de!==C||Je!==A||rt!==I)&&(n.blendFuncSeparate(ze[pe],ze[de],ze[Je],ze[rt]),S=pe,C=de,A=Je,I=rt),(ht.equals(E)===!1||pt!==k)&&(n.blendColor(ht.r,ht.g,ht.b,pt),E.copy(ht),k=pt),v=G,P=!1}function nt(G,re){G.side===$a?Ye(n.CULL_FACE):Ue(n.CULL_FACE);let pe=G.side===Ys;re&&(pe=!pe),Ze(pe),G.blending===tf&&G.transparent===!1?Re(Ac):Re(G.blending,G.blendEquation,G.blendSrc,G.blendDst,G.blendEquationAlpha,G.blendSrcAlpha,G.blendDstAlpha,G.blendColor,G.blendAlpha,G.premultipliedAlpha),l.setFunc(G.depthFunc),l.setTest(G.depthTest),l.setMask(G.depthWrite),a.setMask(G.colorWrite);const de=G.stencilWrite;u.setTest(de),de&&(u.setMask(G.stencilWriteMask),u.setFunc(G.stencilFunc,G.stencilRef,G.stencilFuncMask),u.setOp(G.stencilFail,G.stencilZFail,G.stencilZPass)),Lt(G.polygonOffset,G.polygonOffsetFactor,G.polygonOffsetUnits),G.alphaToCoverage===!0?Ue(n.SAMPLE_ALPHA_TO_COVERAGE):Ye(n.SAMPLE_ALPHA_TO_COVERAGE)}function Ze(G){V!==G&&(G?n.frontFace(n.CW):n.frontFace(n.CCW),V=G)}function st(G){G!==pQ?(Ue(n.CULL_FACE),G!==U&&(G===qD?n.cullFace(n.BACK):G===fQ?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Ye(n.CULL_FACE),U=G}function yt(G){G!==F&&(O&&n.lineWidth(G),F=G)}function Lt(G,re,pe){G?(Ue(n.POLYGON_OFFSET_FILL),($!==re||J!==pe)&&(n.polygonOffset(re,pe),$=re,J=pe)):Ye(n.POLYGON_OFFSET_FILL)}function ye(G){G?Ue(n.SCISSOR_TEST):Ye(n.SCISSOR_TEST)}function H(G){G===void 0&&(G=n.TEXTURE0+q-1),z!==G&&(n.activeTexture(G),z=G)}function D(G,re,pe){pe===void 0&&(z===null?pe=n.TEXTURE0+q-1:pe=z);let de=Z[pe];de===void 0&&(de={type:void 0,texture:void 0},Z[pe]=de),(de.type!==G||de.texture!==re)&&(z!==pe&&(n.activeTexture(pe),z=pe),n.bindTexture(G,re||We[G]),de.type=G,de.texture=re)}function oe(){const G=Z[z];G!==void 0&&G.type!==void 0&&(n.bindTexture(G.type,null),G.type=void 0,G.texture=void 0)}function Ie(){try{n.compressedTexImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Me(){try{n.compressedTexImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ve(){try{n.texSubImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function ct(){try{n.texSubImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function qe(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function at(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Ot(){try{n.texStorage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Xt(){try{n.texStorage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function Qe(){try{n.texImage2D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function sn(){try{n.texImage3D.apply(n,arguments)}catch(G){console.error("THREE.WebGLState:",G)}}function le(G){ge.equals(G)===!1&&(n.scissor(G.x,G.y,G.z,G.w),ge.copy(G))}function Oe(G){Ne.equals(G)===!1&&(n.viewport(G.x,G.y,G.z,G.w),Ne.copy(G))}function je(G,re){let pe=h.get(re);pe===void 0&&(pe=new WeakMap,h.set(re,pe));let de=pe.get(G);de===void 0&&(de=n.getUniformBlockIndex(re,G.name),pe.set(G,de))}function Ke(G,re){const de=h.get(re).get(G);c.get(re)!==de&&(n.uniformBlockBinding(re,de,G.__bindingPointIndex),c.set(re,de))}function Pt(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),i===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),d={},z=null,Z={},p={},f=new WeakMap,g=[],y=null,m=!1,v=null,w=null,S=null,C=null,_=null,A=null,I=null,E=new lt(0,0,0),k=0,P=!1,V=null,U=null,F=null,$=null,J=null,ge.set(0,0,n.canvas.width,n.canvas.height),Ne.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),u.reset()}return{buffers:{color:a,depth:l,stencil:u},enable:Ue,disable:Ye,bindFramebuffer:$e,drawBuffers:ee,useProgram:De,setBlending:Re,setMaterial:nt,setFlipSided:Ze,setCullFace:st,setLineWidth:yt,setPolygonOffset:Lt,setScissorTest:ye,activeTexture:H,bindTexture:D,unbindTexture:oe,compressedTexImage2D:Ie,compressedTexImage3D:Me,texImage2D:Qe,texImage3D:sn,updateUBOMapping:je,uniformBlockBinding:Ke,texStorage2D:Ot,texStorage3D:Xt,texSubImage2D:Ve,texSubImage3D:ct,compressedTexSubImage2D:qe,compressedTexSubImage3D:at,scissor:le,viewport:Oe,reset:Pt}}function ake(n,e,t,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,u=r.maxCubemapSize,c=r.maxTextureSize,h=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let g;const y=new WeakMap;let m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(H,D){return m?new OffscreenCanvas(H,D):Qv("canvas")}function w(H,D,oe,Ie){let Me=1;if((H.width>Ie||H.height>Ie)&&(Me=Ie/Math.max(H.width,H.height)),Me<1||D===!0)if(typeof HTMLImageElement<"u"&&H instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&H instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&H instanceof ImageBitmap){const Ve=D?WM:Math.floor,ct=Ve(Me*H.width),qe=Ve(Me*H.height);g===void 0&&(g=v(ct,qe));const at=oe?v(ct,qe):g;return at.width=ct,at.height=qe,at.getContext("2d").drawImage(H,0,0,ct,qe),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+H.width+"x"+H.height+") to ("+ct+"x"+qe+")."),at}else return"data"in H&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+H.width+"x"+H.height+")."),H;return H}function S(H){return L3(H.width)&&L3(H.height)}function C(H){return a?!1:H.wrapS!==$r||H.wrapT!==$r||H.minFilter!==Ei&&H.minFilter!==Zn}function _(H,D){return H.generateMipmaps&&D&&H.minFilter!==Ei&&H.minFilter!==Zn}function A(H){n.generateMipmap(H)}function I(H,D,oe,Ie,Me=!1){if(a===!1)return D;if(H!==null){if(n[H]!==void 0)return n[H];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+H+"'")}let Ve=D;if(D===n.RED&&(oe===n.FLOAT&&(Ve=n.R32F),oe===n.HALF_FLOAT&&(Ve=n.R16F),oe===n.UNSIGNED_BYTE&&(Ve=n.R8)),D===n.RED_INTEGER&&(oe===n.UNSIGNED_BYTE&&(Ve=n.R8UI),oe===n.UNSIGNED_SHORT&&(Ve=n.R16UI),oe===n.UNSIGNED_INT&&(Ve=n.R32UI),oe===n.BYTE&&(Ve=n.R8I),oe===n.SHORT&&(Ve=n.R16I),oe===n.INT&&(Ve=n.R32I)),D===n.RG&&(oe===n.FLOAT&&(Ve=n.RG32F),oe===n.HALF_FLOAT&&(Ve=n.RG16F),oe===n.UNSIGNED_BYTE&&(Ve=n.RG8)),D===n.RGBA){const ct=Me?Kv:Fn.getTransfer(Ie);oe===n.FLOAT&&(Ve=n.RGBA32F),oe===n.HALF_FLOAT&&(Ve=n.RGBA16F),oe===n.UNSIGNED_BYTE&&(Ve=ct===Qn?n.SRGB8_ALPHA8:n.RGBA8),oe===n.UNSIGNED_SHORT_4_4_4_4&&(Ve=n.RGBA4),oe===n.UNSIGNED_SHORT_5_5_5_1&&(Ve=n.RGB5_A1)}return(Ve===n.R16F||Ve===n.R32F||Ve===n.RG16F||Ve===n.RG32F||Ve===n.RGBA16F||Ve===n.RGBA32F)&&e.get("EXT_color_buffer_float"),Ve}function E(H,D,oe){return _(H,oe)===!0||H.isFramebufferTexture&&H.minFilter!==Ei&&H.minFilter!==Zn?Math.log2(Math.max(D.width,D.height))+1:H.mipmaps!==void 0&&H.mipmaps.length>0?H.mipmaps.length:H.isCompressedTexture&&Array.isArray(H.image)?D.mipmaps.length:1}function k(H){return H===Ei||H===_y||H===nf?n.NEAREST:n.LINEAR}function P(H){const D=H.target;D.removeEventListener("dispose",P),U(D),D.isVideoTexture&&f.delete(D)}function V(H){const D=H.target;D.removeEventListener("dispose",V),$(D)}function U(H){const D=i.get(H);if(D.__webglInit===void 0)return;const oe=H.source,Ie=y.get(oe);if(Ie){const Me=Ie[D.__cacheKey];Me.usedTimes--,Me.usedTimes===0&&F(H),Object.keys(Ie).length===0&&y.delete(oe)}i.remove(H)}function F(H){const D=i.get(H);n.deleteTexture(D.__webglTexture);const oe=H.source,Ie=y.get(oe);delete Ie[D.__cacheKey],o.memory.textures--}function $(H){const D=H.texture,oe=i.get(H),Ie=i.get(D);if(Ie.__webglTexture!==void 0&&(n.deleteTexture(Ie.__webglTexture),o.memory.textures--),H.depthTexture&&H.depthTexture.dispose(),H.isWebGLCubeRenderTarget)for(let Me=0;Me<6;Me++){if(Array.isArray(oe.__webglFramebuffer[Me]))for(let Ve=0;Ve<oe.__webglFramebuffer[Me].length;Ve++)n.deleteFramebuffer(oe.__webglFramebuffer[Me][Ve]);else n.deleteFramebuffer(oe.__webglFramebuffer[Me]);oe.__webglDepthbuffer&&n.deleteRenderbuffer(oe.__webglDepthbuffer[Me])}else{if(Array.isArray(oe.__webglFramebuffer))for(let Me=0;Me<oe.__webglFramebuffer.length;Me++)n.deleteFramebuffer(oe.__webglFramebuffer[Me]);else n.deleteFramebuffer(oe.__webglFramebuffer);if(oe.__webglDepthbuffer&&n.deleteRenderbuffer(oe.__webglDepthbuffer),oe.__webglMultisampledFramebuffer&&n.deleteFramebuffer(oe.__webglMultisampledFramebuffer),oe.__webglColorRenderbuffer)for(let Me=0;Me<oe.__webglColorRenderbuffer.length;Me++)oe.__webglColorRenderbuffer[Me]&&n.deleteRenderbuffer(oe.__webglColorRenderbuffer[Me]);oe.__webglDepthRenderbuffer&&n.deleteRenderbuffer(oe.__webglDepthRenderbuffer)}if(H.isWebGLMultipleRenderTargets)for(let Me=0,Ve=D.length;Me<Ve;Me++){const ct=i.get(D[Me]);ct.__webglTexture&&(n.deleteTexture(ct.__webglTexture),o.memory.textures--),i.remove(D[Me])}i.remove(D),i.remove(H)}let J=0;function q(){J=0}function O(){const H=J;return H>=l&&console.warn("THREE.WebGLTextures: Trying to use "+H+" texture units while this GPU supports only "+l),J+=1,H}function X(H){const D=[];return D.push(H.wrapS),D.push(H.wrapT),D.push(H.wrapR||0),D.push(H.magFilter),D.push(H.minFilter),D.push(H.anisotropy),D.push(H.internalFormat),D.push(H.format),D.push(H.type),D.push(H.generateMipmaps),D.push(H.premultiplyAlpha),D.push(H.flipY),D.push(H.unpackAlignment),D.push(H.colorSpace),D.join()}function j(H,D){const oe=i.get(H);if(H.isVideoTexture&&Lt(H),H.isRenderTargetTexture===!1&&H.version>0&&oe.__version!==H.version){const Ie=H.image;if(Ie===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ie.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ue(oe,H,D);return}}t.bindTexture(n.TEXTURE_2D,oe.__webglTexture,n.TEXTURE0+D)}function z(H,D){const oe=i.get(H);if(H.version>0&&oe.__version!==H.version){Ue(oe,H,D);return}t.bindTexture(n.TEXTURE_2D_ARRAY,oe.__webglTexture,n.TEXTURE0+D)}function Z(H,D){const oe=i.get(H);if(H.version>0&&oe.__version!==H.version){Ue(oe,H,D);return}t.bindTexture(n.TEXTURE_3D,oe.__webglTexture,n.TEXTURE0+D)}function ce(H,D){const oe=i.get(H);if(H.version>0&&oe.__version!==H.version){Ye(oe,H,D);return}t.bindTexture(n.TEXTURE_CUBE_MAP,oe.__webglTexture,n.TEXTURE0+D)}const fe={[Ul]:n.REPEAT,[$r]:n.CLAMP_TO_EDGE,[Tf]:n.MIRRORED_REPEAT},ge={[Ei]:n.NEAREST,[_y]:n.NEAREST_MIPMAP_NEAREST,[nf]:n.NEAREST_MIPMAP_LINEAR,[Zn]:n.LINEAR,[V1]:n.LINEAR_MIPMAP_NEAREST,[qa]:n.LINEAR_MIPMAP_LINEAR},Ne={[aq]:n.NEVER,[fq]:n.ALWAYS,[lq]:n.LESS,[cq]:n.LEQUAL,[uq]:n.EQUAL,[pq]:n.GEQUAL,[hq]:n.GREATER,[dq]:n.NOTEQUAL};function Fe(H,D,oe){if(oe?(n.texParameteri(H,n.TEXTURE_WRAP_S,fe[D.wrapS]),n.texParameteri(H,n.TEXTURE_WRAP_T,fe[D.wrapT]),(H===n.TEXTURE_3D||H===n.TEXTURE_2D_ARRAY)&&n.texParameteri(H,n.TEXTURE_WRAP_R,fe[D.wrapR]),n.texParameteri(H,n.TEXTURE_MAG_FILTER,ge[D.magFilter]),n.texParameteri(H,n.TEXTURE_MIN_FILTER,ge[D.minFilter])):(n.texParameteri(H,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(H,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(H===n.TEXTURE_3D||H===n.TEXTURE_2D_ARRAY)&&n.texParameteri(H,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(D.wrapS!==$r||D.wrapT!==$r)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(H,n.TEXTURE_MAG_FILTER,k(D.magFilter)),n.texParameteri(H,n.TEXTURE_MIN_FILTER,k(D.minFilter)),D.minFilter!==Ei&&D.minFilter!==Zn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),D.compareFunction&&(n.texParameteri(H,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(H,n.TEXTURE_COMPARE_FUNC,Ne[D.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const Ie=e.get("EXT_texture_filter_anisotropic");if(D.magFilter===Ei||D.minFilter!==nf&&D.minFilter!==qa||D.type===Ml&&e.has("OES_texture_float_linear")===!1||a===!1&&D.type===Cf&&e.has("OES_texture_half_float_linear")===!1)return;(D.anisotropy>1||i.get(D).__currentAnisotropy)&&(n.texParameterf(H,Ie.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(D.anisotropy,r.getMaxAnisotropy())),i.get(D).__currentAnisotropy=D.anisotropy)}}function We(H,D){let oe=!1;H.__webglInit===void 0&&(H.__webglInit=!0,D.addEventListener("dispose",P));const Ie=D.source;let Me=y.get(Ie);Me===void 0&&(Me={},y.set(Ie,Me));const Ve=X(D);if(Ve!==H.__cacheKey){Me[Ve]===void 0&&(Me[Ve]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,oe=!0),Me[Ve].usedTimes++;const ct=Me[H.__cacheKey];ct!==void 0&&(Me[H.__cacheKey].usedTimes--,ct.usedTimes===0&&F(D)),H.__cacheKey=Ve,H.__webglTexture=Me[Ve].texture}return oe}function Ue(H,D,oe){let Ie=n.TEXTURE_2D;(D.isDataArrayTexture||D.isCompressedArrayTexture)&&(Ie=n.TEXTURE_2D_ARRAY),D.isData3DTexture&&(Ie=n.TEXTURE_3D);const Me=We(H,D),Ve=D.source;t.bindTexture(Ie,H.__webglTexture,n.TEXTURE0+oe);const ct=i.get(Ve);if(Ve.version!==ct.__version||Me===!0){t.activeTexture(n.TEXTURE0+oe);const qe=Fn.getPrimaries(Fn.workingColorSpace),at=D.colorSpace===jo?null:Fn.getPrimaries(D.colorSpace),Ot=D.colorSpace===jo||qe===at?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,D.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,D.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,D.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ot);const Xt=C(D)&&S(D.image)===!1;let Qe=w(D.image,Xt,!1,c);Qe=ye(D,Qe);const sn=S(Qe)||a,le=s.convert(D.format,D.colorSpace);let Oe=s.convert(D.type),je=I(D.internalFormat,le,Oe,D.colorSpace,D.isVideoTexture);Fe(Ie,D,sn);let Ke;const Pt=D.mipmaps,G=a&&D.isVideoTexture!==!0,re=ct.__version===void 0||Me===!0,pe=E(D,Qe,sn);if(D.isDepthTexture)je=n.DEPTH_COMPONENT,a?D.type===Ml?je=n.DEPTH_COMPONENT32F:D.type===xc?je=n.DEPTH_COMPONENT24:D.type===id?je=n.DEPTH24_STENCIL8:je=n.DEPTH_COMPONENT16:D.type===Ml&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),D.format===rd&&je===n.DEPTH_COMPONENT&&D.type!==CE&&D.type!==xc&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),D.type=xc,Oe=s.convert(D.type)),D.format===_f&&je===n.DEPTH_COMPONENT&&(je=n.DEPTH_STENCIL,D.type!==id&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),D.type=id,Oe=s.convert(D.type))),re&&(G?t.texStorage2D(n.TEXTURE_2D,1,je,Qe.width,Qe.height):t.texImage2D(n.TEXTURE_2D,0,je,Qe.width,Qe.height,0,le,Oe,null));else if(D.isDataTexture)if(Pt.length>0&&sn){G&&re&&t.texStorage2D(n.TEXTURE_2D,pe,je,Pt[0].width,Pt[0].height);for(let de=0,Te=Pt.length;de<Te;de++)Ke=Pt[de],G?t.texSubImage2D(n.TEXTURE_2D,de,0,0,Ke.width,Ke.height,le,Oe,Ke.data):t.texImage2D(n.TEXTURE_2D,de,je,Ke.width,Ke.height,0,le,Oe,Ke.data);D.generateMipmaps=!1}else G?(re&&t.texStorage2D(n.TEXTURE_2D,pe,je,Qe.width,Qe.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,Qe.width,Qe.height,le,Oe,Qe.data)):t.texImage2D(n.TEXTURE_2D,0,je,Qe.width,Qe.height,0,le,Oe,Qe.data);else if(D.isCompressedTexture)if(D.isCompressedArrayTexture){G&&re&&t.texStorage3D(n.TEXTURE_2D_ARRAY,pe,je,Pt[0].width,Pt[0].height,Qe.depth);for(let de=0,Te=Pt.length;de<Te;de++)Ke=Pt[de],D.format!==xo?le!==null?G?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,de,0,0,0,Ke.width,Ke.height,Qe.depth,le,Ke.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,de,je,Ke.width,Ke.height,Qe.depth,0,Ke.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):G?t.texSubImage3D(n.TEXTURE_2D_ARRAY,de,0,0,0,Ke.width,Ke.height,Qe.depth,le,Oe,Ke.data):t.texImage3D(n.TEXTURE_2D_ARRAY,de,je,Ke.width,Ke.height,Qe.depth,0,le,Oe,Ke.data)}else{G&&re&&t.texStorage2D(n.TEXTURE_2D,pe,je,Pt[0].width,Pt[0].height);for(let de=0,Te=Pt.length;de<Te;de++)Ke=Pt[de],D.format!==xo?le!==null?G?t.compressedTexSubImage2D(n.TEXTURE_2D,de,0,0,Ke.width,Ke.height,le,Ke.data):t.compressedTexImage2D(n.TEXTURE_2D,de,je,Ke.width,Ke.height,0,Ke.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):G?t.texSubImage2D(n.TEXTURE_2D,de,0,0,Ke.width,Ke.height,le,Oe,Ke.data):t.texImage2D(n.TEXTURE_2D,de,je,Ke.width,Ke.height,0,le,Oe,Ke.data)}else if(D.isDataArrayTexture)G?(re&&t.texStorage3D(n.TEXTURE_2D_ARRAY,pe,je,Qe.width,Qe.height,Qe.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Qe.width,Qe.height,Qe.depth,le,Oe,Qe.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,je,Qe.width,Qe.height,Qe.depth,0,le,Oe,Qe.data);else if(D.isData3DTexture)G?(re&&t.texStorage3D(n.TEXTURE_3D,pe,je,Qe.width,Qe.height,Qe.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Qe.width,Qe.height,Qe.depth,le,Oe,Qe.data)):t.texImage3D(n.TEXTURE_3D,0,je,Qe.width,Qe.height,Qe.depth,0,le,Oe,Qe.data);else if(D.isFramebufferTexture){if(re)if(G)t.texStorage2D(n.TEXTURE_2D,pe,je,Qe.width,Qe.height);else{let de=Qe.width,Te=Qe.height;for(let Je=0;Je<pe;Je++)t.texImage2D(n.TEXTURE_2D,Je,je,de,Te,0,le,Oe,null),de>>=1,Te>>=1}}else if(Pt.length>0&&sn){G&&re&&t.texStorage2D(n.TEXTURE_2D,pe,je,Pt[0].width,Pt[0].height);for(let de=0,Te=Pt.length;de<Te;de++)Ke=Pt[de],G?t.texSubImage2D(n.TEXTURE_2D,de,0,0,le,Oe,Ke):t.texImage2D(n.TEXTURE_2D,de,je,le,Oe,Ke);D.generateMipmaps=!1}else G?(re&&t.texStorage2D(n.TEXTURE_2D,pe,je,Qe.width,Qe.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,le,Oe,Qe)):t.texImage2D(n.TEXTURE_2D,0,je,le,Oe,Qe);_(D,sn)&&A(Ie),ct.__version=Ve.version,D.onUpdate&&D.onUpdate(D)}H.__version=D.version}function Ye(H,D,oe){if(D.image.length!==6)return;const Ie=We(H,D),Me=D.source;t.bindTexture(n.TEXTURE_CUBE_MAP,H.__webglTexture,n.TEXTURE0+oe);const Ve=i.get(Me);if(Me.version!==Ve.__version||Ie===!0){t.activeTexture(n.TEXTURE0+oe);const ct=Fn.getPrimaries(Fn.workingColorSpace),qe=D.colorSpace===jo?null:Fn.getPrimaries(D.colorSpace),at=D.colorSpace===jo||ct===qe?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,D.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,D.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,D.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,at);const Ot=D.isCompressedTexture||D.image[0].isCompressedTexture,Xt=D.image[0]&&D.image[0].isDataTexture,Qe=[];for(let de=0;de<6;de++)!Ot&&!Xt?Qe[de]=w(D.image[de],!1,!0,u):Qe[de]=Xt?D.image[de].image:D.image[de],Qe[de]=ye(D,Qe[de]);const sn=Qe[0],le=S(sn)||a,Oe=s.convert(D.format,D.colorSpace),je=s.convert(D.type),Ke=I(D.internalFormat,Oe,je,D.colorSpace),Pt=a&&D.isVideoTexture!==!0,G=Ve.__version===void 0||Ie===!0;let re=E(D,sn,le);Fe(n.TEXTURE_CUBE_MAP,D,le);let pe;if(Ot){Pt&&G&&t.texStorage2D(n.TEXTURE_CUBE_MAP,re,Ke,sn.width,sn.height);for(let de=0;de<6;de++){pe=Qe[de].mipmaps;for(let Te=0;Te<pe.length;Te++){const Je=pe[Te];D.format!==xo?Oe!==null?Pt?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te,0,0,Je.width,Je.height,Oe,Je.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te,Ke,Je.width,Je.height,0,Je.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Pt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te,0,0,Je.width,Je.height,Oe,je,Je.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te,Ke,Je.width,Je.height,0,Oe,je,Je.data)}}}else{pe=D.mipmaps,Pt&&G&&(pe.length>0&&re++,t.texStorage2D(n.TEXTURE_CUBE_MAP,re,Ke,Qe[0].width,Qe[0].height));for(let de=0;de<6;de++)if(Xt){Pt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,0,0,0,Qe[de].width,Qe[de].height,Oe,je,Qe[de].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,0,Ke,Qe[de].width,Qe[de].height,0,Oe,je,Qe[de].data);for(let Te=0;Te<pe.length;Te++){const rt=pe[Te].image[de].image;Pt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te+1,0,0,rt.width,rt.height,Oe,je,rt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te+1,Ke,rt.width,rt.height,0,Oe,je,rt.data)}}else{Pt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,0,0,0,Oe,je,Qe[de]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,0,Ke,Oe,je,Qe[de]);for(let Te=0;Te<pe.length;Te++){const Je=pe[Te];Pt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te+1,0,0,Oe,je,Je.image[de]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+de,Te+1,Ke,Oe,je,Je.image[de])}}}_(D,le)&&A(n.TEXTURE_CUBE_MAP),Ve.__version=Me.version,D.onUpdate&&D.onUpdate(D)}H.__version=D.version}function $e(H,D,oe,Ie,Me,Ve){const ct=s.convert(oe.format,oe.colorSpace),qe=s.convert(oe.type),at=I(oe.internalFormat,ct,qe,oe.colorSpace);if(!i.get(D).__hasExternalTextures){const Xt=Math.max(1,D.width>>Ve),Qe=Math.max(1,D.height>>Ve);Me===n.TEXTURE_3D||Me===n.TEXTURE_2D_ARRAY?t.texImage3D(Me,Ve,at,Xt,Qe,D.depth,0,ct,qe,null):t.texImage2D(Me,Ve,at,Xt,Qe,0,ct,qe,null)}t.bindFramebuffer(n.FRAMEBUFFER,H),yt(D)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Ie,Me,i.get(oe).__webglTexture,0,st(D)):(Me===n.TEXTURE_2D||Me>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&Me<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,Ie,Me,i.get(oe).__webglTexture,Ve),t.bindFramebuffer(n.FRAMEBUFFER,null)}function ee(H,D,oe){if(n.bindRenderbuffer(n.RENDERBUFFER,H),D.depthBuffer&&!D.stencilBuffer){let Ie=a===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(oe||yt(D)){const Me=D.depthTexture;Me&&Me.isDepthTexture&&(Me.type===Ml?Ie=n.DEPTH_COMPONENT32F:Me.type===xc&&(Ie=n.DEPTH_COMPONENT24));const Ve=st(D);yt(D)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Ve,Ie,D.width,D.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,Ve,Ie,D.width,D.height)}else n.renderbufferStorage(n.RENDERBUFFER,Ie,D.width,D.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,H)}else if(D.depthBuffer&&D.stencilBuffer){const Ie=st(D);oe&&yt(D)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Ie,n.DEPTH24_STENCIL8,D.width,D.height):yt(D)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Ie,n.DEPTH24_STENCIL8,D.width,D.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,D.width,D.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,H)}else{const Ie=D.isWebGLMultipleRenderTargets===!0?D.texture:[D.texture];for(let Me=0;Me<Ie.length;Me++){const Ve=Ie[Me],ct=s.convert(Ve.format,Ve.colorSpace),qe=s.convert(Ve.type),at=I(Ve.internalFormat,ct,qe,Ve.colorSpace),Ot=st(D);oe&&yt(D)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Ot,at,D.width,D.height):yt(D)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Ot,at,D.width,D.height):n.renderbufferStorage(n.RENDERBUFFER,at,D.width,D.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function De(H,D){if(D&&D.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,H),!(D.depthTexture&&D.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(D.depthTexture).__webglTexture||D.depthTexture.image.width!==D.width||D.depthTexture.image.height!==D.height)&&(D.depthTexture.image.width=D.width,D.depthTexture.image.height=D.height,D.depthTexture.needsUpdate=!0),j(D.depthTexture,0);const Ie=i.get(D.depthTexture).__webglTexture,Me=st(D);if(D.depthTexture.format===rd)yt(D)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Ie,0,Me):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Ie,0);else if(D.depthTexture.format===_f)yt(D)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Ie,0,Me):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Ie,0);else throw new Error("Unknown depthTexture format")}function _e(H){const D=i.get(H),oe=H.isWebGLCubeRenderTarget===!0;if(H.depthTexture&&!D.__autoAllocateDepthBuffer){if(oe)throw new Error("target.depthTexture not supported in Cube render targets");De(D.__webglFramebuffer,H)}else if(oe){D.__webglDepthbuffer=[];for(let Ie=0;Ie<6;Ie++)t.bindFramebuffer(n.FRAMEBUFFER,D.__webglFramebuffer[Ie]),D.__webglDepthbuffer[Ie]=n.createRenderbuffer(),ee(D.__webglDepthbuffer[Ie],H,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,D.__webglFramebuffer),D.__webglDepthbuffer=n.createRenderbuffer(),ee(D.__webglDepthbuffer,H,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function ze(H,D,oe){const Ie=i.get(H);D!==void 0&&$e(Ie.__webglFramebuffer,H,H.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),oe!==void 0&&_e(H)}function Re(H){const D=H.texture,oe=i.get(H),Ie=i.get(D);H.addEventListener("dispose",V),H.isWebGLMultipleRenderTargets!==!0&&(Ie.__webglTexture===void 0&&(Ie.__webglTexture=n.createTexture()),Ie.__version=D.version,o.memory.textures++);const Me=H.isWebGLCubeRenderTarget===!0,Ve=H.isWebGLMultipleRenderTargets===!0,ct=S(H)||a;if(Me){oe.__webglFramebuffer=[];for(let qe=0;qe<6;qe++)if(a&&D.mipmaps&&D.mipmaps.length>0){oe.__webglFramebuffer[qe]=[];for(let at=0;at<D.mipmaps.length;at++)oe.__webglFramebuffer[qe][at]=n.createFramebuffer()}else oe.__webglFramebuffer[qe]=n.createFramebuffer()}else{if(a&&D.mipmaps&&D.mipmaps.length>0){oe.__webglFramebuffer=[];for(let qe=0;qe<D.mipmaps.length;qe++)oe.__webglFramebuffer[qe]=n.createFramebuffer()}else oe.__webglFramebuffer=n.createFramebuffer();if(Ve)if(r.drawBuffers){const qe=H.texture;for(let at=0,Ot=qe.length;at<Ot;at++){const Xt=i.get(qe[at]);Xt.__webglTexture===void 0&&(Xt.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&H.samples>0&&yt(H)===!1){const qe=Ve?D:[D];oe.__webglMultisampledFramebuffer=n.createFramebuffer(),oe.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,oe.__webglMultisampledFramebuffer);for(let at=0;at<qe.length;at++){const Ot=qe[at];oe.__webglColorRenderbuffer[at]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,oe.__webglColorRenderbuffer[at]);const Xt=s.convert(Ot.format,Ot.colorSpace),Qe=s.convert(Ot.type),sn=I(Ot.internalFormat,Xt,Qe,Ot.colorSpace,H.isXRRenderTarget===!0),le=st(H);n.renderbufferStorageMultisample(n.RENDERBUFFER,le,sn,H.width,H.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+at,n.RENDERBUFFER,oe.__webglColorRenderbuffer[at])}n.bindRenderbuffer(n.RENDERBUFFER,null),H.depthBuffer&&(oe.__webglDepthRenderbuffer=n.createRenderbuffer(),ee(oe.__webglDepthRenderbuffer,H,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(Me){t.bindTexture(n.TEXTURE_CUBE_MAP,Ie.__webglTexture),Fe(n.TEXTURE_CUBE_MAP,D,ct);for(let qe=0;qe<6;qe++)if(a&&D.mipmaps&&D.mipmaps.length>0)for(let at=0;at<D.mipmaps.length;at++)$e(oe.__webglFramebuffer[qe][at],H,D,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+qe,at);else $e(oe.__webglFramebuffer[qe],H,D,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+qe,0);_(D,ct)&&A(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Ve){const qe=H.texture;for(let at=0,Ot=qe.length;at<Ot;at++){const Xt=qe[at],Qe=i.get(Xt);t.bindTexture(n.TEXTURE_2D,Qe.__webglTexture),Fe(n.TEXTURE_2D,Xt,ct),$e(oe.__webglFramebuffer,H,Xt,n.COLOR_ATTACHMENT0+at,n.TEXTURE_2D,0),_(Xt,ct)&&A(n.TEXTURE_2D)}t.unbindTexture()}else{let qe=n.TEXTURE_2D;if((H.isWebGL3DRenderTarget||H.isWebGLArrayRenderTarget)&&(a?qe=H.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(qe,Ie.__webglTexture),Fe(qe,D,ct),a&&D.mipmaps&&D.mipmaps.length>0)for(let at=0;at<D.mipmaps.length;at++)$e(oe.__webglFramebuffer[at],H,D,n.COLOR_ATTACHMENT0,qe,at);else $e(oe.__webglFramebuffer,H,D,n.COLOR_ATTACHMENT0,qe,0);_(D,ct)&&A(qe),t.unbindTexture()}H.depthBuffer&&_e(H)}function nt(H){const D=S(H)||a,oe=H.isWebGLMultipleRenderTargets===!0?H.texture:[H.texture];for(let Ie=0,Me=oe.length;Ie<Me;Ie++){const Ve=oe[Ie];if(_(Ve,D)){const ct=H.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,qe=i.get(Ve).__webglTexture;t.bindTexture(ct,qe),A(ct),t.unbindTexture()}}}function Ze(H){if(a&&H.samples>0&&yt(H)===!1){const D=H.isWebGLMultipleRenderTargets?H.texture:[H.texture],oe=H.width,Ie=H.height;let Me=n.COLOR_BUFFER_BIT;const Ve=[],ct=H.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,qe=i.get(H),at=H.isWebGLMultipleRenderTargets===!0;if(at)for(let Ot=0;Ot<D.length;Ot++)t.bindFramebuffer(n.FRAMEBUFFER,qe.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ot,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,qe.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ot,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,qe.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,qe.__webglFramebuffer);for(let Ot=0;Ot<D.length;Ot++){Ve.push(n.COLOR_ATTACHMENT0+Ot),H.depthBuffer&&Ve.push(ct);const Xt=qe.__ignoreDepthValues!==void 0?qe.__ignoreDepthValues:!1;if(Xt===!1&&(H.depthBuffer&&(Me|=n.DEPTH_BUFFER_BIT),H.stencilBuffer&&(Me|=n.STENCIL_BUFFER_BIT)),at&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,qe.__webglColorRenderbuffer[Ot]),Xt===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[ct]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[ct])),at){const Qe=i.get(D[Ot]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Qe,0)}n.blitFramebuffer(0,0,oe,Ie,0,0,oe,Ie,Me,n.NEAREST),p&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,Ve)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),at)for(let Ot=0;Ot<D.length;Ot++){t.bindFramebuffer(n.FRAMEBUFFER,qe.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ot,n.RENDERBUFFER,qe.__webglColorRenderbuffer[Ot]);const Xt=i.get(D[Ot]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,qe.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ot,n.TEXTURE_2D,Xt,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,qe.__webglMultisampledFramebuffer)}}function st(H){return Math.min(h,H.samples)}function yt(H){const D=i.get(H);return a&&H.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&D.__useRenderToTexture!==!1}function Lt(H){const D=o.render.frame;f.get(H)!==D&&(f.set(H,D),H.update())}function ye(H,D){const oe=H.colorSpace,Ie=H.format,Me=H.type;return H.isCompressedTexture===!0||H.isVideoTexture===!0||H.format===$M||oe!==Zr&&oe!==jo&&(Fn.getTransfer(oe)===Qn?a===!1?e.has("EXT_sRGB")===!0&&Ie===xo?(H.format=$M,H.minFilter=Zn,H.generateMipmaps=!1):D=YB.sRGBToLinear(D):(Ie!==xo||Me!==Eu)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",oe)),D}this.allocateTextureUnit=O,this.resetTextureUnits=q,this.setTexture2D=j,this.setTexture2DArray=z,this.setTexture3D=Z,this.setTextureCube=ce,this.rebindTextures=ze,this.setupRenderTarget=Re,this.updateRenderTargetMipmap=nt,this.updateMultisampleRenderTarget=Ze,this.setupDepthRenderbuffer=_e,this.setupFrameBufferTexture=$e,this.useMultisampledRTT=yt}function Iq(n,e,t){const i=t.isWebGL2;function r(s,o=jo){let a;const l=Fn.getTransfer(o);if(s===Eu)return n.UNSIGNED_BYTE;if(s===VB)return n.UNSIGNED_SHORT_4_4_4_4;if(s===UB)return n.UNSIGNED_SHORT_5_5_5_1;if(s===XQ)return n.BYTE;if(s===KQ)return n.SHORT;if(s===CE)return n.UNSIGNED_SHORT;if(s===GB)return n.INT;if(s===xc)return n.UNSIGNED_INT;if(s===Ml)return n.FLOAT;if(s===Cf)return i?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===ZQ)return n.ALPHA;if(s===xo)return n.RGBA;if(s===jQ)return n.LUMINANCE;if(s===YQ)return n.LUMINANCE_ALPHA;if(s===rd)return n.DEPTH_COMPONENT;if(s===_f)return n.DEPTH_STENCIL;if(s===$M)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===JQ)return n.RED;if(s===$B)return n.RED_INTEGER;if(s===QQ)return n.RG;if(s===WB)return n.RG_INTEGER;if(s===HB)return n.RGBA_INTEGER;if(s===z_||s===G_||s===V_||s===U_)if(l===Qn)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===z_)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===G_)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===V_)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===U_)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===z_)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===G_)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===V_)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===U_)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===o3||s===a3||s===l3||s===u3)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===o3)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===a3)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===l3)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===u3)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===qQ)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===c3||s===h3)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===c3)return l===Qn?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===h3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===d3||s===p3||s===f3||s===m3||s===g3||s===y3||s===b3||s===x3||s===v3||s===w3||s===S3||s===T3||s===C3||s===_3)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===d3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===p3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===f3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===m3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===g3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===y3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===b3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===x3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===v3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===w3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===S3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===T3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===C3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===_3)return l===Qn?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===$_||s===M3||s===A3)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===$_)return l===Qn?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===M3)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===A3)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===eq||s===E3||s===I3||s===k3)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===$_)return a.COMPRESSED_RED_RGTC1_EXT;if(s===E3)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===I3)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===k3)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===id?i?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[s]!==void 0?n[s]:null}return{convert:r}}class kq extends ci{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Ks extends yn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const lke={type:"move"};class cL{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ks,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ks,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Y,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Y),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ks,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Y,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Y),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const i of e.hand.values())this._getHandJoint(t,i)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let r=null,s=null,o=null;const a=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){o=!0;for(const g of e.hand.values()){const y=t.getJointPose(g,i),m=this._getHandJoint(u,g);y!==null&&(m.matrix.fromArray(y.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.matrixWorldNeedsUpdate=!0,m.jointRadius=y.radius),m.visible=y!==null}const c=u.joints["index-finger-tip"],h=u.joints["thumb-tip"],d=c.position.distanceTo(h.position),p=.02,f=.005;u.inputState.pinching&&d>p+f?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&d<=p-f&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,i),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,i),r===null&&s!==null&&(r=s),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(lke)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),u!==null&&(u.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const i=new Ks;i.matrixAutoUpdate=!1,i.visible=!1,e.joints[t.jointName]=i,e.add(i)}return e.joints[t.jointName]}}class iz extends ni{constructor(e,t,i,r,s,o,a,l,u,c){if(c=c!==void 0?c:rd,c!==rd&&c!==_f)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&c===rd&&(i=xc),i===void 0&&c===_f&&(i=id),super(null,r,s,o,a,l,c,i,u),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:Ei,this.minFilter=l!==void 0?l:Ei,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class uke extends Wu{constructor(e,t){super();const i=this;let r=null,s=1,o=null,a="local-floor",l=1,u=null,c=null,h=null,d=null,p=null,f=null;const g=t.getContextAttributes();let y=null,m=null;const v=[],w=[],S=new ci;S.layers.enable(1),S.viewport=new Gn;const C=new ci;C.layers.enable(2),C.viewport=new Gn;const _=[S,C],A=new kq;A.layers.enable(1),A.layers.enable(2);let I=null,E=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(z){let Z=v[z];return Z===void 0&&(Z=new cL,v[z]=Z),Z.getTargetRaySpace()},this.getControllerGrip=function(z){let Z=v[z];return Z===void 0&&(Z=new cL,v[z]=Z),Z.getGripSpace()},this.getHand=function(z){let Z=v[z];return Z===void 0&&(Z=new cL,v[z]=Z),Z.getHandSpace()};function k(z){const Z=w.indexOf(z.inputSource);if(Z===-1)return;const ce=v[Z];ce!==void 0&&(ce.update(z.inputSource,z.frame,u||o),ce.dispatchEvent({type:z.type,data:z.inputSource}))}function P(){r.removeEventListener("select",k),r.removeEventListener("selectstart",k),r.removeEventListener("selectend",k),r.removeEventListener("squeeze",k),r.removeEventListener("squeezestart",k),r.removeEventListener("squeezeend",k),r.removeEventListener("end",P),r.removeEventListener("inputsourceschange",V);for(let z=0;z<v.length;z++){const Z=w[z];Z!==null&&(w[z]=null,v[z].disconnect(Z))}I=null,E=null,e.setRenderTarget(y),p=null,d=null,h=null,r=null,m=null,j.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(z){s=z,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(z){a=z,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||o},this.setReferenceSpace=function(z){u=z},this.getBaseLayer=function(){return d!==null?d:p},this.getBinding=function(){return h},this.getFrame=function(){return f},this.getSession=function(){return r},this.setSession=async function(z){if(r=z,r!==null){if(y=e.getRenderTarget(),r.addEventListener("select",k),r.addEventListener("selectstart",k),r.addEventListener("selectend",k),r.addEventListener("squeeze",k),r.addEventListener("squeezestart",k),r.addEventListener("squeezeend",k),r.addEventListener("end",P),r.addEventListener("inputsourceschange",V),g.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const Z={antialias:r.renderState.layers===void 0?g.antialias:!0,alpha:!0,depth:g.depth,stencil:g.stencil,framebufferScaleFactor:s};p=new XRWebGLLayer(r,t,Z),r.updateRenderState({baseLayer:p}),m=new el(p.framebufferWidth,p.framebufferHeight,{format:xo,type:Eu,colorSpace:e.outputColorSpace,stencilBuffer:g.stencil})}else{let Z=null,ce=null,fe=null;g.depth&&(fe=g.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Z=g.stencil?_f:rd,ce=g.stencil?id:xc);const ge={colorFormat:t.RGBA8,depthFormat:fe,scaleFactor:s};h=new XRWebGLBinding(r,t),d=h.createProjectionLayer(ge),r.updateRenderState({layers:[d]}),m=new el(d.textureWidth,d.textureHeight,{format:xo,type:Eu,depthTexture:new iz(d.textureWidth,d.textureHeight,ce,void 0,void 0,void 0,void 0,void 0,void 0,Z),stencilBuffer:g.stencil,colorSpace:e.outputColorSpace,samples:g.antialias?4:0});const Ne=e.properties.get(m);Ne.__ignoreDepthValues=d.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(l),u=null,o=await r.requestReferenceSpace(a),j.setContext(r),j.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(r!==null)return r.environmentBlendMode};function V(z){for(let Z=0;Z<z.removed.length;Z++){const ce=z.removed[Z],fe=w.indexOf(ce);fe>=0&&(w[fe]=null,v[fe].disconnect(ce))}for(let Z=0;Z<z.added.length;Z++){const ce=z.added[Z];let fe=w.indexOf(ce);if(fe===-1){for(let Ne=0;Ne<v.length;Ne++)if(Ne>=w.length){w.push(ce),fe=Ne;break}else if(w[Ne]===null){w[Ne]=ce,fe=Ne;break}if(fe===-1)break}const ge=v[fe];ge&&ge.connect(ce)}}const U=new Y,F=new Y;function $(z,Z,ce){U.setFromMatrixPosition(Z.matrixWorld),F.setFromMatrixPosition(ce.matrixWorld);const fe=U.distanceTo(F),ge=Z.projectionMatrix.elements,Ne=ce.projectionMatrix.elements,Fe=ge[14]/(ge[10]-1),We=ge[14]/(ge[10]+1),Ue=(ge[9]+1)/ge[5],Ye=(ge[9]-1)/ge[5],$e=(ge[8]-1)/ge[0],ee=(Ne[8]+1)/Ne[0],De=Fe*$e,_e=Fe*ee,ze=fe/(-$e+ee),Re=ze*-$e;Z.matrixWorld.decompose(z.position,z.quaternion,z.scale),z.translateX(Re),z.translateZ(ze),z.matrixWorld.compose(z.position,z.quaternion,z.scale),z.matrixWorldInverse.copy(z.matrixWorld).invert();const nt=Fe+ze,Ze=We+ze,st=De-Re,yt=_e+(fe-Re),Lt=Ue*We/Ze*nt,ye=Ye*We/Ze*nt;z.projectionMatrix.makePerspective(st,yt,Lt,ye,nt,Ze),z.projectionMatrixInverse.copy(z.projectionMatrix).invert()}function J(z,Z){Z===null?z.matrixWorld.copy(z.matrix):z.matrixWorld.multiplyMatrices(Z.matrixWorld,z.matrix),z.matrixWorldInverse.copy(z.matrixWorld).invert()}this.updateCamera=function(z){if(r===null)return;A.near=C.near=S.near=z.near,A.far=C.far=S.far=z.far,(I!==A.near||E!==A.far)&&(r.updateRenderState({depthNear:A.near,depthFar:A.far}),I=A.near,E=A.far);const Z=z.parent,ce=A.cameras;J(A,Z);for(let fe=0;fe<ce.length;fe++)J(ce[fe],Z);ce.length===2?$(A,S,C):A.projectionMatrix.copy(S.projectionMatrix),q(z,A,Z)};function q(z,Z,ce){ce===null?z.matrix.copy(Z.matrixWorld):(z.matrix.copy(ce.matrixWorld),z.matrix.invert(),z.matrix.multiply(Z.matrixWorld)),z.matrix.decompose(z.position,z.quaternion,z.scale),z.updateMatrixWorld(!0),z.projectionMatrix.copy(Z.projectionMatrix),z.projectionMatrixInverse.copy(Z.projectionMatrixInverse),z.isPerspectiveCamera&&(z.fov=My*2*Math.atan(1/z.projectionMatrix.elements[5]),z.zoom=1)}this.getCamera=function(){return A},this.getFoveation=function(){if(!(d===null&&p===null))return l},this.setFoveation=function(z){l=z,d!==null&&(d.fixedFoveation=z),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=z)};let O=null;function X(z,Z){if(c=Z.getViewerPose(u||o),f=Z,c!==null){const ce=c.views;p!==null&&(e.setRenderTargetFramebuffer(m,p.framebuffer),e.setRenderTarget(m));let fe=!1;ce.length!==A.cameras.length&&(A.cameras.length=0,fe=!0);for(let ge=0;ge<ce.length;ge++){const Ne=ce[ge];let Fe=null;if(p!==null)Fe=p.getViewport(Ne);else{const Ue=h.getViewSubImage(d,Ne);Fe=Ue.viewport,ge===0&&(e.setRenderTargetTextures(m,Ue.colorTexture,d.ignoreDepthValues?void 0:Ue.depthStencilTexture),e.setRenderTarget(m))}let We=_[ge];We===void 0&&(We=new ci,We.layers.enable(ge),We.viewport=new Gn,_[ge]=We),We.matrix.fromArray(Ne.transform.matrix),We.matrix.decompose(We.position,We.quaternion,We.scale),We.projectionMatrix.fromArray(Ne.projectionMatrix),We.projectionMatrixInverse.copy(We.projectionMatrix).invert(),We.viewport.set(Fe.x,Fe.y,Fe.width,Fe.height),ge===0&&(A.matrix.copy(We.matrix),A.matrix.decompose(A.position,A.quaternion,A.scale)),fe===!0&&A.cameras.push(We)}}for(let ce=0;ce<v.length;ce++){const fe=w[ce],ge=v[ce];fe!==null&&ge!==void 0&&ge.update(fe,Z,u||o)}O&&O(z,Z),Z.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:Z}),f=null}const j=new Cq;j.setAnimationLoop(X),this.setAnimationLoop=function(z){O=z},this.dispose=function(){}}}function cke(n,e){function t(y,m){y.matrixAutoUpdate===!0&&y.updateMatrix(),m.value.copy(y.matrix)}function i(y,m){m.color.getRGB(y.fogColor.value,vq(n)),m.isFog?(y.fogNear.value=m.near,y.fogFar.value=m.far):m.isFogExp2&&(y.fogDensity.value=m.density)}function r(y,m,v,w,S){m.isMeshBasicMaterial||m.isMeshLambertMaterial?s(y,m):m.isMeshToonMaterial?(s(y,m),h(y,m)):m.isMeshPhongMaterial?(s(y,m),c(y,m)):m.isMeshStandardMaterial?(s(y,m),d(y,m),m.isMeshPhysicalMaterial&&p(y,m,S)):m.isMeshMatcapMaterial?(s(y,m),f(y,m)):m.isMeshDepthMaterial?s(y,m):m.isMeshDistanceMaterial?(s(y,m),g(y,m)):m.isMeshNormalMaterial?s(y,m):m.isLineBasicMaterial?(o(y,m),m.isLineDashedMaterial&&a(y,m)):m.isPointsMaterial?l(y,m,v,w):m.isSpriteMaterial?u(y,m):m.isShadowMaterial?(y.color.value.copy(m.color),y.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function s(y,m){y.opacity.value=m.opacity,m.color&&y.diffuse.value.copy(m.color),m.emissive&&y.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(y.map.value=m.map,t(m.map,y.mapTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,t(m.alphaMap,y.alphaMapTransform)),m.bumpMap&&(y.bumpMap.value=m.bumpMap,t(m.bumpMap,y.bumpMapTransform),y.bumpScale.value=m.bumpScale,m.side===Ys&&(y.bumpScale.value*=-1)),m.normalMap&&(y.normalMap.value=m.normalMap,t(m.normalMap,y.normalMapTransform),y.normalScale.value.copy(m.normalScale),m.side===Ys&&y.normalScale.value.negate()),m.displacementMap&&(y.displacementMap.value=m.displacementMap,t(m.displacementMap,y.displacementMapTransform),y.displacementScale.value=m.displacementScale,y.displacementBias.value=m.displacementBias),m.emissiveMap&&(y.emissiveMap.value=m.emissiveMap,t(m.emissiveMap,y.emissiveMapTransform)),m.specularMap&&(y.specularMap.value=m.specularMap,t(m.specularMap,y.specularMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest);const v=e.get(m).envMap;if(v&&(y.envMap.value=v,y.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,y.reflectivity.value=m.reflectivity,y.ior.value=m.ior,y.refractionRatio.value=m.refractionRatio),m.lightMap){y.lightMap.value=m.lightMap;const w=n._useLegacyLights===!0?Math.PI:1;y.lightMapIntensity.value=m.lightMapIntensity*w,t(m.lightMap,y.lightMapTransform)}m.aoMap&&(y.aoMap.value=m.aoMap,y.aoMapIntensity.value=m.aoMapIntensity,t(m.aoMap,y.aoMapTransform))}function o(y,m){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,m.map&&(y.map.value=m.map,t(m.map,y.mapTransform))}function a(y,m){y.dashSize.value=m.dashSize,y.totalSize.value=m.dashSize+m.gapSize,y.scale.value=m.scale}function l(y,m,v,w){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,y.size.value=m.size*v,y.scale.value=w*.5,m.map&&(y.map.value=m.map,t(m.map,y.uvTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,t(m.alphaMap,y.alphaMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest)}function u(y,m){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,y.rotation.value=m.rotation,m.map&&(y.map.value=m.map,t(m.map,y.mapTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,t(m.alphaMap,y.alphaMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest)}function c(y,m){y.specular.value.copy(m.specular),y.shininess.value=Math.max(m.shininess,1e-4)}function h(y,m){m.gradientMap&&(y.gradientMap.value=m.gradientMap)}function d(y,m){y.metalness.value=m.metalness,m.metalnessMap&&(y.metalnessMap.value=m.metalnessMap,t(m.metalnessMap,y.metalnessMapTransform)),y.roughness.value=m.roughness,m.roughnessMap&&(y.roughnessMap.value=m.roughnessMap,t(m.roughnessMap,y.roughnessMapTransform)),e.get(m).envMap&&(y.envMapIntensity.value=m.envMapIntensity)}function p(y,m,v){y.ior.value=m.ior,m.sheen>0&&(y.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),y.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(y.sheenColorMap.value=m.sheenColorMap,t(m.sheenColorMap,y.sheenColorMapTransform)),m.sheenRoughnessMap&&(y.sheenRoughnessMap.value=m.sheenRoughnessMap,t(m.sheenRoughnessMap,y.sheenRoughnessMapTransform))),m.clearcoat>0&&(y.clearcoat.value=m.clearcoat,y.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(y.clearcoatMap.value=m.clearcoatMap,t(m.clearcoatMap,y.clearcoatMapTransform)),m.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap,t(m.clearcoatRoughnessMap,y.clearcoatRoughnessMapTransform)),m.clearcoatNormalMap&&(y.clearcoatNormalMap.value=m.clearcoatNormalMap,t(m.clearcoatNormalMap,y.clearcoatNormalMapTransform),y.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),m.side===Ys&&y.clearcoatNormalScale.value.negate())),m.iridescence>0&&(y.iridescence.value=m.iridescence,y.iridescenceIOR.value=m.iridescenceIOR,y.iridescenceThicknessMinimum.value=m.iridescenceThicknessRange[0],y.iridescenceThicknessMaximum.value=m.iridescenceThicknessRange[1],m.iridescenceMap&&(y.iridescenceMap.value=m.iridescenceMap,t(m.iridescenceMap,y.iridescenceMapTransform)),m.iridescenceThicknessMap&&(y.iridescenceThicknessMap.value=m.iridescenceThicknessMap,t(m.iridescenceThicknessMap,y.iridescenceThicknessMapTransform))),m.transmission>0&&(y.transmission.value=m.transmission,y.transmissionSamplerMap.value=v.texture,y.transmissionSamplerSize.value.set(v.width,v.height),m.transmissionMap&&(y.transmissionMap.value=m.transmissionMap,t(m.transmissionMap,y.transmissionMapTransform)),y.thickness.value=m.thickness,m.thicknessMap&&(y.thicknessMap.value=m.thicknessMap,t(m.thicknessMap,y.thicknessMapTransform)),y.attenuationDistance.value=m.attenuationDistance,y.attenuationColor.value.copy(m.attenuationColor)),m.anisotropy>0&&(y.anisotropyVector.value.set(m.anisotropy*Math.cos(m.anisotropyRotation),m.anisotropy*Math.sin(m.anisotropyRotation)),m.anisotropyMap&&(y.anisotropyMap.value=m.anisotropyMap,t(m.anisotropyMap,y.anisotropyMapTransform))),y.specularIntensity.value=m.specularIntensity,y.specularColor.value.copy(m.specularColor),m.specularColorMap&&(y.specularColorMap.value=m.specularColorMap,t(m.specularColorMap,y.specularColorMapTransform)),m.specularIntensityMap&&(y.specularIntensityMap.value=m.specularIntensityMap,t(m.specularIntensityMap,y.specularIntensityMapTransform))}function f(y,m){m.matcap&&(y.matcap.value=m.matcap)}function g(y,m){const v=e.get(m).light;y.referencePosition.value.setFromMatrixPosition(v.matrixWorld),y.nearDistance.value=v.shadow.camera.near,y.farDistance.value=v.shadow.camera.far}return{refreshFogUniforms:i,refreshMaterialUniforms:r}}function hke(n,e,t,i){let r={},s={},o=[];const a=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(v,w){const S=w.program;i.uniformBlockBinding(v,S)}function u(v,w){let S=r[v.id];S===void 0&&(f(v),S=c(v),r[v.id]=S,v.addEventListener("dispose",y));const C=w.program;i.updateUBOMapping(v,C);const _=e.render.frame;s[v.id]!==_&&(d(v),s[v.id]=_)}function c(v){const w=h();v.__bindingPointIndex=w;const S=n.createBuffer(),C=v.__size,_=v.usage;return n.bindBuffer(n.UNIFORM_BUFFER,S),n.bufferData(n.UNIFORM_BUFFER,C,_),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,w,S),S}function h(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(v){const w=r[v.id],S=v.uniforms,C=v.__cache;n.bindBuffer(n.UNIFORM_BUFFER,w);for(let _=0,A=S.length;_<A;_++){const I=S[_];if(p(I,_,C)===!0){const E=I.__offset,k=Array.isArray(I.value)?I.value:[I.value];let P=0;for(let V=0;V<k.length;V++){const U=k[V],F=g(U);typeof U=="number"?(I.__data[0]=U,n.bufferSubData(n.UNIFORM_BUFFER,E+P,I.__data)):U.isMatrix3?(I.__data[0]=U.elements[0],I.__data[1]=U.elements[1],I.__data[2]=U.elements[2],I.__data[3]=U.elements[0],I.__data[4]=U.elements[3],I.__data[5]=U.elements[4],I.__data[6]=U.elements[5],I.__data[7]=U.elements[0],I.__data[8]=U.elements[6],I.__data[9]=U.elements[7],I.__data[10]=U.elements[8],I.__data[11]=U.elements[0]):(U.toArray(I.__data,P),P+=F.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,E,I.__data)}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(v,w,S){const C=v.value;if(S[w]===void 0){if(typeof C=="number")S[w]=C;else{const _=Array.isArray(C)?C:[C],A=[];for(let I=0;I<_.length;I++)A.push(_[I].clone());S[w]=A}return!0}else if(typeof C=="number"){if(S[w]!==C)return S[w]=C,!0}else{const _=Array.isArray(S[w])?S[w]:[S[w]],A=Array.isArray(C)?C:[C];for(let I=0;I<_.length;I++){const E=_[I];if(E.equals(A[I])===!1)return E.copy(A[I]),!0}}return!1}function f(v){const w=v.uniforms;let S=0;const C=16;let _=0;for(let A=0,I=w.length;A<I;A++){const E=w[A],k={boundary:0,storage:0},P=Array.isArray(E.value)?E.value:[E.value];for(let V=0,U=P.length;V<U;V++){const F=P[V],$=g(F);k.boundary+=$.boundary,k.storage+=$.storage}if(E.__data=new Float32Array(k.storage/Float32Array.BYTES_PER_ELEMENT),E.__offset=S,A>0){_=S%C;const V=C-_;_!==0&&V-k.boundary<0&&(S+=C-_,E.__offset=S)}S+=k.storage}return _=S%C,_>0&&(S+=C-_),v.__size=S,v.__cache={},this}function g(v){const w={boundary:0,storage:0};return typeof v=="number"?(w.boundary=4,w.storage=4):v.isVector2?(w.boundary=8,w.storage=8):v.isVector3||v.isColor?(w.boundary=16,w.storage=12):v.isVector4?(w.boundary=16,w.storage=16):v.isMatrix3?(w.boundary=48,w.storage=48):v.isMatrix4?(w.boundary=64,w.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),w}function y(v){const w=v.target;w.removeEventListener("dispose",y);const S=o.indexOf(w.__bindingPointIndex);o.splice(S,1),n.deleteBuffer(r[w.id]),delete r[w.id],delete s[w.id]}function m(){for(const v in r)n.deleteBuffer(r[v]);o=[],r={},s={}}return{bind:l,update:u,dispose:m}}class kE{constructor(e={}){const{canvas:t=yq(),context:i=null,depth:r=!0,stencil:s=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:u=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:h=!1}=e;this.isWebGLRenderer=!0;let d;i!==null?d=i.getContextAttributes().alpha:d=o;const p=new Uint32Array(4),f=new Int32Array(4);let g=null,y=null;const m=[],v=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=bi,this._useLegacyLights=!1,this.toneMapping=Au,this.toneMappingExposure=1;const w=this;let S=!1,C=0,_=0,A=null,I=-1,E=null;const k=new Gn,P=new Gn;let V=null;const U=new lt(0);let F=0,$=t.width,J=t.height,q=1,O=null,X=null;const j=new Gn(0,0,$,J),z=new Gn(0,0,$,J);let Z=!1;const ce=new EE;let fe=!1,ge=!1,Ne=null;const Fe=new Ft,We=new Ge,Ue=new Y,Ye={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function $e(){return A===null?q:1}let ee=i;function De(Q,we){for(let Ae=0;Ae<Q.length;Ae++){const Se=Q[Ae],Ee=t.getContext(Se,we);if(Ee!==null)return Ee}return null}try{const Q={alpha:!0,depth:r,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${z1}`),t.addEventListener("webglcontextlost",Pt,!1),t.addEventListener("webglcontextrestored",G,!1),t.addEventListener("webglcontextcreationerror",re,!1),ee===null){const we=["webgl2","webgl","experimental-webgl"];if(w.isWebGL1Renderer===!0&&we.shift(),ee=De(we,Q),ee===null)throw De(we)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&ee instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),ee.getShaderPrecisionFormat===void 0&&(ee.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Q){throw console.error("THREE.WebGLRenderer: "+Q.message),Q}let _e,ze,Re,nt,Ze,st,yt,Lt,ye,H,D,oe,Ie,Me,Ve,ct,qe,at,Ot,Xt,Qe,sn,le,Oe;function je(){_e=new M2e(ee),ze=new v2e(ee,_e,e),_e.init(ze),sn=new Iq(ee,_e,ze),Re=new oke(ee,_e,ze),nt=new I2e(ee),Ze=new ZIe,st=new ake(ee,_e,Re,Ze,ze,sn,nt),yt=new S2e(w),Lt=new _2e(w),ye=new zMe(ee,ze),le=new b2e(ee,_e,ye,ze),H=new A2e(ee,ye,nt,le),D=new L2e(ee,H,ye,nt),Ot=new N2e(ee,ze,st),ct=new w2e(Ze),oe=new KIe(w,yt,Lt,_e,ze,le,ct),Ie=new cke(w,Ze),Me=new YIe,Ve=new nke(_e,ze),at=new y2e(w,yt,Lt,Re,D,d,l),qe=new ske(w,D,ze),Oe=new hke(ee,nt,ze,Re),Xt=new x2e(ee,_e,nt,ze),Qe=new E2e(ee,_e,nt,ze),nt.programs=oe.programs,w.capabilities=ze,w.extensions=_e,w.properties=Ze,w.renderLists=Me,w.shadowMap=qe,w.state=Re,w.info=nt}je();const Ke=new uke(w,ee);this.xr=Ke,this.getContext=function(){return ee},this.getContextAttributes=function(){return ee.getContextAttributes()},this.forceContextLoss=function(){const Q=_e.get("WEBGL_lose_context");Q&&Q.loseContext()},this.forceContextRestore=function(){const Q=_e.get("WEBGL_lose_context");Q&&Q.restoreContext()},this.getPixelRatio=function(){return q},this.setPixelRatio=function(Q){Q!==void 0&&(q=Q,this.setSize($,J,!1))},this.getSize=function(Q){return Q.set($,J)},this.setSize=function(Q,we,Ae=!0){if(Ke.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}$=Q,J=we,t.width=Math.floor(Q*q),t.height=Math.floor(we*q),Ae===!0&&(t.style.width=Q+"px",t.style.height=we+"px"),this.setViewport(0,0,Q,we)},this.getDrawingBufferSize=function(Q){return Q.set($*q,J*q).floor()},this.setDrawingBufferSize=function(Q,we,Ae){$=Q,J=we,q=Ae,t.width=Math.floor(Q*Ae),t.height=Math.floor(we*Ae),this.setViewport(0,0,Q,we)},this.getCurrentViewport=function(Q){return Q.copy(k)},this.getViewport=function(Q){return Q.copy(j)},this.setViewport=function(Q,we,Ae,Se){Q.isVector4?j.set(Q.x,Q.y,Q.z,Q.w):j.set(Q,we,Ae,Se),Re.viewport(k.copy(j).multiplyScalar(q).floor())},this.getScissor=function(Q){return Q.copy(z)},this.setScissor=function(Q,we,Ae,Se){Q.isVector4?z.set(Q.x,Q.y,Q.z,Q.w):z.set(Q,we,Ae,Se),Re.scissor(P.copy(z).multiplyScalar(q).floor())},this.getScissorTest=function(){return Z},this.setScissorTest=function(Q){Re.setScissorTest(Z=Q)},this.setOpaqueSort=function(Q){O=Q},this.setTransparentSort=function(Q){X=Q},this.getClearColor=function(Q){return Q.copy(at.getClearColor())},this.setClearColor=function(){at.setClearColor.apply(at,arguments)},this.getClearAlpha=function(){return at.getClearAlpha()},this.setClearAlpha=function(){at.setClearAlpha.apply(at,arguments)},this.clear=function(Q=!0,we=!0,Ae=!0){let Se=0;if(Q){let Ee=!1;if(A!==null){const tt=A.texture.format;Ee=tt===HB||tt===WB||tt===$B}if(Ee){const tt=A.texture.type,Ct=tt===Eu||tt===xc||tt===CE||tt===id||tt===VB||tt===UB,Bt=at.getClearColor(),Gt=at.getClearAlpha(),Jt=Bt.r,Zt=Bt.g,Qt=Bt.b;Ct?(p[0]=Jt,p[1]=Zt,p[2]=Qt,p[3]=Gt,ee.clearBufferuiv(ee.COLOR,0,p)):(f[0]=Jt,f[1]=Zt,f[2]=Qt,f[3]=Gt,ee.clearBufferiv(ee.COLOR,0,f))}else Se|=ee.COLOR_BUFFER_BIT}we&&(Se|=ee.DEPTH_BUFFER_BIT),Ae&&(Se|=ee.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),ee.clear(Se)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Pt,!1),t.removeEventListener("webglcontextrestored",G,!1),t.removeEventListener("webglcontextcreationerror",re,!1),Me.dispose(),Ve.dispose(),Ze.dispose(),yt.dispose(),Lt.dispose(),D.dispose(),le.dispose(),Oe.dispose(),oe.dispose(),Ke.dispose(),Ke.removeEventListener("sessionstart",pt),Ke.removeEventListener("sessionend",vt),Ne&&(Ne.dispose(),Ne=null),Tn.stop()};function Pt(Q){Q.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),S=!0}function G(){console.log("THREE.WebGLRenderer: Context Restored."),S=!1;const Q=nt.autoReset,we=qe.enabled,Ae=qe.autoUpdate,Se=qe.needsUpdate,Ee=qe.type;je(),nt.autoReset=Q,qe.enabled=we,qe.autoUpdate=Ae,qe.needsUpdate=Se,qe.type=Ee}function re(Q){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Q.statusMessage)}function pe(Q){const we=Q.target;we.removeEventListener("dispose",pe),de(we)}function de(Q){Te(Q),Ze.remove(Q)}function Te(Q){const we=Ze.get(Q).programs;we!==void 0&&(we.forEach(function(Ae){oe.releaseProgram(Ae)}),Q.isShaderMaterial&&oe.releaseShaderCache(Q))}this.renderBufferDirect=function(Q,we,Ae,Se,Ee,tt){we===null&&(we=Ye);const Ct=Ee.isMesh&&Ee.matrixWorld.determinant()<0,Bt=zs(Q,we,Ae,Se,Ee);Re.setMaterial(Se,Ct);let Gt=Ae.index,Jt=1;if(Se.wireframe===!0){if(Gt=H.getWireframeAttribute(Ae),Gt===void 0)return;Jt=2}const Zt=Ae.drawRange,Qt=Ae.attributes.position;let Ci=Zt.start*Jt,rs=(Zt.start+Zt.count)*Jt;tt!==null&&(Ci=Math.max(Ci,tt.start*Jt),rs=Math.min(rs,(tt.start+tt.count)*Jt)),Gt!==null?(Ci=Math.max(Ci,0),rs=Math.min(rs,Gt.count)):Qt!=null&&(Ci=Math.max(Ci,0),rs=Math.min(rs,Qt.count));const oi=rs-Ci;if(oi<0||oi===1/0)return;le.setup(Ee,Se,Bt,Ae,Gt);let Nr,Ht=Xt;if(Gt!==null&&(Nr=ye.get(Gt),Ht=Qe,Ht.setIndex(Nr)),Ee.isMesh)Se.wireframe===!0?(Re.setLineWidth(Se.wireframeLinewidth*$e()),Ht.setMode(ee.LINES)):Ht.setMode(ee.TRIANGLES);else if(Ee.isLine){let Mt=Se.linewidth;Mt===void 0&&(Mt=1),Re.setLineWidth(Mt*$e()),Ee.isLineSegments?Ht.setMode(ee.LINES):Ee.isLineLoop?Ht.setMode(ee.LINE_LOOP):Ht.setMode(ee.LINE_STRIP)}else Ee.isPoints?Ht.setMode(ee.POINTS):Ee.isSprite&&Ht.setMode(ee.TRIANGLES);if(Ee.isInstancedMesh)Ht.renderInstances(Ci,oi,Ee.count);else if(Ae.isInstancedBufferGeometry){const Mt=Ae._maxInstanceCount!==void 0?Ae._maxInstanceCount:1/0,va=Math.min(Ae.instanceCount,Mt);Ht.renderInstances(Ci,oi,va)}else Ht.render(Ci,oi)};function Je(Q,we,Ae){Q.transparent===!0&&Q.side===$a&&Q.forceSinglePass===!1?(Q.side=Ys,Q.needsUpdate=!0,xa(Q,we,Ae),Q.side=Vl,Q.needsUpdate=!0,xa(Q,we,Ae),Q.side=$a):xa(Q,we,Ae)}this.compile=function(Q,we,Ae=null){Ae===null&&(Ae=Q),y=Ve.get(Ae),y.init(),v.push(y),Ae.traverseVisible(function(Ee){Ee.isLight&&Ee.layers.test(we.layers)&&(y.pushLight(Ee),Ee.castShadow&&y.pushShadow(Ee))}),Q!==Ae&&Q.traverseVisible(function(Ee){Ee.isLight&&Ee.layers.test(we.layers)&&(y.pushLight(Ee),Ee.castShadow&&y.pushShadow(Ee))}),y.setupLights(w._useLegacyLights);const Se=new Set;return Q.traverse(function(Ee){const tt=Ee.material;if(tt)if(Array.isArray(tt))for(let Ct=0;Ct<tt.length;Ct++){const Bt=tt[Ct];Je(Bt,Ae,Ee),Se.add(Bt)}else Je(tt,Ae,Ee),Se.add(tt)}),v.pop(),y=null,Se},this.compileAsync=function(Q,we,Ae=null){const Se=this.compile(Q,we,Ae);return new Promise(Ee=>{function tt(){if(Se.forEach(function(Ct){Ze.get(Ct).currentProgram.isReady()&&Se.delete(Ct)}),Se.size===0){Ee(Q);return}setTimeout(tt,10)}_e.get("KHR_parallel_shader_compile")!==null?tt():setTimeout(tt,10)})};let rt=null;function ht(Q){rt&&rt(Q)}function pt(){Tn.stop()}function vt(){Tn.start()}const Tn=new Cq;Tn.setAnimationLoop(ht),typeof self<"u"&&Tn.setContext(self),this.setAnimationLoop=function(Q){rt=Q,Ke.setAnimationLoop(Q),Q===null?Tn.stop():Tn.start()},Ke.addEventListener("sessionstart",pt),Ke.addEventListener("sessionend",vt),this.render=function(Q,we){if(we!==void 0&&we.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(S===!0)return;Q.matrixWorldAutoUpdate===!0&&Q.updateMatrixWorld(),we.parent===null&&we.matrixWorldAutoUpdate===!0&&we.updateMatrixWorld(),Ke.enabled===!0&&Ke.isPresenting===!0&&(Ke.cameraAutoUpdate===!0&&Ke.updateCamera(we),we=Ke.getCamera()),Q.isScene===!0&&Q.onBeforeRender(w,Q,we,A),y=Ve.get(Q,v.length),y.init(),v.push(y),Fe.multiplyMatrices(we.projectionMatrix,we.matrixWorldInverse),ce.setFromProjectionMatrix(Fe),ge=this.localClippingEnabled,fe=ct.init(this.clippingPlanes,ge),g=Me.get(Q,m.length),g.init(),m.push(g),Ut(Q,we,0,w.sortObjects),g.finish(),w.sortObjects===!0&&g.sort(O,X),this.info.render.frame++,fe===!0&&ct.beginShadows();const Ae=y.state.shadowsArray;if(qe.render(Ae,Q,we),fe===!0&&ct.endShadows(),this.info.autoReset===!0&&this.info.reset(),at.render(g,Q),y.setupLights(w._useLegacyLights),we.isArrayCamera){const Se=we.cameras;for(let Ee=0,tt=Se.length;Ee<tt;Ee++){const Ct=Se[Ee];Nn(g,Q,Ct,Ct.viewport)}}else Nn(g,Q,we);A!==null&&(st.updateMultisampleRenderTarget(A),st.updateRenderTargetMipmap(A)),Q.isScene===!0&&Q.onAfterRender(w,Q,we),le.resetDefaultState(),I=-1,E=null,v.pop(),v.length>0?y=v[v.length-1]:y=null,m.pop(),m.length>0?g=m[m.length-1]:g=null};function Ut(Q,we,Ae,Se){if(Q.visible===!1)return;if(Q.layers.test(we.layers)){if(Q.isGroup)Ae=Q.renderOrder;else if(Q.isLOD)Q.autoUpdate===!0&&Q.update(we);else if(Q.isLight)y.pushLight(Q),Q.castShadow&&y.pushShadow(Q);else if(Q.isSprite){if(!Q.frustumCulled||ce.intersectsSprite(Q)){Se&&Ue.setFromMatrixPosition(Q.matrixWorld).applyMatrix4(Fe);const Ct=D.update(Q),Bt=Q.material;Bt.visible&&g.push(Q,Ct,Bt,Ae,Ue.z,null)}}else if((Q.isMesh||Q.isLine||Q.isPoints)&&(!Q.frustumCulled||ce.intersectsObject(Q))){const Ct=D.update(Q),Bt=Q.material;if(Se&&(Q.boundingSphere!==void 0?(Q.boundingSphere===null&&Q.computeBoundingSphere(),Ue.copy(Q.boundingSphere.center)):(Ct.boundingSphere===null&&Ct.computeBoundingSphere(),Ue.copy(Ct.boundingSphere.center)),Ue.applyMatrix4(Q.matrixWorld).applyMatrix4(Fe)),Array.isArray(Bt)){const Gt=Ct.groups;for(let Jt=0,Zt=Gt.length;Jt<Zt;Jt++){const Qt=Gt[Jt],Ci=Bt[Qt.materialIndex];Ci&&Ci.visible&&g.push(Q,Ct,Ci,Ae,Ue.z,Qt)}}else Bt.visible&&g.push(Q,Ct,Bt,Ae,Ue.z,null)}}const tt=Q.children;for(let Ct=0,Bt=tt.length;Ct<Bt;Ct++)Ut(tt[Ct],we,Ae,Se)}function Nn(Q,we,Ae,Se){const Ee=Q.opaque,tt=Q.transmissive,Ct=Q.transparent;y.setupLightsView(Ae),fe===!0&&ct.setGlobalState(w.clippingPlanes,Ae),tt.length>0&&zn(Ee,tt,we,Ae),Se&&Re.viewport(k.copy(Se)),Ee.length>0&&Fi(Ee,we,Ae),tt.length>0&&Fi(tt,we,Ae),Ct.length>0&&Fi(Ct,we,Ae),Re.buffers.depth.setTest(!0),Re.buffers.depth.setMask(!0),Re.buffers.color.setMask(!0),Re.setPolygonOffset(!1)}function zn(Q,we,Ae,Se){if((Ae.isScene===!0?Ae.overrideMaterial:null)!==null)return;const tt=ze.isWebGL2;Ne===null&&(Ne=new el(1,1,{generateMipmaps:!0,type:_e.has("EXT_color_buffer_half_float")?Cf:Eu,minFilter:qa,samples:tt?4:0})),w.getDrawingBufferSize(We),tt?Ne.setSize(We.x,We.y):Ne.setSize(WM(We.x),WM(We.y));const Ct=w.getRenderTarget();w.setRenderTarget(Ne),w.getClearColor(U),F=w.getClearAlpha(),F<1&&w.setClearColor(16777215,.5),w.clear();const Bt=w.toneMapping;w.toneMapping=Au,Fi(Q,Ae,Se),st.updateMultisampleRenderTarget(Ne),st.updateRenderTargetMipmap(Ne);let Gt=!1;for(let Jt=0,Zt=we.length;Jt<Zt;Jt++){const Qt=we[Jt],Ci=Qt.object,rs=Qt.geometry,oi=Qt.material,Nr=Qt.group;if(oi.side===$a&&Ci.layers.test(Se.layers)){const Ht=oi.side;oi.side=Ys,oi.needsUpdate=!0,xr(Ci,Ae,Se,rs,oi,Nr),oi.side=Ht,oi.needsUpdate=!0,Gt=!0}}Gt===!0&&(st.updateMultisampleRenderTarget(Ne),st.updateRenderTargetMipmap(Ne)),w.setRenderTarget(Ct),w.setClearColor(U,F),w.toneMapping=Bt}function Fi(Q,we,Ae){const Se=we.isScene===!0?we.overrideMaterial:null;for(let Ee=0,tt=Q.length;Ee<tt;Ee++){const Ct=Q[Ee],Bt=Ct.object,Gt=Ct.geometry,Jt=Se===null?Ct.material:Se,Zt=Ct.group;Bt.layers.test(Ae.layers)&&xr(Bt,we,Ae,Gt,Jt,Zt)}}function xr(Q,we,Ae,Se,Ee,tt){Q.onBeforeRender(w,we,Ae,Se,Ee,tt),Q.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse,Q.matrixWorld),Q.normalMatrix.getNormalMatrix(Q.modelViewMatrix),Ee.onBeforeRender(w,we,Ae,Se,Q,tt),Ee.transparent===!0&&Ee.side===$a&&Ee.forceSinglePass===!1?(Ee.side=Ys,Ee.needsUpdate=!0,w.renderBufferDirect(Ae,we,Se,Ee,Q,tt),Ee.side=Vl,Ee.needsUpdate=!0,w.renderBufferDirect(Ae,we,Se,Ee,Q,tt),Ee.side=$a):w.renderBufferDirect(Ae,we,Se,Ee,Q,tt),Q.onAfterRender(w,we,Ae,Se,Ee,tt)}function xa(Q,we,Ae){we.isScene!==!0&&(we=Ye);const Se=Ze.get(Q),Ee=y.state.lights,tt=y.state.shadowsArray,Ct=Ee.state.version,Bt=oe.getParameters(Q,Ee.state,tt,we,Ae),Gt=oe.getProgramCacheKey(Bt);let Jt=Se.programs;Se.environment=Q.isMeshStandardMaterial?we.environment:null,Se.fog=we.fog,Se.envMap=(Q.isMeshStandardMaterial?Lt:yt).get(Q.envMap||Se.environment),Jt===void 0&&(Q.addEventListener("dispose",pe),Jt=new Map,Se.programs=Jt);let Zt=Jt.get(Gt);if(Zt!==void 0){if(Se.currentProgram===Zt&&Se.lightsStateVersion===Ct)return al(Q,Bt),Zt}else Bt.uniforms=oe.getUniforms(Q),Q.onBuild(Ae,Bt,w),Q.onBeforeCompile(Bt,w),Zt=oe.acquireProgram(Bt,Gt),Jt.set(Gt,Zt),Se.uniforms=Bt.uniforms;const Qt=Se.uniforms;return(!Q.isShaderMaterial&&!Q.isRawShaderMaterial||Q.clipping===!0)&&(Qt.clippingPlanes=ct.uniform),al(Q,Bt),Se.needsLights=Hd(Q),Se.lightsStateVersion=Ct,Se.needsLights&&(Qt.ambientLightColor.value=Ee.state.ambient,Qt.lightProbe.value=Ee.state.probe,Qt.directionalLights.value=Ee.state.directional,Qt.directionalLightShadows.value=Ee.state.directionalShadow,Qt.spotLights.value=Ee.state.spot,Qt.spotLightShadows.value=Ee.state.spotShadow,Qt.rectAreaLights.value=Ee.state.rectArea,Qt.ltc_1.value=Ee.state.rectAreaLTC1,Qt.ltc_2.value=Ee.state.rectAreaLTC2,Qt.pointLights.value=Ee.state.point,Qt.pointLightShadows.value=Ee.state.pointShadow,Qt.hemisphereLights.value=Ee.state.hemi,Qt.directionalShadowMap.value=Ee.state.directionalShadowMap,Qt.directionalShadowMatrix.value=Ee.state.directionalShadowMatrix,Qt.spotShadowMap.value=Ee.state.spotShadowMap,Qt.spotLightMatrix.value=Ee.state.spotLightMatrix,Qt.spotLightMap.value=Ee.state.spotLightMap,Qt.pointShadowMap.value=Ee.state.pointShadowMap,Qt.pointShadowMatrix.value=Ee.state.pointShadowMatrix),Se.currentProgram=Zt,Se.uniformsList=null,Zt}function rh(Q){if(Q.uniformsList===null){const we=Q.currentProgram.getUniforms();Q.uniformsList=H_.seqWithValue(we.seq,Q.uniforms)}return Q.uniformsList}function al(Q,we){const Ae=Ze.get(Q);Ae.outputColorSpace=we.outputColorSpace,Ae.instancing=we.instancing,Ae.instancingColor=we.instancingColor,Ae.skinning=we.skinning,Ae.morphTargets=we.morphTargets,Ae.morphNormals=we.morphNormals,Ae.morphColors=we.morphColors,Ae.morphTargetsCount=we.morphTargetsCount,Ae.numClippingPlanes=we.numClippingPlanes,Ae.numIntersection=we.numClipIntersection,Ae.vertexAlphas=we.vertexAlphas,Ae.vertexTangents=we.vertexTangents,Ae.toneMapping=we.toneMapping}function zs(Q,we,Ae,Se,Ee){we.isScene!==!0&&(we=Ye),st.resetTextureUnits();const tt=we.fog,Ct=Se.isMeshStandardMaterial?we.environment:null,Bt=A===null?w.outputColorSpace:A.isXRRenderTarget===!0?A.texture.colorSpace:Zr,Gt=(Se.isMeshStandardMaterial?Lt:yt).get(Se.envMap||Ct),Jt=Se.vertexColors===!0&&!!Ae.attributes.color&&Ae.attributes.color.itemSize===4,Zt=!!Ae.attributes.tangent&&(!!Se.normalMap||Se.anisotropy>0),Qt=!!Ae.morphAttributes.position,Ci=!!Ae.morphAttributes.normal,rs=!!Ae.morphAttributes.color;let oi=Au;Se.toneMapped&&(A===null||A.isXRRenderTarget===!0)&&(oi=w.toneMapping);const Nr=Ae.morphAttributes.position||Ae.morphAttributes.normal||Ae.morphAttributes.color,Ht=Nr!==void 0?Nr.length:0,Mt=Ze.get(Se),va=y.state.lights;if(fe===!0&&(ge===!0||Q!==E)){const Pr=Q===E&&Se.id===I;ct.setState(Se,Q,Pr)}let xn=!1;Se.version===Mt.__version?(Mt.needsLights&&Mt.lightsStateVersion!==va.state.version||Mt.outputColorSpace!==Bt||Ee.isInstancedMesh&&Mt.instancing===!1||!Ee.isInstancedMesh&&Mt.instancing===!0||Ee.isSkinnedMesh&&Mt.skinning===!1||!Ee.isSkinnedMesh&&Mt.skinning===!0||Ee.isInstancedMesh&&Mt.instancingColor===!0&&Ee.instanceColor===null||Ee.isInstancedMesh&&Mt.instancingColor===!1&&Ee.instanceColor!==null||Mt.envMap!==Gt||Se.fog===!0&&Mt.fog!==tt||Mt.numClippingPlanes!==void 0&&(Mt.numClippingPlanes!==ct.numPlanes||Mt.numIntersection!==ct.numIntersection)||Mt.vertexAlphas!==Jt||Mt.vertexTangents!==Zt||Mt.morphTargets!==Qt||Mt.morphNormals!==Ci||Mt.morphColors!==rs||Mt.toneMapping!==oi||ze.isWebGL2===!0&&Mt.morphTargetsCount!==Ht)&&(xn=!0):(xn=!0,Mt.__version=Se.version);let Oi=Mt.currentProgram;xn===!0&&(Oi=xa(Se,we,Ee));let Ql=!1,wa=!1,Lr=!1;const or=Oi.getUniforms(),ql=Mt.uniforms;if(Re.useProgram(Oi.program)&&(Ql=!0,wa=!0,Lr=!0),Se.id!==I&&(I=Se.id,wa=!0),Ql||E!==Q){or.setValue(ee,"projectionMatrix",Q.projectionMatrix),or.setValue(ee,"viewMatrix",Q.matrixWorldInverse);const Pr=or.map.cameraPosition;Pr!==void 0&&Pr.setValue(ee,Ue.setFromMatrixPosition(Q.matrixWorld)),ze.logarithmicDepthBuffer&&or.setValue(ee,"logDepthBufFC",2/(Math.log(Q.far+1)/Math.LN2)),(Se.isMeshPhongMaterial||Se.isMeshToonMaterial||Se.isMeshLambertMaterial||Se.isMeshBasicMaterial||Se.isMeshStandardMaterial||Se.isShaderMaterial)&&or.setValue(ee,"isOrthographic",Q.isOrthographicCamera===!0),E!==Q&&(E=Q,wa=!0,Lr=!0)}if(Ee.isSkinnedMesh){or.setOptional(ee,Ee,"bindMatrix"),or.setOptional(ee,Ee,"bindMatrixInverse");const Pr=Ee.skeleton;Pr&&(ze.floatVertexTextures?(Pr.boneTexture===null&&Pr.computeBoneTexture(),or.setValue(ee,"boneTexture",Pr.boneTexture,st),or.setValue(ee,"boneTextureSize",Pr.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const km=Ae.morphAttributes;if((km.position!==void 0||km.normal!==void 0||km.color!==void 0&&ze.isWebGL2===!0)&&Ot.update(Ee,Ae,Oi),(wa||Mt.receiveShadow!==Ee.receiveShadow)&&(Mt.receiveShadow=Ee.receiveShadow,or.setValue(ee,"receiveShadow",Ee.receiveShadow)),Se.isMeshGouraudMaterial&&Se.envMap!==null&&(ql.envMap.value=Gt,ql.flipEnvMap.value=Gt.isCubeTexture&&Gt.isRenderTargetTexture===!1?-1:1),wa&&(or.setValue(ee,"toneMappingExposure",w.toneMappingExposure),Mt.needsLights&&sh(ql,Lr),tt&&Se.fog===!0&&Ie.refreshFogUniforms(ql,tt),Ie.refreshMaterialUniforms(ql,Se,q,J,Ne),H_.upload(ee,rh(Mt),ql,st)),Se.isShaderMaterial&&Se.uniformsNeedUpdate===!0&&(H_.upload(ee,rh(Mt),ql,st),Se.uniformsNeedUpdate=!1),Se.isSpriteMaterial&&or.setValue(ee,"center",Ee.center),or.setValue(ee,"modelViewMatrix",Ee.modelViewMatrix),or.setValue(ee,"normalMatrix",Ee.normalMatrix),or.setValue(ee,"modelMatrix",Ee.matrixWorld),Se.isShaderMaterial||Se.isRawShaderMaterial){const Pr=Se.uniformsGroups;for(let Rm=0,Oo=Pr.length;Rm<Oo;Rm++)if(ze.isWebGL2){const VS=Pr[Rm];Oe.update(VS,Oi),Oe.bind(VS,Oi)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Oi}function sh(Q,we){Q.ambientLightColor.needsUpdate=we,Q.lightProbe.needsUpdate=we,Q.directionalLights.needsUpdate=we,Q.directionalLightShadows.needsUpdate=we,Q.pointLights.needsUpdate=we,Q.pointLightShadows.needsUpdate=we,Q.spotLights.needsUpdate=we,Q.spotLightShadows.needsUpdate=we,Q.rectAreaLights.needsUpdate=we,Q.hemisphereLights.needsUpdate=we}function Hd(Q){return Q.isMeshLambertMaterial||Q.isMeshToonMaterial||Q.isMeshPhongMaterial||Q.isMeshStandardMaterial||Q.isShadowMaterial||Q.isShaderMaterial&&Q.lights===!0}this.getActiveCubeFace=function(){return C},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return A},this.setRenderTargetTextures=function(Q,we,Ae){Ze.get(Q.texture).__webglTexture=we,Ze.get(Q.depthTexture).__webglTexture=Ae;const Se=Ze.get(Q);Se.__hasExternalTextures=!0,Se.__hasExternalTextures&&(Se.__autoAllocateDepthBuffer=Ae===void 0,Se.__autoAllocateDepthBuffer||_e.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Se.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(Q,we){const Ae=Ze.get(Q);Ae.__webglFramebuffer=we,Ae.__useDefaultFramebuffer=we===void 0},this.setRenderTarget=function(Q,we=0,Ae=0){A=Q,C=we,_=Ae;let Se=!0,Ee=null,tt=!1,Ct=!1;if(Q){const Gt=Ze.get(Q);Gt.__useDefaultFramebuffer!==void 0?(Re.bindFramebuffer(ee.FRAMEBUFFER,null),Se=!1):Gt.__webglFramebuffer===void 0?st.setupRenderTarget(Q):Gt.__hasExternalTextures&&st.rebindTextures(Q,Ze.get(Q.texture).__webglTexture,Ze.get(Q.depthTexture).__webglTexture);const Jt=Q.texture;(Jt.isData3DTexture||Jt.isDataArrayTexture||Jt.isCompressedArrayTexture)&&(Ct=!0);const Zt=Ze.get(Q).__webglFramebuffer;Q.isWebGLCubeRenderTarget?(Array.isArray(Zt[we])?Ee=Zt[we][Ae]:Ee=Zt[we],tt=!0):ze.isWebGL2&&Q.samples>0&&st.useMultisampledRTT(Q)===!1?Ee=Ze.get(Q).__webglMultisampledFramebuffer:Array.isArray(Zt)?Ee=Zt[Ae]:Ee=Zt,k.copy(Q.viewport),P.copy(Q.scissor),V=Q.scissorTest}else k.copy(j).multiplyScalar(q).floor(),P.copy(z).multiplyScalar(q).floor(),V=Z;if(Re.bindFramebuffer(ee.FRAMEBUFFER,Ee)&&ze.drawBuffers&&Se&&Re.drawBuffers(Q,Ee),Re.viewport(k),Re.scissor(P),Re.setScissorTest(V),tt){const Gt=Ze.get(Q.texture);ee.framebufferTexture2D(ee.FRAMEBUFFER,ee.COLOR_ATTACHMENT0,ee.TEXTURE_CUBE_MAP_POSITIVE_X+we,Gt.__webglTexture,Ae)}else if(Ct){const Gt=Ze.get(Q.texture),Jt=we||0;ee.framebufferTextureLayer(ee.FRAMEBUFFER,ee.COLOR_ATTACHMENT0,Gt.__webglTexture,Ae||0,Jt)}I=-1},this.readRenderTargetPixels=function(Q,we,Ae,Se,Ee,tt,Ct){if(!(Q&&Q.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Bt=Ze.get(Q).__webglFramebuffer;if(Q.isWebGLCubeRenderTarget&&Ct!==void 0&&(Bt=Bt[Ct]),Bt){Re.bindFramebuffer(ee.FRAMEBUFFER,Bt);try{const Gt=Q.texture,Jt=Gt.format,Zt=Gt.type;if(Jt!==xo&&sn.convert(Jt)!==ee.getParameter(ee.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Qt=Zt===Cf&&(_e.has("EXT_color_buffer_half_float")||ze.isWebGL2&&_e.has("EXT_color_buffer_float"));if(Zt!==Eu&&sn.convert(Zt)!==ee.getParameter(ee.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Zt===Ml&&(ze.isWebGL2||_e.has("OES_texture_float")||_e.has("WEBGL_color_buffer_float")))&&!Qt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}we>=0&&we<=Q.width-Se&&Ae>=0&&Ae<=Q.height-Ee&&ee.readPixels(we,Ae,Se,Ee,sn.convert(Jt),sn.convert(Zt),tt)}finally{const Gt=A!==null?Ze.get(A).__webglFramebuffer:null;Re.bindFramebuffer(ee.FRAMEBUFFER,Gt)}}},this.copyFramebufferToTexture=function(Q,we,Ae=0){const Se=Math.pow(2,-Ae),Ee=Math.floor(we.image.width*Se),tt=Math.floor(we.image.height*Se);st.setTexture2D(we,0),ee.copyTexSubImage2D(ee.TEXTURE_2D,Ae,0,0,Q.x,Q.y,Ee,tt),Re.unbindTexture()},this.copyTextureToTexture=function(Q,we,Ae,Se=0){const Ee=we.image.width,tt=we.image.height,Ct=sn.convert(Ae.format),Bt=sn.convert(Ae.type);st.setTexture2D(Ae,0),ee.pixelStorei(ee.UNPACK_FLIP_Y_WEBGL,Ae.flipY),ee.pixelStorei(ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Ae.premultiplyAlpha),ee.pixelStorei(ee.UNPACK_ALIGNMENT,Ae.unpackAlignment),we.isDataTexture?ee.texSubImage2D(ee.TEXTURE_2D,Se,Q.x,Q.y,Ee,tt,Ct,Bt,we.image.data):we.isCompressedTexture?ee.compressedTexSubImage2D(ee.TEXTURE_2D,Se,Q.x,Q.y,we.mipmaps[0].width,we.mipmaps[0].height,Ct,we.mipmaps[0].data):ee.texSubImage2D(ee.TEXTURE_2D,Se,Q.x,Q.y,Ct,Bt,we.image),Se===0&&Ae.generateMipmaps&&ee.generateMipmap(ee.TEXTURE_2D),Re.unbindTexture()},this.copyTextureToTexture3D=function(Q,we,Ae,Se,Ee=0){if(w.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const tt=Q.max.x-Q.min.x+1,Ct=Q.max.y-Q.min.y+1,Bt=Q.max.z-Q.min.z+1,Gt=sn.convert(Se.format),Jt=sn.convert(Se.type);let Zt;if(Se.isData3DTexture)st.setTexture3D(Se,0),Zt=ee.TEXTURE_3D;else if(Se.isDataArrayTexture)st.setTexture2DArray(Se,0),Zt=ee.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ee.pixelStorei(ee.UNPACK_FLIP_Y_WEBGL,Se.flipY),ee.pixelStorei(ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Se.premultiplyAlpha),ee.pixelStorei(ee.UNPACK_ALIGNMENT,Se.unpackAlignment);const Qt=ee.getParameter(ee.UNPACK_ROW_LENGTH),Ci=ee.getParameter(ee.UNPACK_IMAGE_HEIGHT),rs=ee.getParameter(ee.UNPACK_SKIP_PIXELS),oi=ee.getParameter(ee.UNPACK_SKIP_ROWS),Nr=ee.getParameter(ee.UNPACK_SKIP_IMAGES),Ht=Ae.isCompressedTexture?Ae.mipmaps[0]:Ae.image;ee.pixelStorei(ee.UNPACK_ROW_LENGTH,Ht.width),ee.pixelStorei(ee.UNPACK_IMAGE_HEIGHT,Ht.height),ee.pixelStorei(ee.UNPACK_SKIP_PIXELS,Q.min.x),ee.pixelStorei(ee.UNPACK_SKIP_ROWS,Q.min.y),ee.pixelStorei(ee.UNPACK_SKIP_IMAGES,Q.min.z),Ae.isDataTexture||Ae.isData3DTexture?ee.texSubImage3D(Zt,Ee,we.x,we.y,we.z,tt,Ct,Bt,Gt,Jt,Ht.data):Ae.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ee.compressedTexSubImage3D(Zt,Ee,we.x,we.y,we.z,tt,Ct,Bt,Gt,Ht.data)):ee.texSubImage3D(Zt,Ee,we.x,we.y,we.z,tt,Ct,Bt,Gt,Jt,Ht),ee.pixelStorei(ee.UNPACK_ROW_LENGTH,Qt),ee.pixelStorei(ee.UNPACK_IMAGE_HEIGHT,Ci),ee.pixelStorei(ee.UNPACK_SKIP_PIXELS,rs),ee.pixelStorei(ee.UNPACK_SKIP_ROWS,oi),ee.pixelStorei(ee.UNPACK_SKIP_IMAGES,Nr),Ee===0&&Se.generateMipmaps&&ee.generateMipmap(Zt),Re.unbindTexture()},this.initTexture=function(Q){Q.isCubeTexture?st.setTextureCube(Q,0):Q.isData3DTexture?st.setTexture3D(Q,0):Q.isDataArrayTexture||Q.isCompressedArrayTexture?st.setTexture2DArray(Q,0):st.setTexture2D(Q,0),Re.unbindTexture()},this.resetState=function(){C=0,_=0,A=null,Re.reset(),le.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return xu}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===ME?"display-p3":"srgb",t.unpackColorSpace=Fn.workingColorSpace===$1?"display-p3":"srgb"}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(e){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!e}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===bi?Ec:ZB}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===Ec?bi:Zr}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class Rq extends kE{}Rq.prototype.isWebGL1Renderer=!0;class RE{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new lt(e),this.density=t}clone(){return new RE(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class NE{constructor(e,t=1,i=1e3){this.isFog=!0,this.name="",this.color=new lt(e),this.near=t,this.far=i}clone(){return new NE(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Ey extends yn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class n0{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Yv,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=sa()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let r=0,s=this.stride;r<s;r++)this.array[e+r]=t.array[i+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=sa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=sa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Us=new Y;class Oc{constructor(e,t,i,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)Us.fromBufferAttribute(this,t),Us.applyMatrix4(e),this.setXYZ(t,Us.x,Us.y,Us.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Us.fromBufferAttribute(this,t),Us.applyNormalMatrix(e),this.setXYZ(t,Us.x,Us.y,Us.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Us.fromBufferAttribute(this,t),Us.transformDirection(e),this.setXYZ(t,Us.x,Us.y,Us.z);return this}setX(e,t){return this.normalized&&(t=an(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=an(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=an(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=an(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=vo(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=vo(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=vo(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=vo(t,this.array)),t}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=an(t,this.array),i=an(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=an(t,this.array),i=an(i,this.array),r=an(r,this.array),s=an(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return new En(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Oc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class rz extends Pi{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new lt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let lg;const hx=new Y,ug=new Y,cg=new Y,hg=new Ge,dx=new Ge,Nq=new Ft,MC=new Y,px=new Y,AC=new Y,A5=new Ge,hL=new Ge,E5=new Ge;class Lq extends yn{constructor(e=new rz){if(super(),this.isSprite=!0,this.type="Sprite",lg===void 0){lg=new rn;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new n0(t,5);lg.setIndex([0,1,2,0,2,3]),lg.setAttribute("position",new Oc(i,3,0,!1)),lg.setAttribute("uv",new Oc(i,2,3,!1))}this.geometry=lg,this.material=e,this.center=new Ge(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ug.setFromMatrixScale(this.matrixWorld),Nq.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),cg.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&ug.multiplyScalar(-cg.z);const i=this.material.rotation;let r,s;i!==0&&(s=Math.cos(i),r=Math.sin(i));const o=this.center;EC(MC.set(-.5,-.5,0),cg,o,ug,r,s),EC(px.set(.5,-.5,0),cg,o,ug,r,s),EC(AC.set(.5,.5,0),cg,o,ug,r,s),A5.set(0,0),hL.set(1,0),E5.set(1,1);let a=e.ray.intersectTriangle(MC,px,AC,!1,hx);if(a===null&&(EC(px.set(-.5,.5,0),cg,o,ug,r,s),hL.set(0,1),a=e.ray.intersectTriangle(MC,AC,px,!1,hx),a===null))return;const l=e.ray.origin.distanceTo(hx);l<e.near||l>e.far||t.push({distance:l,point:hx.clone(),uv:bo.getInterpolation(hx,MC,px,AC,A5,hL,E5,new Ge),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function EC(n,e,t,i,r,s){hg.subVectors(n,t).addScalar(.5).multiply(i),r!==void 0?(dx.x=s*hg.x-r*hg.y,dx.y=r*hg.x+s*hg.y):dx.copy(hg),n.copy(e),n.x+=dx.x,n.y+=dx.y,n.applyMatrix4(Nq)}const IC=new Y,I5=new Y;class Pq extends yn{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let i=0,r=t.length;i<r;i++){const s=t[i];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,i=0){t=Math.abs(t);const r=this.levels;let s;for(s=0;s<r.length&&!(t<r[s].distance);s++);return r.splice(s,0,{distance:t,hysteresis:i,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let i,r;for(i=1,r=t.length;i<r;i++){let s=t[i].distance;if(t[i].object.visible&&(s-=s*t[i].hysteresis),e<s)break}return t[i-1].object}return null}raycast(e,t){if(this.levels.length>0){IC.setFromMatrixPosition(this.matrixWorld);const r=e.ray.origin.distanceTo(IC);this.getObjectForDistance(r).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){IC.setFromMatrixPosition(e.matrixWorld),I5.setFromMatrixPosition(this.matrixWorld);const i=IC.distanceTo(I5)/e.zoom;t[0].object.visible=!0;let r,s;for(r=1,s=t.length;r<s;r++){let o=t[r].distance;if(t[r].object.visible&&(o-=o*t[r].hysteresis),i>=o)t[r-1].object.visible=!1,t[r].object.visible=!0;else break}for(this._currentLevel=r-1;r<s;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const i=this.levels;for(let r=0,s=i.length;r<s;r++){const o=i[r];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const k5=new Y,R5=new Gn,N5=new Gn,dke=new Y,L5=new Ft,kC=new Y,dL=new ya,P5=new Ft,pL=new sm;class LE extends pr{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=s3,this.bindMatrix=new Ft,this.bindMatrixInverse=new Ft,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new nl),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,kC),this.boundingBox.expandByPoint(kC)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ya),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,kC),this.boundingSphere.expandByPoint(kC)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const i=this.material,r=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),dL.copy(this.boundingSphere),dL.applyMatrix4(r),e.ray.intersectsSphere(dL)!==!1&&(P5.copy(r).invert(),pL.copy(e.ray).applyMatrix4(P5),!(this.boundingBox!==null&&pL.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,pL)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Gn,t=this.geometry.attributes.skinWeight;for(let i=0,r=t.count;i<r;i++){e.fromBufferAttribute(t,i);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===s3?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===HQ?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const i=this.skeleton,r=this.geometry;R5.fromBufferAttribute(r.attributes.skinIndex,e),N5.fromBufferAttribute(r.attributes.skinWeight,e),k5.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=N5.getComponent(s);if(o!==0){const a=R5.getComponent(s);L5.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),t.addScaledVector(dke.copy(k5).applyMatrix4(L5),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class K1 extends yn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class sy extends ni{constructor(e=null,t=1,i=1,r,s,o,a,l,u=Ei,c=Ei,h,d){super(null,o,a,l,u,c,r,s,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const D5=new Ft,pke=new Ft;class i0{constructor(e=[],t=[]){this.uuid=sa(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,r=this.bones.length;i<r;i++)this.boneInverses.push(new Ft)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const i=new Ft;this.bones[e]&&i.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&i.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,r=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:pke;D5.multiplyMatrices(a,t[s]),D5.toArray(i,s*16)}r!==null&&(r.needsUpdate=!0)}clone(){return new i0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=mq(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new sy(t,e,e,xo,Ml);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,r=e.bones.length;i<r;i++){const s=e.bones[i];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new K1),this.bones.push(o),this.boneInverses.push(new Ft().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let r=0,s=t.length;r<s;r++){const o=t[r];e.bones.push(o.uuid);const a=i[r];e.boneInverses.push(a.toArray())}return e}}class Ef extends En{constructor(e,t,i,r=1){super(e,t,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const dg=new Ft,F5=new Ft,RC=[],O5=new nl,fke=new Ft,fx=new pr,mx=new ya;class PE extends pr{constructor(e,t,i){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Ef(new Float32Array(i*16),16),this.instanceColor=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let r=0;r<i;r++)this.setMatrixAt(r,fke)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new nl),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,dg),O5.copy(e.boundingBox).applyMatrix4(dg),this.boundingBox.union(O5)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new ya),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,dg),mx.copy(e.boundingSphere).applyMatrix4(dg),this.boundingSphere.union(mx)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const i=this.matrixWorld,r=this.count;if(fx.geometry=this.geometry,fx.material=this.material,fx.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),mx.copy(this.boundingSphere),mx.applyMatrix4(i),e.ray.intersectsSphere(mx)!==!1))for(let s=0;s<r;s++){this.getMatrixAt(s,dg),F5.multiplyMatrices(i,dg),fx.matrixWorld=F5,fx.raycast(e,RC);for(let o=0,a=RC.length;o<a;o++){const l=RC[o];l.instanceId=s,l.object=this,t.push(l)}RC.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Ef(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class ps extends Pi{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new lt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const B5=new Y,z5=new Y,G5=new Ft,fL=new sm,NC=new ya;class Fu extends yn{constructor(e=new rn,t=new ps){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[0];for(let r=1,s=t.count;r<s;r++)B5.fromBufferAttribute(t,r-1),z5.fromBufferAttribute(t,r),i[r]=i[r-1],i[r]+=B5.distanceTo(z5);e.setAttribute("lineDistance",new It(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),NC.copy(i.boundingSphere),NC.applyMatrix4(r),NC.radius+=s,e.ray.intersectsSphere(NC)===!1)return;G5.copy(r).invert(),fL.copy(e.ray).applyMatrix4(G5);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=new Y,c=new Y,h=new Y,d=new Y,p=this.isLineSegments?2:1,f=i.index,y=i.attributes.position;if(f!==null){const m=Math.max(0,o.start),v=Math.min(f.count,o.start+o.count);for(let w=m,S=v-1;w<S;w+=p){const C=f.getX(w),_=f.getX(w+1);if(u.fromBufferAttribute(y,C),c.fromBufferAttribute(y,_),fL.distanceSqToSegment(u,c,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(d);I<e.near||I>e.far||t.push({distance:I,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}else{const m=Math.max(0,o.start),v=Math.min(y.count,o.start+o.count);for(let w=m,S=v-1;w<S;w+=p){if(u.fromBufferAttribute(y,w),c.fromBufferAttribute(y,w+1),fL.distanceSqToSegment(u,c,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const _=e.ray.origin.distanceTo(d);_<e.near||_>e.far||t.push({distance:_,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const V5=new Y,U5=new Y;class il extends Fu{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[];for(let r=0,s=t.count;r<s;r+=2)V5.fromBufferAttribute(t,r),U5.fromBufferAttribute(t,r+1),i[r]=r===0?0:i[r-1],i[r+1]=i[r]+V5.distanceTo(U5);e.setAttribute("lineDistance",new It(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class DE extends Fu{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class Z1 extends Pi{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new lt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const $5=new Ft,F3=new sm,LC=new ya,PC=new Y;class FE extends yn{constructor(e=new rn,t=new Z1){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),LC.copy(i.boundingSphere),LC.applyMatrix4(r),LC.radius+=s,e.ray.intersectsSphere(LC)===!1)return;$5.copy(r).invert(),F3.copy(e.ray).applyMatrix4($5);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=i.index,h=i.attributes.position;if(u!==null){const d=Math.max(0,o.start),p=Math.min(u.count,o.start+o.count);for(let f=d,g=p;f<g;f++){const y=u.getX(f);PC.fromBufferAttribute(h,y),W5(PC,y,l,r,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let f=d,g=p;f<g;f++)PC.fromBufferAttribute(h,f),W5(PC,f,l,r,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function W5(n,e,t,i,r,s,o){const a=F3.distanceSqToPoint(n);if(a<t){const l=new Y;F3.closestPointToPoint(n,l),l.applyMatrix4(i);const u=r.ray.origin.distanceTo(l);if(u<r.near||u>r.far)return;s.push({distance:u,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class mke extends ni{constructor(e,t,i,r,s,o,a,l,u){super(e,t,i,r,s,o,a,l,u),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:Zn,this.magFilter=s!==void 0?s:Zn,this.generateMipmaps=!1;const c=this;function h(){c.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class gke extends ni{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=Ei,this.minFilter=Ei,this.generateMipmaps=!1,this.needsUpdate=!0}}class OE extends ni{constructor(e,t,i,r,s,o,a,l,u,c,h,d){super(null,o,a,l,u,c,r,s,h,d),this.isCompressedTexture=!0,this.image={width:t,height:i},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class yke extends OE{constructor(e,t,i,r,s,o){super(e,t,i,s,o),this.isCompressedArrayTexture=!0,this.image.depth=r,this.wrapR=$r}}class bke extends OE{constructor(e,t,i){super(void 0,e[0].width,e[0].height,t,i,Dc),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class xke extends ni{constructor(e,t,i,r,s,o,a,l,u){super(e,t,i,r,s,o,a,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Xl{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,r=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)i=this.getPoint(o/e),s+=i.distanceTo(r),t.push(s),r=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let r=0;const s=i.length;let o;t?o=t:o=e*i[s-1];let a=0,l=s-1,u;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),u=i[r]-o,u<0)a=r+1;else if(u>0)l=r-1;else{l=r;break}if(r=l,i[r]===o)return r/(s-1);const c=i[r],d=i[r+1]-c,p=(o-c)/d;return(r+p)/(s-1)}getTangent(e,t){let r=e-1e-4,s=e+1e-4;r<0&&(r=0),s>1&&(s=1);const o=this.getPoint(r),a=this.getPoint(s),l=t||(o.isVector2?new Ge:new Y);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new Y,r=[],s=[],o=[],a=new Y,l=new Ft;for(let p=0;p<=e;p++){const f=p/e;r[p]=this.getTangentAt(f,new Y)}s[0]=new Y,o[0]=new Y;let u=Number.MAX_VALUE;const c=Math.abs(r[0].x),h=Math.abs(r[0].y),d=Math.abs(r[0].z);c<=u&&(u=c,i.set(1,0,0)),h<=u&&(u=h,i.set(0,1,0)),d<=u&&i.set(0,0,1),a.crossVectors(r[0],i).normalize(),s[0].crossVectors(r[0],a),o[0].crossVectors(r[0],s[0]);for(let p=1;p<=e;p++){if(s[p]=s[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(r[p-1],r[p]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Ui(r[p-1].dot(r[p]),-1,1));s[p].applyMatrix4(l.makeRotationAxis(a,f))}o[p].crossVectors(r[p],s[p])}if(t===!0){let p=Math.acos(Ui(s[0].dot(s[e]),-1,1));p/=e,r[0].dot(a.crossVectors(s[0],s[e]))>0&&(p=-p);for(let f=1;f<=e;f++)s[f].applyMatrix4(l.makeRotationAxis(r[f],p*f)),o[f].crossVectors(r[f],s[f])}return{tangents:r,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class BE extends Xl{constructor(e=0,t=0,i=1,r=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const i=t||new Ge,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(o?s=0:s=r),this.aClockwise===!0&&!o&&(s===r?s=-r:s=s-r);const a=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(a),u=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const c=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,p=u-this.aY;l=d*c-p*h+this.aX,u=d*h+p*c+this.aY}return i.set(l,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class Dq extends BE{constructor(e,t,i,r,s,o){super(e,t,i,i,r,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}function sz(){let n=0,e=0,t=0,i=0;function r(s,o,a,l){n=s,e=a,t=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,u){r(o,a,u*(a-s),u*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,u,c,h){let d=(o-s)/u-(a-s)/(u+c)+(a-o)/c,p=(a-o)/c-(l-o)/(c+h)+(l-a)/h;d*=c,p*=c,r(o,a,d,p)},calc:function(s){const o=s*s,a=o*s;return n+e*s+t*o+i*a}}}const DC=new Y,mL=new sz,gL=new sz,yL=new sz;class Fq extends Xl{constructor(e=[],t=!1,i="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=r}getPoint(e,t=new Y){const i=t,r=this.points,s=r.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let u,c;this.closed||a>0?u=r[(a-1)%s]:(DC.subVectors(r[0],r[1]).add(r[0]),u=DC);const h=r[a%s],d=r[(a+1)%s];if(this.closed||a+2<s?c=r[(a+2)%s]:(DC.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=DC),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(u.distanceToSquared(h),p),g=Math.pow(h.distanceToSquared(d),p),y=Math.pow(d.distanceToSquared(c),p);g<1e-4&&(g=1),f<1e-4&&(f=g),y<1e-4&&(y=g),mL.initNonuniformCatmullRom(u.x,h.x,d.x,c.x,f,g,y),gL.initNonuniformCatmullRom(u.y,h.y,d.y,c.y,f,g,y),yL.initNonuniformCatmullRom(u.z,h.z,d.z,c.z,f,g,y)}else this.curveType==="catmullrom"&&(mL.initCatmullRom(u.x,h.x,d.x,c.x,this.tension),gL.initCatmullRom(u.y,h.y,d.y,c.y,this.tension),yL.initCatmullRom(u.z,h.z,d.z,c.z,this.tension));return i.set(mL.calc(l),gL.calc(l),yL.calc(l)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new Y().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function H5(n,e,t,i,r){const s=(i-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*i+s+o)*l+(-3*t+3*i-2*s-o)*a+s*n+t}function vke(n,e){const t=1-n;return t*t*e}function wke(n,e){return 2*(1-n)*n*e}function Ske(n,e){return n*n*e}function dv(n,e,t,i){return vke(n,e)+wke(n,t)+Ske(n,i)}function Tke(n,e){const t=1-n;return t*t*t*e}function Cke(n,e){const t=1-n;return 3*t*t*n*e}function _ke(n,e){return 3*(1-n)*n*n*e}function Mke(n,e){return n*n*n*e}function pv(n,e,t,i,r){return Tke(n,e)+Cke(n,t)+_ke(n,i)+Mke(n,r)}class oz extends Xl{constructor(e=new Ge,t=new Ge,i=new Ge,r=new Ge){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Ge){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(pv(e,r.x,s.x,o.x,a.x),pv(e,r.y,s.y,o.y,a.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class Oq extends Xl{constructor(e=new Y,t=new Y,i=new Y,r=new Y){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Y){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(pv(e,r.x,s.x,o.x,a.x),pv(e,r.y,s.y,o.y,a.y),pv(e,r.z,s.z,o.z,a.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class az extends Xl{constructor(e=new Ge,t=new Ge){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ge){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Ge){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Bq extends Xl{constructor(e=new Y,t=new Y){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new Y){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Y){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class lz extends Xl{constructor(e=new Ge,t=new Ge,i=new Ge){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Ge){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(dv(e,r.x,s.x,o.x),dv(e,r.y,s.y,o.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class uz extends Xl{constructor(e=new Y,t=new Y,i=new Y){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Y){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(dv(e,r.x,s.x,o.x),dv(e,r.y,s.y,o.y),dv(e,r.z,s.z,o.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class cz extends Xl{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Ge){const i=t,r=this.points,s=(r.length-1)*e,o=Math.floor(s),a=s-o,l=r[o===0?o:o-1],u=r[o],c=r[o>r.length-2?r.length-1:o+1],h=r[o>r.length-3?r.length-1:o+2];return i.set(H5(a,l.x,u.x,c.x,h.x),H5(a,l.y,u.y,c.y,h.y)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new Ge().fromArray(r))}return this}}var HM=Object.freeze({__proto__:null,ArcCurve:Dq,CatmullRomCurve3:Fq,CubicBezierCurve:oz,CubicBezierCurve3:Oq,EllipseCurve:BE,LineCurve:az,LineCurve3:Bq,QuadraticBezierCurve:lz,QuadraticBezierCurve3:uz,SplineCurve:cz});class zq extends Xl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const i=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new HM[i](t,e))}return this}getPoint(e,t){const i=e*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=i){const o=r[s]-i,a=this.curves[s],l=a.getLength(),u=l===0?0:1-o/l;return a.getPointAt(u,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let i=0,r=this.curves.length;i<r;i++)t+=this.curves[i].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let i;for(let r=0,s=this.curves;r<s.length;r++){const o=s[r],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let u=0;u<l.length;u++){const c=l[u];i&&i.equals(c)||(t.push(c),i=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(new HM[r.type]().fromJSON(r))}return this}}class qv extends zq{constructor(e){super(),this.type="Path",this.currentPoint=new Ge,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const i=new az(this.currentPoint.clone(),new Ge(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,r){const s=new lz(this.currentPoint.clone(),new Ge(e,t),new Ge(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}bezierCurveTo(e,t,i,r,s,o){const a=new oz(this.currentPoint.clone(),new Ge(e,t),new Ge(i,r),new Ge(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),i=new cz(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,r,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,i,r,s,o),this}absarc(e,t,i,r,s,o){return this.absellipse(e,t,i,i,r,s,o),this}ellipse(e,t,i,r,s,o,a,l){const u=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+u,t+c,i,r,s,o,a,l),this}absellipse(e,t,i,r,s,o,a,l){const u=new BE(e,t,i,r,s,o,a,l);if(this.curves.length>0){const h=u.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(u);const c=u.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class j1 extends rn{constructor(e=[new Ge(0,-.5),new Ge(.5,0),new Ge(0,.5)],t=12,i=0,r=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:r},t=Math.floor(t),r=Ui(r,0,Math.PI*2);const s=[],o=[],a=[],l=[],u=[],c=1/t,h=new Y,d=new Ge,p=new Y,f=new Y,g=new Y;let y=0,m=0;for(let v=0;v<=e.length-1;v++)switch(v){case 0:y=e[v+1].x-e[v].x,m=e[v+1].y-e[v].y,p.x=m*1,p.y=-y,p.z=m*0,g.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(g.x,g.y,g.z);break;default:y=e[v+1].x-e[v].x,m=e[v+1].y-e[v].y,p.x=m*1,p.y=-y,p.z=m*0,f.copy(p),p.x+=g.x,p.y+=g.y,p.z+=g.z,p.normalize(),l.push(p.x,p.y,p.z),g.copy(f)}for(let v=0;v<=t;v++){const w=i+v*c*r,S=Math.sin(w),C=Math.cos(w);for(let _=0;_<=e.length-1;_++){h.x=e[_].x*S,h.y=e[_].y,h.z=e[_].x*C,o.push(h.x,h.y,h.z),d.x=v/t,d.y=_/(e.length-1),a.push(d.x,d.y);const A=l[3*_+0]*S,I=l[3*_+1],E=l[3*_+0]*C;u.push(A,I,E)}}for(let v=0;v<t;v++)for(let w=0;w<e.length-1;w++){const S=w+v*e.length,C=S,_=S+e.length,A=S+e.length+1,I=S+1;s.push(C,_,I),s.push(A,I,_)}this.setIndex(s),this.setAttribute("position",new It(o,3)),this.setAttribute("uv",new It(a,2)),this.setAttribute("normal",new It(u,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new j1(e.points,e.segments,e.phiStart,e.phiLength)}}class zE extends j1{constructor(e=1,t=1,i=4,r=8){const s=new qv;s.absarc(0,-t/2,e,Math.PI*1.5,0),s.absarc(0,t/2,e,0,Math.PI*.5),super(s.getPoints(i),r),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:i,radialSegments:r}}static fromJSON(e){return new zE(e.radius,e.length,e.capSegments,e.radialSegments)}}class GE extends rn{constructor(e=1,t=32,i=0,r=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:r},t=Math.max(3,t);const s=[],o=[],a=[],l=[],u=new Y,c=new Ge;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const p=i+h/t*r;u.x=e*Math.cos(p),u.y=e*Math.sin(p),o.push(u.x,u.y,u.z),a.push(0,0,1),c.x=(o[d]/e+1)/2,c.y=(o[d+1]/e+1)/2,l.push(c.x,c.y)}for(let h=1;h<=t;h++)s.push(h,h+1,0);this.setIndex(s),this.setAttribute("position",new It(o,3)),this.setAttribute("normal",new It(a,3)),this.setAttribute("uv",new It(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new GE(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class r0 extends rn{constructor(e=1,t=1,i=1,r=32,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const u=this;r=Math.floor(r),s=Math.floor(s);const c=[],h=[],d=[],p=[];let f=0;const g=[],y=i/2;let m=0;v(),o===!1&&(e>0&&w(!0),t>0&&w(!1)),this.setIndex(c),this.setAttribute("position",new It(h,3)),this.setAttribute("normal",new It(d,3)),this.setAttribute("uv",new It(p,2));function v(){const S=new Y,C=new Y;let _=0;const A=(t-e)/i;for(let I=0;I<=s;I++){const E=[],k=I/s,P=k*(t-e)+e;for(let V=0;V<=r;V++){const U=V/r,F=U*l+a,$=Math.sin(F),J=Math.cos(F);C.x=P*$,C.y=-k*i+y,C.z=P*J,h.push(C.x,C.y,C.z),S.set($,A,J).normalize(),d.push(S.x,S.y,S.z),p.push(U,1-k),E.push(f++)}g.push(E)}for(let I=0;I<r;I++)for(let E=0;E<s;E++){const k=g[E][I],P=g[E+1][I],V=g[E+1][I+1],U=g[E][I+1];c.push(k,P,U),c.push(P,V,U),_+=6}u.addGroup(m,_,0),m+=_}function w(S){const C=f,_=new Ge,A=new Y;let I=0;const E=S===!0?e:t,k=S===!0?1:-1;for(let V=1;V<=r;V++)h.push(0,y*k,0),d.push(0,k,0),p.push(.5,.5),f++;const P=f;for(let V=0;V<=r;V++){const F=V/r*l+a,$=Math.cos(F),J=Math.sin(F);A.x=E*J,A.y=y*k,A.z=E*$,h.push(A.x,A.y,A.z),d.push(0,k,0),_.x=$*.5+.5,_.y=J*.5*k+.5,p.push(_.x,_.y),f++}for(let V=0;V<r;V++){const U=C+V,F=P+V;S===!0?c.push(F,F+1,U):c.push(F+1,F,U),I+=3}u.addGroup(m,I,S===!0?1:2),m+=I}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new r0(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class VE extends r0{constructor(e=1,t=1,i=32,r=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,i,r,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new VE(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Dd extends rn{constructor(e=[],t=[],i=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:r};const s=[],o=[];a(r),u(i),c(),this.setAttribute("position",new It(s,3)),this.setAttribute("normal",new It(s.slice(),3)),this.setAttribute("uv",new It(o,2)),r===0?this.computeVertexNormals():this.normalizeNormals();function a(v){const w=new Y,S=new Y,C=new Y;for(let _=0;_<t.length;_+=3)p(t[_+0],w),p(t[_+1],S),p(t[_+2],C),l(w,S,C,v)}function l(v,w,S,C){const _=C+1,A=[];for(let I=0;I<=_;I++){A[I]=[];const E=v.clone().lerp(S,I/_),k=w.clone().lerp(S,I/_),P=_-I;for(let V=0;V<=P;V++)V===0&&I===_?A[I][V]=E:A[I][V]=E.clone().lerp(k,V/P)}for(let I=0;I<_;I++)for(let E=0;E<2*(_-I)-1;E++){const k=Math.floor(E/2);E%2===0?(d(A[I][k+1]),d(A[I+1][k]),d(A[I][k])):(d(A[I][k+1]),d(A[I+1][k+1]),d(A[I+1][k]))}}function u(v){const w=new Y;for(let S=0;S<s.length;S+=3)w.x=s[S+0],w.y=s[S+1],w.z=s[S+2],w.normalize().multiplyScalar(v),s[S+0]=w.x,s[S+1]=w.y,s[S+2]=w.z}function c(){const v=new Y;for(let w=0;w<s.length;w+=3){v.x=s[w+0],v.y=s[w+1],v.z=s[w+2];const S=y(v)/2/Math.PI+.5,C=m(v)/Math.PI+.5;o.push(S,1-C)}f(),h()}function h(){for(let v=0;v<o.length;v+=6){const w=o[v+0],S=o[v+2],C=o[v+4],_=Math.max(w,S,C),A=Math.min(w,S,C);_>.9&&A<.1&&(w<.2&&(o[v+0]+=1),S<.2&&(o[v+2]+=1),C<.2&&(o[v+4]+=1))}}function d(v){s.push(v.x,v.y,v.z)}function p(v,w){const S=v*3;w.x=e[S+0],w.y=e[S+1],w.z=e[S+2]}function f(){const v=new Y,w=new Y,S=new Y,C=new Y,_=new Ge,A=new Ge,I=new Ge;for(let E=0,k=0;E<s.length;E+=9,k+=6){v.set(s[E+0],s[E+1],s[E+2]),w.set(s[E+3],s[E+4],s[E+5]),S.set(s[E+6],s[E+7],s[E+8]),_.set(o[k+0],o[k+1]),A.set(o[k+2],o[k+3]),I.set(o[k+4],o[k+5]),C.copy(v).add(w).add(S).divideScalar(3);const P=y(C);g(_,k+0,v,P),g(A,k+2,w,P),g(I,k+4,S,P)}}function g(v,w,S,C){C<0&&v.x===1&&(o[w]=v.x-1),S.x===0&&S.z===0&&(o[w]=C/2/Math.PI+.5)}function y(v){return Math.atan2(v.z,-v.x)}function m(v){return Math.atan2(-v.y,Math.sqrt(v.x*v.x+v.z*v.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Dd(e.vertices,e.indices,e.radius,e.details)}}class UE extends Dd{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=1/i,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-i,0,-r,i,0,r,-i,0,r,i,-r,-i,0,-r,i,0,r,-i,0,r,i,0,-i,0,-r,i,0,-r,-i,0,r,i,0,r],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new UE(e.radius,e.detail)}}const FC=new Y,OC=new Y,bL=new Y,BC=new bo;class Gq extends rn{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const r=Math.pow(10,4),s=Math.cos(rf*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,u=[0,0,0],c=["a","b","c"],h=new Array(3),d={},p=[];for(let f=0;f<l;f+=3){o?(u[0]=o.getX(f),u[1]=o.getX(f+1),u[2]=o.getX(f+2)):(u[0]=f,u[1]=f+1,u[2]=f+2);const{a:g,b:y,c:m}=BC;if(g.fromBufferAttribute(a,u[0]),y.fromBufferAttribute(a,u[1]),m.fromBufferAttribute(a,u[2]),BC.getNormal(bL),h[0]=`${Math.round(g.x*r)},${Math.round(g.y*r)},${Math.round(g.z*r)}`,h[1]=`${Math.round(y.x*r)},${Math.round(y.y*r)},${Math.round(y.z*r)}`,h[2]=`${Math.round(m.x*r)},${Math.round(m.y*r)},${Math.round(m.z*r)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let v=0;v<3;v++){const w=(v+1)%3,S=h[v],C=h[w],_=BC[c[v]],A=BC[c[w]],I=`${S}_${C}`,E=`${C}_${S}`;E in d&&d[E]?(bL.dot(d[E].normal)<=s&&(p.push(_.x,_.y,_.z),p.push(A.x,A.y,A.z)),d[E]=null):I in d||(d[I]={index0:u[v],index1:u[w],normal:bL.clone()})}}for(const f in d)if(d[f]){const{index0:g,index1:y}=d[f];FC.fromBufferAttribute(a,g),OC.fromBufferAttribute(a,y),p.push(FC.x,FC.y,FC.z),p.push(OC.x,OC.y,OC.z)}this.setAttribute("position",new It(p,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class of extends qv{constructor(e){super(e),this.uuid=sa(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let i=0,r=this.holes.length;i<r;i++)t[i]=this.holes[i].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(new qv().fromJSON(r))}return this}}const Ake={triangulate:function(n,e,t=2){const i=e&&e.length,r=i?e[0]*t:n.length;let s=Vq(n,0,r,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,u,c,h,d,p;if(i&&(s=Nke(n,e,s,t)),n.length>80*t){a=u=n[0],l=c=n[1];for(let f=t;f<r;f+=t)h=n[f],d=n[f+1],h<a&&(a=h),d<l&&(l=d),h>u&&(u=h),d>c&&(c=d);p=Math.max(u-a,c-l),p=p!==0?32767/p:0}return e1(s,o,t,a,l,p,0),o}};function Vq(n,e,t,i,r){let s,o;if(r===$ke(n,e,t,i)>0)for(s=e;s<t;s+=i)o=X5(s,n[s],n[s+1],o);else for(s=t-i;s>=e;s-=i)o=X5(s,n[s],n[s+1],o);return o&&$E(o,o.next)&&(n1(o),o=o.next),o}function If(n,e){if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&($E(t,t.next)||ki(t.prev,t,t.next)===0)){if(n1(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function e1(n,e,t,i,r,s,o){if(!n)return;!o&&s&&Oke(n,i,r,s);let a=n,l,u;for(;n.prev!==n.next;){if(l=n.prev,u=n.next,s?Ike(n,i,r,s):Eke(n)){e.push(l.i/t|0),e.push(n.i/t|0),e.push(u.i/t|0),n1(n),n=u.next,a=u.next;continue}if(n=u,n===a){o?o===1?(n=kke(If(n),e,t),e1(n,e,t,i,r,s,2)):o===2&&Rke(n,e,t,i,r,s):e1(If(n),e,t,i,r,s,1);break}}}function Eke(n){const e=n.prev,t=n,i=n.next;if(ki(e,t,i)>=0)return!1;const r=e.x,s=t.x,o=i.x,a=e.y,l=t.y,u=i.y,c=r<s?r<o?r:o:s<o?s:o,h=a<l?a<u?a:u:l<u?l:u,d=r>s?r>o?r:o:s>o?s:o,p=a>l?a>u?a:u:l>u?l:u;let f=i.next;for(;f!==e;){if(f.x>=c&&f.x<=d&&f.y>=h&&f.y<=p&&Hg(r,a,s,l,o,u,f.x,f.y)&&ki(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function Ike(n,e,t,i){const r=n.prev,s=n,o=n.next;if(ki(r,s,o)>=0)return!1;const a=r.x,l=s.x,u=o.x,c=r.y,h=s.y,d=o.y,p=a<l?a<u?a:u:l<u?l:u,f=c<h?c<d?c:d:h<d?h:d,g=a>l?a>u?a:u:l>u?l:u,y=c>h?c>d?c:d:h>d?h:d,m=O3(p,f,e,t,i),v=O3(g,y,e,t,i);let w=n.prevZ,S=n.nextZ;for(;w&&w.z>=m&&S&&S.z<=v;){if(w.x>=p&&w.x<=g&&w.y>=f&&w.y<=y&&w!==r&&w!==o&&Hg(a,c,l,h,u,d,w.x,w.y)&&ki(w.prev,w,w.next)>=0||(w=w.prevZ,S.x>=p&&S.x<=g&&S.y>=f&&S.y<=y&&S!==r&&S!==o&&Hg(a,c,l,h,u,d,S.x,S.y)&&ki(S.prev,S,S.next)>=0))return!1;S=S.nextZ}for(;w&&w.z>=m;){if(w.x>=p&&w.x<=g&&w.y>=f&&w.y<=y&&w!==r&&w!==o&&Hg(a,c,l,h,u,d,w.x,w.y)&&ki(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;S&&S.z<=v;){if(S.x>=p&&S.x<=g&&S.y>=f&&S.y<=y&&S!==r&&S!==o&&Hg(a,c,l,h,u,d,S.x,S.y)&&ki(S.prev,S,S.next)>=0)return!1;S=S.nextZ}return!0}function kke(n,e,t){let i=n;do{const r=i.prev,s=i.next.next;!$E(r,s)&&Uq(r,i,i.next,s)&&t1(r,s)&&t1(s,r)&&(e.push(r.i/t|0),e.push(i.i/t|0),e.push(s.i/t|0),n1(i),n1(i.next),i=n=s),i=i.next}while(i!==n);return If(i)}function Rke(n,e,t,i,r,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&Gke(o,a)){let l=$q(o,a);o=If(o,o.next),l=If(l,l.next),e1(o,e,t,i,r,s,0),e1(l,e,t,i,r,s,0);return}a=a.next}o=o.next}while(o!==n)}function Nke(n,e,t,i){const r=[];let s,o,a,l,u;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:n.length,u=Vq(n,a,l,i,!1),u===u.next&&(u.steiner=!0),r.push(zke(u));for(r.sort(Lke),s=0;s<r.length;s++)t=Pke(r[s],t);return t}function Lke(n,e){return n.x-e.x}function Pke(n,e){const t=Dke(n,e);if(!t)return e;const i=$q(t,n);return If(i,i.next),If(t,t.next)}function Dke(n,e){let t=e,i=-1/0,r;const s=n.x,o=n.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>i&&(i=d,r=t.x<t.next.x?t:t.next,d===s))return r}t=t.next}while(t!==e);if(!r)return null;const a=r,l=r.x,u=r.y;let c=1/0,h;t=r;do s>=t.x&&t.x>=l&&s!==t.x&&Hg(o<u?s:i,o,l,u,o<u?i:s,o,t.x,t.y)&&(h=Math.abs(o-t.y)/(s-t.x),t1(t,n)&&(h<c||h===c&&(t.x>r.x||t.x===r.x&&Fke(r,t)))&&(r=t,c=h)),t=t.next;while(t!==a);return r}function Fke(n,e){return ki(n.prev,n,e.prev)<0&&ki(e.next,n,n.next)<0}function Oke(n,e,t,i){let r=n;do r.z===0&&(r.z=O3(r.x,r.y,e,t,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,Bke(r)}function Bke(n){let e,t,i,r,s,o,a,l,u=1;do{for(t=n,n=null,s=null,o=0;t;){for(o++,i=t,a=0,e=0;e<u&&(a++,i=i.nextZ,!!i);e++);for(l=u;a>0||l>0&&i;)a!==0&&(l===0||!i||t.z<=i.z)?(r=t,t=t.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:n=r,r.prevZ=s,s=r;t=i}s.nextZ=null,u*=2}while(o>1);return n}function O3(n,e,t,i,r){return n=(n-t)*r|0,e=(e-i)*r|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function zke(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Hg(n,e,t,i,r,s,o,a){return(r-o)*(e-a)>=(n-o)*(s-a)&&(n-o)*(i-a)>=(t-o)*(e-a)&&(t-o)*(s-a)>=(r-o)*(i-a)}function Gke(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!Vke(n,e)&&(t1(n,e)&&t1(e,n)&&Uke(n,e)&&(ki(n.prev,n,e.prev)||ki(n,e.prev,e))||$E(n,e)&&ki(n.prev,n,n.next)>0&&ki(e.prev,e,e.next)>0)}function ki(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function $E(n,e){return n.x===e.x&&n.y===e.y}function Uq(n,e,t,i){const r=GC(ki(n,e,t)),s=GC(ki(n,e,i)),o=GC(ki(t,i,n)),a=GC(ki(t,i,e));return!!(r!==s&&o!==a||r===0&&zC(n,t,e)||s===0&&zC(n,i,e)||o===0&&zC(t,n,i)||a===0&&zC(t,e,i))}function zC(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function GC(n){return n>0?1:n<0?-1:0}function Vke(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Uq(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function t1(n,e){return ki(n.prev,n,n.next)<0?ki(n,e,n.next)>=0&&ki(n,n.prev,e)>=0:ki(n,e,n.prev)<0||ki(n,n.next,e)<0}function Uke(n,e){let t=n,i=!1;const r=(n.x+e.x)/2,s=(n.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i}function $q(n,e){const t=new B3(n.i,n.x,n.y),i=new B3(e.i,e.x,e.y),r=n.next,s=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,i.next=t,t.prev=i,s.next=i,i.prev=s,i}function X5(n,e,t,i){const r=new B3(n,e,t);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function n1(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function B3(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function $ke(n,e,t,i){let r=0;for(let s=e,o=t-i;s<t;s+=i)r+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return r}class Iu{static area(e){const t=e.length;let i=0;for(let r=t-1,s=0;s<t;r=s++)i+=e[r].x*e[s].y-e[s].x*e[r].y;return i*.5}static isClockWise(e){return Iu.area(e)<0}static triangulateShape(e,t){const i=[],r=[],s=[];K5(e),Z5(i,e);let o=e.length;t.forEach(K5);for(let l=0;l<t.length;l++)r.push(o),o+=t[l].length,Z5(i,t[l]);const a=Ake.triangulate(i,r);for(let l=0;l<a.length;l+=3)s.push(a.slice(l,l+3));return s}}function K5(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function Z5(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class WE extends rn{constructor(e=new of([new Ge(.5,.5),new Ge(-.5,.5),new Ge(-.5,-.5),new Ge(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,r=[],s=[];for(let a=0,l=e.length;a<l;a++){const u=e[a];o(u)}this.setAttribute("position",new It(r,3)),this.setAttribute("uv",new It(s,2)),this.computeVertexNormals();function o(a){const l=[],u=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,f=t.bevelSize!==void 0?t.bevelSize:p-.1,g=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const m=t.extrudePath,v=t.UVGenerator!==void 0?t.UVGenerator:Wke;let w,S=!1,C,_,A,I;m&&(w=m.getSpacedPoints(c),S=!0,d=!1,C=m.computeFrenetFrames(c,!1),_=new Y,A=new Y,I=new Y),d||(y=0,p=0,f=0,g=0);const E=a.extractPoints(u);let k=E.shape;const P=E.holes;if(!Iu.isClockWise(k)){k=k.reverse();for(let ee=0,De=P.length;ee<De;ee++){const _e=P[ee];Iu.isClockWise(_e)&&(P[ee]=_e.reverse())}}const U=Iu.triangulateShape(k,P),F=k;for(let ee=0,De=P.length;ee<De;ee++){const _e=P[ee];k=k.concat(_e)}function $(ee,De,_e){return De||console.error("THREE.ExtrudeGeometry: vec does not exist"),ee.clone().addScaledVector(De,_e)}const J=k.length,q=U.length;function O(ee,De,_e){let ze,Re,nt;const Ze=ee.x-De.x,st=ee.y-De.y,yt=_e.x-ee.x,Lt=_e.y-ee.y,ye=Ze*Ze+st*st,H=Ze*Lt-st*yt;if(Math.abs(H)>Number.EPSILON){const D=Math.sqrt(ye),oe=Math.sqrt(yt*yt+Lt*Lt),Ie=De.x-st/D,Me=De.y+Ze/D,Ve=_e.x-Lt/oe,ct=_e.y+yt/oe,qe=((Ve-Ie)*Lt-(ct-Me)*yt)/(Ze*Lt-st*yt);ze=Ie+Ze*qe-ee.x,Re=Me+st*qe-ee.y;const at=ze*ze+Re*Re;if(at<=2)return new Ge(ze,Re);nt=Math.sqrt(at/2)}else{let D=!1;Ze>Number.EPSILON?yt>Number.EPSILON&&(D=!0):Ze<-Number.EPSILON?yt<-Number.EPSILON&&(D=!0):Math.sign(st)===Math.sign(Lt)&&(D=!0),D?(ze=-st,Re=Ze,nt=Math.sqrt(ye)):(ze=Ze,Re=st,nt=Math.sqrt(ye/2))}return new Ge(ze/nt,Re/nt)}const X=[];for(let ee=0,De=F.length,_e=De-1,ze=ee+1;ee<De;ee++,_e++,ze++)_e===De&&(_e=0),ze===De&&(ze=0),X[ee]=O(F[ee],F[_e],F[ze]);const j=[];let z,Z=X.concat();for(let ee=0,De=P.length;ee<De;ee++){const _e=P[ee];z=[];for(let ze=0,Re=_e.length,nt=Re-1,Ze=ze+1;ze<Re;ze++,nt++,Ze++)nt===Re&&(nt=0),Ze===Re&&(Ze=0),z[ze]=O(_e[ze],_e[nt],_e[Ze]);j.push(z),Z=Z.concat(z)}for(let ee=0;ee<y;ee++){const De=ee/y,_e=p*Math.cos(De*Math.PI/2),ze=f*Math.sin(De*Math.PI/2)+g;for(let Re=0,nt=F.length;Re<nt;Re++){const Ze=$(F[Re],X[Re],ze);Fe(Ze.x,Ze.y,-_e)}for(let Re=0,nt=P.length;Re<nt;Re++){const Ze=P[Re];z=j[Re];for(let st=0,yt=Ze.length;st<yt;st++){const Lt=$(Ze[st],z[st],ze);Fe(Lt.x,Lt.y,-_e)}}}const ce=f+g;for(let ee=0;ee<J;ee++){const De=d?$(k[ee],Z[ee],ce):k[ee];S?(A.copy(C.normals[0]).multiplyScalar(De.x),_.copy(C.binormals[0]).multiplyScalar(De.y),I.copy(w[0]).add(A).add(_),Fe(I.x,I.y,I.z)):Fe(De.x,De.y,0)}for(let ee=1;ee<=c;ee++)for(let De=0;De<J;De++){const _e=d?$(k[De],Z[De],ce):k[De];S?(A.copy(C.normals[ee]).multiplyScalar(_e.x),_.copy(C.binormals[ee]).multiplyScalar(_e.y),I.copy(w[ee]).add(A).add(_),Fe(I.x,I.y,I.z)):Fe(_e.x,_e.y,h/c*ee)}for(let ee=y-1;ee>=0;ee--){const De=ee/y,_e=p*Math.cos(De*Math.PI/2),ze=f*Math.sin(De*Math.PI/2)+g;for(let Re=0,nt=F.length;Re<nt;Re++){const Ze=$(F[Re],X[Re],ze);Fe(Ze.x,Ze.y,h+_e)}for(let Re=0,nt=P.length;Re<nt;Re++){const Ze=P[Re];z=j[Re];for(let st=0,yt=Ze.length;st<yt;st++){const Lt=$(Ze[st],z[st],ze);S?Fe(Lt.x,Lt.y+w[c-1].y,w[c-1].x+_e):Fe(Lt.x,Lt.y,h+_e)}}}fe(),ge();function fe(){const ee=r.length/3;if(d){let De=0,_e=J*De;for(let ze=0;ze<q;ze++){const Re=U[ze];We(Re[2]+_e,Re[1]+_e,Re[0]+_e)}De=c+y*2,_e=J*De;for(let ze=0;ze<q;ze++){const Re=U[ze];We(Re[0]+_e,Re[1]+_e,Re[2]+_e)}}else{for(let De=0;De<q;De++){const _e=U[De];We(_e[2],_e[1],_e[0])}for(let De=0;De<q;De++){const _e=U[De];We(_e[0]+J*c,_e[1]+J*c,_e[2]+J*c)}}i.addGroup(ee,r.length/3-ee,0)}function ge(){const ee=r.length/3;let De=0;Ne(F,De),De+=F.length;for(let _e=0,ze=P.length;_e<ze;_e++){const Re=P[_e];Ne(Re,De),De+=Re.length}i.addGroup(ee,r.length/3-ee,1)}function Ne(ee,De){let _e=ee.length;for(;--_e>=0;){const ze=_e;let Re=_e-1;Re<0&&(Re=ee.length-1);for(let nt=0,Ze=c+y*2;nt<Ze;nt++){const st=J*nt,yt=J*(nt+1),Lt=De+ze+st,ye=De+Re+st,H=De+Re+yt,D=De+ze+yt;Ue(Lt,ye,H,D)}}}function Fe(ee,De,_e){l.push(ee),l.push(De),l.push(_e)}function We(ee,De,_e){Ye(ee),Ye(De),Ye(_e);const ze=r.length/3,Re=v.generateTopUV(i,r,ze-3,ze-2,ze-1);$e(Re[0]),$e(Re[1]),$e(Re[2])}function Ue(ee,De,_e,ze){Ye(ee),Ye(De),Ye(ze),Ye(De),Ye(_e),Ye(ze);const Re=r.length/3,nt=v.generateSideWallUV(i,r,Re-6,Re-3,Re-2,Re-1);$e(nt[0]),$e(nt[1]),$e(nt[3]),$e(nt[1]),$e(nt[2]),$e(nt[3])}function Ye(ee){r.push(l[ee*3+0]),r.push(l[ee*3+1]),r.push(l[ee*3+2])}function $e(ee){s.push(ee.x),s.push(ee.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,i=this.parameters.options;return Hke(t,i,e)}static fromJSON(e,t){const i=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];i.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new HM[r.type]().fromJSON(r)),new WE(i,e.options)}}const Wke={generateTopUV:function(n,e,t,i,r){const s=e[t*3],o=e[t*3+1],a=e[i*3],l=e[i*3+1],u=e[r*3],c=e[r*3+1];return[new Ge(s,o),new Ge(a,l),new Ge(u,c)]},generateSideWallUV:function(n,e,t,i,r,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],u=e[i*3],c=e[i*3+1],h=e[i*3+2],d=e[r*3],p=e[r*3+1],f=e[r*3+2],g=e[s*3],y=e[s*3+1],m=e[s*3+2];return Math.abs(a-c)<Math.abs(o-u)?[new Ge(o,1-l),new Ge(u,1-h),new Ge(d,1-f),new Ge(g,1-m)]:[new Ge(a,1-l),new Ge(c,1-h),new Ge(p,1-f),new Ge(y,1-m)]}};function Hke(n,e,t){if(t.shapes=[],Array.isArray(n))for(let i=0,r=n.length;i<r;i++){const s=n[i];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class HE extends Dd{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(r,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new HE(e.radius,e.detail)}}class Y1 extends Dd{constructor(e=1,t=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],r=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,r,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Y1(e.radius,e.detail)}}class XE extends rn{constructor(e=.5,t=1,i=32,r=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:r,thetaStart:s,thetaLength:o},i=Math.max(3,i),r=Math.max(1,r);const a=[],l=[],u=[],c=[];let h=e;const d=(t-e)/r,p=new Y,f=new Ge;for(let g=0;g<=r;g++){for(let y=0;y<=i;y++){const m=s+y/i*o;p.x=h*Math.cos(m),p.y=h*Math.sin(m),l.push(p.x,p.y,p.z),u.push(0,0,1),f.x=(p.x/t+1)/2,f.y=(p.y/t+1)/2,c.push(f.x,f.y)}h+=d}for(let g=0;g<r;g++){const y=g*(i+1);for(let m=0;m<i;m++){const v=m+y,w=v,S=v+i+1,C=v+i+2,_=v+1;a.push(w,S,_),a.push(S,C,_)}}this.setIndex(a),this.setAttribute("position",new It(l,3)),this.setAttribute("normal",new It(u,3)),this.setAttribute("uv",new It(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new XE(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class KE extends rn{constructor(e=new of([new Ge(0,.5),new Ge(-.5,-.5),new Ge(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)u(e);else for(let c=0;c<e.length;c++)u(e[c]),this.addGroup(a,l,c),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new It(r,3)),this.setAttribute("normal",new It(s,3)),this.setAttribute("uv",new It(o,2));function u(c){const h=r.length/3,d=c.extractPoints(t);let p=d.shape;const f=d.holes;Iu.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,m=f.length;y<m;y++){const v=f[y];Iu.isClockWise(v)===!0&&(f[y]=v.reverse())}const g=Iu.triangulateShape(p,f);for(let y=0,m=f.length;y<m;y++){const v=f[y];p=p.concat(v)}for(let y=0,m=p.length;y<m;y++){const v=p[y];r.push(v.x,v.y,0),s.push(0,0,1),o.push(v.x,v.y)}for(let y=0,m=g.length;y<m;y++){const v=g[y],w=v[0]+h,S=v[1]+h,C=v[2]+h;i.push(w,S,C),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return Xke(t,e)}static fromJSON(e,t){const i=[];for(let r=0,s=e.shapes.length;r<s;r++){const o=t[e.shapes[r]];i.push(o)}return new KE(i,e.curveSegments)}}function Xke(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class J1 extends rn{constructor(e=1,t=32,i=16,r=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:r,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const l=Math.min(o+a,Math.PI);let u=0;const c=[],h=new Y,d=new Y,p=[],f=[],g=[],y=[];for(let m=0;m<=i;m++){const v=[],w=m/i;let S=0;m===0&&o===0?S=.5/t:m===i&&l===Math.PI&&(S=-.5/t);for(let C=0;C<=t;C++){const _=C/t;h.x=-e*Math.cos(r+_*s)*Math.sin(o+w*a),h.y=e*Math.cos(o+w*a),h.z=e*Math.sin(r+_*s)*Math.sin(o+w*a),f.push(h.x,h.y,h.z),d.copy(h).normalize(),g.push(d.x,d.y,d.z),y.push(_+S,1-w),v.push(u++)}c.push(v)}for(let m=0;m<i;m++)for(let v=0;v<t;v++){const w=c[m][v+1],S=c[m][v],C=c[m+1][v],_=c[m+1][v+1];(m!==0||o>0)&&p.push(w,S,_),(m!==i-1||l<Math.PI)&&p.push(S,C,_)}this.setIndex(p),this.setAttribute("position",new It(f,3)),this.setAttribute("normal",new It(g,3)),this.setAttribute("uv",new It(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new J1(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class ZE extends Dd{constructor(e=1,t=0){const i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],r=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,r,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new ZE(e.radius,e.detail)}}class jE extends rn{constructor(e=1,t=.4,i=12,r=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:r,arc:s},i=Math.floor(i),r=Math.floor(r);const o=[],a=[],l=[],u=[],c=new Y,h=new Y,d=new Y;for(let p=0;p<=i;p++)for(let f=0;f<=r;f++){const g=f/r*s,y=p/i*Math.PI*2;h.x=(e+t*Math.cos(y))*Math.cos(g),h.y=(e+t*Math.cos(y))*Math.sin(g),h.z=t*Math.sin(y),a.push(h.x,h.y,h.z),c.x=e*Math.cos(g),c.y=e*Math.sin(g),d.subVectors(h,c).normalize(),l.push(d.x,d.y,d.z),u.push(f/r),u.push(p/i)}for(let p=1;p<=i;p++)for(let f=1;f<=r;f++){const g=(r+1)*p+f-1,y=(r+1)*(p-1)+f-1,m=(r+1)*(p-1)+f,v=(r+1)*p+f;o.push(g,y,v),o.push(y,m,v)}this.setIndex(o),this.setAttribute("position",new It(a,3)),this.setAttribute("normal",new It(l,3)),this.setAttribute("uv",new It(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jE(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class YE extends rn{constructor(e=1,t=.4,i=64,r=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:r,p:s,q:o},i=Math.floor(i),r=Math.floor(r);const a=[],l=[],u=[],c=[],h=new Y,d=new Y,p=new Y,f=new Y,g=new Y,y=new Y,m=new Y;for(let w=0;w<=i;++w){const S=w/i*s*Math.PI*2;v(S,s,o,e,p),v(S+.01,s,o,e,f),y.subVectors(f,p),m.addVectors(f,p),g.crossVectors(y,m),m.crossVectors(g,y),g.normalize(),m.normalize();for(let C=0;C<=r;++C){const _=C/r*Math.PI*2,A=-t*Math.cos(_),I=t*Math.sin(_);h.x=p.x+(A*m.x+I*g.x),h.y=p.y+(A*m.y+I*g.y),h.z=p.z+(A*m.z+I*g.z),l.push(h.x,h.y,h.z),d.subVectors(h,p).normalize(),u.push(d.x,d.y,d.z),c.push(w/i),c.push(C/r)}}for(let w=1;w<=i;w++)for(let S=1;S<=r;S++){const C=(r+1)*(w-1)+(S-1),_=(r+1)*w+(S-1),A=(r+1)*w+S,I=(r+1)*(w-1)+S;a.push(C,_,I),a.push(_,A,I)}this.setIndex(a),this.setAttribute("position",new It(l,3)),this.setAttribute("normal",new It(u,3)),this.setAttribute("uv",new It(c,2));function v(w,S,C,_,A){const I=Math.cos(w),E=Math.sin(w),k=C/S*w,P=Math.cos(k);A.x=_*(2+P)*.5*I,A.y=_*(2+P)*E*.5,A.z=_*Math.sin(k)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new YE(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class JE extends rn{constructor(e=new uz(new Y(-1,-1,0),new Y(-1,1,0),new Y(1,1,0)),t=64,i=1,r=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:r,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new Y,l=new Y,u=new Ge;let c=new Y;const h=[],d=[],p=[],f=[];g(),this.setIndex(f),this.setAttribute("position",new It(h,3)),this.setAttribute("normal",new It(d,3)),this.setAttribute("uv",new It(p,2));function g(){for(let w=0;w<t;w++)y(w);y(s===!1?t:0),v(),m()}function y(w){c=e.getPointAt(w/t,c);const S=o.normals[w],C=o.binormals[w];for(let _=0;_<=r;_++){const A=_/r*Math.PI*2,I=Math.sin(A),E=-Math.cos(A);l.x=E*S.x+I*C.x,l.y=E*S.y+I*C.y,l.z=E*S.z+I*C.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=c.x+i*l.x,a.y=c.y+i*l.y,a.z=c.z+i*l.z,h.push(a.x,a.y,a.z)}}function m(){for(let w=1;w<=t;w++)for(let S=1;S<=r;S++){const C=(r+1)*(w-1)+(S-1),_=(r+1)*w+(S-1),A=(r+1)*w+S,I=(r+1)*(w-1)+S;f.push(C,_,I),f.push(_,A,I)}}function v(){for(let w=0;w<=t;w++)for(let S=0;S<=r;S++)u.x=w/t,u.y=S/r,p.push(u.x,u.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new JE(new HM[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class Wq extends rn{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],i=new Set,r=new Y,s=new Y;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let u=0,c=l.length;u<c;++u){const h=l[u],d=h.start,p=h.count;for(let f=d,g=d+p;f<g;f+=3)for(let y=0;y<3;y++){const m=a.getX(f+y),v=a.getX(f+(y+1)%3);r.fromBufferAttribute(o,m),s.fromBufferAttribute(o,v),j5(r,s,i)===!0&&(t.push(r.x,r.y,r.z),t.push(s.x,s.y,s.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let u=0;u<3;u++){const c=3*a+u,h=3*a+(u+1)%3;r.fromBufferAttribute(o,c),s.fromBufferAttribute(o,h),j5(r,s,i)===!0&&(t.push(r.x,r.y,r.z),t.push(s.x,s.y,s.z))}}this.setAttribute("position",new It(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function j5(n,e,t){const i=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(i)===!0||t.has(r)===!0?!1:(t.add(i),t.add(r),!0)}var Y5=Object.freeze({__proto__:null,BoxGeometry:om,CapsuleGeometry:zE,CircleGeometry:GE,ConeGeometry:VE,CylinderGeometry:r0,DodecahedronGeometry:UE,EdgesGeometry:Gq,ExtrudeGeometry:WE,IcosahedronGeometry:HE,LatheGeometry:j1,OctahedronGeometry:Y1,PlaneGeometry:e0,PolyhedronGeometry:Dd,RingGeometry:XE,ShapeGeometry:KE,SphereGeometry:J1,TetrahedronGeometry:ZE,TorusGeometry:jE,TorusKnotGeometry:YE,TubeGeometry:JE,WireframeGeometry:Wq});class Hq extends Pi{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new lt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Xq extends Du{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class am extends Pi{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new lt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Qr extends am{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ge(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ui(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new lt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new lt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new lt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class Kq extends Pi{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new lt(16777215),this.specular=new lt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=G1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Zq extends Pi{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new lt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class jq extends Pi{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Yq extends Pi{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=G1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Jq extends Pi{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new lt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pd,this.normalScale=new Ge(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Qq extends ps{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Xp(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function qq(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function eee(n){function e(r,s){return n[r]-n[s]}const t=n.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort(e),i}function z3(n,e,t){const i=n.length,r=new n.constructor(i);for(let s=0,o=0;o!==i;++s){const a=t[s]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r}function hz(n,e,t,i){let r=1,s=n[0];for(;s!==void 0&&s[i]===void 0;)s=n[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=n[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=n[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(e.push(s.time),t.push(o)),s=n[r++];while(s!==void 0)}function Kke(n,e,t,i,r=30){const s=n.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const u=s.tracks[l],c=u.getValueSize(),h=[],d=[];for(let p=0;p<u.times.length;++p){const f=u.times[p]*r;if(!(f<t||f>=i)){h.push(u.times[p]);for(let g=0;g<c;++g)d.push(u.values[p*c+g])}}h.length!==0&&(u.times=Xp(h,u.times.constructor),u.values=Xp(d,u.values.constructor),o.push(u))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s}function Zke(n,e=0,t=n,i=30){i<=0&&(i=30);const r=t.tracks.length,s=e/i;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const u=n.tracks.find(function(m){return m.name===a.name&&m.ValueTypeName===l});if(u===void 0)continue;let c=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);let d=0;const p=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const f=a.times.length-1;let g;if(s<=a.times[0]){const m=c,v=h-c;g=a.values.slice(m,v)}else if(s>=a.times[f]){const m=f*h+c,v=m+h-c;g=a.values.slice(m,v)}else{const m=a.createInterpolant(),v=c,w=h-c;m.evaluate(s),g=m.resultBuffer.slice(v,w)}l==="quaternion"&&new Li().fromArray(g).normalize().conjugate().toArray(g);const y=u.times.length;for(let m=0;m<y;++m){const v=m*p+d;if(l==="quaternion")Li.multiplyQuaternionsFlat(u.values,v,g,0,u.values,v);else{const w=p-d*2;for(let S=0;S<w;++S)u.values[v+S]-=g[S]}}}return n.blendMode=XB,n}const jke={convertArray:Xp,isTypedArray:qq,getKeyframeOrder:eee,sortedArray:z3,flattenJSON:hz,subclip:Kke,makeClipAdditive:Zke};class lm{constructor(e,t,i,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,r=t[i],s=t[i-1];e:{t:{let o;n:{i:if(!(e<r)){for(let a=i+2;;){if(r===void 0){if(e<s)break i;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(s=r,r=t[++i],e<r)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(i=2,s=a);for(let l=i-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(r=s,s=t[--i-1],e>=s)break t}o=i,i=0;break n}break e}for(;i<o;){const a=i+o>>>1;e<t[a]?o=a:i=a+1}if(r=t[i],s=t[i-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===void 0)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,s,r)}return this.interpolate_(i,s,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r;for(let o=0;o!==r;++o)t[o]=i[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class tee extends lm{constructor(e,t,i,r){super(e,t,i,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Up,endingEnd:Up}}intervalChanged_(e,t,i){const r=this.parameterPositions;let s=e-2,o=e+1,a=r[s],l=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case $p:s=e,a=2*t-i;break;case Xv:s=r.length-2,a=t+r[s]-r[s+1];break;default:s=e,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case $p:o=e,l=2*i-t;break;case Xv:o=1,l=i+r[1]-r[0];break;default:o=e-1,l=t}const u=(i-t)*.5,c=this.valueSize;this._weightPrev=u/(t-a),this._weightNext=u/(l-i),this._offsetPrev=s*c,this._offsetNext=o*c}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(i-t)/(r-t),g=f*f,y=g*f,m=-d*y+2*d*g-d*f,v=(1+d)*y+(-1.5-2*d)*g+(-.5+d)*f+1,w=(-1-p)*y+(1.5+p)*g+.5*f,S=p*y-p*g;for(let C=0;C!==a;++C)s[C]=m*o[c+C]+v*o[u+C]+w*o[l+C]+S*o[h+C];return s}}class dz extends lm{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=(i-t)/(r-t),h=1-c;for(let d=0;d!==a;++d)s[d]=o[u+d]*h+o[l+d]*c;return s}}class nee extends lm{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class Kl{constructor(e,t,i,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Xp(t,this.TimeBufferType),this.values=Xp(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:Xp(e.times,Array),values:Xp(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(i.interpolation=r)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new nee(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new dz(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new tee(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Mf:t=this.InterpolantFactoryMethodDiscrete;break;case Fc:t=this.InterpolantFactoryMethodLinear;break;case W_:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Mf;case this.InterpolantFactoryMethodLinear:return Fc;case this.InterpolantFactoryMethodSmooth:return W_}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]*=e}return this}trim(e,t){const i=this.times,r=i.length;let s=0,o=r-1;for(;s!==r&&i[s]<e;)++s;for(;o!==-1&&i[o]>t;)--o;if(++o,s!==0||o!==r){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=i.slice(s,o),this.values=this.values.slice(s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,r=this.values,s=i.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(r!==void 0&&qq(r))for(let a=0,l=r.length;a!==l;++a){const u=r[a];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,u),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),i=this.getValueSize(),r=this.getInterpolation()===W_,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const u=e[a],c=e[a+1];if(u!==c&&(a!==1||u!==e[0]))if(r)l=!0;else{const h=a*i,d=h-i,p=h+i;for(let f=0;f!==i;++f){const g=t[h+f];if(g!==t[d+f]||g!==t[p+f]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*i,d=o*i;for(let p=0;p!==i;++p)t[d+p]=t[h+p]}++o}}if(s>0){e[o]=e[s];for(let a=s*i,l=o*i,u=0;u!==i;++u)t[l+u]=t[a+u];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*i)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),i=this.constructor,r=new i(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}Kl.prototype.TimeBufferType=Float32Array;Kl.prototype.ValueBufferType=Float32Array;Kl.prototype.DefaultInterpolation=Fc;class um extends Kl{}um.prototype.ValueTypeName="bool";um.prototype.ValueBufferType=Array;um.prototype.DefaultInterpolation=Mf;um.prototype.InterpolantFactoryMethodLinear=void 0;um.prototype.InterpolantFactoryMethodSmooth=void 0;class pz extends Kl{}pz.prototype.ValueTypeName="color";class gd extends Kl{}gd.prototype.ValueTypeName="number";class iee extends lm{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(i-t)/(r-t);let u=e*a;for(let c=u+a;u!==c;u+=4)Li.slerpFlat(s,0,o,u-a,o,u,l);return s}}class Ou extends Kl{InterpolantFactoryMethodLinear(e){return new iee(this.times,this.values,this.getValueSize(),e)}}Ou.prototype.ValueTypeName="quaternion";Ou.prototype.DefaultInterpolation=Fc;Ou.prototype.InterpolantFactoryMethodSmooth=void 0;class cm extends Kl{}cm.prototype.ValueTypeName="string";cm.prototype.ValueBufferType=Array;cm.prototype.DefaultInterpolation=Mf;cm.prototype.InterpolantFactoryMethodLinear=void 0;cm.prototype.InterpolantFactoryMethodSmooth=void 0;class yd extends Kl{}yd.prototype.ValueTypeName="vector";class kf{constructor(e,t=-1,i,r=_E){this.name=e,this.tracks=i,this.duration=t,this.blendMode=r,this.uuid=sa(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,r=1/(e.fps||1);for(let o=0,a=i.length;o!==a;++o)t.push(Jke(i[o]).scale(r));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],i=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=i.length;s!==o;++s)t.push(Kl.toJSON(i[s]));return r}static CreateFromMorphTargetSequence(e,t,i,r){const s=t.length,o=[];for(let a=0;a<s;a++){let l=[],u=[];l.push((a+s-1)%s,a,(a+1)%s),u.push(0,1,0);const c=eee(l);l=z3(l,1,c),u=z3(u,1,c),!r&&l[0]===0&&(l.push(s),u.push(u[0])),o.push(new gd(".morphTargetInfluences["+t[a].name+"]",l,u).scale(1/i))}return new this(e,-1,o)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const r=e;i=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<i.length;r++)if(i[r].name===t)return i[r];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const r={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const u=e[a],c=u.name.match(s);if(c&&c.length>1){const h=c[1];let d=r[h];d||(r[h]=d=[]),d.push(u)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,i));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(h,d,p,f,g){if(p.length!==0){const y=[],m=[];hz(p,y,m,f),y.length!==0&&g.push(new h(d,y,m))}},r=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let h=0;h<u.length;h++){const d=u[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let g=0;g<d[f].morphTargets.length;g++)p[d[f].morphTargets[g]]=-1;for(const g in p){const y=[],m=[];for(let v=0;v!==d[f].morphTargets.length;++v){const w=d[f];y.push(w.time),m.push(w.morphTarget===g?1:0)}r.push(new gd(".morphTargetInfluence["+g+"]",y,m))}l=p.length*o}else{const p=".bones["+t[h].name+"]";i(yd,p+".position",d,"pos",r),i(Ou,p+".quaternion",d,"rot",r),i(yd,p+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let i=0,r=e.length;i!==r;++i){const s=this.tracks[i];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Yke(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return gd;case"vector":case"vector2":case"vector3":case"vector4":return yd;case"color":return pz;case"quaternion":return Ou;case"bool":case"boolean":return um;case"string":return cm}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function Jke(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Yke(n.type);if(n.times===void 0){const t=[],i=[];hz(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const Rf={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class fz{constructor(e,t,i){const r=this;let s=!1,o=0,a=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(c){a++,s===!1&&r.onStart!==void 0&&r.onStart(c,o,a),s=!0},this.itemEnd=function(c){o++,r.onProgress!==void 0&&r.onProgress(c,o,a),o===a&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,h){return u.push(c,h),this},this.removeHandler=function(c){const h=u.indexOf(c);return h!==-1&&u.splice(h,2),this},this.getHandler=function(c){for(let h=0,d=u.length;h<d;h+=2){const p=u[h],f=u[h+1];if(p.global&&(p.lastIndex=0),p.test(c))return f}return null}}}const ree=new fz;class fs{constructor(e){this.manager=e!==void 0?e:ree,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise(function(r,s){i.load(e,r,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}fs.DEFAULT_MATERIAL_NAME="__DEFAULT";const rc={};class Qke extends Error{constructor(e,t){super(e),this.response=t}}class Qs extends fs{constructor(e){super(e)}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Rf.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(rc[e]!==void 0){rc[e].push({onLoad:t,onProgress:i,onError:r});return}rc[e]=[],rc[e].push({onLoad:t,onProgress:i,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=rc[e],h=u.body.getReader(),d=u.headers.get("Content-Length")||u.headers.get("X-File-Size"),p=d?parseInt(d):0,f=p!==0;let g=0;const y=new ReadableStream({start(m){v();function v(){h.read().then(({done:w,value:S})=>{if(w)m.close();else{g+=S.byteLength;const C=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:p});for(let _=0,A=c.length;_<A;_++){const I=c[_];I.onProgress&&I.onProgress(C)}m.enqueue(S),v()}})}}});return new Response(y)}else throw new Qke(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,a));case"json":return u.json();default:if(a===void 0)return u.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(d);return u.arrayBuffer().then(f=>p.decode(f))}}}).then(u=>{Rf.add(e,u);const c=rc[e];delete rc[e];for(let h=0,d=c.length;h<d;h++){const p=c[h];p.onLoad&&p.onLoad(u)}}).catch(u=>{const c=rc[e];if(c===void 0)throw this.manager.itemError(e),u;delete rc[e];for(let h=0,d=c.length;h<d;h++){const p=c[h];p.onError&&p.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class qke extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new Qs(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t=[];for(let i=0;i<e.length;i++){const r=kf.parse(e[i]);t.push(r)}return t}}class eRe extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=[],a=new OE,l=new Qs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials);let u=0;function c(h){l.load(e[h],function(d){const p=s.parse(d,!0);o[h]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},u+=1,u===6&&(p.mipmapCount===1&&(a.minFilter=Zn),a.image=o,a.format=p.format,a.needsUpdate=!0,t&&t(a))},i,r)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)c(h);else l.load(e,function(h){const d=s.parse(h,!0);if(d.isCubemap){const p=d.mipmaps.length/d.mipmapCount;for(let f=0;f<p;f++){o[f]={mipmaps:[]};for(let g=0;g<d.mipmapCount;g++)o[f].mipmaps.push(d.mipmaps[f*d.mipmapCount+g]),o[f].format=d.format,o[f].width=d.width,o[f].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=Zn),a.format=d.format,a.needsUpdate=!0,t&&t(a)},i,r);return a}}class i1 extends fs{constructor(e){super(e)}load(e,t,i,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Rf.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=Qv("img");function l(){c(),Rf.add(e,this),t&&t(this),s.manager.itemEnd(e)}function u(h){c(),r&&r(h),s.manager.itemError(e),s.manager.itemEnd(e)}function c(){a.removeEventListener("load",l,!1),a.removeEventListener("error",u,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class tRe extends fs{constructor(e){super(e)}load(e,t,i,r){const s=new X1;s.colorSpace=bi;const o=new i1(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(u){o.load(e[u],function(c){s.images[u]=c,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,r)}for(let u=0;u<e.length;++u)l(u);return s}}class nRe extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new sy,a=new Qs(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(e,function(l){let u;try{u=s.parse(l)}catch(c){if(r!==void 0)r(c);else{console.error(c);return}}u.image!==void 0?o.image=u.image:u.data!==void 0&&(o.image.width=u.width,o.image.height=u.height,o.image.data=u.data),o.wrapS=u.wrapS!==void 0?u.wrapS:$r,o.wrapT=u.wrapT!==void 0?u.wrapT:$r,o.magFilter=u.magFilter!==void 0?u.magFilter:Zn,o.minFilter=u.minFilter!==void 0?u.minFilter:Zn,o.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.colorSpace!==void 0?o.colorSpace=u.colorSpace:u.encoding!==void 0&&(o.encoding=u.encoding),u.flipY!==void 0&&(o.flipY=u.flipY),u.format!==void 0&&(o.format=u.format),u.type!==void 0&&(o.type=u.type),u.mipmaps!==void 0&&(o.mipmaps=u.mipmaps,o.minFilter=qa),u.mipmapCount===1&&(o.minFilter=Zn),u.generateMipmaps!==void 0&&(o.generateMipmaps=u.generateMipmaps),o.needsUpdate=!0,t&&t(o,u)},i,r),o}}class mz extends fs{constructor(e){super(e)}load(e,t,i,r){const s=new ni,o=new i1(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},i,r),s}}class Fd extends yn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new lt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class see extends Fd{constructor(e,t,i){super(e,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(yn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new lt(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const xL=new Ft,J5=new Y,Q5=new Y;class gz{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ge(512,512),this.map=null,this.mapPass=null,this.matrix=new Ft,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new EE,this._frameExtents=new Ge(1,1),this._viewportCount=1,this._viewports=[new Gn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;J5.setFromMatrixPosition(e.matrixWorld),t.position.copy(J5),Q5.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Q5),t.updateMatrixWorld(),xL.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xL),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(xL)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class iRe extends gz{constructor(){super(new ci(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,i=My*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(i!==t.fov||r!==t.aspect||s!==t.far)&&(t.fov=i,t.aspect=r,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class QE extends Fd{constructor(e,t,i=0,r=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(yn.DEFAULT_UP),this.updateMatrix(),this.target=new yn,this.distance=i,this.angle=r,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new iRe}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const q5=new Ft,gx=new Y,vL=new Y;class rRe extends gz{constructor(){super(new ci(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ge(4,2),this._viewportCount=6,this._viewports=[new Gn(2,1,1,1),new Gn(0,1,1,1),new Gn(3,1,1,1),new Gn(1,1,1,1),new Gn(3,0,1,1),new Gn(1,0,1,1)],this._cubeDirections=[new Y(1,0,0),new Y(-1,0,0),new Y(0,0,1),new Y(0,0,-1),new Y(0,1,0),new Y(0,-1,0)],this._cubeUps=[new Y(0,1,0),new Y(0,1,0),new Y(0,1,0),new Y(0,1,0),new Y(0,0,1),new Y(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,r=this.matrix,s=e.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),gx.setFromMatrixPosition(e.matrixWorld),i.position.copy(gx),vL.copy(i.position),vL.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(vL),i.updateMatrixWorld(),r.makeTranslation(-gx.x,-gx.y,-gx.z),q5.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(q5)}}class qE extends Fd{constructor(e,t,i=0,r=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new rRe}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class sRe extends gz{constructor(){super(new Al(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class e2 extends Fd{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(yn.DEFAULT_UP),this.updateMatrix(),this.target=new yn,this.shadow=new sRe}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class yz extends Fd{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class oee extends Fd{constructor(e,t,i=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class aee{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Y)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*i),t.addScaledVector(o[4],1.092548*(i*r)),t.addScaledVector(o[5],1.092548*(r*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(i*s)),t.addScaledVector(o[8],.546274*(i*i-r*r)),t}getIrradianceAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*i),t.addScaledVector(o[4],2*.429043*i*r),t.addScaledVector(o[5],2*.429043*r*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*i*s),t.addScaledVector(o[8],.429043*(i*i-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const i=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*i,t[4]=1.092548*i*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*i*s,t[8]=.546274*(i*i-r*r)}}class lee extends Fd{constructor(e=new aee,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class t2 extends fs{constructor(e){super(e),this.textures={}}load(e,t,i,r){const s=this,o=new Qs(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t=this.textures;function i(s){return t[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),t[s]}const r=t2.createMaterialFromType(e.type);if(e.uuid!==void 0&&(r.uuid=e.uuid),e.name!==void 0&&(r.name=e.name),e.color!==void 0&&r.color!==void 0&&r.color.setHex(e.color),e.roughness!==void 0&&(r.roughness=e.roughness),e.metalness!==void 0&&(r.metalness=e.metalness),e.sheen!==void 0&&(r.sheen=e.sheen),e.sheenColor!==void 0&&(r.sheenColor=new lt().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(r.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(e.emissive),e.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(e.specular),e.specularIntensity!==void 0&&(r.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&r.specularColor!==void 0&&r.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(r.shininess=e.shininess),e.clearcoat!==void 0&&(r.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(r.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(r.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(r.transmission=e.transmission),e.thickness!==void 0&&(r.thickness=e.thickness),e.attenuationDistance!==void 0&&(r.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&r.attenuationColor!==void 0&&r.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(r.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(r.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(r.fog=e.fog),e.flatShading!==void 0&&(r.flatShading=e.flatShading),e.blending!==void 0&&(r.blending=e.blending),e.combine!==void 0&&(r.combine=e.combine),e.side!==void 0&&(r.side=e.side),e.shadowSide!==void 0&&(r.shadowSide=e.shadowSide),e.opacity!==void 0&&(r.opacity=e.opacity),e.transparent!==void 0&&(r.transparent=e.transparent),e.alphaTest!==void 0&&(r.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(r.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(r.depthFunc=e.depthFunc),e.depthTest!==void 0&&(r.depthTest=e.depthTest),e.depthWrite!==void 0&&(r.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(r.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(r.blendSrc=e.blendSrc),e.blendDst!==void 0&&(r.blendDst=e.blendDst),e.blendEquation!==void 0&&(r.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(r.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(r.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(r.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&r.blendColor!==void 0&&r.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(r.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(r.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(r.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(r.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(r.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(r.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(r.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(r.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(r.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(r.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(r.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(r.rotation=e.rotation),e.linewidth!==void 0&&(r.linewidth=e.linewidth),e.dashSize!==void 0&&(r.dashSize=e.dashSize),e.gapSize!==void 0&&(r.gapSize=e.gapSize),e.scale!==void 0&&(r.scale=e.scale),e.polygonOffset!==void 0&&(r.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(r.dithering=e.dithering),e.alphaToCoverage!==void 0&&(r.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(r.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(r.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(r.visible=e.visible),e.toneMapped!==void 0&&(r.toneMapped=e.toneMapped),e.userData!==void 0&&(r.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const o=e.uniforms[s];switch(r.uniforms[s]={},o.type){case"t":r.uniforms[s].value=i(o.value);break;case"c":r.uniforms[s].value=new lt().setHex(o.value);break;case"v2":r.uniforms[s].value=new Ge().fromArray(o.value);break;case"v3":r.uniforms[s].value=new Y().fromArray(o.value);break;case"v4":r.uniforms[s].value=new Gn().fromArray(o.value);break;case"m3":r.uniforms[s].value=new hn().fromArray(o.value);break;case"m4":r.uniforms[s].value=new Ft().fromArray(o.value);break;default:r.uniforms[s].value=o.value}}if(e.defines!==void 0&&(r.defines=e.defines),e.vertexShader!==void 0&&(r.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(r.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(r.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)r.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(r.lights=e.lights),e.clipping!==void 0&&(r.clipping=e.clipping),e.size!==void 0&&(r.size=e.size),e.sizeAttenuation!==void 0&&(r.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(r.map=i(e.map)),e.matcap!==void 0&&(r.matcap=i(e.matcap)),e.alphaMap!==void 0&&(r.alphaMap=i(e.alphaMap)),e.bumpMap!==void 0&&(r.bumpMap=i(e.bumpMap)),e.bumpScale!==void 0&&(r.bumpScale=e.bumpScale),e.normalMap!==void 0&&(r.normalMap=i(e.normalMap)),e.normalMapType!==void 0&&(r.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),r.normalScale=new Ge().fromArray(s)}return e.displacementMap!==void 0&&(r.displacementMap=i(e.displacementMap)),e.displacementScale!==void 0&&(r.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(r.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(r.roughnessMap=i(e.roughnessMap)),e.metalnessMap!==void 0&&(r.metalnessMap=i(e.metalnessMap)),e.emissiveMap!==void 0&&(r.emissiveMap=i(e.emissiveMap)),e.emissiveIntensity!==void 0&&(r.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(r.specularMap=i(e.specularMap)),e.specularIntensityMap!==void 0&&(r.specularIntensityMap=i(e.specularIntensityMap)),e.specularColorMap!==void 0&&(r.specularColorMap=i(e.specularColorMap)),e.envMap!==void 0&&(r.envMap=i(e.envMap)),e.envMapIntensity!==void 0&&(r.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(r.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(r.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(r.lightMap=i(e.lightMap)),e.lightMapIntensity!==void 0&&(r.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(r.aoMap=i(e.aoMap)),e.aoMapIntensity!==void 0&&(r.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(r.gradientMap=i(e.gradientMap)),e.clearcoatMap!==void 0&&(r.clearcoatMap=i(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=i(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=i(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new Ge().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(r.iridescenceMap=i(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(r.iridescenceThicknessMap=i(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(r.transmissionMap=i(e.transmissionMap)),e.thicknessMap!==void 0&&(r.thicknessMap=i(e.thicknessMap)),e.anisotropyMap!==void 0&&(r.anisotropyMap=i(e.anisotropyMap)),e.sheenColorMap!==void 0&&(r.sheenColorMap=i(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(r.sheenRoughnessMap=i(e.sheenRoughnessMap)),r}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:Hq,SpriteMaterial:rz,RawShaderMaterial:Xq,ShaderMaterial:Du,PointsMaterial:Z1,MeshPhysicalMaterial:Qr,MeshStandardMaterial:am,MeshPhongMaterial:Kq,MeshToonMaterial:Zq,MeshNormalMaterial:jq,MeshLambertMaterial:Yq,MeshDepthMaterial:tz,MeshDistanceMaterial:nz,MeshBasicMaterial:dr,MeshMatcapMaterial:Jq,LineDashedMaterial:Qq,LineBasicMaterial:ps,Material:Pi};return new t[e]}}class oa{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class uee extends rn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class cee extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new Qs(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t={},i={};function r(p,f){if(t[f]!==void 0)return t[f];const y=p.interleavedBuffers[f],m=s(p,y.buffer),v=$g(y.type,m),w=new n0(v,y.stride);return w.uuid=y.uuid,t[f]=w,w}function s(p,f){if(i[f]!==void 0)return i[f];const y=p.arrayBuffers[f],m=new Uint32Array(y).buffer;return i[f]=m,m}const o=e.isInstancedBufferGeometry?new uee:new rn,a=e.data.index;if(a!==void 0){const p=$g(a.type,a.array);o.setIndex(new En(p,1))}const l=e.data.attributes;for(const p in l){const f=l[p];let g;if(f.isInterleavedBufferAttribute){const y=r(e.data,f.data);g=new Oc(y,f.itemSize,f.offset,f.normalized)}else{const y=$g(f.type,f.array),m=f.isInstancedBufferAttribute?Ef:En;g=new m(y,f.itemSize,f.normalized)}f.name!==void 0&&(g.name=f.name),f.usage!==void 0&&g.setUsage(f.usage),f.updateRange!==void 0&&(g.updateRange.offset=f.updateRange.offset,g.updateRange.count=f.updateRange.count),o.setAttribute(p,g)}const u=e.data.morphAttributes;if(u)for(const p in u){const f=u[p],g=[];for(let y=0,m=f.length;y<m;y++){const v=f[y];let w;if(v.isInterleavedBufferAttribute){const S=r(e.data,v.data);w=new Oc(S,v.itemSize,v.offset,v.normalized)}else{const S=$g(v.type,v.array);w=new En(S,v.itemSize,v.normalized)}v.name!==void 0&&(w.name=v.name),g.push(w)}o.morphAttributes[p]=g}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let p=0,f=h.length;p!==f;++p){const g=h[p];o.addGroup(g.start,g.count,g.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const p=new Y;d.center!==void 0&&p.fromArray(d.center),o.boundingSphere=new ya(p,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class oRe extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=this.path===""?oa.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Qs(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let u=null;try{u=JSON.parse(l)}catch(h){r!==void 0&&r(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const c=u.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry"){r!==void 0&&r(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(u,t)},i,r)}async loadAsync(e,t){const i=this,r=this.path===""?oa.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const s=new Qs(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const o=await s.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await i.parseAsync(a)}parse(e,t){const i=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,r),o=this.parseImages(e.images,function(){t!==void 0&&t(u)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),u=this.parseObject(e.object,s,l,a,i),c=this.parseSkeletons(e.skeletons,u);if(this.bindSkeletons(u,c),t!==void 0){let h=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(u)}return u}async parseAsync(e){const t=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),s=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,s),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,r,a,o,t),u=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,u),l}parseShapes(e){const t={};if(e!==void 0)for(let i=0,r=e.length;i<r;i++){const s=new of().fromJSON(e[i]);t[s.uuid]=s}return t}parseSkeletons(e,t){const i={},r={};if(t.traverse(function(s){s.isBone&&(r[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new i0().fromJSON(e[s],r);i[a.uuid]=a}return i}parseGeometries(e,t){const i={};if(e!==void 0){const r=new cee;for(let s=0,o=e.length;s<o;s++){let a;const l=e[s];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=r.parse(l);break;default:l.type in Y5?a=Y5[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),i[l.uuid]=a}}return i}parseMaterials(e,t){const i={},r={};if(e!==void 0){const s=new t2;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];i[l.uuid]===void 0&&(i[l.uuid]=s.parse(l)),r[l.uuid]=i[l.uuid]}}return r}parseAnimations(e){const t={};if(e!==void 0)for(let i=0;i<e.length;i++){const r=e[i],s=kf.parse(r);t[s.uuid]=s}return t}parseImages(e,t){const i=this,r={};let s;function o(l){return i.manager.itemStart(l),s.load(l,function(){i.manager.itemEnd(l)},void 0,function(){i.manager.itemError(l),i.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const u=l,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:i.resourcePath+u;return o(c)}else return l.data?{data:$g(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new fz(t);s=new i1(l),s.setCrossOrigin(this.crossOrigin);for(let u=0,c=e.length;u<c;u++){const h=e[u],d=h.url;if(Array.isArray(d)){const p=[];for(let f=0,g=d.length;f<g;f++){const y=d[f],m=a(y);m!==null&&(m instanceof HTMLImageElement?p.push(m):p.push(new sy(m.data,m.width,m.height)))}r[h.uuid]=new Hp(p)}else{const p=a(h.url);r[h.uuid]=new Hp(p)}}}return r}async parseImagesAsync(e){const t=this,i={};let r;async function s(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await r.loadAsync(l)}else return o.data?{data:$g(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){r=new i1(this.manager),r.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],u=l.url;if(Array.isArray(u)){const c=[];for(let h=0,d=u.length;h<d;h++){const p=u[h],f=await s(p);f!==null&&(f instanceof HTMLImageElement?c.push(f):c.push(new sy(f.data,f.width,f.height)))}i[l.uuid]=new Hp(c)}else{const c=await s(l.url);i[l.uuid]=new Hp(c)}}}return i}parseTextures(e,t){function i(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const r={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],u=l.data;let c;Array.isArray(u)?(c=new X1,u.length===6&&(c.needsUpdate=!0)):(u&&u.data?c=new sy:c=new ni,u&&(c.needsUpdate=!0)),c.source=l,c.uuid=a.uuid,a.name!==void 0&&(c.name=a.name),a.mapping!==void 0&&(c.mapping=i(a.mapping,aRe)),a.channel!==void 0&&(c.channel=a.channel),a.offset!==void 0&&c.offset.fromArray(a.offset),a.repeat!==void 0&&c.repeat.fromArray(a.repeat),a.center!==void 0&&c.center.fromArray(a.center),a.rotation!==void 0&&(c.rotation=a.rotation),a.wrap!==void 0&&(c.wrapS=i(a.wrap[0],eK),c.wrapT=i(a.wrap[1],eK)),a.format!==void 0&&(c.format=a.format),a.internalFormat!==void 0&&(c.internalFormat=a.internalFormat),a.type!==void 0&&(c.type=a.type),a.colorSpace!==void 0&&(c.colorSpace=a.colorSpace),a.encoding!==void 0&&(c.encoding=a.encoding),a.minFilter!==void 0&&(c.minFilter=i(a.minFilter,tK)),a.magFilter!==void 0&&(c.magFilter=i(a.magFilter,tK)),a.anisotropy!==void 0&&(c.anisotropy=a.anisotropy),a.flipY!==void 0&&(c.flipY=a.flipY),a.generateMipmaps!==void 0&&(c.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(c.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(c.compareFunction=a.compareFunction),a.userData!==void 0&&(c.userData=a.userData),r[a.uuid]=c}return r}parseObject(e,t,i,r,s){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const p=[];for(let f=0,g=d.length;f<g;f++){const y=d[f];i[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),p.push(i[y])}return p}return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),i[d]}}function u(d){return r[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),r[d]}let c,h;switch(e.type){case"Scene":o=new Ey,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new lt(e.background):o.background=u(e.background)),e.environment!==void 0&&(o.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new NE(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new RE(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":o=new ci(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new Al(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new yz(e.color,e.intensity);break;case"DirectionalLight":o=new e2(e.color,e.intensity);break;case"PointLight":o=new qE(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new oee(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new QE(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new see(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new lee().fromJSON(e);break;case"SkinnedMesh":c=a(e.geometry),h=l(e.material),o=new LE(c,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":c=a(e.geometry),h=l(e.material),o=new pr(c,h);break;case"InstancedMesh":c=a(e.geometry),h=l(e.material);const d=e.count,p=e.instanceMatrix,f=e.instanceColor;o=new PE(c,h,d),o.instanceMatrix=new Ef(new Float32Array(p.array),16),f!==void 0&&(o.instanceColor=new Ef(new Float32Array(f.array),f.itemSize));break;case"LOD":o=new Pq;break;case"Line":o=new Fu(a(e.geometry),l(e.material));break;case"LineLoop":o=new DE(a(e.geometry),l(e.material));break;case"LineSegments":o=new il(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new FE(a(e.geometry),l(e.material));break;case"Sprite":o=new Lq(l(e.material));break;case"Group":o=new Ks;break;case"Bone":o=new K1;break;default:o=new yn}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let p=0;p<d.length;p++)o.add(this.parseObject(d[p],t,i,r,s))}if(e.animations!==void 0){const d=e.animations;for(let p=0;p<d.length;p++){const f=d[p];o.animations.push(s[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let p=0;p<d.length;p++){const f=d[p],g=o.getObjectByProperty("uuid",f.object);g!==void 0&&o.addLevel(g,f.distance,f.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(i){if(i.isSkinnedMesh===!0&&i.skeleton!==void 0){const r=t[i.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(r,i.bindMatrix)}})}}const aRe={UVMapping:TE,CubeReflectionMapping:Dc,CubeRefractionMapping:md,EquirectangularReflectionMapping:Wv,EquirectangularRefractionMapping:Hv,CubeUVReflectionMapping:qy},eK={RepeatWrapping:Ul,ClampToEdgeWrapping:$r,MirroredRepeatWrapping:Tf},tK={NearestFilter:Ei,NearestMipmapNearestFilter:_y,NearestMipmapLinearFilter:nf,LinearFilter:Zn,LinearMipmapNearestFilter:V1,LinearMipmapLinearFilter:qa};class bz extends fs{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Rf.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){Rf.add(e,l),t&&t(l),s.manager.itemEnd(e)}).catch(function(l){r&&r(l),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}let VC;class xz{static getContext(){return VC===void 0&&(VC=new(window.AudioContext||window.webkitAudioContext)),VC}static setContext(e){VC=e}}class lRe extends fs{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new Qs(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const u=l.slice(0);xz.getContext().decodeAudioData(u,function(h){t(h)},a)}catch(u){a(u)}},i,r);function a(l){r?r(l):console.error(l),s.manager.itemError(e)}}}const nK=new Ft,iK=new Ft,ap=new Ft;class uRe{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ci,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ci,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,ap.copy(e.projectionMatrix);const r=t.eyeSep/2,s=r*t.near/t.focus,o=t.near*Math.tan(rf*t.fov*.5)/t.zoom;let a,l;iK.elements[12]=-r,nK.elements[12]=r,a=-o*t.aspect+s,l=o*t.aspect+s,ap.elements[0]=2*t.near/(l-a),ap.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(ap),a=-o*t.aspect-s,l=o*t.aspect-s,ap.elements[0]=2*t.near/(l-a),ap.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(ap)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(iK),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(nK)}}class vz{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=rK(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=rK();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function rK(){return(typeof performance>"u"?Date:performance).now()}const lp=new Y,sK=new Li,cRe=new Y,up=new Y;class hRe extends yn{constructor(){super(),this.type="AudioListener",this.context=xz.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new vz}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(lp,sK,cRe),up.set(0,0,-1).applyQuaternion(sK),t.positionX){const r=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(lp.x,r),t.positionY.linearRampToValueAtTime(lp.y,r),t.positionZ.linearRampToValueAtTime(lp.z,r),t.forwardX.linearRampToValueAtTime(up.x,r),t.forwardY.linearRampToValueAtTime(up.y,r),t.forwardZ.linearRampToValueAtTime(up.z,r),t.upX.linearRampToValueAtTime(i.x,r),t.upY.linearRampToValueAtTime(i.y,r),t.upZ.linearRampToValueAtTime(i.z,r)}else t.setPosition(lp.x,lp.y,lp.z),t.setOrientation(up.x,up.y,up.z,i.x,i.y,i.z)}}class hee extends yn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const cp=new Y,oK=new Li,dRe=new Y,hp=new Y;class pRe extends hee{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,i){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=i,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(cp,oK,dRe),hp.set(0,0,1).applyQuaternion(oK);const t=this.panner;if(t.positionX){const i=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(cp.x,i),t.positionY.linearRampToValueAtTime(cp.y,i),t.positionZ.linearRampToValueAtTime(cp.z,i),t.orientationX.linearRampToValueAtTime(hp.x,i),t.orientationY.linearRampToValueAtTime(hp.y,i),t.orientationZ.linearRampToValueAtTime(hp.z,i)}else t.setPosition(cp.x,cp.y,cp.z),t.setOrientation(hp.x,hp.y,hp.z)}}class fRe{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}class dee{constructor(e,t,i){this.binding=e,this.valueSize=i;let r,s,o;switch(t){case"quaternion":r=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:r=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const i=this.buffer,r=this.valueSize,s=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)i[s+a]=i[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(i,s,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,i=this.valueSize,r=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,i),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,i=this.buffer,r=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=t*this._origIndex;this._mixBufferRegion(i,r,l,1-s,t)}o>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*t,1,t);for(let l=t,u=t+t;l!==u;++l)if(i[l]!==i[l+t]){a.setValue(i,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,i=this.valueSize,r=i*this._origIndex;e.getValue(t,r);for(let s=i,o=r;s!==o;++s)t[s]=t[r+s%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}_select(e,t,i,r,s){if(r>=.5)for(let o=0;o!==s;++o)e[t+o]=e[i+o]}_slerp(e,t,i,r){Li.slerpFlat(e,t,e,t,e,i,r)}_slerpAdditive(e,t,i,r,s){const o=this._workIndex*s;Li.multiplyQuaternionsFlat(e,o,e,t,e,i),Li.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,i,r,s){const o=1-r;for(let a=0;a!==s;++a){const l=t+a;e[l]=e[l]*o+e[i+a]*r}}_lerpAdditive(e,t,i,r,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[i+o]*r}}}const wz="\\[\\]\\.:\\/",mRe=new RegExp("["+wz+"]","g"),Sz="[^"+wz+"]",gRe="[^"+wz.replace("\\.","")+"]",yRe=/((?:WC+[\/:])*)/.source.replace("WC",Sz),bRe=/(WCOD+)?/.source.replace("WCOD",gRe),xRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Sz),vRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Sz),wRe=new RegExp("^"+yRe+bRe+xRe+vRe+"$"),SRe=["material","materials","bones","map"];class TRe{constructor(e,t,i){const r=i||Cn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,r=this._bindings[i];r!==void 0&&r.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=i.length;r!==s;++r)i[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}}class Cn{constructor(e,t,i){this.path=t,this.parsedPath=i||Cn.parseTrackName(t),this.node=Cn.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new Cn.Composite(e,t,i):new Cn(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(mRe,"")}static parseTrackName(e){const t=wRe.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=i.nodeName&&i.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=i.nodeName.substring(r+1);SRe.indexOf(s)!==-1&&(i.nodeName=i.nodeName.substring(0,r),i.objectName=s)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(i!==void 0)return i}if(e.children){const i=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const l=i(a.children);if(l)return l}return null},r=i(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)e[t++]=i[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,r=t.propertyName;let s=t.propertyIndex;if(e||(e=Cn.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let u=t.objectIndex;switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const o=e[r];if(o===void 0){const u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Cn.Composite=TRe;Cn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Cn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Cn.prototype.GetterByBindingType=[Cn.prototype._getValue_direct,Cn.prototype._getValue_array,Cn.prototype._getValue_arrayElement,Cn.prototype._getValue_toArray];Cn.prototype.SetterByBindingTypeAndVersioning=[[Cn.prototype._setValue_direct,Cn.prototype._setValue_direct_setNeedsUpdate,Cn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Cn.prototype._setValue_array,Cn.prototype._setValue_array_setNeedsUpdate,Cn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Cn.prototype._setValue_arrayElement,Cn.prototype._setValue_arrayElement_setNeedsUpdate,Cn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Cn.prototype._setValue_fromArray,Cn.prototype._setValue_fromArray_setNeedsUpdate,Cn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class CRe{constructor(){this.isAnimationObjectGroup=!0,this.uuid=sa(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let i=0,r=arguments.length;i!==r;++i)e[arguments[i].uuid]=i;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length;let a,l=e.length,u=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const d=arguments[c],p=d.uuid;let f=t[p];if(f===void 0){f=l++,t[p]=f,e.push(d);for(let g=0,y=o;g!==y;++g)s[g].push(new Cn(d,i[g],r[g]))}else if(f<u){a=e[f];const g=--u,y=e[g];t[y.uuid]=f,e[f]=y,t[p]=g,e[g]=d;for(let m=0,v=o;m!==v;++m){const w=s[m],S=w[g];let C=w[f];w[f]=S,C===void 0&&(C=new Cn(d,i[m],r[m])),w[g]=C}}else e[f]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let s=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],u=l.uuid,c=t[u];if(c!==void 0&&c>=s){const h=s++,d=e[h];t[d.uuid]=c,e[c]=d,t[u]=h,e[h]=l;for(let p=0,f=r;p!==f;++p){const g=i[p],y=g[h],m=g[c];g[c]=y,g[h]=m}}}this.nCachedObjects_=s}uncache(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let s=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const u=arguments[a],c=u.uuid,h=t[c];if(h!==void 0)if(delete t[c],h<s){const d=--s,p=e[d],f=--o,g=e[f];t[p.uuid]=h,e[h]=p,t[g.uuid]=d,e[d]=g,e.pop();for(let y=0,m=r;y!==m;++y){const v=i[y],w=v[d],S=v[f];v[h]=w,v[d]=S,v.pop()}}else{const d=--o,p=e[d];d>0&&(t[p.uuid]=h),e[h]=p,e.pop();for(let f=0,g=r;f!==g;++f){const y=i[f];y[h]=y[d],y.pop()}}}this.nCachedObjects_=s}subscribe_(e,t){const i=this._bindingsIndicesByPath;let r=i[e];const s=this._bindings;if(r!==void 0)return s[r];const o=this._paths,a=this._parsedPaths,l=this._objects,u=l.length,c=this.nCachedObjects_,h=new Array(u);r=s.length,i[e]=r,o.push(e),a.push(t),s.push(h);for(let d=c,p=l.length;d!==p;++d){const f=l[d];h[d]=new Cn(f,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,i=t[e];if(i!==void 0){const r=this._paths,s=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],u=e[a];t[u]=i,o[i]=l,o.pop(),s[i]=s[a],s.pop(),r[i]=r[a],r.pop()}}}class pee{constructor(e,t,i=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=r;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:Up,endingEnd:Up};for(let u=0;u!==o;++u){const c=s[u].createInterpolant(null);a[u]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=nq,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){const r=this._clip.duration,s=e._clip.duration,o=s/r,a=r/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,u=a.sampleValues;return l[0]=s,l[1]=s+i,u[0]=e/o,u[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*i;l<0||i===0?t=0:(this._startTime=null,t=i*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case XB:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulateAdditive(a);break;case _E:default:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let r=this.time+e,s=this._loopCount;const o=i===iq;if(e===0)return s===-1?r:o&&(s&1)===1?t-r:r;if(i===tq){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const u=e<0;this._setEndings(u,!u,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return t-r}return r}_setEndings(e,t,i){const r=this._interpolantSettings;i?(r.endingStart=$p,r.endingEnd=$p):(e?r.endingStart=this.zeroSlopeAtStart?$p:Up:r.endingStart=Xv,t?r.endingEnd=this.zeroSlopeAtEnd?$p:Up:r.endingEnd=Xv)}_scheduleFading(e,t,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=i,this}}const _Re=new Float32Array(1);class Tz extends Wu{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const i=e._localRoot||this._root,r=e._clip.tracks,s=r.length,o=e._propertyBindings,a=e._interpolants,l=i.uuid,u=this._bindingsByRootAndName;let c=u[l];c===void 0&&(c={},u[l]=c);for(let h=0;h!==s;++h){const d=r[h],p=d.name;let f=c[p];if(f!==void 0)++f.referenceCount,o[h]=f;else{if(f=o[h],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const g=t&&t._propertyBindings[h].binding.parsedPath;f=new dee(Cn.create(i,p,g),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),o[h]=f}a[h].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const i=(e._localRoot||this._root).uuid,r=e._clip.uuid,s=this._actionsByClip[r];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,r,i)}const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,i){const r=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[i]=e}_removeInactiveAction(e){const t=this._actions,i=t[t.length-1],r=e._cacheIndex;i._cacheIndex=r,t[r]=i,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,u=l[l.length-1],c=e._byClipCacheIndex;u._byClipCacheIndex=c,l[c]=u,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,i=e._cacheIndex,r=this._nActiveActions++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackAction(e){const t=this._actions,i=e._cacheIndex,r=--this._nActiveActions,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_addInactiveBinding(e,t,i){const r=this._bindingsByRootAndName,s=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[i]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,i=e.binding,r=i.rootNode.uuid,s=i.path,o=this._bindingsByRootAndName,a=o[r],l=t[t.length-1],u=e._cacheIndex;l._cacheIndex=u,t[u]=l,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,i=e._cacheIndex,r=this._nActiveBindings++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackBinding(e){const t=this._bindings,i=e._cacheIndex,r=--this._nActiveBindings,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let i=e[t];return i===void 0&&(i=new dz(new Float32Array(2),new Float32Array(2),1,_Re),i.__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){const t=this._controlInterpolants,i=e.__cacheIndex,r=--this._nActiveControlInterpolants,s=t[r];e.__cacheIndex=r,t[r]=e,s.__cacheIndex=i,t[i]=s}clipAction(e,t,i){const r=t||this._root,s=r.uuid;let o=typeof e=="string"?kf.findByName(r,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let u=null;if(i===void 0&&(o!==null?i=o.blendMode:i=_E),l!==void 0){const h=l.actionByRoot[s];if(h!==void 0&&h.blendMode===i)return h;u=l.knownActions[0],o===null&&(o=u._clip)}if(o===null)return null;const c=new pee(this,o,t,i);return this._bindAction(c,u),this._addInactiveAction(c,a,s),c}existingAction(e,t){const i=t||this._root,r=i.uuid,s=typeof e=="string"?kf.findByName(i,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let i=t-1;i>=0;--i)e[i].stop();return this}update(e){e*=this.timeScale;const t=this._actions,i=this._nActiveActions,r=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let u=0;u!==i;++u)t[u]._update(r,e,s,o);const a=this._bindings,l=this._nActiveBindings;for(let u=0;u!==l;++u)a[u].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,i=e.uuid,r=this._actionsByClip,s=r[i];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const u=o[a];this._deactivateAction(u);const c=u._cacheIndex,h=t[t.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,h._cacheIndex=c,t[c]=h,t.pop(),this._removeInactiveBindingsForAction(u)}delete r[i]}}uncacheRoot(e){const t=e.uuid,i=this._actionsByClip;for(const o in i){const a=i[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const i=this.existingAction(e,t);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class Cz{constructor(e){this.value=e}clone(){return new Cz(this.value.clone===void 0?this.value:this.value.clone())}}let MRe=0;class ARe extends Wu{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:MRe++}),this.name="",this.usage=Yv,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let i=0,r=t.length;i<r;i++)this.uniforms.push(t[i].clone());return this}clone(){return new this.constructor().copy(this)}}class ERe extends n0{constructor(e,t,i=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class IRe{constructor(e,t,i,r,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=i,this.elementSize=r,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class _z{constructor(e,t,i=0,r=1/0){this.ray=new sm(e,t),this.near=i,this.far=r,this.camera=null,this.layers=new sf,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,i=[]){return G3(e,this,i,t),i.sort(aK),i}intersectObjects(e,t=!0,i=[]){for(let r=0,s=e.length;r<s;r++)G3(e[r],this,i,t);return i.sort(aK),i}}function aK(n,e){return n.distance-e.distance}function G3(n,e,t,i){if(n.layers.test(e.layers)&&n.raycast(e,t),i===!0){const r=n.children;for(let s=0,o=r.length;s<o;s++)G3(r[s],e,t,!0)}}class V3{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(Ui(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class kRe{constructor(e=1,t=0,i=0){return this.radius=e,this.theta=t,this.y=i,this}set(e,t,i){return this.radius=e,this.theta=t,this.y=i,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+i*i),this.theta=Math.atan2(e,i),this.y=t,this}clone(){return new this.constructor().copy(this)}}const lK=new Ge;class RRe{constructor(e=new Ge(1/0,1/0),t=new Ge(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=lK.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,lK).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const uK=new Y,UC=new Y;class NRe{constructor(e=new Y,t=new Y){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){uK.subVectors(e,this.start),UC.subVectors(this.end,this.start);const i=UC.dot(UC);let s=UC.dot(uK)/i;return t&&(s=Ui(s,0,1)),s}closestPointToPoint(e,t,i){const r=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const cK=new Y;class LRe extends yn{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const i=new rn,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const u=o/l*Math.PI*2,c=a/l*Math.PI*2;r.push(Math.cos(u),Math.sin(u),1,Math.cos(c),Math.sin(c),1)}i.setAttribute("position",new It(r,3));const s=new ps({fog:!1,toneMapped:!1});this.cone=new il(i,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),cK.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(cK),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const vh=new Y,$C=new Ft,wL=new Ft;class PRe extends il{constructor(e){const t=fee(e),i=new rn,r=[],s=[],o=new lt(0,0,1),a=new lt(0,1,0);for(let u=0;u<t.length;u++){const c=t[u];c.parent&&c.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new It(r,3)),i.setAttribute("color",new It(s,3));const l=new ps({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,i=this.geometry,r=i.getAttribute("position");wL.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&($C.multiplyMatrices(wL,a.matrixWorld),vh.setFromMatrixPosition($C),r.setXYZ(o,vh.x,vh.y,vh.z),$C.multiplyMatrices(wL,a.parent.matrixWorld),vh.setFromMatrixPosition($C),r.setXYZ(o+1,vh.x,vh.y,vh.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function fee(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,fee(n.children[t]));return e}class DRe extends pr{constructor(e,t,i){const r=new J1(t,4,2),s=new dr({wireframe:!0,fog:!1,toneMapped:!1});super(r,s),this.light=e,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const FRe=new Y,hK=new lt,dK=new lt;class ORe extends yn{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="HemisphereLightHelper";const r=new Y1(t);r.rotateY(Math.PI*.5),this.material=new dr({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=r.getAttribute("position"),o=new Float32Array(s.count*3);r.setAttribute("color",new En(o,3)),this.add(new pr(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");hK.copy(this.light.color),dK.copy(this.light.groundColor);for(let i=0,r=t.count;i<r;i++){const s=i<r/2?hK:dK;t.setXYZ(i,s.r,s.g,s.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(FRe.setFromMatrixPosition(this.light.matrixWorld).negate())}}class BRe extends il{constructor(e=10,t=10,i=4473924,r=8947848){i=new lt(i),r=new lt(r);const s=t/2,o=e/t,a=e/2,l=[],u=[];for(let d=0,p=0,f=-a;d<=t;d++,f+=o){l.push(-a,0,f,a,0,f),l.push(f,0,-a,f,0,a);const g=d===s?i:r;g.toArray(u,p),p+=3,g.toArray(u,p),p+=3,g.toArray(u,p),p+=3,g.toArray(u,p),p+=3}const c=new rn;c.setAttribute("position",new It(l,3)),c.setAttribute("color",new It(u,3));const h=new ps({vertexColors:!0,toneMapped:!1});super(c,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class zRe extends il{constructor(e=10,t=16,i=8,r=64,s=4473924,o=8947848){s=new lt(s),o=new lt(o);const a=[],l=[];if(t>1)for(let h=0;h<t;h++){const d=h/t*(Math.PI*2),p=Math.sin(d)*e,f=Math.cos(d)*e;a.push(0,0,0),a.push(p,0,f);const g=h&1?s:o;l.push(g.r,g.g,g.b),l.push(g.r,g.g,g.b)}for(let h=0;h<i;h++){const d=h&1?s:o,p=e-e/i*h;for(let f=0;f<r;f++){let g=f/r*(Math.PI*2),y=Math.sin(g)*p,m=Math.cos(g)*p;a.push(y,0,m),l.push(d.r,d.g,d.b),g=(f+1)/r*(Math.PI*2),y=Math.sin(g)*p,m=Math.cos(g)*p,a.push(y,0,m),l.push(d.r,d.g,d.b)}}const u=new rn;u.setAttribute("position",new It(a,3)),u.setAttribute("color",new It(l,3));const c=new ps({vertexColors:!0,toneMapped:!1});super(u,c),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const pK=new Y,WC=new Y,fK=new Y;class GRe extends yn{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",t===void 0&&(t=1);let r=new rn;r.setAttribute("position",new It([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new ps({fog:!1,toneMapped:!1});this.lightPlane=new Fu(r,s),this.add(this.lightPlane),r=new rn,r.setAttribute("position",new It([0,0,0,0,0,1],3)),this.targetLine=new Fu(r,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),pK.setFromMatrixPosition(this.light.matrixWorld),WC.setFromMatrixPosition(this.light.target.matrixWorld),fK.subVectors(WC,pK),this.lightPlane.lookAt(WC),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(WC),this.targetLine.scale.z=fK.length()}}const HC=new Y,zi=new H1;class VRe extends il{constructor(e){const t=new rn,i=new ps({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],s=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(f,g){l(f),l(g)}function l(f){r.push(0,0,0),s.push(0,0,0),o[f]===void 0&&(o[f]=[]),o[f].push(r.length/3-1)}t.setAttribute("position",new It(r,3)),t.setAttribute("color",new It(s,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const u=new lt(16755200),c=new lt(16711680),h=new lt(43775),d=new lt(16777215),p=new lt(3355443);this.setColors(u,c,h,d,p)}setColors(e,t,i,r,s){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,i.r,i.g,i.b),a.setXYZ(33,i.r,i.g,i.b),a.setXYZ(34,i.r,i.g,i.b),a.setXYZ(35,i.r,i.g,i.b),a.setXYZ(36,i.r,i.g,i.b),a.setXYZ(37,i.r,i.g,i.b),a.setXYZ(38,r.r,r.g,r.b),a.setXYZ(39,r.r,r.g,r.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,i=1,r=1;zi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Yi("c",t,e,zi,0,0,-1),Yi("t",t,e,zi,0,0,1),Yi("n1",t,e,zi,-i,-r,-1),Yi("n2",t,e,zi,i,-r,-1),Yi("n3",t,e,zi,-i,r,-1),Yi("n4",t,e,zi,i,r,-1),Yi("f1",t,e,zi,-i,-r,1),Yi("f2",t,e,zi,i,-r,1),Yi("f3",t,e,zi,-i,r,1),Yi("f4",t,e,zi,i,r,1),Yi("u1",t,e,zi,i*.7,r*1.1,-1),Yi("u2",t,e,zi,-i*.7,r*1.1,-1),Yi("u3",t,e,zi,0,r*2,-1),Yi("cf1",t,e,zi,-i,0,1),Yi("cf2",t,e,zi,i,0,1),Yi("cf3",t,e,zi,0,-r,1),Yi("cf4",t,e,zi,0,r,1),Yi("cn1",t,e,zi,-i,0,-1),Yi("cn2",t,e,zi,i,0,-1),Yi("cn3",t,e,zi,0,-r,-1),Yi("cn4",t,e,zi,0,r,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Yi(n,e,t,i,r,s,o){HC.set(r,s,o).unproject(i);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let u=0,c=a.length;u<c;u++)l.setXYZ(a[u],HC.x,HC.y,HC.z)}}const XC=new nl;class URe extends il{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),s=new rn;s.setIndex(new En(i,1)),s.setAttribute("position",new En(r,3)),super(s,new ps({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&XC.setFromObject(this.object),XC.isEmpty())return;const t=XC.min,i=XC.max,r=this.geometry.attributes.position,s=r.array;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=t.x,s[4]=i.y,s[5]=i.z,s[6]=t.x,s[7]=t.y,s[8]=i.z,s[9]=i.x,s[10]=t.y,s[11]=i.z,s[12]=i.x,s[13]=i.y,s[14]=t.z,s[15]=t.x,s[16]=i.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=i.x,s[22]=t.y,s[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class $Re extends il{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new rn;s.setIndex(new En(i,1)),s.setAttribute("position",new It(r,3)),super(s,new ps({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class WRe extends Fu{constructor(e,t=1,i=16776960){const r=i,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new rn;o.setAttribute("position",new It(s,3)),o.computeBoundingSphere(),super(o,new ps({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new rn;l.setAttribute("position",new It(a,3)),l.computeBoundingSphere(),this.add(new pr(l,new dr({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const mK=new Y;let KC,SL;class HRe extends yn{constructor(e=new Y(0,0,1),t=new Y(0,0,0),i=1,r=16776960,s=i*.2,o=s*.2){super(),this.type="ArrowHelper",KC===void 0&&(KC=new rn,KC.setAttribute("position",new It([0,0,0,0,1,0],3)),SL=new r0(0,.5,1,5,1),SL.translate(0,-.5,0)),this.position.copy(t),this.line=new Fu(KC,new ps({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new pr(SL,new dr({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(i,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{mK.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(mK,t)}}setLength(e,t=e*.2,i=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(i,t,i),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class XRe extends il{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new rn;r.setAttribute("position",new It(t,3)),r.setAttribute("color",new It(i,3));const s=new ps({vertexColors:!0,toneMapped:!1});super(r,s),this.type="AxesHelper"}setColors(e,t,i){const r=new lt,s=this.geometry.attributes.color.array;return r.set(e),r.toArray(s,0),r.toArray(s,3),r.set(t),r.toArray(s,6),r.toArray(s,9),r.set(i),r.toArray(s,12),r.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class KRe{constructor(){this.type="ShapePath",this.color=new lt,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new qv,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,i,r){return this.currentPath.quadraticCurveTo(e,t,i,r),this}bezierCurveTo(e,t,i,r,s,o){return this.currentPath.bezierCurveTo(e,t,i,r,s,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(m){const v=[];for(let w=0,S=m.length;w<S;w++){const C=m[w],_=new of;_.curves=C.curves,v.push(_)}return v}function i(m,v){const w=v.length;let S=!1;for(let C=w-1,_=0;_<w;C=_++){let A=v[C],I=v[_],E=I.x-A.x,k=I.y-A.y;if(Math.abs(k)>Number.EPSILON){if(k<0&&(A=v[_],E=-E,I=v[C],k=-k),m.y<A.y||m.y>I.y)continue;if(m.y===A.y){if(m.x===A.x)return!0}else{const P=k*(m.x-A.x)-E*(m.y-A.y);if(P===0)return!0;if(P<0)continue;S=!S}}else{if(m.y!==A.y)continue;if(I.x<=m.x&&m.x<=A.x||A.x<=m.x&&m.x<=I.x)return!0}}return S}const r=Iu.isClockWise,s=this.subPaths;if(s.length===0)return[];let o,a,l;const u=[];if(s.length===1)return a=s[0],l=new of,l.curves=a.curves,u.push(l),u;let c=!r(s[0].getPoints());c=e?!c:c;const h=[],d=[];let p=[],f=0,g;d[f]=void 0,p[f]=[];for(let m=0,v=s.length;m<v;m++)a=s[m],g=a.getPoints(),o=r(g),o=e?!o:o,o?(!c&&d[f]&&f++,d[f]={s:new of,p:g},d[f].s.curves=a.curves,c&&f++,p[f]=[]):p[f].push({h:a,p:g[0]});if(!d[0])return t(s);if(d.length>1){let m=!1,v=0;for(let w=0,S=d.length;w<S;w++)h[w]=[];for(let w=0,S=d.length;w<S;w++){const C=p[w];for(let _=0;_<C.length;_++){const A=C[_];let I=!0;for(let E=0;E<d.length;E++)i(A.p,d[E].p)&&(w!==E&&v++,I?(I=!1,h[E].push(A)):m=!0);I&&h[w].push(A)}}v>0&&m===!1&&(p=h)}let y;for(let m=0,v=d.length;m<v;m++){l=d[m].s,u.push(l),y=p[m];for(let w=0,S=y.length;w<S;w++)l.holes.push(y[w].h)}return u}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:z1}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=z1);const ZRe=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:zB,AddEquation:Fh,AddOperation:GQ,AdditiveAnimationBlendMode:XB,AdditiveBlending:e3,AlphaFormat:ZQ,AlwaysCompare:fq,AlwaysDepth:LQ,AlwaysStencilFunc:R3,AmbientLight:yz,AnimationAction:pee,AnimationClip:kf,AnimationLoader:qke,AnimationMixer:Tz,AnimationObjectGroup:CRe,AnimationUtils:jke,ArcCurve:Dq,ArrayCamera:kq,ArrowHelper:HRe,AttachedBindMode:s3,Audio:hee,AudioAnalyser:fRe,AudioContext:xz,AudioListener:hRe,AudioLoader:lRe,AxesHelper:XRe,BackSide:Ys,BasicDepthPacking:rq,BasicShadowMap:mQ,Bone:K1,BooleanKeyframeTrack:um,Box2:RRe,Box3:nl,Box3Helper:$Re,BoxGeometry:om,BoxHelper:URe,BufferAttribute:En,BufferGeometry:rn,BufferGeometryLoader:cee,ByteType:XQ,Cache:Rf,Camera:H1,CameraHelper:VRe,CanvasTexture:xke,CapsuleGeometry:zE,CatmullRomCurve3:Fq,CineonToneMapping:$Q,CircleGeometry:GE,ClampToEdgeWrapping:$r,Clock:vz,Color:lt,ColorKeyframeTrack:pz,ColorManagement:Fn,CompressedArrayTexture:yke,CompressedCubeTexture:bke,CompressedTexture:OE,CompressedTextureLoader:eRe,ConeGeometry:VE,ConstantAlphaFactor:kQ,ConstantColorFactor:EQ,CubeCamera:Sq,CubeReflectionMapping:Dc,CubeRefractionMapping:md,CubeTexture:X1,CubeTextureLoader:tRe,CubeUVReflectionMapping:qy,CubicBezierCurve:oz,CubicBezierCurve3:Oq,CubicInterpolant:tee,CullFaceBack:qD,CullFaceFront:fQ,CullFaceFrontBack:x_e,CullFaceNone:pQ,Curve:Xl,CurvePath:zq,CustomBlending:gQ,CustomToneMapping:WQ,CylinderGeometry:r0,Cylindrical:kRe,Data3DTexture:JB,DataArrayTexture:AE,DataTexture:sy,DataTextureLoader:nRe,DataUtils:CMe,DecrementStencilOp:E_e,DecrementWrapStencilOp:k_e,DefaultLoadingManager:ree,DepthFormat:rd,DepthStencilFormat:_f,DepthTexture:iz,DetachedBindMode:HQ,DirectionalLight:e2,DirectionalLightHelper:GRe,DiscreteInterpolant:nee,DisplayP3ColorSpace:ME,DodecahedronGeometry:UE,DoubleSide:$a,DstAlphaFactor:TQ,DstColorFactor:_Q,DynamicCopyUsage:H_e,DynamicDrawUsage:z_e,DynamicReadUsage:U_e,EdgesGeometry:Gq,EllipseCurve:BE,EqualCompare:uq,EqualDepth:DQ,EqualStencilFunc:P_e,EquirectangularReflectionMapping:Wv,EquirectangularRefractionMapping:Hv,Euler:W1,EventDispatcher:Wu,ExtrudeGeometry:WE,FileLoader:Qs,Float16BufferAttribute:kMe,Float32BufferAttribute:It,Float64BufferAttribute:RMe,FloatType:Ml,Fog:NE,FogExp2:RE,FramebufferTexture:gke,FrontSide:Vl,Frustum:EE,GLBufferAttribute:IRe,GLSL1:K_e,GLSL3:N3,GreaterCompare:hq,GreaterDepth:OQ,GreaterEqualCompare:pq,GreaterEqualDepth:FQ,GreaterEqualStencilFunc:B_e,GreaterStencilFunc:F_e,GridHelper:BRe,Group:Ks,HalfFloatType:Cf,HemisphereLight:see,HemisphereLightHelper:ORe,IcosahedronGeometry:HE,ImageBitmapLoader:bz,ImageLoader:i1,ImageUtils:YB,IncrementStencilOp:A_e,IncrementWrapStencilOp:I_e,InstancedBufferAttribute:Ef,InstancedBufferGeometry:uee,InstancedInterleavedBuffer:ERe,InstancedMesh:PE,Int16BufferAttribute:EMe,Int32BufferAttribute:IMe,Int8BufferAttribute:_Me,IntType:GB,InterleavedBuffer:n0,InterleavedBufferAttribute:Oc,Interpolant:lm,InterpolateDiscrete:Mf,InterpolateLinear:Fc,InterpolateSmooth:W_,InvertStencilOp:R_e,KeepStencilOp:Mp,KeyframeTrack:Kl,LOD:Pq,LatheGeometry:j1,Layers:sf,LessCompare:lq,LessDepth:PQ,LessEqualCompare:cq,LessEqualDepth:$v,LessEqualStencilFunc:D_e,LessStencilFunc:L_e,Light:Fd,LightProbe:lee,Line:Fu,Line3:NRe,LineBasicMaterial:ps,LineCurve:az,LineCurve3:Bq,LineDashedMaterial:Qq,LineLoop:DE,LineSegments:il,LinearDisplayP3ColorSpace:$1,LinearEncoding:ZB,LinearFilter:Zn,LinearInterpolant:dz,LinearMipMapLinearFilter:C_e,LinearMipMapNearestFilter:T_e,LinearMipmapLinearFilter:qa,LinearMipmapNearestFilter:V1,LinearSRGBColorSpace:Zr,LinearToneMapping:VQ,LinearTransfer:Kv,Loader:fs,LoaderUtils:oa,LoadingManager:fz,LoopOnce:tq,LoopPingPong:iq,LoopRepeat:nq,LuminanceAlphaFormat:YQ,LuminanceFormat:jQ,MOUSE:Cp,Material:Pi,MaterialLoader:t2,MathUtils:Wp,Matrix3:hn,Matrix4:Ft,MaxEquation:r3,Mesh:pr,MeshBasicMaterial:dr,MeshDepthMaterial:tz,MeshDistanceMaterial:nz,MeshLambertMaterial:Yq,MeshMatcapMaterial:Jq,MeshNormalMaterial:jq,MeshPhongMaterial:Kq,MeshPhysicalMaterial:Qr,MeshStandardMaterial:am,MeshToonMaterial:Zq,MinEquation:i3,MirroredRepeatWrapping:Tf,MixOperation:zQ,MultiplyBlending:n3,MultiplyOperation:G1,NearestFilter:Ei,NearestMipMapLinearFilter:S_e,NearestMipMapNearestFilter:w_e,NearestMipmapLinearFilter:nf,NearestMipmapNearestFilter:_y,NeverCompare:aq,NeverDepth:NQ,NeverStencilFunc:N_e,NoBlending:Ac,NoColorSpace:jo,NoToneMapping:Au,NormalAnimationBlendMode:_E,NormalBlending:tf,NotEqualCompare:dq,NotEqualDepth:BQ,NotEqualStencilFunc:O_e,NumberKeyframeTrack:gd,Object3D:yn,ObjectLoader:oRe,ObjectSpaceNormalMap:oq,OctahedronGeometry:Y1,OneFactor:vQ,OneMinusConstantAlphaFactor:RQ,OneMinusConstantColorFactor:IQ,OneMinusDstAlphaFactor:CQ,OneMinusDstColorFactor:MQ,OneMinusSrcAlphaFactor:UM,OneMinusSrcColorFactor:SQ,OrthographicCamera:Al,P3Primaries:jv,PCFShadowMap:SE,PCFSoftShadowMap:uv,PMREMGenerator:P3,Path:qv,PerspectiveCamera:ci,Plane:uc,PlaneGeometry:e0,PlaneHelper:WRe,PointLight:qE,PointLightHelper:DRe,Points:FE,PointsMaterial:Z1,PolarGridHelper:zRe,PolyhedronGeometry:Dd,PositionalAudio:pRe,PropertyBinding:Cn,PropertyMixer:dee,QuadraticBezierCurve:lz,QuadraticBezierCurve3:uz,Quaternion:Li,QuaternionKeyframeTrack:Ou,QuaternionLinearInterpolant:iee,RED_GREEN_RGTC2_Format:I3,RED_RGTC1_Format:eq,REVISION:z1,RGBADepthPacking:sq,RGBAFormat:xo,RGBAIntegerFormat:HB,RGBA_ASTC_10x10_Format:T3,RGBA_ASTC_10x5_Format:v3,RGBA_ASTC_10x6_Format:w3,RGBA_ASTC_10x8_Format:S3,RGBA_ASTC_12x10_Format:C3,RGBA_ASTC_12x12_Format:_3,RGBA_ASTC_4x4_Format:d3,RGBA_ASTC_5x4_Format:p3,RGBA_ASTC_5x5_Format:f3,RGBA_ASTC_6x5_Format:m3,RGBA_ASTC_6x6_Format:g3,RGBA_ASTC_8x5_Format:y3,RGBA_ASTC_8x6_Format:b3,RGBA_ASTC_8x8_Format:x3,RGBA_BPTC_Format:$_,RGBA_ETC2_EAC_Format:h3,RGBA_PVRTC_2BPPV1_Format:u3,RGBA_PVRTC_4BPPV1_Format:l3,RGBA_S3TC_DXT1_Format:G_,RGBA_S3TC_DXT3_Format:V_,RGBA_S3TC_DXT5_Format:U_,RGB_BPTC_SIGNED_Format:M3,RGB_BPTC_UNSIGNED_Format:A3,RGB_ETC1_Format:qQ,RGB_ETC2_Format:c3,RGB_PVRTC_2BPPV1_Format:a3,RGB_PVRTC_4BPPV1_Format:o3,RGB_S3TC_DXT1_Format:z_,RGFormat:QQ,RGIntegerFormat:WB,RawShaderMaterial:Xq,Ray:sm,Raycaster:_z,Rec709Primaries:Zv,RectAreaLight:oee,RedFormat:JQ,RedIntegerFormat:$B,ReinhardToneMapping:UQ,RenderTarget:bq,RepeatWrapping:Ul,ReplaceStencilOp:M_e,ReverseSubtractEquation:bQ,RingGeometry:XE,SIGNED_RED_GREEN_RGTC2_Format:k3,SIGNED_RED_RGTC1_Format:E3,SRGBColorSpace:bi,SRGBTransfer:Qn,Scene:Ey,ShaderChunk:on,ShaderLib:Tl,ShaderMaterial:Du,ShadowMaterial:Hq,Shape:of,ShapeGeometry:KE,ShapePath:KRe,ShapeUtils:Iu,ShortType:KQ,Skeleton:i0,SkeletonHelper:PRe,SkinnedMesh:LE,Source:Hp,Sphere:ya,SphereGeometry:J1,Spherical:V3,SphericalHarmonics3:aee,SplineCurve:cz,SpotLight:QE,SpotLightHelper:LRe,Sprite:Lq,SpriteMaterial:rz,SrcAlphaFactor:VM,SrcAlphaSaturateFactor:AQ,SrcColorFactor:wQ,StaticCopyUsage:W_e,StaticDrawUsage:Yv,StaticReadUsage:V_e,StereoCamera:uRe,StreamCopyUsage:X_e,StreamDrawUsage:G_e,StreamReadUsage:$_e,StringKeyframeTrack:cm,SubtractEquation:yQ,SubtractiveBlending:t3,TOUCH:_p,TangentSpaceNormalMap:Pd,TetrahedronGeometry:ZE,Texture:ni,TextureLoader:mz,TorusGeometry:jE,TorusKnotGeometry:YE,Triangle:bo,TriangleFanDrawMode:Af,TriangleStripDrawMode:U1,TrianglesDrawMode:KB,TubeGeometry:JE,TwoPassDoubleSide:v_e,UVMapping:TE,Uint16BufferAttribute:QB,Uint32BufferAttribute:qB,Uint8BufferAttribute:MMe,Uint8ClampedBufferAttribute:AMe,Uniform:Cz,UniformsGroup:ARe,UniformsLib:dt,UniformsUtils:wq,UnsignedByteType:Eu,UnsignedInt248Type:id,UnsignedIntType:xc,UnsignedShort4444Type:VB,UnsignedShort5551Type:UB,UnsignedShortType:CE,VSMShadowMap:xl,Vector2:Ge,Vector3:Y,Vector4:Gn,VectorKeyframeTrack:yd,VideoTexture:mke,WebGL1Renderer:Rq,WebGL3DRenderTarget:dMe,WebGLArrayRenderTarget:hMe,WebGLCoordinateSystem:xu,WebGLCubeRenderTarget:Tq,WebGLMultipleRenderTargets:pMe,WebGLRenderTarget:el,WebGLRenderer:kE,WebGLUtils:Iq,WebGPUCoordinateSystem:Jv,WireframeGeometry:Wq,WrapAroundEnding:Xv,ZeroCurvatureEnding:Up,ZeroFactor:xQ,ZeroSlopeEnding:$p,ZeroStencilOp:__e,_SRGBAFormat:$M,createCanvasElement:yq,sRGBEncoding:Ec},Symbol.toStringTag,{value:"Module"}));var mee={exports:{}},hm={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */hm.ConcurrentRoot=1;hm.ContinuousEventPriority=4;hm.DefaultEventPriority=16;hm.DiscreteEventPriority=1;hm.IdleEventPriority=536870912;hm.LegacyRoot=0;mee.exports=hm;var Xg=mee.exports;function jRe(n){let e;const t=new Set,i=(u,c)=>{const h=typeof u=="function"?u(e):u;if(h!==e){const d=e;e=c?h:Object.assign({},e,h),t.forEach(p=>p(e,d))}},r=()=>e,s=(u,c=r,h=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let d=c(e);function p(){const f=c(e);if(!h(d,f)){const g=d;u(d=f,g)}}return t.add(p),()=>t.delete(p)},l={setState:i,getState:r,subscribe:(u,c,h)=>c||h?s(u,c,h):(t.add(u),()=>t.delete(u)),destroy:()=>t.clear()};return e=n(i,r,l),l}const YRe=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),gK=YRe?K.useEffect:K.useLayoutEffect;function JRe(n){const e=typeof n=="function"?jRe(n):n,t=(i=e.getState,r=Object.is)=>{const[,s]=K.useReducer(y=>y+1,0),o=e.getState(),a=K.useRef(o),l=K.useRef(i),u=K.useRef(r),c=K.useRef(!1),h=K.useRef();h.current===void 0&&(h.current=i(o));let d,p=!1;(a.current!==o||l.current!==i||u.current!==r||c.current)&&(d=i(o),p=!r(h.current,d)),gK(()=>{p&&(h.current=d),a.current=o,l.current=i,u.current=r,c.current=!1});const f=K.useRef(o);gK(()=>{const y=()=>{try{const v=e.getState(),w=l.current(v);u.current(h.current,w)||(a.current=v,h.current=w,s())}catch{c.current=!0,s()}},m=e.subscribe(y);return e.getState()!==f.current&&y(),m},[]);const g=p?d:h.current;return K.useDebugValue(g),g};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const i=[t,e];return{next(){const r=i.length<=0;return{value:i.shift(),done:r}}}},t}var gee={exports:{}},yee={exports:{}},bee={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(n){function e(O,X){var j=O.length;O.push(X);e:for(;0<j;){var z=j-1>>>1,Z=O[z];if(0<r(Z,X))O[z]=X,O[j]=Z,j=z;else break e}}function t(O){return O.length===0?null:O[0]}function i(O){if(O.length===0)return null;var X=O[0],j=O.pop();if(j!==X){O[0]=j;e:for(var z=0,Z=O.length,ce=Z>>>1;z<ce;){var fe=2*(z+1)-1,ge=O[fe],Ne=fe+1,Fe=O[Ne];if(0>r(ge,j))Ne<Z&&0>r(Fe,ge)?(O[z]=Fe,O[Ne]=j,z=Ne):(O[z]=ge,O[fe]=j,z=fe);else if(Ne<Z&&0>r(Fe,j))O[z]=Fe,O[Ne]=j,z=Ne;else break e}}return X}function r(O,X){var j=O.sortIndex-X.sortIndex;return j!==0?j:O.id-X.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;n.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,d=3,p=!1,f=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,m=typeof clearTimeout=="function"?clearTimeout:null,v=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(O){for(var X=t(u);X!==null;){if(X.callback===null)i(u);else if(X.startTime<=O)i(u),X.sortIndex=X.expirationTime,e(l,X);else break;X=t(u)}}function S(O){if(g=!1,w(O),!f)if(t(l)!==null)f=!0,J(C);else{var X=t(u);X!==null&&q(S,X.startTime-O)}}function C(O,X){f=!1,g&&(g=!1,m(I),I=-1),p=!0;var j=d;try{for(w(X),h=t(l);h!==null&&(!(h.expirationTime>X)||O&&!P());){var z=h.callback;if(typeof z=="function"){h.callback=null,d=h.priorityLevel;var Z=z(h.expirationTime<=X);X=n.unstable_now(),typeof Z=="function"?h.callback=Z:h===t(l)&&i(l),w(X)}else i(l);h=t(l)}if(h!==null)var ce=!0;else{var fe=t(u);fe!==null&&q(S,fe.startTime-X),ce=!1}return ce}finally{h=null,d=j,p=!1}}var _=!1,A=null,I=-1,E=5,k=-1;function P(){return!(n.unstable_now()-k<E)}function V(){if(A!==null){var O=n.unstable_now();k=O;var X=!0;try{X=A(!0,O)}finally{X?U():(_=!1,A=null)}}else _=!1}var U;if(typeof v=="function")U=function(){v(V)};else if(typeof MessageChannel<"u"){var F=new MessageChannel,$=F.port2;F.port1.onmessage=V,U=function(){$.postMessage(null)}}else U=function(){y(V,0)};function J(O){A=O,_||(_=!0,U())}function q(O,X){I=y(function(){O(n.unstable_now())},X)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(O){O.callback=null},n.unstable_continueExecution=function(){f||p||(f=!0,J(C))},n.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<O?Math.floor(1e3/O):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(O){switch(d){case 1:case 2:case 3:var X=3;break;default:X=d}var j=d;d=X;try{return O()}finally{d=j}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(O,X){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var j=d;d=O;try{return X()}finally{d=j}},n.unstable_scheduleCallback=function(O,X,j){var z=n.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?z+j:z):j=z,O){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=j+Z,O={id:c++,callback:X,priorityLevel:O,startTime:j,expirationTime:Z,sortIndex:-1},j>z?(O.sortIndex=j,e(u,O),t(l)===null&&O===t(u)&&(g?(m(I),I=-1):g=!0,q(S,j-z))):(O.sortIndex=Z,e(l,O),f||p||(f=!0,J(C))),O},n.unstable_shouldYield=P,n.unstable_wrapCallback=function(O){var X=d;return function(){var j=d;d=X;try{return O.apply(this,arguments)}finally{d=j}}}})(bee);yee.exports=bee;var U3=yee.exports;/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var QRe=function(e){var t={},i=K,r=U3,s=Object.assign;function o(b){for(var x="https://reactjs.org/docs/error-decoder.html?invariant="+b,T=1;T<arguments.length;T++)x+="&args[]="+encodeURIComponent(arguments[T]);return"Minified React error #"+b+"; visit "+x+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),u=Symbol.for("react.portal"),c=Symbol.for("react.fragment"),h=Symbol.for("react.strict_mode"),d=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),f=Symbol.for("react.context"),g=Symbol.for("react.forward_ref"),y=Symbol.for("react.suspense"),m=Symbol.for("react.suspense_list"),v=Symbol.for("react.memo"),w=Symbol.for("react.lazy"),S=Symbol.for("react.offscreen"),C=Symbol.iterator;function _(b){return b===null||typeof b!="object"?null:(b=C&&b[C]||b["@@iterator"],typeof b=="function"?b:null)}function A(b){if(b==null)return null;if(typeof b=="function")return b.displayName||b.name||null;if(typeof b=="string")return b;switch(b){case c:return"Fragment";case u:return"Portal";case d:return"Profiler";case h:return"StrictMode";case y:return"Suspense";case m:return"SuspenseList"}if(typeof b=="object")switch(b.$$typeof){case f:return(b.displayName||"Context")+".Consumer";case p:return(b._context.displayName||"Context")+".Provider";case g:var x=b.render;return b=b.displayName,b||(b=x.displayName||x.name||"",b=b!==""?"ForwardRef("+b+")":"ForwardRef"),b;case v:return x=b.displayName||null,x!==null?x:A(b.type)||"Memo";case w:x=b._payload,b=b._init;try{return A(b(x))}catch{}}return null}function I(b){var x=b.type;switch(b.tag){case 24:return"Cache";case 9:return(x.displayName||"Context")+".Consumer";case 10:return(x._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return b=x.render,b=b.displayName||b.name||"",x.displayName||(b!==""?"ForwardRef("+b+")":"ForwardRef");case 7:return"Fragment";case 5:return x;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return A(x);case 8:return x===h?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof x=="function")return x.displayName||x.name||null;if(typeof x=="string")return x}return null}function E(b){var x=b,T=b;if(b.alternate)for(;x.return;)x=x.return;else{b=x;do x=b,x.flags&4098&&(T=x.return),b=x.return;while(b)}return x.tag===3?T:null}function k(b){if(E(b)!==b)throw Error(o(188))}function P(b){var x=b.alternate;if(!x){if(x=E(b),x===null)throw Error(o(188));return x!==b?null:b}for(var T=b,M=x;;){var R=T.return;if(R===null)break;var L=R.alternate;if(L===null){if(M=R.return,M!==null){T=M;continue}break}if(R.child===L.child){for(L=R.child;L;){if(L===T)return k(R),b;if(L===M)return k(R),x;L=L.sibling}throw Error(o(188))}if(T.return!==M.return)T=R,M=L;else{for(var te=!1,be=R.child;be;){if(be===T){te=!0,T=R,M=L;break}if(be===M){te=!0,M=R,T=L;break}be=be.sibling}if(!te){for(be=L.child;be;){if(be===T){te=!0,T=L,M=R;break}if(be===M){te=!0,M=L,T=R;break}be=be.sibling}if(!te)throw Error(o(189))}}if(T.alternate!==M)throw Error(o(190))}if(T.tag!==3)throw Error(o(188));return T.stateNode.current===T?b:x}function V(b){return b=P(b),b!==null?U(b):null}function U(b){if(b.tag===5||b.tag===6)return b;for(b=b.child;b!==null;){var x=U(b);if(x!==null)return x;b=b.sibling}return null}function F(b){if(b.tag===5||b.tag===6)return b;for(b=b.child;b!==null;){if(b.tag!==4){var x=F(b);if(x!==null)return x}b=b.sibling}return null}var $=Array.isArray,J=e.getPublicInstance,q=e.getRootHostContext,O=e.getChildHostContext,X=e.prepareForCommit,j=e.resetAfterCommit,z=e.createInstance,Z=e.appendInitialChild,ce=e.finalizeInitialChildren,fe=e.prepareUpdate,ge=e.shouldSetTextContent,Ne=e.createTextInstance,Fe=e.scheduleTimeout,We=e.cancelTimeout,Ue=e.noTimeout,Ye=e.isPrimaryRenderer,$e=e.supportsMutation,ee=e.supportsPersistence,De=e.supportsHydration,_e=e.getInstanceFromNode,ze=e.preparePortalMount,Re=e.getCurrentEventPriority,nt=e.detachDeletedInstance,Ze=e.supportsMicrotasks,st=e.scheduleMicrotask,yt=e.supportsTestSelectors,Lt=e.findFiberRoot,ye=e.getBoundingRect,H=e.getTextContent,D=e.isHiddenSubtree,oe=e.matchAccessibilityRole,Ie=e.setFocusIfFocusable,Me=e.setupIntersectionObserver,Ve=e.appendChild,ct=e.appendChildToContainer,qe=e.commitTextUpdate,at=e.commitMount,Ot=e.commitUpdate,Xt=e.insertBefore,Qe=e.insertInContainerBefore,sn=e.removeChild,le=e.removeChildFromContainer,Oe=e.resetTextContent,je=e.hideInstance,Ke=e.hideTextInstance,Pt=e.unhideInstance,G=e.unhideTextInstance,re=e.clearContainer,pe=e.cloneInstance,de=e.createContainerChildSet,Te=e.appendChildToContainerChildSet,Je=e.finalizeContainerChildren,rt=e.replaceContainerChildren,ht=e.cloneHiddenInstance,pt=e.cloneHiddenTextInstance,vt=e.canHydrateInstance,Tn=e.canHydrateTextInstance,Ut=e.canHydrateSuspenseInstance,Nn=e.isSuspenseInstancePending,zn=e.isSuspenseInstanceFallback,Fi=e.registerSuspenseInstanceRetry,xr=e.getNextHydratableSibling,xa=e.getFirstHydratableChild,rh=e.getFirstHydratableChildWithinContainer,al=e.getFirstHydratableChildWithinSuspenseInstance,zs=e.hydrateInstance,sh=e.hydrateTextInstance,Hd=e.hydrateSuspenseInstance,Q=e.getNextHydratableInstanceAfterSuspenseInstance,we=e.commitHydratedContainer,Ae=e.commitHydratedSuspenseInstance,Se=e.clearSuspenseBoundary,Ee=e.clearSuspenseBoundaryFromContainer,tt=e.shouldDeleteUnhydratedTailInstances,Ct=e.didNotMatchHydratedContainerTextInstance,Bt=e.didNotMatchHydratedTextInstance,Gt;function Jt(b){if(Gt===void 0)try{throw Error()}catch(T){var x=T.stack.trim().match(/\n( *(at )?)/);Gt=x&&x[1]||""}return`
`+Gt+b}var Zt=!1;function Qt(b,x){if(!b||Zt)return"";Zt=!0;var T=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(x)if(x=function(){throw Error()},Object.defineProperty(x.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(x,[])}catch(it){var M=it}Reflect.construct(b,[],x)}else{try{x.call()}catch(it){M=it}b.call(x.prototype)}else{try{throw Error()}catch(it){M=it}b()}}catch(it){if(it&&M&&typeof it.stack=="string"){for(var R=it.stack.split(`
`),L=M.stack.split(`
`),te=R.length-1,be=L.length-1;1<=te&&0<=be&&R[te]!==L[be];)be--;for(;1<=te&&0<=be;te--,be--)if(R[te]!==L[be]){if(te!==1||be!==1)do if(te--,be--,0>be||R[te]!==L[be]){var Be=`
`+R[te].replace(" at new "," at ");return b.displayName&&Be.includes("<anonymous>")&&(Be=Be.replace("<anonymous>",b.displayName)),Be}while(1<=te&&0<=be);break}}}finally{Zt=!1,Error.prepareStackTrace=T}return(b=b?b.displayName||b.name:"")?Jt(b):""}var Ci=Object.prototype.hasOwnProperty,rs=[],oi=-1;function Nr(b){return{current:b}}function Ht(b){0>oi||(b.current=rs[oi],rs[oi]=null,oi--)}function Mt(b,x){oi++,rs[oi]=b.current,b.current=x}var va={},xn=Nr(va),Oi=Nr(!1),Ql=va;function wa(b,x){var T=b.type.contextTypes;if(!T)return va;var M=b.stateNode;if(M&&M.__reactInternalMemoizedUnmaskedChildContext===x)return M.__reactInternalMemoizedMaskedChildContext;var R={},L;for(L in T)R[L]=x[L];return M&&(b=b.stateNode,b.__reactInternalMemoizedUnmaskedChildContext=x,b.__reactInternalMemoizedMaskedChildContext=R),R}function Lr(b){return b=b.childContextTypes,b!=null}function or(){Ht(Oi),Ht(xn)}function ql(b,x,T){if(xn.current!==va)throw Error(o(168));Mt(xn,x),Mt(Oi,T)}function km(b,x,T){var M=b.stateNode;if(x=x.childContextTypes,typeof M.getChildContext!="function")return T;M=M.getChildContext();for(var R in M)if(!(R in x))throw Error(o(108,I(b)||"Unknown",R));return s({},T,M)}function Pr(b){return b=(b=b.stateNode)&&b.__reactInternalMemoizedMergedChildContext||va,Ql=xn.current,Mt(xn,b),Mt(Oi,Oi.current),!0}function Rm(b,x,T){var M=b.stateNode;if(!M)throw Error(o(169));T?(b=km(b,x,Ql),M.__reactInternalMemoizedMergedChildContext=b,Ht(Oi),Ht(xn),Mt(xn,b)):Ht(Oi),Mt(Oi,T)}var Oo=Math.clz32?Math.clz32:wae,VS=Math.log,vae=Math.LN2;function wae(b){return b>>>=0,b===0?32:31-(VS(b)/vae|0)|0}var US=64,$S=4194304;function Mb(b){switch(b&-b){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return b&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return b}}function WS(b,x){var T=b.pendingLanes;if(T===0)return 0;var M=0,R=b.suspendedLanes,L=b.pingedLanes,te=T&268435455;if(te!==0){var be=te&~R;be!==0?M=Mb(be):(L&=te,L!==0&&(M=Mb(L)))}else te=T&~R,te!==0?M=Mb(te):L!==0&&(M=Mb(L));if(M===0)return 0;if(x!==0&&x!==M&&!(x&R)&&(R=M&-M,L=x&-x,R>=L||R===16&&(L&4194240)!==0))return x;if(M&4&&(M|=T&16),x=b.entangledLanes,x!==0)for(b=b.entanglements,x&=M;0<x;)T=31-Oo(x),R=1<<T,M|=b[T],x&=~R;return M}function Sae(b,x){switch(b){case 1:case 2:case 4:return x+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return x+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Tae(b,x){for(var T=b.suspendedLanes,M=b.pingedLanes,R=b.expirationTimes,L=b.pendingLanes;0<L;){var te=31-Oo(L),be=1<<te,Be=R[te];Be===-1?(!(be&T)||be&M)&&(R[te]=Sae(be,x)):Be<=x&&(b.expiredLanes|=be),L&=~be}}function Ek(b){return b=b.pendingLanes&-1073741825,b!==0?b:b&1073741824?1073741824:0}function Ik(b){for(var x=[],T=0;31>T;T++)x.push(b);return x}function Ab(b,x,T){b.pendingLanes|=x,x!==536870912&&(b.suspendedLanes=0,b.pingedLanes=0),b=b.eventTimes,x=31-Oo(x),b[x]=T}function Cae(b,x){var T=b.pendingLanes&~x;b.pendingLanes=x,b.suspendedLanes=0,b.pingedLanes=0,b.expiredLanes&=x,b.mutableReadLanes&=x,b.entangledLanes&=x,x=b.entanglements;var M=b.eventTimes;for(b=b.expirationTimes;0<T;){var R=31-Oo(T),L=1<<R;x[R]=0,M[R]=-1,b[R]=-1,T&=~L}}function kk(b,x){var T=b.entangledLanes|=x;for(b=b.entanglements;T;){var M=31-Oo(T),R=1<<M;R&x|b[M]&x&&(b[M]|=x),T&=~R}}var Ln=0;function P$(b){return b&=-b,1<b?4<b?b&268435455?16:536870912:4:1}var Rk=r.unstable_scheduleCallback,D$=r.unstable_cancelCallback,_ae=r.unstable_shouldYield,Mae=r.unstable_requestPaint,Dr=r.unstable_now,Nk=r.unstable_ImmediatePriority,Aae=r.unstable_UserBlockingPriority,Lk=r.unstable_NormalPriority,Eae=r.unstable_IdlePriority,HS=null,eu=null;function Iae(b){if(eu&&typeof eu.onCommitFiberRoot=="function")try{eu.onCommitFiberRoot(HS,b,void 0,(b.current.flags&128)===128)}catch{}}function kae(b,x){return b===x&&(b!==0||1/b===1/x)||b!==b&&x!==x}var tu=typeof Object.is=="function"?Object.is:kae,Xu=null,XS=!1,Pk=!1;function F$(b){Xu===null?Xu=[b]:Xu.push(b)}function Rae(b){XS=!0,F$(b)}function nu(){if(!Pk&&Xu!==null){Pk=!0;var b=0,x=Ln;try{var T=Xu;for(Ln=1;b<T.length;b++){var M=T[b];do M=M(!0);while(M!==null)}Xu=null,XS=!1}catch(R){throw Xu!==null&&(Xu=Xu.slice(b+1)),Rk(Nk,nu),R}finally{Ln=x,Pk=!1}}return null}var Nae=a.ReactCurrentBatchConfig;function KS(b,x){if(tu(b,x))return!0;if(typeof b!="object"||b===null||typeof x!="object"||x===null)return!1;var T=Object.keys(b),M=Object.keys(x);if(T.length!==M.length)return!1;for(M=0;M<T.length;M++){var R=T[M];if(!Ci.call(x,R)||!tu(b[R],x[R]))return!1}return!0}function Lae(b){switch(b.tag){case 5:return Jt(b.type);case 16:return Jt("Lazy");case 13:return Jt("Suspense");case 19:return Jt("SuspenseList");case 0:case 2:case 15:return b=Qt(b.type,!1),b;case 11:return b=Qt(b.type.render,!1),b;case 1:return b=Qt(b.type,!0),b;default:return""}}function ll(b,x){if(b&&b.defaultProps){x=s({},x),b=b.defaultProps;for(var T in b)x[T]===void 0&&(x[T]=b[T]);return x}return x}var ZS=Nr(null),jS=null,Nm=null,Dk=null;function Fk(){Dk=Nm=jS=null}function O$(b,x,T){Ye?(Mt(ZS,x._currentValue),x._currentValue=T):(Mt(ZS,x._currentValue2),x._currentValue2=T)}function Ok(b){var x=ZS.current;Ht(ZS),Ye?b._currentValue=x:b._currentValue2=x}function Bk(b,x,T){for(;b!==null;){var M=b.alternate;if((b.childLanes&x)!==x?(b.childLanes|=x,M!==null&&(M.childLanes|=x)):M!==null&&(M.childLanes&x)!==x&&(M.childLanes|=x),b===T)break;b=b.return}}function Lm(b,x){jS=b,Dk=Nm=null,b=b.dependencies,b!==null&&b.firstContext!==null&&(b.lanes&x&&(Go=!0),b.firstContext=null)}function Sa(b){var x=Ye?b._currentValue:b._currentValue2;if(Dk!==b)if(b={context:b,memoizedValue:x,next:null},Nm===null){if(jS===null)throw Error(o(308));Nm=b,jS.dependencies={lanes:0,firstContext:b}}else Nm=Nm.next=b;return x}var iu=null,oh=!1;function zk(b){b.updateQueue={baseState:b.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function B$(b,x){b=b.updateQueue,x.updateQueue===b&&(x.updateQueue={baseState:b.baseState,firstBaseUpdate:b.firstBaseUpdate,lastBaseUpdate:b.lastBaseUpdate,shared:b.shared,effects:b.effects})}function Ku(b,x){return{eventTime:b,lane:x,tag:0,payload:null,callback:null,next:null}}function ah(b,x){var T=b.updateQueue;T!==null&&(T=T.shared,ar!==null&&b.mode&1&&!(fn&2)?(b=T.interleaved,b===null?(x.next=x,iu===null?iu=[T]:iu.push(T)):(x.next=b.next,b.next=x),T.interleaved=x):(b=T.pending,b===null?x.next=x:(x.next=b.next,b.next=x),T.pending=x))}function YS(b,x,T){if(x=x.updateQueue,x!==null&&(x=x.shared,(T&4194240)!==0)){var M=x.lanes;M&=b.pendingLanes,T|=M,x.lanes=T,kk(b,T)}}function z$(b,x){var T=b.updateQueue,M=b.alternate;if(M!==null&&(M=M.updateQueue,T===M)){var R=null,L=null;if(T=T.firstBaseUpdate,T!==null){do{var te={eventTime:T.eventTime,lane:T.lane,tag:T.tag,payload:T.payload,callback:T.callback,next:null};L===null?R=L=te:L=L.next=te,T=T.next}while(T!==null);L===null?R=L=x:L=L.next=x}else R=L=x;T={baseState:M.baseState,firstBaseUpdate:R,lastBaseUpdate:L,shared:M.shared,effects:M.effects},b.updateQueue=T;return}b=T.lastBaseUpdate,b===null?T.firstBaseUpdate=x:b.next=x,T.lastBaseUpdate=x}function JS(b,x,T,M){var R=b.updateQueue;oh=!1;var L=R.firstBaseUpdate,te=R.lastBaseUpdate,be=R.shared.pending;if(be!==null){R.shared.pending=null;var Be=be,it=Be.next;Be.next=null,te===null?L=it:te.next=it,te=Be;var _t=b.alternate;_t!==null&&(_t=_t.updateQueue,be=_t.lastBaseUpdate,be!==te&&(be===null?_t.firstBaseUpdate=it:be.next=it,_t.lastBaseUpdate=Be))}if(L!==null){var qt=R.baseState;te=0,_t=it=Be=null,be=L;do{var zt=be.lane,Xn=be.eventTime;if((M&zt)===zt){_t!==null&&(_t=_t.next={eventTime:Xn,lane:0,tag:be.tag,payload:be.payload,callback:be.callback,next:null});e:{var Dt=b,bs=be;switch(zt=x,Xn=T,bs.tag){case 1:if(Dt=bs.payload,typeof Dt=="function"){qt=Dt.call(Xn,qt,zt);break e}qt=Dt;break e;case 3:Dt.flags=Dt.flags&-65537|128;case 0:if(Dt=bs.payload,zt=typeof Dt=="function"?Dt.call(Xn,qt,zt):Dt,zt==null)break e;qt=s({},qt,zt);break e;case 2:oh=!0}}be.callback!==null&&be.lane!==0&&(b.flags|=64,zt=R.effects,zt===null?R.effects=[be]:zt.push(be))}else Xn={eventTime:Xn,lane:zt,tag:be.tag,payload:be.payload,callback:be.callback,next:null},_t===null?(it=_t=Xn,Be=qt):_t=_t.next=Xn,te|=zt;if(be=be.next,be===null){if(be=R.shared.pending,be===null)break;zt=be,be=zt.next,zt.next=null,R.lastBaseUpdate=zt,R.shared.pending=null}}while(1);if(_t===null&&(Be=qt),R.baseState=Be,R.firstBaseUpdate=it,R.lastBaseUpdate=_t,x=R.shared.interleaved,x!==null){R=x;do te|=R.lane,R=R.next;while(R!==x)}else L===null&&(R.shared.lanes=0);Um|=te,b.lanes=te,b.memoizedState=qt}}function G$(b,x,T){if(b=x.effects,x.effects=null,b!==null)for(x=0;x<b.length;x++){var M=b[x],R=M.callback;if(R!==null){if(M.callback=null,M=T,typeof R!="function")throw Error(o(191,R));R.call(M)}}}var V$=new i.Component().refs;function Gk(b,x,T,M){x=b.memoizedState,T=T(M,x),T=T==null?x:s({},x,T),b.memoizedState=T,b.lanes===0&&(b.updateQueue.baseState=T)}var QS={isMounted:function(b){return(b=b._reactInternals)?E(b)===b:!1},enqueueSetState:function(b,x,T){b=b._reactInternals;var M=Vs(),R=ch(b),L=Ku(M,R);L.payload=x,T!=null&&(L.callback=T),ah(b,L),x=Aa(b,R,M),x!==null&&YS(x,b,R)},enqueueReplaceState:function(b,x,T){b=b._reactInternals;var M=Vs(),R=ch(b),L=Ku(M,R);L.tag=1,L.payload=x,T!=null&&(L.callback=T),ah(b,L),x=Aa(b,R,M),x!==null&&YS(x,b,R)},enqueueForceUpdate:function(b,x){b=b._reactInternals;var T=Vs(),M=ch(b),R=Ku(T,M);R.tag=2,x!=null&&(R.callback=x),ah(b,R),x=Aa(b,M,T),x!==null&&YS(x,b,M)}};function U$(b,x,T,M,R,L,te){return b=b.stateNode,typeof b.shouldComponentUpdate=="function"?b.shouldComponentUpdate(M,L,te):x.prototype&&x.prototype.isPureReactComponent?!KS(T,M)||!KS(R,L):!0}function $$(b,x,T){var M=!1,R=va,L=x.contextType;return typeof L=="object"&&L!==null?L=Sa(L):(R=Lr(x)?Ql:xn.current,M=x.contextTypes,L=(M=M!=null)?wa(b,R):va),x=new x(T,L),b.memoizedState=x.state!==null&&x.state!==void 0?x.state:null,x.updater=QS,b.stateNode=x,x._reactInternals=b,M&&(b=b.stateNode,b.__reactInternalMemoizedUnmaskedChildContext=R,b.__reactInternalMemoizedMaskedChildContext=L),x}function W$(b,x,T,M){b=x.state,typeof x.componentWillReceiveProps=="function"&&x.componentWillReceiveProps(T,M),typeof x.UNSAFE_componentWillReceiveProps=="function"&&x.UNSAFE_componentWillReceiveProps(T,M),x.state!==b&&QS.enqueueReplaceState(x,x.state,null)}function Vk(b,x,T,M){var R=b.stateNode;R.props=T,R.state=b.memoizedState,R.refs=V$,zk(b);var L=x.contextType;typeof L=="object"&&L!==null?R.context=Sa(L):(L=Lr(x)?Ql:xn.current,R.context=wa(b,L)),R.state=b.memoizedState,L=x.getDerivedStateFromProps,typeof L=="function"&&(Gk(b,x,L,T),R.state=b.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof R.getSnapshotBeforeUpdate=="function"||typeof R.UNSAFE_componentWillMount!="function"&&typeof R.componentWillMount!="function"||(x=R.state,typeof R.componentWillMount=="function"&&R.componentWillMount(),typeof R.UNSAFE_componentWillMount=="function"&&R.UNSAFE_componentWillMount(),x!==R.state&&QS.enqueueReplaceState(R,R.state,null),JS(b,T,R,M),R.state=b.memoizedState),typeof R.componentDidMount=="function"&&(b.flags|=4194308)}var Pm=[],Dm=0,qS=null,eT=0,Ta=[],Ca=0,Xd=null,Zu=1,ju="";function Kd(b,x){Pm[Dm++]=eT,Pm[Dm++]=qS,qS=b,eT=x}function H$(b,x,T){Ta[Ca++]=Zu,Ta[Ca++]=ju,Ta[Ca++]=Xd,Xd=b;var M=Zu;b=ju;var R=32-Oo(M)-1;M&=~(1<<R),T+=1;var L=32-Oo(x)+R;if(30<L){var te=R-R%5;L=(M&(1<<te)-1).toString(32),M>>=te,R-=te,Zu=1<<32-Oo(x)+R|T<<R|M,ju=L+b}else Zu=1<<L|T<<R|M,ju=b}function Uk(b){b.return!==null&&(Kd(b,1),H$(b,1,0))}function $k(b){for(;b===qS;)qS=Pm[--Dm],Pm[Dm]=null,eT=Pm[--Dm],Pm[Dm]=null;for(;b===Xd;)Xd=Ta[--Ca],Ta[Ca]=null,ju=Ta[--Ca],Ta[Ca]=null,Zu=Ta[--Ca],Ta[Ca]=null}var Bo=null,zo=null,gi=!1,Eb=!1,ul=null;function X$(b,x){var T=Ea(5,null,null,0);T.elementType="DELETED",T.stateNode=x,T.return=b,x=b.deletions,x===null?(b.deletions=[T],b.flags|=16):x.push(T)}function K$(b,x){switch(b.tag){case 5:return x=vt(x,b.type,b.pendingProps),x!==null?(b.stateNode=x,Bo=b,zo=xa(x),!0):!1;case 6:return x=Tn(x,b.pendingProps),x!==null?(b.stateNode=x,Bo=b,zo=null,!0):!1;case 13:if(x=Ut(x),x!==null){var T=Xd!==null?{id:Zu,overflow:ju}:null;return b.memoizedState={dehydrated:x,treeContext:T,retryLane:1073741824},T=Ea(18,null,null,0),T.stateNode=x,T.return=b,b.child=T,Bo=b,zo=null,!0}return!1;default:return!1}}function Wk(b){return(b.mode&1)!==0&&(b.flags&128)===0}function Hk(b){if(gi){var x=zo;if(x){var T=x;if(!K$(b,x)){if(Wk(b))throw Error(o(418));x=xr(T);var M=Bo;x&&K$(b,x)?X$(M,T):(b.flags=b.flags&-4097|2,gi=!1,Bo=b)}}else{if(Wk(b))throw Error(o(418));b.flags=b.flags&-4097|2,gi=!1,Bo=b}}}function Z$(b){for(b=b.return;b!==null&&b.tag!==5&&b.tag!==3&&b.tag!==13;)b=b.return;Bo=b}function Ib(b){if(!De||b!==Bo)return!1;if(!gi)return Z$(b),gi=!0,!1;if(b.tag!==3&&(b.tag!==5||tt(b.type)&&!ge(b.type,b.memoizedProps))){var x=zo;if(x){if(Wk(b)){for(b=zo;b;)b=xr(b);throw Error(o(418))}for(;x;)X$(b,x),x=xr(x)}}if(Z$(b),b.tag===13){if(!De)throw Error(o(316));if(b=b.memoizedState,b=b!==null?b.dehydrated:null,!b)throw Error(o(317));zo=Q(b)}else zo=Bo?xr(b.stateNode):null;return!0}function Fm(){De&&(zo=Bo=null,Eb=gi=!1)}function Xk(b){ul===null?ul=[b]:ul.push(b)}function kb(b,x,T){if(b=T.ref,b!==null&&typeof b!="function"&&typeof b!="object"){if(T._owner){if(T=T._owner,T){if(T.tag!==1)throw Error(o(309));var M=T.stateNode}if(!M)throw Error(o(147,b));var R=M,L=""+b;return x!==null&&x.ref!==null&&typeof x.ref=="function"&&x.ref._stringRef===L?x.ref:(x=function(te){var be=R.refs;be===V$&&(be=R.refs={}),te===null?delete be[L]:be[L]=te},x._stringRef=L,x)}if(typeof b!="string")throw Error(o(284));if(!T._owner)throw Error(o(290,b))}return b}function tT(b,x){throw b=Object.prototype.toString.call(x),Error(o(31,b==="[object Object]"?"object with keys {"+Object.keys(x).join(", ")+"}":b))}function j$(b){var x=b._init;return x(b._payload)}function Y$(b){function x(Ce,xe){if(b){var Pe=Ce.deletions;Pe===null?(Ce.deletions=[xe],Ce.flags|=16):Pe.push(xe)}}function T(Ce,xe){if(!b)return null;for(;xe!==null;)x(Ce,xe),xe=xe.sibling;return null}function M(Ce,xe){for(Ce=new Map;xe!==null;)xe.key!==null?Ce.set(xe.key,xe):Ce.set(xe.index,xe),xe=xe.sibling;return Ce}function R(Ce,xe){return Ce=dh(Ce,xe),Ce.index=0,Ce.sibling=null,Ce}function L(Ce,xe,Pe){return Ce.index=Pe,b?(Pe=Ce.alternate,Pe!==null?(Pe=Pe.index,Pe<xe?(Ce.flags|=2,xe):Pe):(Ce.flags|=2,xe)):(Ce.flags|=1048576,xe)}function te(Ce){return b&&Ce.alternate===null&&(Ce.flags|=2),Ce}function be(Ce,xe,Pe,bt){return xe===null||xe.tag!==6?(xe=IR(Pe,Ce.mode,bt),xe.return=Ce,xe):(xe=R(xe,Pe),xe.return=Ce,xe)}function Be(Ce,xe,Pe,bt){var Rt=Pe.type;return Rt===c?_t(Ce,xe,Pe.props.children,bt,Pe.key):xe!==null&&(xe.elementType===Rt||typeof Rt=="object"&&Rt!==null&&Rt.$$typeof===w&&j$(Rt)===xe.type)?(bt=R(xe,Pe.props),bt.ref=kb(Ce,xe,Pe),bt.return=Ce,bt):(bt=NT(Pe.type,Pe.key,Pe.props,null,Ce.mode,bt),bt.ref=kb(Ce,xe,Pe),bt.return=Ce,bt)}function it(Ce,xe,Pe,bt){return xe===null||xe.tag!==4||xe.stateNode.containerInfo!==Pe.containerInfo||xe.stateNode.implementation!==Pe.implementation?(xe=kR(Pe,Ce.mode,bt),xe.return=Ce,xe):(xe=R(xe,Pe.children||[]),xe.return=Ce,xe)}function _t(Ce,xe,Pe,bt,Rt){return xe===null||xe.tag!==7?(xe=ep(Pe,Ce.mode,bt,Rt),xe.return=Ce,xe):(xe=R(xe,Pe),xe.return=Ce,xe)}function qt(Ce,xe,Pe){if(typeof xe=="string"&&xe!==""||typeof xe=="number")return xe=IR(""+xe,Ce.mode,Pe),xe.return=Ce,xe;if(typeof xe=="object"&&xe!==null){switch(xe.$$typeof){case l:return Pe=NT(xe.type,xe.key,xe.props,null,Ce.mode,Pe),Pe.ref=kb(Ce,null,xe),Pe.return=Ce,Pe;case u:return xe=kR(xe,Ce.mode,Pe),xe.return=Ce,xe;case w:var bt=xe._init;return qt(Ce,bt(xe._payload),Pe)}if($(xe)||_(xe))return xe=ep(xe,Ce.mode,Pe,null),xe.return=Ce,xe;tT(Ce,xe)}return null}function zt(Ce,xe,Pe,bt){var Rt=xe!==null?xe.key:null;if(typeof Pe=="string"&&Pe!==""||typeof Pe=="number")return Rt!==null?null:be(Ce,xe,""+Pe,bt);if(typeof Pe=="object"&&Pe!==null){switch(Pe.$$typeof){case l:return Pe.key===Rt?Be(Ce,xe,Pe,bt):null;case u:return Pe.key===Rt?it(Ce,xe,Pe,bt):null;case w:return Rt=Pe._init,zt(Ce,xe,Rt(Pe._payload),bt)}if($(Pe)||_(Pe))return Rt!==null?null:_t(Ce,xe,Pe,bt,null);tT(Ce,Pe)}return null}function Xn(Ce,xe,Pe,bt,Rt){if(typeof bt=="string"&&bt!==""||typeof bt=="number")return Ce=Ce.get(Pe)||null,be(xe,Ce,""+bt,Rt);if(typeof bt=="object"&&bt!==null){switch(bt.$$typeof){case l:return Ce=Ce.get(bt.key===null?Pe:bt.key)||null,Be(xe,Ce,bt,Rt);case u:return Ce=Ce.get(bt.key===null?Pe:bt.key)||null,it(xe,Ce,bt,Rt);case w:var cn=bt._init;return Xn(Ce,xe,Pe,cn(bt._payload),Rt)}if($(bt)||_(bt))return Ce=Ce.get(Pe)||null,_t(xe,Ce,bt,Rt,null);tT(xe,bt)}return null}function Dt(Ce,xe,Pe,bt){for(var Rt=null,cn=null,en=xe,Pn=xe=0,Or=null;en!==null&&Pn<Pe.length;Pn++){en.index>Pn?(Or=en,en=null):Or=en.sibling;var Dn=zt(Ce,en,Pe[Pn],bt);if(Dn===null){en===null&&(en=Or);break}b&&en&&Dn.alternate===null&&x(Ce,en),xe=L(Dn,xe,Pn),cn===null?Rt=Dn:cn.sibling=Dn,cn=Dn,en=Or}if(Pn===Pe.length)return T(Ce,en),gi&&Kd(Ce,Pn),Rt;if(en===null){for(;Pn<Pe.length;Pn++)en=qt(Ce,Pe[Pn],bt),en!==null&&(xe=L(en,xe,Pn),cn===null?Rt=en:cn.sibling=en,cn=en);return gi&&Kd(Ce,Pn),Rt}for(en=M(Ce,en);Pn<Pe.length;Pn++)Or=Xn(en,Ce,Pn,Pe[Pn],bt),Or!==null&&(b&&Or.alternate!==null&&en.delete(Or.key===null?Pn:Or.key),xe=L(Or,xe,Pn),cn===null?Rt=Or:cn.sibling=Or,cn=Or);return b&&en.forEach(function(ph){return x(Ce,ph)}),gi&&Kd(Ce,Pn),Rt}function bs(Ce,xe,Pe,bt){var Rt=_(Pe);if(typeof Rt!="function")throw Error(o(150));if(Pe=Rt.call(Pe),Pe==null)throw Error(o(151));for(var cn=Rt=null,en=xe,Pn=xe=0,Or=null,Dn=Pe.next();en!==null&&!Dn.done;Pn++,Dn=Pe.next()){en.index>Pn?(Or=en,en=null):Or=en.sibling;var ph=zt(Ce,en,Dn.value,bt);if(ph===null){en===null&&(en=Or);break}b&&en&&ph.alternate===null&&x(Ce,en),xe=L(ph,xe,Pn),cn===null?Rt=ph:cn.sibling=ph,cn=ph,en=Or}if(Dn.done)return T(Ce,en),gi&&Kd(Ce,Pn),Rt;if(en===null){for(;!Dn.done;Pn++,Dn=Pe.next())Dn=qt(Ce,Dn.value,bt),Dn!==null&&(xe=L(Dn,xe,Pn),cn===null?Rt=Dn:cn.sibling=Dn,cn=Dn);return gi&&Kd(Ce,Pn),Rt}for(en=M(Ce,en);!Dn.done;Pn++,Dn=Pe.next())Dn=Xn(en,Ce,Pn,Dn.value,bt),Dn!==null&&(b&&Dn.alternate!==null&&en.delete(Dn.key===null?Pn:Dn.key),xe=L(Dn,xe,Pn),cn===null?Rt=Dn:cn.sibling=Dn,cn=Dn);return b&&en.forEach(function(ule){return x(Ce,ule)}),gi&&Kd(Ce,Pn),Rt}function Ia(Ce,xe,Pe,bt){if(typeof Pe=="object"&&Pe!==null&&Pe.type===c&&Pe.key===null&&(Pe=Pe.props.children),typeof Pe=="object"&&Pe!==null){switch(Pe.$$typeof){case l:e:{for(var Rt=Pe.key,cn=xe;cn!==null;){if(cn.key===Rt){if(Rt=Pe.type,Rt===c){if(cn.tag===7){T(Ce,cn.sibling),xe=R(cn,Pe.props.children),xe.return=Ce,Ce=xe;break e}}else if(cn.elementType===Rt||typeof Rt=="object"&&Rt!==null&&Rt.$$typeof===w&&j$(Rt)===cn.type){T(Ce,cn.sibling),xe=R(cn,Pe.props),xe.ref=kb(Ce,cn,Pe),xe.return=Ce,Ce=xe;break e}T(Ce,cn);break}else x(Ce,cn);cn=cn.sibling}Pe.type===c?(xe=ep(Pe.props.children,Ce.mode,bt,Pe.key),xe.return=Ce,Ce=xe):(bt=NT(Pe.type,Pe.key,Pe.props,null,Ce.mode,bt),bt.ref=kb(Ce,xe,Pe),bt.return=Ce,Ce=bt)}return te(Ce);case u:e:{for(cn=Pe.key;xe!==null;){if(xe.key===cn)if(xe.tag===4&&xe.stateNode.containerInfo===Pe.containerInfo&&xe.stateNode.implementation===Pe.implementation){T(Ce,xe.sibling),xe=R(xe,Pe.children||[]),xe.return=Ce,Ce=xe;break e}else{T(Ce,xe);break}else x(Ce,xe);xe=xe.sibling}xe=kR(Pe,Ce.mode,bt),xe.return=Ce,Ce=xe}return te(Ce);case w:return cn=Pe._init,Ia(Ce,xe,cn(Pe._payload),bt)}if($(Pe))return Dt(Ce,xe,Pe,bt);if(_(Pe))return bs(Ce,xe,Pe,bt);tT(Ce,Pe)}return typeof Pe=="string"&&Pe!==""||typeof Pe=="number"?(Pe=""+Pe,xe!==null&&xe.tag===6?(T(Ce,xe.sibling),xe=R(xe,Pe),xe.return=Ce,Ce=xe):(T(Ce,xe),xe=IR(Pe,Ce.mode,bt),xe.return=Ce,Ce=xe),te(Ce)):T(Ce,xe)}return Ia}var Om=Y$(!0),J$=Y$(!1),Rb={},_a=Nr(Rb),Nb=Nr(Rb),Bm=Nr(Rb);function ru(b){if(b===Rb)throw Error(o(174));return b}function Kk(b,x){Mt(Bm,x),Mt(Nb,b),Mt(_a,Rb),b=q(x),Ht(_a),Mt(_a,b)}function zm(){Ht(_a),Ht(Nb),Ht(Bm)}function Q$(b){var x=ru(Bm.current),T=ru(_a.current);x=O(T,b.type,x),T!==x&&(Mt(Nb,b),Mt(_a,x))}function Zk(b){Nb.current===b&&(Ht(_a),Ht(Nb))}var _i=Nr(0);function nT(b){for(var x=b;x!==null;){if(x.tag===13){var T=x.memoizedState;if(T!==null&&(T=T.dehydrated,T===null||Nn(T)||zn(T)))return x}else if(x.tag===19&&x.memoizedProps.revealOrder!==void 0){if(x.flags&128)return x}else if(x.child!==null){x.child.return=x,x=x.child;continue}if(x===b)break;for(;x.sibling===null;){if(x.return===null||x.return===b)return null;x=x.return}x.sibling.return=x.return,x=x.sibling}return null}var jk=[];function Yk(){for(var b=0;b<jk.length;b++){var x=jk[b];Ye?x._workInProgressVersionPrimary=null:x._workInProgressVersionSecondary=null}jk.length=0}var iT=a.ReactCurrentDispatcher,Ma=a.ReactCurrentBatchConfig,Gm=0,Bi=null,ms=null,Fr=null,rT=!1,Lb=!1,Pb=0,Pae=0;function gs(){throw Error(o(321))}function Jk(b,x){if(x===null)return!1;for(var T=0;T<x.length&&T<b.length;T++)if(!tu(b[T],x[T]))return!1;return!0}function Qk(b,x,T,M,R,L){if(Gm=L,Bi=x,x.memoizedState=null,x.updateQueue=null,x.lanes=0,iT.current=b===null||b.memoizedState===null?Bae:zae,b=T(M,R),Lb){L=0;do{if(Lb=!1,Pb=0,25<=L)throw Error(o(301));L+=1,Fr=ms=null,x.updateQueue=null,iT.current=Gae,b=T(M,R)}while(Lb)}if(iT.current=uT,x=ms!==null&&ms.next!==null,Gm=0,Fr=ms=Bi=null,rT=!1,x)throw Error(o(300));return b}function qk(){var b=Pb!==0;return Pb=0,b}function Yu(){var b={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Fr===null?Bi.memoizedState=Fr=b:Fr=Fr.next=b,Fr}function su(){if(ms===null){var b=Bi.alternate;b=b!==null?b.memoizedState:null}else b=ms.next;var x=Fr===null?Bi.memoizedState:Fr.next;if(x!==null)Fr=x,ms=b;else{if(b===null)throw Error(o(310));ms=b,b={memoizedState:ms.memoizedState,baseState:ms.baseState,baseQueue:ms.baseQueue,queue:ms.queue,next:null},Fr===null?Bi.memoizedState=Fr=b:Fr=Fr.next=b}return Fr}function Zd(b,x){return typeof x=="function"?x(b):x}function sT(b){var x=su(),T=x.queue;if(T===null)throw Error(o(311));T.lastRenderedReducer=b;var M=ms,R=M.baseQueue,L=T.pending;if(L!==null){if(R!==null){var te=R.next;R.next=L.next,L.next=te}M.baseQueue=R=L,T.pending=null}if(R!==null){L=R.next,M=M.baseState;var be=te=null,Be=null,it=L;do{var _t=it.lane;if((Gm&_t)===_t)Be!==null&&(Be=Be.next={lane:0,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null}),M=it.hasEagerState?it.eagerState:b(M,it.action);else{var qt={lane:_t,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null};Be===null?(be=Be=qt,te=M):Be=Be.next=qt,Bi.lanes|=_t,Um|=_t}it=it.next}while(it!==null&&it!==L);Be===null?te=M:Be.next=be,tu(M,x.memoizedState)||(Go=!0),x.memoizedState=M,x.baseState=te,x.baseQueue=Be,T.lastRenderedState=M}if(b=T.interleaved,b!==null){R=b;do L=R.lane,Bi.lanes|=L,Um|=L,R=R.next;while(R!==b)}else R===null&&(T.lanes=0);return[x.memoizedState,T.dispatch]}function oT(b){var x=su(),T=x.queue;if(T===null)throw Error(o(311));T.lastRenderedReducer=b;var M=T.dispatch,R=T.pending,L=x.memoizedState;if(R!==null){T.pending=null;var te=R=R.next;do L=b(L,te.action),te=te.next;while(te!==R);tu(L,x.memoizedState)||(Go=!0),x.memoizedState=L,x.baseQueue===null&&(x.baseState=L),T.lastRenderedState=L}return[L,M]}function q$(){}function eW(b,x){var T=Bi,M=su(),R=x(),L=!tu(M.memoizedState,R);if(L&&(M.memoizedState=R,Go=!0),M=M.queue,Fb(iW.bind(null,T,M,b),[b]),M.getSnapshot!==x||L||Fr!==null&&Fr.memoizedState.tag&1){if(T.flags|=2048,Db(9,nW.bind(null,T,M,R,x),void 0,null),ar===null)throw Error(o(349));Gm&30||tW(T,x,R)}return R}function tW(b,x,T){b.flags|=16384,b={getSnapshot:x,value:T},x=Bi.updateQueue,x===null?(x={lastEffect:null,stores:null},Bi.updateQueue=x,x.stores=[b]):(T=x.stores,T===null?x.stores=[b]:T.push(b))}function nW(b,x,T,M){x.value=T,x.getSnapshot=M,rW(x)&&Aa(b,1,-1)}function iW(b,x,T){return T(function(){rW(x)&&Aa(b,1,-1)})}function rW(b){var x=b.getSnapshot;b=b.value;try{var T=x();return!tu(b,T)}catch{return!0}}function eR(b){var x=Yu();return typeof b=="function"&&(b=b()),x.memoizedState=x.baseState=b,b={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Zd,lastRenderedState:b},x.queue=b,b=b.dispatch=Oae.bind(null,Bi,b),[x.memoizedState,b]}function Db(b,x,T,M){return b={tag:b,create:x,destroy:T,deps:M,next:null},x=Bi.updateQueue,x===null?(x={lastEffect:null,stores:null},Bi.updateQueue=x,x.lastEffect=b.next=b):(T=x.lastEffect,T===null?x.lastEffect=b.next=b:(M=T.next,T.next=b,b.next=M,x.lastEffect=b)),b}function sW(){return su().memoizedState}function aT(b,x,T,M){var R=Yu();Bi.flags|=b,R.memoizedState=Db(1|x,T,void 0,M===void 0?null:M)}function lT(b,x,T,M){var R=su();M=M===void 0?null:M;var L=void 0;if(ms!==null){var te=ms.memoizedState;if(L=te.destroy,M!==null&&Jk(M,te.deps)){R.memoizedState=Db(x,T,L,M);return}}Bi.flags|=b,R.memoizedState=Db(1|x,T,L,M)}function tR(b,x){return aT(8390656,8,b,x)}function Fb(b,x){return lT(2048,8,b,x)}function oW(b,x){return lT(4,2,b,x)}function aW(b,x){return lT(4,4,b,x)}function lW(b,x){if(typeof x=="function")return b=b(),x(b),function(){x(null)};if(x!=null)return b=b(),x.current=b,function(){x.current=null}}function uW(b,x,T){return T=T!=null?T.concat([b]):null,lT(4,4,lW.bind(null,x,b),T)}function nR(){}function cW(b,x){var T=su();x=x===void 0?null:x;var M=T.memoizedState;return M!==null&&x!==null&&Jk(x,M[1])?M[0]:(T.memoizedState=[b,x],b)}function hW(b,x){var T=su();x=x===void 0?null:x;var M=T.memoizedState;return M!==null&&x!==null&&Jk(x,M[1])?M[0]:(b=b(),T.memoizedState=[b,x],b)}function Dae(b,x){var T=Ln;Ln=T!==0&&4>T?T:4,b(!0);var M=Ma.transition;Ma.transition={};try{b(!1),x()}finally{Ln=T,Ma.transition=M}}function dW(){return su().memoizedState}function Fae(b,x,T){var M=ch(b);T={lane:M,action:T,hasEagerState:!1,eagerState:null,next:null},pW(b)?fW(x,T):(mW(b,x,T),T=Vs(),b=Aa(b,M,T),b!==null&&gW(b,x,M))}function Oae(b,x,T){var M=ch(b),R={lane:M,action:T,hasEagerState:!1,eagerState:null,next:null};if(pW(b))fW(x,R);else{mW(b,x,R);var L=b.alternate;if(b.lanes===0&&(L===null||L.lanes===0)&&(L=x.lastRenderedReducer,L!==null))try{var te=x.lastRenderedState,be=L(te,T);if(R.hasEagerState=!0,R.eagerState=be,tu(be,te))return}catch{}finally{}T=Vs(),b=Aa(b,M,T),b!==null&&gW(b,x,M)}}function pW(b){var x=b.alternate;return b===Bi||x!==null&&x===Bi}function fW(b,x){Lb=rT=!0;var T=b.pending;T===null?x.next=x:(x.next=T.next,T.next=x),b.pending=x}function mW(b,x,T){ar!==null&&b.mode&1&&!(fn&2)?(b=x.interleaved,b===null?(T.next=T,iu===null?iu=[x]:iu.push(x)):(T.next=b.next,b.next=T),x.interleaved=T):(b=x.pending,b===null?T.next=T:(T.next=b.next,b.next=T),x.pending=T)}function gW(b,x,T){if(T&4194240){var M=x.lanes;M&=b.pendingLanes,T|=M,x.lanes=T,kk(b,T)}}var uT={readContext:Sa,useCallback:gs,useContext:gs,useEffect:gs,useImperativeHandle:gs,useInsertionEffect:gs,useLayoutEffect:gs,useMemo:gs,useReducer:gs,useRef:gs,useState:gs,useDebugValue:gs,useDeferredValue:gs,useTransition:gs,useMutableSource:gs,useSyncExternalStore:gs,useId:gs,unstable_isNewReconciler:!1},Bae={readContext:Sa,useCallback:function(b,x){return Yu().memoizedState=[b,x===void 0?null:x],b},useContext:Sa,useEffect:tR,useImperativeHandle:function(b,x,T){return T=T!=null?T.concat([b]):null,aT(4194308,4,lW.bind(null,x,b),T)},useLayoutEffect:function(b,x){return aT(4194308,4,b,x)},useInsertionEffect:function(b,x){return aT(4,2,b,x)},useMemo:function(b,x){var T=Yu();return x=x===void 0?null:x,b=b(),T.memoizedState=[b,x],b},useReducer:function(b,x,T){var M=Yu();return x=T!==void 0?T(x):x,M.memoizedState=M.baseState=x,b={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:b,lastRenderedState:x},M.queue=b,b=b.dispatch=Fae.bind(null,Bi,b),[M.memoizedState,b]},useRef:function(b){var x=Yu();return b={current:b},x.memoizedState=b},useState:eR,useDebugValue:nR,useDeferredValue:function(b){var x=eR(b),T=x[0],M=x[1];return tR(function(){var R=Ma.transition;Ma.transition={};try{M(b)}finally{Ma.transition=R}},[b]),T},useTransition:function(){var b=eR(!1),x=b[0];return b=Dae.bind(null,b[1]),Yu().memoizedState=b,[x,b]},useMutableSource:function(){},useSyncExternalStore:function(b,x,T){var M=Bi,R=Yu();if(gi){if(T===void 0)throw Error(o(407));T=T()}else{if(T=x(),ar===null)throw Error(o(349));Gm&30||tW(M,x,T)}R.memoizedState=T;var L={value:T,getSnapshot:x};return R.queue=L,tR(iW.bind(null,M,L,b),[b]),M.flags|=2048,Db(9,nW.bind(null,M,L,T,x),void 0,null),T},useId:function(){var b=Yu(),x=ar.identifierPrefix;if(gi){var T=ju,M=Zu;T=(M&~(1<<32-Oo(M)-1)).toString(32)+T,x=":"+x+"R"+T,T=Pb++,0<T&&(x+="H"+T.toString(32)),x+=":"}else T=Pae++,x=":"+x+"r"+T.toString(32)+":";return b.memoizedState=x},unstable_isNewReconciler:!1},zae={readContext:Sa,useCallback:cW,useContext:Sa,useEffect:Fb,useImperativeHandle:uW,useInsertionEffect:oW,useLayoutEffect:aW,useMemo:hW,useReducer:sT,useRef:sW,useState:function(){return sT(Zd)},useDebugValue:nR,useDeferredValue:function(b){var x=sT(Zd),T=x[0],M=x[1];return Fb(function(){var R=Ma.transition;Ma.transition={};try{M(b)}finally{Ma.transition=R}},[b]),T},useTransition:function(){var b=sT(Zd)[0],x=su().memoizedState;return[b,x]},useMutableSource:q$,useSyncExternalStore:eW,useId:dW,unstable_isNewReconciler:!1},Gae={readContext:Sa,useCallback:cW,useContext:Sa,useEffect:Fb,useImperativeHandle:uW,useInsertionEffect:oW,useLayoutEffect:aW,useMemo:hW,useReducer:oT,useRef:sW,useState:function(){return oT(Zd)},useDebugValue:nR,useDeferredValue:function(b){var x=oT(Zd),T=x[0],M=x[1];return Fb(function(){var R=Ma.transition;Ma.transition={};try{M(b)}finally{Ma.transition=R}},[b]),T},useTransition:function(){var b=oT(Zd)[0],x=su().memoizedState;return[b,x]},useMutableSource:q$,useSyncExternalStore:eW,useId:dW,unstable_isNewReconciler:!1};function iR(b,x){try{var T="",M=x;do T+=Lae(M),M=M.return;while(M);var R=T}catch(L){R=`
Error generating stack: `+L.message+`
`+L.stack}return{value:b,source:x,stack:R}}function rR(b,x){try{console.error(x.value)}catch(T){setTimeout(function(){throw T})}}var Vae=typeof WeakMap=="function"?WeakMap:Map;function yW(b,x,T){T=Ku(-1,T),T.tag=3,T.payload={element:null};var M=x.value;return T.callback=function(){_T||(_T=!0,SR=M),rR(b,x)},T}function bW(b,x,T){T=Ku(-1,T),T.tag=3;var M=b.type.getDerivedStateFromError;if(typeof M=="function"){var R=x.value;T.payload=function(){return M(R)},T.callback=function(){rR(b,x)}}var L=b.stateNode;return L!==null&&typeof L.componentDidCatch=="function"&&(T.callback=function(){rR(b,x),typeof M!="function"&&(lh===null?lh=new Set([this]):lh.add(this));var te=x.stack;this.componentDidCatch(x.value,{componentStack:te!==null?te:""})}),T}function xW(b,x,T){var M=b.pingCache;if(M===null){M=b.pingCache=new Vae;var R=new Set;M.set(x,R)}else R=M.get(x),R===void 0&&(R=new Set,M.set(x,R));R.has(T)||(R.add(T),b=tle.bind(null,b,x,T),x.then(b,b))}function vW(b){do{var x;if((x=b.tag===13)&&(x=b.memoizedState,x=x!==null?x.dehydrated!==null:!0),x)return b;b=b.return}while(b!==null);return null}function wW(b,x,T,M,R){return b.mode&1?(b.flags|=65536,b.lanes=R,b):(b===x?b.flags|=65536:(b.flags|=128,T.flags|=131072,T.flags&=-52805,T.tag===1&&(T.alternate===null?T.tag=17:(x=Ku(-1,1),x.tag=2,ah(T,x))),T.lanes|=1),b)}function ou(b){b.flags|=4}function SW(b,x){if(b!==null&&b.child===x.child)return!0;if(x.flags&16)return!1;for(b=x.child;b!==null;){if(b.flags&12854||b.subtreeFlags&12854)return!1;b=b.sibling}return!0}var Ob,Bb,cT,hT;if($e)Ob=function(b,x){for(var T=x.child;T!==null;){if(T.tag===5||T.tag===6)Z(b,T.stateNode);else if(T.tag!==4&&T.child!==null){T.child.return=T,T=T.child;continue}if(T===x)break;for(;T.sibling===null;){if(T.return===null||T.return===x)return;T=T.return}T.sibling.return=T.return,T=T.sibling}},Bb=function(){},cT=function(b,x,T,M,R){if(b=b.memoizedProps,b!==M){var L=x.stateNode,te=ru(_a.current);T=fe(L,T,b,M,R,te),(x.updateQueue=T)&&ou(x)}},hT=function(b,x,T,M){T!==M&&ou(x)};else if(ee){Ob=function(b,x,T,M){for(var R=x.child;R!==null;){if(R.tag===5){var L=R.stateNode;T&&M&&(L=ht(L,R.type,R.memoizedProps,R)),Z(b,L)}else if(R.tag===6)L=R.stateNode,T&&M&&(L=pt(L,R.memoizedProps,R)),Z(b,L);else if(R.tag!==4){if(R.tag===22&&R.memoizedState!==null)L=R.child,L!==null&&(L.return=R),Ob(b,R,!0,!0);else if(R.child!==null){R.child.return=R,R=R.child;continue}}if(R===x)break;for(;R.sibling===null;){if(R.return===null||R.return===x)return;R=R.return}R.sibling.return=R.return,R=R.sibling}};var TW=function(b,x,T,M){for(var R=x.child;R!==null;){if(R.tag===5){var L=R.stateNode;T&&M&&(L=ht(L,R.type,R.memoizedProps,R)),Te(b,L)}else if(R.tag===6)L=R.stateNode,T&&M&&(L=pt(L,R.memoizedProps,R)),Te(b,L);else if(R.tag!==4){if(R.tag===22&&R.memoizedState!==null)L=R.child,L!==null&&(L.return=R),TW(b,R,!0,!0);else if(R.child!==null){R.child.return=R,R=R.child;continue}}if(R===x)break;for(;R.sibling===null;){if(R.return===null||R.return===x)return;R=R.return}R.sibling.return=R.return,R=R.sibling}};Bb=function(b,x){var T=x.stateNode;if(!SW(b,x)){b=T.containerInfo;var M=de(b);TW(M,x,!1,!1),T.pendingChildren=M,ou(x),Je(b,M)}},cT=function(b,x,T,M,R){var L=b.stateNode,te=b.memoizedProps;if((b=SW(b,x))&&te===M)x.stateNode=L;else{var be=x.stateNode,Be=ru(_a.current),it=null;te!==M&&(it=fe(be,T,te,M,R,Be)),b&&it===null?x.stateNode=L:(L=pe(L,it,T,te,M,x,b,be),ce(L,T,M,R,Be)&&ou(x),x.stateNode=L,b?ou(x):Ob(L,x,!1,!1))}},hT=function(b,x,T,M){T!==M?(b=ru(Bm.current),T=ru(_a.current),x.stateNode=Ne(M,b,T,x),ou(x)):x.stateNode=b.stateNode}}else Bb=function(){},cT=function(){},hT=function(){};function zb(b,x){if(!gi)switch(b.tailMode){case"hidden":x=b.tail;for(var T=null;x!==null;)x.alternate!==null&&(T=x),x=x.sibling;T===null?b.tail=null:T.sibling=null;break;case"collapsed":T=b.tail;for(var M=null;T!==null;)T.alternate!==null&&(M=T),T=T.sibling;M===null?x||b.tail===null?b.tail=null:b.tail.sibling=null:M.sibling=null}}function ys(b){var x=b.alternate!==null&&b.alternate.child===b.child,T=0,M=0;if(x)for(var R=b.child;R!==null;)T|=R.lanes|R.childLanes,M|=R.subtreeFlags&14680064,M|=R.flags&14680064,R.return=b,R=R.sibling;else for(R=b.child;R!==null;)T|=R.lanes|R.childLanes,M|=R.subtreeFlags,M|=R.flags,R.return=b,R=R.sibling;return b.subtreeFlags|=M,b.childLanes=T,x}function Uae(b,x,T){var M=x.pendingProps;switch($k(x),x.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ys(x),null;case 1:return Lr(x.type)&&or(),ys(x),null;case 3:return M=x.stateNode,zm(),Ht(Oi),Ht(xn),Yk(),M.pendingContext&&(M.context=M.pendingContext,M.pendingContext=null),(b===null||b.child===null)&&(Ib(x)?ou(x):b===null||b.memoizedState.isDehydrated&&!(x.flags&256)||(x.flags|=1024,ul!==null&&(_R(ul),ul=null))),Bb(b,x),ys(x),null;case 5:Zk(x),T=ru(Bm.current);var R=x.type;if(b!==null&&x.stateNode!=null)cT(b,x,R,M,T),b.ref!==x.ref&&(x.flags|=512,x.flags|=2097152);else{if(!M){if(x.stateNode===null)throw Error(o(166));return ys(x),null}if(b=ru(_a.current),Ib(x)){if(!De)throw Error(o(175));b=zs(x.stateNode,x.type,x.memoizedProps,T,b,x,!Eb),x.updateQueue=b,b!==null&&ou(x)}else{var L=z(R,M,T,b,x);Ob(L,x,!1,!1),x.stateNode=L,ce(L,R,M,T,b)&&ou(x)}x.ref!==null&&(x.flags|=512,x.flags|=2097152)}return ys(x),null;case 6:if(b&&x.stateNode!=null)hT(b,x,b.memoizedProps,M);else{if(typeof M!="string"&&x.stateNode===null)throw Error(o(166));if(b=ru(Bm.current),T=ru(_a.current),Ib(x)){if(!De)throw Error(o(176));if(b=x.stateNode,M=x.memoizedProps,(T=sh(b,M,x,!Eb))&&(R=Bo,R!==null))switch(L=(R.mode&1)!==0,R.tag){case 3:Ct(R.stateNode.containerInfo,b,M,L);break;case 5:Bt(R.type,R.memoizedProps,R.stateNode,b,M,L)}T&&ou(x)}else x.stateNode=Ne(M,b,T,x)}return ys(x),null;case 13:if(Ht(_i),M=x.memoizedState,gi&&zo!==null&&x.mode&1&&!(x.flags&128)){for(b=zo;b;)b=xr(b);return Fm(),x.flags|=98560,x}if(M!==null&&M.dehydrated!==null){if(M=Ib(x),b===null){if(!M)throw Error(o(318));if(!De)throw Error(o(344));if(b=x.memoizedState,b=b!==null?b.dehydrated:null,!b)throw Error(o(317));Hd(b,x)}else Fm(),!(x.flags&128)&&(x.memoizedState=null),x.flags|=4;return ys(x),null}return ul!==null&&(_R(ul),ul=null),x.flags&128?(x.lanes=T,x):(M=M!==null,T=!1,b===null?Ib(x):T=b.memoizedState!==null,M&&!T&&(x.child.flags|=8192,x.mode&1&&(b===null||_i.current&1?vr===0&&(vr=3):AR())),x.updateQueue!==null&&(x.flags|=4),ys(x),null);case 4:return zm(),Bb(b,x),b===null&&ze(x.stateNode.containerInfo),ys(x),null;case 10:return Ok(x.type._context),ys(x),null;case 17:return Lr(x.type)&&or(),ys(x),null;case 19:if(Ht(_i),R=x.memoizedState,R===null)return ys(x),null;if(M=(x.flags&128)!==0,L=R.rendering,L===null)if(M)zb(R,!1);else{if(vr!==0||b!==null&&b.flags&128)for(b=x.child;b!==null;){if(L=nT(b),L!==null){for(x.flags|=128,zb(R,!1),b=L.updateQueue,b!==null&&(x.updateQueue=b,x.flags|=4),x.subtreeFlags=0,b=T,M=x.child;M!==null;)T=M,R=b,T.flags&=14680066,L=T.alternate,L===null?(T.childLanes=0,T.lanes=R,T.child=null,T.subtreeFlags=0,T.memoizedProps=null,T.memoizedState=null,T.updateQueue=null,T.dependencies=null,T.stateNode=null):(T.childLanes=L.childLanes,T.lanes=L.lanes,T.child=L.child,T.subtreeFlags=0,T.deletions=null,T.memoizedProps=L.memoizedProps,T.memoizedState=L.memoizedState,T.updateQueue=L.updateQueue,T.type=L.type,R=L.dependencies,T.dependencies=R===null?null:{lanes:R.lanes,firstContext:R.firstContext}),M=M.sibling;return Mt(_i,_i.current&1|2),x.child}b=b.sibling}R.tail!==null&&Dr()>wR&&(x.flags|=128,M=!0,zb(R,!1),x.lanes=4194304)}else{if(!M)if(b=nT(L),b!==null){if(x.flags|=128,M=!0,b=b.updateQueue,b!==null&&(x.updateQueue=b,x.flags|=4),zb(R,!0),R.tail===null&&R.tailMode==="hidden"&&!L.alternate&&!gi)return ys(x),null}else 2*Dr()-R.renderingStartTime>wR&&T!==1073741824&&(x.flags|=128,M=!0,zb(R,!1),x.lanes=4194304);R.isBackwards?(L.sibling=x.child,x.child=L):(b=R.last,b!==null?b.sibling=L:x.child=L,R.last=L)}return R.tail!==null?(x=R.tail,R.rendering=x,R.tail=x.sibling,R.renderingStartTime=Dr(),x.sibling=null,b=_i.current,Mt(_i,M?b&1|2:b&1),x):(ys(x),null);case 22:case 23:return MR(),M=x.memoizedState!==null,b!==null&&b.memoizedState!==null!==M&&(x.flags|=8192),M&&x.mode&1?Vo&1073741824&&(ys(x),$e&&x.subtreeFlags&6&&(x.flags|=8192)):ys(x),null;case 24:return null;case 25:return null}throw Error(o(156,x.tag))}var $ae=a.ReactCurrentOwner,Go=!1;function Gs(b,x,T,M){x.child=b===null?J$(x,null,T,M):Om(x,b.child,T,M)}function CW(b,x,T,M,R){T=T.render;var L=x.ref;return Lm(x,R),M=Qk(b,x,T,M,L,R),T=qk(),b!==null&&!Go?(x.updateQueue=b.updateQueue,x.flags&=-2053,b.lanes&=~R,Ju(b,x,R)):(gi&&T&&Uk(x),x.flags|=1,Gs(b,x,M,R),x.child)}function _W(b,x,T,M,R){if(b===null){var L=T.type;return typeof L=="function"&&!ER(L)&&L.defaultProps===void 0&&T.compare===null&&T.defaultProps===void 0?(x.tag=15,x.type=L,MW(b,x,L,M,R)):(b=NT(T.type,null,M,x,x.mode,R),b.ref=x.ref,b.return=x,x.child=b)}if(L=b.child,!(b.lanes&R)){var te=L.memoizedProps;if(T=T.compare,T=T!==null?T:KS,T(te,M)&&b.ref===x.ref)return Ju(b,x,R)}return x.flags|=1,b=dh(L,M),b.ref=x.ref,b.return=x,x.child=b}function MW(b,x,T,M,R){if(b!==null&&KS(b.memoizedProps,M)&&b.ref===x.ref)if(Go=!1,(b.lanes&R)!==0)b.flags&131072&&(Go=!0);else return x.lanes=b.lanes,Ju(b,x,R);return sR(b,x,T,M,R)}function AW(b,x,T){var M=x.pendingProps,R=M.children,L=b!==null?b.memoizedState:null;if(M.mode==="hidden")if(!(x.mode&1))x.memoizedState={baseLanes:0,cachePool:null},Mt(Vm,Vo),Vo|=T;else if(T&1073741824)x.memoizedState={baseLanes:0,cachePool:null},M=L!==null?L.baseLanes:T,Mt(Vm,Vo),Vo|=M;else return b=L!==null?L.baseLanes|T:T,x.lanes=x.childLanes=1073741824,x.memoizedState={baseLanes:b,cachePool:null},x.updateQueue=null,Mt(Vm,Vo),Vo|=b,null;else L!==null?(M=L.baseLanes|T,x.memoizedState=null):M=T,Mt(Vm,Vo),Vo|=M;return Gs(b,x,R,T),x.child}function EW(b,x){var T=x.ref;(b===null&&T!==null||b!==null&&b.ref!==T)&&(x.flags|=512,x.flags|=2097152)}function sR(b,x,T,M,R){var L=Lr(T)?Ql:xn.current;return L=wa(x,L),Lm(x,R),T=Qk(b,x,T,M,L,R),M=qk(),b!==null&&!Go?(x.updateQueue=b.updateQueue,x.flags&=-2053,b.lanes&=~R,Ju(b,x,R)):(gi&&M&&Uk(x),x.flags|=1,Gs(b,x,T,R),x.child)}function IW(b,x,T,M,R){if(Lr(T)){var L=!0;Pr(x)}else L=!1;if(Lm(x,R),x.stateNode===null)b!==null&&(b.alternate=null,x.alternate=null,x.flags|=2),$$(x,T,M),Vk(x,T,M,R),M=!0;else if(b===null){var te=x.stateNode,be=x.memoizedProps;te.props=be;var Be=te.context,it=T.contextType;typeof it=="object"&&it!==null?it=Sa(it):(it=Lr(T)?Ql:xn.current,it=wa(x,it));var _t=T.getDerivedStateFromProps,qt=typeof _t=="function"||typeof te.getSnapshotBeforeUpdate=="function";qt||typeof te.UNSAFE_componentWillReceiveProps!="function"&&typeof te.componentWillReceiveProps!="function"||(be!==M||Be!==it)&&W$(x,te,M,it),oh=!1;var zt=x.memoizedState;te.state=zt,JS(x,M,te,R),Be=x.memoizedState,be!==M||zt!==Be||Oi.current||oh?(typeof _t=="function"&&(Gk(x,T,_t,M),Be=x.memoizedState),(be=oh||U$(x,T,be,M,zt,Be,it))?(qt||typeof te.UNSAFE_componentWillMount!="function"&&typeof te.componentWillMount!="function"||(typeof te.componentWillMount=="function"&&te.componentWillMount(),typeof te.UNSAFE_componentWillMount=="function"&&te.UNSAFE_componentWillMount()),typeof te.componentDidMount=="function"&&(x.flags|=4194308)):(typeof te.componentDidMount=="function"&&(x.flags|=4194308),x.memoizedProps=M,x.memoizedState=Be),te.props=M,te.state=Be,te.context=it,M=be):(typeof te.componentDidMount=="function"&&(x.flags|=4194308),M=!1)}else{te=x.stateNode,B$(b,x),be=x.memoizedProps,it=x.type===x.elementType?be:ll(x.type,be),te.props=it,qt=x.pendingProps,zt=te.context,Be=T.contextType,typeof Be=="object"&&Be!==null?Be=Sa(Be):(Be=Lr(T)?Ql:xn.current,Be=wa(x,Be));var Xn=T.getDerivedStateFromProps;(_t=typeof Xn=="function"||typeof te.getSnapshotBeforeUpdate=="function")||typeof te.UNSAFE_componentWillReceiveProps!="function"&&typeof te.componentWillReceiveProps!="function"||(be!==qt||zt!==Be)&&W$(x,te,M,Be),oh=!1,zt=x.memoizedState,te.state=zt,JS(x,M,te,R);var Dt=x.memoizedState;be!==qt||zt!==Dt||Oi.current||oh?(typeof Xn=="function"&&(Gk(x,T,Xn,M),Dt=x.memoizedState),(it=oh||U$(x,T,it,M,zt,Dt,Be)||!1)?(_t||typeof te.UNSAFE_componentWillUpdate!="function"&&typeof te.componentWillUpdate!="function"||(typeof te.componentWillUpdate=="function"&&te.componentWillUpdate(M,Dt,Be),typeof te.UNSAFE_componentWillUpdate=="function"&&te.UNSAFE_componentWillUpdate(M,Dt,Be)),typeof te.componentDidUpdate=="function"&&(x.flags|=4),typeof te.getSnapshotBeforeUpdate=="function"&&(x.flags|=1024)):(typeof te.componentDidUpdate!="function"||be===b.memoizedProps&&zt===b.memoizedState||(x.flags|=4),typeof te.getSnapshotBeforeUpdate!="function"||be===b.memoizedProps&&zt===b.memoizedState||(x.flags|=1024),x.memoizedProps=M,x.memoizedState=Dt),te.props=M,te.state=Dt,te.context=Be,M=it):(typeof te.componentDidUpdate!="function"||be===b.memoizedProps&&zt===b.memoizedState||(x.flags|=4),typeof te.getSnapshotBeforeUpdate!="function"||be===b.memoizedProps&&zt===b.memoizedState||(x.flags|=1024),M=!1)}return oR(b,x,T,M,L,R)}function oR(b,x,T,M,R,L){EW(b,x);var te=(x.flags&128)!==0;if(!M&&!te)return R&&Rm(x,T,!1),Ju(b,x,L);M=x.stateNode,$ae.current=x;var be=te&&typeof T.getDerivedStateFromError!="function"?null:M.render();return x.flags|=1,b!==null&&te?(x.child=Om(x,b.child,null,L),x.child=Om(x,null,be,L)):Gs(b,x,be,L),x.memoizedState=M.state,R&&Rm(x,T,!0),x.child}function kW(b){var x=b.stateNode;x.pendingContext?ql(b,x.pendingContext,x.pendingContext!==x.context):x.context&&ql(b,x.context,!1),Kk(b,x.containerInfo)}function RW(b,x,T,M,R){return Fm(),Xk(R),x.flags|=256,Gs(b,x,T,M),x.child}var dT={dehydrated:null,treeContext:null,retryLane:0};function pT(b){return{baseLanes:b,cachePool:null}}function NW(b,x,T){var M=x.pendingProps,R=_i.current,L=!1,te=(x.flags&128)!==0,be;if((be=te)||(be=b!==null&&b.memoizedState===null?!1:(R&2)!==0),be?(L=!0,x.flags&=-129):(b===null||b.memoizedState!==null)&&(R|=1),Mt(_i,R&1),b===null)return Hk(x),b=x.memoizedState,b!==null&&(b=b.dehydrated,b!==null)?(x.mode&1?zn(b)?x.lanes=8:x.lanes=1073741824:x.lanes=1,null):(R=M.children,b=M.fallback,L?(M=x.mode,L=x.child,R={mode:"hidden",children:R},!(M&1)&&L!==null?(L.childLanes=0,L.pendingProps=R):L=LT(R,M,0,null),b=ep(b,M,T,null),L.return=x,b.return=x,L.sibling=b,x.child=L,x.child.memoizedState=pT(T),x.memoizedState=dT,b):aR(x,R));if(R=b.memoizedState,R!==null){if(be=R.dehydrated,be!==null){if(te)return x.flags&256?(x.flags&=-257,fT(b,x,T,Error(o(422)))):x.memoizedState!==null?(x.child=b.child,x.flags|=128,null):(L=M.fallback,R=x.mode,M=LT({mode:"visible",children:M.children},R,0,null),L=ep(L,R,T,null),L.flags|=2,M.return=x,L.return=x,M.sibling=L,x.child=M,x.mode&1&&Om(x,b.child,null,T),x.child.memoizedState=pT(T),x.memoizedState=dT,L);if(!(x.mode&1))x=fT(b,x,T,null);else if(zn(be))x=fT(b,x,T,Error(o(419)));else if(M=(T&b.childLanes)!==0,Go||M){if(M=ar,M!==null){switch(T&-T){case 4:L=2;break;case 16:L=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:L=32;break;case 536870912:L=268435456;break;default:L=0}M=L&(M.suspendedLanes|T)?0:L,M!==0&&M!==R.retryLane&&(R.retryLane=M,Aa(b,M,-1))}AR(),x=fT(b,x,T,Error(o(421)))}else Nn(be)?(x.flags|=128,x.child=b.child,x=nle.bind(null,b),Fi(be,x),x=null):(T=R.treeContext,De&&(zo=al(be),Bo=x,gi=!0,ul=null,Eb=!1,T!==null&&(Ta[Ca++]=Zu,Ta[Ca++]=ju,Ta[Ca++]=Xd,Zu=T.id,ju=T.overflow,Xd=x)),x=aR(x,x.pendingProps.children),x.flags|=4096);return x}return L?(M=PW(b,x,M.children,M.fallback,T),L=x.child,R=b.child.memoizedState,L.memoizedState=R===null?pT(T):{baseLanes:R.baseLanes|T,cachePool:null},L.childLanes=b.childLanes&~T,x.memoizedState=dT,M):(T=LW(b,x,M.children,T),x.memoizedState=null,T)}return L?(M=PW(b,x,M.children,M.fallback,T),L=x.child,R=b.child.memoizedState,L.memoizedState=R===null?pT(T):{baseLanes:R.baseLanes|T,cachePool:null},L.childLanes=b.childLanes&~T,x.memoizedState=dT,M):(T=LW(b,x,M.children,T),x.memoizedState=null,T)}function aR(b,x){return x=LT({mode:"visible",children:x},b.mode,0,null),x.return=b,b.child=x}function LW(b,x,T,M){var R=b.child;return b=R.sibling,T=dh(R,{mode:"visible",children:T}),!(x.mode&1)&&(T.lanes=M),T.return=x,T.sibling=null,b!==null&&(M=x.deletions,M===null?(x.deletions=[b],x.flags|=16):M.push(b)),x.child=T}function PW(b,x,T,M,R){var L=x.mode;b=b.child;var te=b.sibling,be={mode:"hidden",children:T};return!(L&1)&&x.child!==b?(T=x.child,T.childLanes=0,T.pendingProps=be,x.deletions=null):(T=dh(b,be),T.subtreeFlags=b.subtreeFlags&14680064),te!==null?M=dh(te,M):(M=ep(M,L,R,null),M.flags|=2),M.return=x,T.return=x,T.sibling=M,x.child=T,M}function fT(b,x,T,M){return M!==null&&Xk(M),Om(x,b.child,null,T),b=aR(x,x.pendingProps.children),b.flags|=2,x.memoizedState=null,b}function DW(b,x,T){b.lanes|=x;var M=b.alternate;M!==null&&(M.lanes|=x),Bk(b.return,x,T)}function lR(b,x,T,M,R){var L=b.memoizedState;L===null?b.memoizedState={isBackwards:x,rendering:null,renderingStartTime:0,last:M,tail:T,tailMode:R}:(L.isBackwards=x,L.rendering=null,L.renderingStartTime=0,L.last=M,L.tail=T,L.tailMode=R)}function FW(b,x,T){var M=x.pendingProps,R=M.revealOrder,L=M.tail;if(Gs(b,x,M.children,T),M=_i.current,M&2)M=M&1|2,x.flags|=128;else{if(b!==null&&b.flags&128)e:for(b=x.child;b!==null;){if(b.tag===13)b.memoizedState!==null&&DW(b,T,x);else if(b.tag===19)DW(b,T,x);else if(b.child!==null){b.child.return=b,b=b.child;continue}if(b===x)break e;for(;b.sibling===null;){if(b.return===null||b.return===x)break e;b=b.return}b.sibling.return=b.return,b=b.sibling}M&=1}if(Mt(_i,M),!(x.mode&1))x.memoizedState=null;else switch(R){case"forwards":for(T=x.child,R=null;T!==null;)b=T.alternate,b!==null&&nT(b)===null&&(R=T),T=T.sibling;T=R,T===null?(R=x.child,x.child=null):(R=T.sibling,T.sibling=null),lR(x,!1,R,T,L);break;case"backwards":for(T=null,R=x.child,x.child=null;R!==null;){if(b=R.alternate,b!==null&&nT(b)===null){x.child=R;break}b=R.sibling,R.sibling=T,T=R,R=b}lR(x,!0,T,null,L);break;case"together":lR(x,!1,null,null,void 0);break;default:x.memoizedState=null}return x.child}function Ju(b,x,T){if(b!==null&&(x.dependencies=b.dependencies),Um|=x.lanes,!(T&x.childLanes))return null;if(b!==null&&x.child!==b.child)throw Error(o(153));if(x.child!==null){for(b=x.child,T=dh(b,b.pendingProps),x.child=T,T.return=x;b.sibling!==null;)b=b.sibling,T=T.sibling=dh(b,b.pendingProps),T.return=x;T.sibling=null}return x.child}function Wae(b,x,T){switch(x.tag){case 3:kW(x),Fm();break;case 5:Q$(x);break;case 1:Lr(x.type)&&Pr(x);break;case 4:Kk(x,x.stateNode.containerInfo);break;case 10:O$(x,x.type._context,x.memoizedProps.value);break;case 13:var M=x.memoizedState;if(M!==null)return M.dehydrated!==null?(Mt(_i,_i.current&1),x.flags|=128,null):T&x.child.childLanes?NW(b,x,T):(Mt(_i,_i.current&1),b=Ju(b,x,T),b!==null?b.sibling:null);Mt(_i,_i.current&1);break;case 19:if(M=(T&x.childLanes)!==0,b.flags&128){if(M)return FW(b,x,T);x.flags|=128}var R=x.memoizedState;if(R!==null&&(R.rendering=null,R.tail=null,R.lastEffect=null),Mt(_i,_i.current),M)break;return null;case 22:case 23:return x.lanes=0,AW(b,x,T)}return Ju(b,x,T)}function Hae(b,x){switch($k(x),x.tag){case 1:return Lr(x.type)&&or(),b=x.flags,b&65536?(x.flags=b&-65537|128,x):null;case 3:return zm(),Ht(Oi),Ht(xn),Yk(),b=x.flags,b&65536&&!(b&128)?(x.flags=b&-65537|128,x):null;case 5:return Zk(x),null;case 13:if(Ht(_i),b=x.memoizedState,b!==null&&b.dehydrated!==null){if(x.alternate===null)throw Error(o(340));Fm()}return b=x.flags,b&65536?(x.flags=b&-65537|128,x):null;case 19:return Ht(_i),null;case 4:return zm(),null;case 10:return Ok(x.type._context),null;case 22:case 23:return MR(),null;case 24:return null;default:return null}}var mT=!1,jd=!1,Xae=typeof WeakSet=="function"?WeakSet:Set,mt=null;function gT(b,x){var T=b.ref;if(T!==null)if(typeof T=="function")try{T(null)}catch(M){uo(b,x,M)}else T.current=null}function uR(b,x,T){try{T()}catch(M){uo(b,x,M)}}var OW=!1;function Kae(b,x){for(X(b.containerInfo),mt=x;mt!==null;)if(b=mt,x=b.child,(b.subtreeFlags&1028)!==0&&x!==null)x.return=b,mt=x;else for(;mt!==null;){b=mt;try{var T=b.alternate;if(b.flags&1024)switch(b.tag){case 0:case 11:case 15:break;case 1:if(T!==null){var M=T.memoizedProps,R=T.memoizedState,L=b.stateNode,te=L.getSnapshotBeforeUpdate(b.elementType===b.type?M:ll(b.type,M),R);L.__reactInternalSnapshotBeforeUpdate=te}break;case 3:$e&&re(b.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(o(163))}}catch(be){uo(b,b.return,be)}if(x=b.sibling,x!==null){x.return=b.return,mt=x;break}mt=b.return}return T=OW,OW=!1,T}function Yd(b,x,T){var M=x.updateQueue;if(M=M!==null?M.lastEffect:null,M!==null){var R=M=M.next;do{if((R.tag&b)===b){var L=R.destroy;R.destroy=void 0,L!==void 0&&uR(x,T,L)}R=R.next}while(R!==M)}}function Gb(b,x){if(x=x.updateQueue,x=x!==null?x.lastEffect:null,x!==null){var T=x=x.next;do{if((T.tag&b)===b){var M=T.create;T.destroy=M()}T=T.next}while(T!==x)}}function cR(b){var x=b.ref;if(x!==null){var T=b.stateNode;switch(b.tag){case 5:b=J(T);break;default:b=T}typeof x=="function"?x(b):x.current=b}}function BW(b,x,T){if(eu&&typeof eu.onCommitFiberUnmount=="function")try{eu.onCommitFiberUnmount(HS,x)}catch{}switch(x.tag){case 0:case 11:case 14:case 15:if(b=x.updateQueue,b!==null&&(b=b.lastEffect,b!==null)){var M=b=b.next;do{var R=M,L=R.destroy;R=R.tag,L!==void 0&&(R&2||R&4)&&uR(x,T,L),M=M.next}while(M!==b)}break;case 1:if(gT(x,T),b=x.stateNode,typeof b.componentWillUnmount=="function")try{b.props=x.memoizedProps,b.state=x.memoizedState,b.componentWillUnmount()}catch(te){uo(x,T,te)}break;case 5:gT(x,T);break;case 4:$e?WW(b,x,T):ee&&ee&&(x=x.stateNode.containerInfo,T=de(x),rt(x,T))}}function zW(b,x,T){for(var M=x;;)if(BW(b,M,T),M.child===null||$e&&M.tag===4){if(M===x)break;for(;M.sibling===null;){if(M.return===null||M.return===x)return;M=M.return}M.sibling.return=M.return,M=M.sibling}else M.child.return=M,M=M.child}function GW(b){var x=b.alternate;x!==null&&(b.alternate=null,GW(x)),b.child=null,b.deletions=null,b.sibling=null,b.tag===5&&(x=b.stateNode,x!==null&&nt(x)),b.stateNode=null,b.return=null,b.dependencies=null,b.memoizedProps=null,b.memoizedState=null,b.pendingProps=null,b.stateNode=null,b.updateQueue=null}function VW(b){return b.tag===5||b.tag===3||b.tag===4}function UW(b){e:for(;;){for(;b.sibling===null;){if(b.return===null||VW(b.return))return null;b=b.return}for(b.sibling.return=b.return,b=b.sibling;b.tag!==5&&b.tag!==6&&b.tag!==18;){if(b.flags&2||b.child===null||b.tag===4)continue e;b.child.return=b,b=b.child}if(!(b.flags&2))return b.stateNode}}function $W(b){if($e){e:{for(var x=b.return;x!==null;){if(VW(x))break e;x=x.return}throw Error(o(160))}var T=x;switch(T.tag){case 5:x=T.stateNode,T.flags&32&&(Oe(x),T.flags&=-33),T=UW(b),dR(b,T,x);break;case 3:case 4:x=T.stateNode.containerInfo,T=UW(b),hR(b,T,x);break;default:throw Error(o(161))}}}function hR(b,x,T){var M=b.tag;if(M===5||M===6)b=b.stateNode,x?Qe(T,b,x):ct(T,b);else if(M!==4&&(b=b.child,b!==null))for(hR(b,x,T),b=b.sibling;b!==null;)hR(b,x,T),b=b.sibling}function dR(b,x,T){var M=b.tag;if(M===5||M===6)b=b.stateNode,x?Xt(T,b,x):Ve(T,b);else if(M!==4&&(b=b.child,b!==null))for(dR(b,x,T),b=b.sibling;b!==null;)dR(b,x,T),b=b.sibling}function WW(b,x,T){for(var M=x,R=!1,L,te;;){if(!R){R=M.return;e:for(;;){if(R===null)throw Error(o(160));switch(L=R.stateNode,R.tag){case 5:te=!1;break e;case 3:L=L.containerInfo,te=!0;break e;case 4:L=L.containerInfo,te=!0;break e}R=R.return}R=!0}if(M.tag===5||M.tag===6)zW(b,M,T),te?le(L,M.stateNode):sn(L,M.stateNode);else if(M.tag===18)te?Ee(L,M.stateNode):Se(L,M.stateNode);else if(M.tag===4){if(M.child!==null){L=M.stateNode.containerInfo,te=!0,M.child.return=M,M=M.child;continue}}else if(BW(b,M,T),M.child!==null){M.child.return=M,M=M.child;continue}if(M===x)break;for(;M.sibling===null;){if(M.return===null||M.return===x)return;M=M.return,M.tag===4&&(R=!1)}M.sibling.return=M.return,M=M.sibling}}function pR(b,x){if($e){switch(x.tag){case 0:case 11:case 14:case 15:Yd(3,x,x.return),Gb(3,x),Yd(5,x,x.return);return;case 1:return;case 5:var T=x.stateNode;if(T!=null){var M=x.memoizedProps;b=b!==null?b.memoizedProps:M;var R=x.type,L=x.updateQueue;x.updateQueue=null,L!==null&&Ot(T,L,R,b,M,x)}return;case 6:if(x.stateNode===null)throw Error(o(162));T=x.memoizedProps,qe(x.stateNode,b!==null?b.memoizedProps:T,T);return;case 3:De&&b!==null&&b.memoizedState.isDehydrated&&we(x.stateNode.containerInfo);return;case 12:return;case 13:yT(x);return;case 19:yT(x);return;case 17:return}throw Error(o(163))}switch(x.tag){case 0:case 11:case 14:case 15:Yd(3,x,x.return),Gb(3,x),Yd(5,x,x.return);return;case 12:return;case 13:yT(x);return;case 19:yT(x);return;case 3:De&&b!==null&&b.memoizedState.isDehydrated&&we(x.stateNode.containerInfo);break;case 22:case 23:return}e:if(ee){switch(x.tag){case 1:case 5:case 6:break e;case 3:case 4:x=x.stateNode,rt(x.containerInfo,x.pendingChildren);break e}throw Error(o(163))}}function yT(b){var x=b.updateQueue;if(x!==null){b.updateQueue=null;var T=b.stateNode;T===null&&(T=b.stateNode=new Xae),x.forEach(function(M){var R=ile.bind(null,b,M);T.has(M)||(T.add(M),M.then(R,R))})}}function Zae(b,x){for(mt=x;mt!==null;){x=mt;var T=x.deletions;if(T!==null)for(var M=0;M<T.length;M++){var R=T[M];try{var L=b;$e?WW(L,R,x):zW(L,R,x);var te=R.alternate;te!==null&&(te.return=null),R.return=null}catch(Rt){uo(R,x,Rt)}}if(T=x.child,x.subtreeFlags&12854&&T!==null)T.return=x,mt=T;else for(;mt!==null;){x=mt;try{var be=x.flags;if(be&32&&$e&&Oe(x.stateNode),be&512){var Be=x.alternate;if(Be!==null){var it=Be.ref;it!==null&&(typeof it=="function"?it(null):it.current=null)}}if(be&8192)switch(x.tag){case 13:if(x.memoizedState!==null){var _t=x.alternate;(_t===null||_t.memoizedState===null)&&(vR=Dr())}break;case 22:var qt=x.memoizedState!==null,zt=x.alternate,Xn=zt!==null&&zt.memoizedState!==null;if(T=x,$e){e:if(M=T,R=qt,L=null,$e)for(var Dt=M;;){if(Dt.tag===5){if(L===null){L=Dt;var bs=Dt.stateNode;R?je(bs):Pt(Dt.stateNode,Dt.memoizedProps)}}else if(Dt.tag===6){if(L===null){var Ia=Dt.stateNode;R?Ke(Ia):G(Ia,Dt.memoizedProps)}}else if((Dt.tag!==22&&Dt.tag!==23||Dt.memoizedState===null||Dt===M)&&Dt.child!==null){Dt.child.return=Dt,Dt=Dt.child;continue}if(Dt===M)break;for(;Dt.sibling===null;){if(Dt.return===null||Dt.return===M)break e;L===Dt&&(L=null),Dt=Dt.return}L===Dt&&(L=null),Dt.sibling.return=Dt.return,Dt=Dt.sibling}}if(qt&&!Xn&&T.mode&1){mt=T;for(var Ce=T.child;Ce!==null;){for(T=mt=Ce;mt!==null;){M=mt;var xe=M.child;switch(M.tag){case 0:case 11:case 14:case 15:Yd(4,M,M.return);break;case 1:gT(M,M.return);var Pe=M.stateNode;if(typeof Pe.componentWillUnmount=="function"){var bt=M.return;try{Pe.props=M.memoizedProps,Pe.state=M.memoizedState,Pe.componentWillUnmount()}catch(Rt){uo(M,bt,Rt)}}break;case 5:gT(M,M.return);break;case 22:if(M.memoizedState!==null){KW(T);continue}}xe!==null?(xe.return=M,mt=xe):KW(T)}Ce=Ce.sibling}}}switch(be&4102){case 2:$W(x),x.flags&=-3;break;case 6:$W(x),x.flags&=-3,pR(x.alternate,x);break;case 4096:x.flags&=-4097;break;case 4100:x.flags&=-4097,pR(x.alternate,x);break;case 4:pR(x.alternate,x)}}catch(Rt){uo(x,x.return,Rt)}if(T=x.sibling,T!==null){T.return=x.return,mt=T;break}mt=x.return}}}function jae(b,x,T){mt=b,HW(b)}function HW(b,x,T){for(var M=(b.mode&1)!==0;mt!==null;){var R=mt,L=R.child;if(R.tag===22&&M){var te=R.memoizedState!==null||mT;if(!te){var be=R.alternate,Be=be!==null&&be.memoizedState!==null||jd;be=mT;var it=jd;if(mT=te,(jd=Be)&&!it)for(mt=R;mt!==null;)te=mt,Be=te.child,te.tag===22&&te.memoizedState!==null?ZW(R):Be!==null?(Be.return=te,mt=Be):ZW(R);for(;L!==null;)mt=L,HW(L),L=L.sibling;mt=R,mT=be,jd=it}XW(b)}else R.subtreeFlags&8772&&L!==null?(L.return=R,mt=L):XW(b)}}function XW(b){for(;mt!==null;){var x=mt;if(x.flags&8772){var T=x.alternate;try{if(x.flags&8772)switch(x.tag){case 0:case 11:case 15:jd||Gb(5,x);break;case 1:var M=x.stateNode;if(x.flags&4&&!jd)if(T===null)M.componentDidMount();else{var R=x.elementType===x.type?T.memoizedProps:ll(x.type,T.memoizedProps);M.componentDidUpdate(R,T.memoizedState,M.__reactInternalSnapshotBeforeUpdate)}var L=x.updateQueue;L!==null&&G$(x,L,M);break;case 3:var te=x.updateQueue;if(te!==null){if(T=null,x.child!==null)switch(x.child.tag){case 5:T=J(x.child.stateNode);break;case 1:T=x.child.stateNode}G$(x,te,T)}break;case 5:var be=x.stateNode;T===null&&x.flags&4&&at(be,x.type,x.memoizedProps,x);break;case 6:break;case 4:break;case 12:break;case 13:if(De&&x.memoizedState===null){var Be=x.alternate;if(Be!==null){var it=Be.memoizedState;if(it!==null){var _t=it.dehydrated;_t!==null&&Ae(_t)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(o(163))}jd||x.flags&512&&cR(x)}catch(qt){uo(x,x.return,qt)}}if(x===b){mt=null;break}if(T=x.sibling,T!==null){T.return=x.return,mt=T;break}mt=x.return}}function KW(b){for(;mt!==null;){var x=mt;if(x===b){mt=null;break}var T=x.sibling;if(T!==null){T.return=x.return,mt=T;break}mt=x.return}}function ZW(b){for(;mt!==null;){var x=mt;try{switch(x.tag){case 0:case 11:case 15:var T=x.return;try{Gb(4,x)}catch(Be){uo(x,T,Be)}break;case 1:var M=x.stateNode;if(typeof M.componentDidMount=="function"){var R=x.return;try{M.componentDidMount()}catch(Be){uo(x,R,Be)}}var L=x.return;try{cR(x)}catch(Be){uo(x,L,Be)}break;case 5:var te=x.return;try{cR(x)}catch(Be){uo(x,te,Be)}}}catch(Be){uo(x,x.return,Be)}if(x===b){mt=null;break}var be=x.sibling;if(be!==null){be.return=x.return,mt=be;break}mt=x.return}}var bT=0,xT=1,vT=2,wT=3,ST=4;if(typeof Symbol=="function"&&Symbol.for){var Vb=Symbol.for;bT=Vb("selector.component"),xT=Vb("selector.has_pseudo_class"),vT=Vb("selector.role"),wT=Vb("selector.test_id"),ST=Vb("selector.text")}function fR(b){var x=_e(b);if(x!=null){if(typeof x.memoizedProps["data-testname"]!="string")throw Error(o(364));return x}if(b=Lt(b),b===null)throw Error(o(362));return b.stateNode.current}function mR(b,x){switch(x.$$typeof){case bT:if(b.type===x.value)return!0;break;case xT:e:{x=x.value,b=[b,0];for(var T=0;T<b.length;){var M=b[T++],R=b[T++],L=x[R];if(M.tag!==5||!D(M)){for(;L!=null&&mR(M,L);)R++,L=x[R];if(R===x.length){x=!0;break e}else for(M=M.child;M!==null;)b.push(M,R),M=M.sibling}}x=!1}return x;case vT:if(b.tag===5&&oe(b.stateNode,x.value))return!0;break;case ST:if((b.tag===5||b.tag===6)&&(b=H(b),b!==null&&0<=b.indexOf(x.value)))return!0;break;case wT:if(b.tag===5&&(b=b.memoizedProps["data-testname"],typeof b=="string"&&b.toLowerCase()===x.value.toLowerCase()))return!0;break;default:throw Error(o(365))}return!1}function gR(b){switch(b.$$typeof){case bT:return"<"+(A(b.value)||"Unknown")+">";case xT:return":has("+(gR(b)||"")+")";case vT:return'[role="'+b.value+'"]';case ST:return'"'+b.value+'"';case wT:return'[data-testname="'+b.value+'"]';default:throw Error(o(365))}}function jW(b,x){var T=[];b=[b,0];for(var M=0;M<b.length;){var R=b[M++],L=b[M++],te=x[L];if(R.tag!==5||!D(R)){for(;te!=null&&mR(R,te);)L++,te=x[L];if(L===x.length)T.push(R);else for(R=R.child;R!==null;)b.push(R,L),R=R.sibling}}return T}function yR(b,x){if(!yt)throw Error(o(363));b=fR(b),b=jW(b,x),x=[],b=Array.from(b);for(var T=0;T<b.length;){var M=b[T++];if(M.tag===5)D(M)||x.push(M.stateNode);else for(M=M.child;M!==null;)b.push(M),M=M.sibling}return x}var Yae=Math.ceil,TT=a.ReactCurrentDispatcher,bR=a.ReactCurrentOwner,ji=a.ReactCurrentBatchConfig,fn=0,ar=null,lr=null,ss=0,Vo=0,Vm=Nr(0),vr=0,Ub=null,Um=0,CT=0,xR=0,$b=null,ao=null,vR=0,wR=1/0;function $m(){wR=Dr()+500}var _T=!1,SR=null,lh=null,MT=!1,uh=null,AT=0,Wb=0,TR=null,ET=-1,IT=0;function Vs(){return fn&6?Dr():ET!==-1?ET:ET=Dr()}function ch(b){return b.mode&1?fn&2&&ss!==0?ss&-ss:Nae.transition!==null?(IT===0&&(b=US,US<<=1,!(US&4194240)&&(US=64),IT=b),IT):(b=Ln,b!==0?b:Re()):1}function Aa(b,x,T){if(50<Wb)throw Wb=0,TR=null,Error(o(185));var M=kT(b,x);return M===null?null:(Ab(M,x,T),(!(fn&2)||M!==ar)&&(M===ar&&(!(fn&2)&&(CT|=x),vr===4&&hh(M,ss)),lo(M,T),x===1&&fn===0&&!(b.mode&1)&&($m(),XS&&nu())),M)}function kT(b,x){b.lanes|=x;var T=b.alternate;for(T!==null&&(T.lanes|=x),T=b,b=b.return;b!==null;)b.childLanes|=x,T=b.alternate,T!==null&&(T.childLanes|=x),T=b,b=b.return;return T.tag===3?T.stateNode:null}function lo(b,x){var T=b.callbackNode;Tae(b,x);var M=WS(b,b===ar?ss:0);if(M===0)T!==null&&D$(T),b.callbackNode=null,b.callbackPriority=0;else if(x=M&-M,b.callbackPriority!==x){if(T!=null&&D$(T),x===1)b.tag===0?Rae(JW.bind(null,b)):F$(JW.bind(null,b)),Ze?st(function(){fn===0&&nu()}):Rk(Nk,nu),T=null;else{switch(P$(M)){case 1:T=Nk;break;case 4:T=Aae;break;case 16:T=Lk;break;case 536870912:T=Eae;break;default:T=Lk}T=oH(T,YW.bind(null,b))}b.callbackPriority=x,b.callbackNode=T}}function YW(b,x){if(ET=-1,IT=0,fn&6)throw Error(o(327));var T=b.callbackNode;if(qd()&&b.callbackNode!==T)return null;var M=WS(b,b===ar?ss:0);if(M===0)return null;if(M&30||M&b.expiredLanes||x)x=RT(b,M);else{x=M;var R=fn;fn|=2;var L=eH();(ar!==b||ss!==x)&&($m(),Jd(b,x));do try{qae();break}catch(be){qW(b,be)}while(1);Fk(),TT.current=L,fn=R,lr!==null?x=0:(ar=null,ss=0,x=vr)}if(x!==0){if(x===2&&(R=Ek(b),R!==0&&(M=R,x=CR(b,R))),x===1)throw T=Ub,Jd(b,0),hh(b,M),lo(b,Dr()),T;if(x===6)hh(b,M);else{if(R=b.current.alternate,!(M&30)&&!Jae(R)&&(x=RT(b,M),x===2&&(L=Ek(b),L!==0&&(M=L,x=CR(b,L))),x===1))throw T=Ub,Jd(b,0),hh(b,M),lo(b,Dr()),T;switch(b.finishedWork=R,b.finishedLanes=M,x){case 0:case 1:throw Error(o(345));case 2:Qd(b,ao);break;case 3:if(hh(b,M),(M&130023424)===M&&(x=vR+500-Dr(),10<x)){if(WS(b,0)!==0)break;if(R=b.suspendedLanes,(R&M)!==M){Vs(),b.pingedLanes|=b.suspendedLanes&R;break}b.timeoutHandle=Fe(Qd.bind(null,b,ao),x);break}Qd(b,ao);break;case 4:if(hh(b,M),(M&4194240)===M)break;for(x=b.eventTimes,R=-1;0<M;){var te=31-Oo(M);L=1<<te,te=x[te],te>R&&(R=te),M&=~L}if(M=R,M=Dr()-M,M=(120>M?120:480>M?480:1080>M?1080:1920>M?1920:3e3>M?3e3:4320>M?4320:1960*Yae(M/1960))-M,10<M){b.timeoutHandle=Fe(Qd.bind(null,b,ao),M);break}Qd(b,ao);break;case 5:Qd(b,ao);break;default:throw Error(o(329))}}}return lo(b,Dr()),b.callbackNode===T?YW.bind(null,b):null}function CR(b,x){var T=$b;return b.current.memoizedState.isDehydrated&&(Jd(b,x).flags|=256),b=RT(b,x),b!==2&&(x=ao,ao=T,x!==null&&_R(x)),b}function _R(b){ao===null?ao=b:ao.push.apply(ao,b)}function Jae(b){for(var x=b;;){if(x.flags&16384){var T=x.updateQueue;if(T!==null&&(T=T.stores,T!==null))for(var M=0;M<T.length;M++){var R=T[M],L=R.getSnapshot;R=R.value;try{if(!tu(L(),R))return!1}catch{return!1}}}if(T=x.child,x.subtreeFlags&16384&&T!==null)T.return=x,x=T;else{if(x===b)break;for(;x.sibling===null;){if(x.return===null||x.return===b)return!0;x=x.return}x.sibling.return=x.return,x=x.sibling}}return!0}function hh(b,x){for(x&=~xR,x&=~CT,b.suspendedLanes|=x,b.pingedLanes&=~x,b=b.expirationTimes;0<x;){var T=31-Oo(x),M=1<<T;b[T]=-1,x&=~M}}function JW(b){if(fn&6)throw Error(o(327));qd();var x=WS(b,0);if(!(x&1))return lo(b,Dr()),null;var T=RT(b,x);if(b.tag!==0&&T===2){var M=Ek(b);M!==0&&(x=M,T=CR(b,M))}if(T===1)throw T=Ub,Jd(b,0),hh(b,x),lo(b,Dr()),T;if(T===6)throw Error(o(345));return b.finishedWork=b.current.alternate,b.finishedLanes=x,Qd(b,ao),lo(b,Dr()),null}function QW(b){uh!==null&&uh.tag===0&&!(fn&6)&&qd();var x=fn;fn|=1;var T=ji.transition,M=Ln;try{if(ji.transition=null,Ln=1,b)return b()}finally{Ln=M,ji.transition=T,fn=x,!(fn&6)&&nu()}}function MR(){Vo=Vm.current,Ht(Vm)}function Jd(b,x){b.finishedWork=null,b.finishedLanes=0;var T=b.timeoutHandle;if(T!==Ue&&(b.timeoutHandle=Ue,We(T)),lr!==null)for(T=lr.return;T!==null;){var M=T;switch($k(M),M.tag){case 1:M=M.type.childContextTypes,M!=null&&or();break;case 3:zm(),Ht(Oi),Ht(xn),Yk();break;case 5:Zk(M);break;case 4:zm();break;case 13:Ht(_i);break;case 19:Ht(_i);break;case 10:Ok(M.type._context);break;case 22:case 23:MR()}T=T.return}if(ar=b,lr=b=dh(b.current,null),ss=Vo=x,vr=0,Ub=null,xR=CT=Um=0,ao=$b=null,iu!==null){for(x=0;x<iu.length;x++)if(T=iu[x],M=T.interleaved,M!==null){T.interleaved=null;var R=M.next,L=T.pending;if(L!==null){var te=L.next;L.next=R,M.next=te}T.pending=M}iu=null}return b}function qW(b,x){do{var T=lr;try{if(Fk(),iT.current=uT,rT){for(var M=Bi.memoizedState;M!==null;){var R=M.queue;R!==null&&(R.pending=null),M=M.next}rT=!1}if(Gm=0,Fr=ms=Bi=null,Lb=!1,Pb=0,bR.current=null,T===null||T.return===null){vr=1,Ub=x,lr=null;break}e:{var L=b,te=T.return,be=T,Be=x;if(x=ss,be.flags|=32768,Be!==null&&typeof Be=="object"&&typeof Be.then=="function"){var it=Be,_t=be,qt=_t.tag;if(!(_t.mode&1)&&(qt===0||qt===11||qt===15)){var zt=_t.alternate;zt?(_t.updateQueue=zt.updateQueue,_t.memoizedState=zt.memoizedState,_t.lanes=zt.lanes):(_t.updateQueue=null,_t.memoizedState=null)}var Xn=vW(te);if(Xn!==null){Xn.flags&=-257,wW(Xn,te,be,L,x),Xn.mode&1&&xW(L,it,x),x=Xn,Be=it;var Dt=x.updateQueue;if(Dt===null){var bs=new Set;bs.add(Be),x.updateQueue=bs}else Dt.add(Be);break e}else{if(!(x&1)){xW(L,it,x),AR();break e}Be=Error(o(426))}}else if(gi&&be.mode&1){var Ia=vW(te);if(Ia!==null){!(Ia.flags&65536)&&(Ia.flags|=256),wW(Ia,te,be,L,x),Xk(Be);break e}}L=Be,vr!==4&&(vr=2),$b===null?$b=[L]:$b.push(L),Be=iR(Be,be),be=te;do{switch(be.tag){case 3:be.flags|=65536,x&=-x,be.lanes|=x;var Ce=yW(be,Be,x);z$(be,Ce);break e;case 1:L=Be;var xe=be.type,Pe=be.stateNode;if(!(be.flags&128)&&(typeof xe.getDerivedStateFromError=="function"||Pe!==null&&typeof Pe.componentDidCatch=="function"&&(lh===null||!lh.has(Pe)))){be.flags|=65536,x&=-x,be.lanes|=x;var bt=bW(be,L,x);z$(be,bt);break e}}be=be.return}while(be!==null)}nH(T)}catch(Rt){x=Rt,lr===T&&T!==null&&(lr=T=T.return);continue}break}while(1)}function eH(){var b=TT.current;return TT.current=uT,b===null?uT:b}function AR(){(vr===0||vr===3||vr===2)&&(vr=4),ar===null||!(Um&268435455)&&!(CT&268435455)||hh(ar,ss)}function RT(b,x){var T=fn;fn|=2;var M=eH();ar===b&&ss===x||Jd(b,x);do try{Qae();break}catch(R){qW(b,R)}while(1);if(Fk(),fn=T,TT.current=M,lr!==null)throw Error(o(261));return ar=null,ss=0,vr}function Qae(){for(;lr!==null;)tH(lr)}function qae(){for(;lr!==null&&!_ae();)tH(lr)}function tH(b){var x=sH(b.alternate,b,Vo);b.memoizedProps=b.pendingProps,x===null?nH(b):lr=x,bR.current=null}function nH(b){var x=b;do{var T=x.alternate;if(b=x.return,x.flags&32768){if(T=Hae(T,x),T!==null){T.flags&=32767,lr=T;return}if(b!==null)b.flags|=32768,b.subtreeFlags=0,b.deletions=null;else{vr=6,lr=null;return}}else if(T=Uae(T,x,Vo),T!==null){lr=T;return}if(x=x.sibling,x!==null){lr=x;return}lr=x=b}while(x!==null);vr===0&&(vr=5)}function Qd(b,x){var T=Ln,M=ji.transition;try{ji.transition=null,Ln=1,ele(b,x,T)}finally{ji.transition=M,Ln=T}return null}function ele(b,x,T){do qd();while(uh!==null);if(fn&6)throw Error(o(327));var M=b.finishedWork,R=b.finishedLanes;if(M===null)return null;if(b.finishedWork=null,b.finishedLanes=0,M===b.current)throw Error(o(177));b.callbackNode=null,b.callbackPriority=0;var L=M.lanes|M.childLanes;if(Cae(b,L),b===ar&&(lr=ar=null,ss=0),!(M.subtreeFlags&2064)&&!(M.flags&2064)||MT||(MT=!0,oH(Lk,function(){return qd(),null})),L=(M.flags&15990)!==0,M.subtreeFlags&15990||L){L=ji.transition,ji.transition=null;var te=Ln;Ln=1;var be=fn;fn|=4,bR.current=null,Kae(b,M),Zae(b,M),j(b.containerInfo),b.current=M,jae(M),Mae(),fn=be,Ln=te,ji.transition=L}else b.current=M;if(MT&&(MT=!1,uh=b,AT=R),L=b.pendingLanes,L===0&&(lh=null),Iae(M.stateNode),lo(b,Dr()),x!==null)for(T=b.onRecoverableError,M=0;M<x.length;M++)T(x[M]);if(_T)throw _T=!1,b=SR,SR=null,b;return AT&1&&b.tag!==0&&qd(),L=b.pendingLanes,L&1?b===TR?Wb++:(Wb=0,TR=b):Wb=0,nu(),null}function qd(){if(uh!==null){var b=P$(AT),x=ji.transition,T=Ln;try{if(ji.transition=null,Ln=16>b?16:b,uh===null)var M=!1;else{if(b=uh,uh=null,AT=0,fn&6)throw Error(o(331));var R=fn;for(fn|=4,mt=b.current;mt!==null;){var L=mt,te=L.child;if(mt.flags&16){var be=L.deletions;if(be!==null){for(var Be=0;Be<be.length;Be++){var it=be[Be];for(mt=it;mt!==null;){var _t=mt;switch(_t.tag){case 0:case 11:case 15:Yd(8,_t,L)}var qt=_t.child;if(qt!==null)qt.return=_t,mt=qt;else for(;mt!==null;){_t=mt;var zt=_t.sibling,Xn=_t.return;if(GW(_t),_t===it){mt=null;break}if(zt!==null){zt.return=Xn,mt=zt;break}mt=Xn}}}var Dt=L.alternate;if(Dt!==null){var bs=Dt.child;if(bs!==null){Dt.child=null;do{var Ia=bs.sibling;bs.sibling=null,bs=Ia}while(bs!==null)}}mt=L}}if(L.subtreeFlags&2064&&te!==null)te.return=L,mt=te;else e:for(;mt!==null;){if(L=mt,L.flags&2048)switch(L.tag){case 0:case 11:case 15:Yd(9,L,L.return)}var Ce=L.sibling;if(Ce!==null){Ce.return=L.return,mt=Ce;break e}mt=L.return}}var xe=b.current;for(mt=xe;mt!==null;){te=mt;var Pe=te.child;if(te.subtreeFlags&2064&&Pe!==null)Pe.return=te,mt=Pe;else e:for(te=xe;mt!==null;){if(be=mt,be.flags&2048)try{switch(be.tag){case 0:case 11:case 15:Gb(9,be)}}catch(Rt){uo(be,be.return,Rt)}if(be===te){mt=null;break e}var bt=be.sibling;if(bt!==null){bt.return=be.return,mt=bt;break e}mt=be.return}}if(fn=R,nu(),eu&&typeof eu.onPostCommitFiberRoot=="function")try{eu.onPostCommitFiberRoot(HS,b)}catch{}M=!0}return M}finally{Ln=T,ji.transition=x}}return!1}function iH(b,x,T){x=iR(T,x),x=yW(b,x,1),ah(b,x),x=Vs(),b=kT(b,1),b!==null&&(Ab(b,1,x),lo(b,x))}function uo(b,x,T){if(b.tag===3)iH(b,b,T);else for(;x!==null;){if(x.tag===3){iH(x,b,T);break}else if(x.tag===1){var M=x.stateNode;if(typeof x.type.getDerivedStateFromError=="function"||typeof M.componentDidCatch=="function"&&(lh===null||!lh.has(M))){b=iR(T,b),b=bW(x,b,1),ah(x,b),b=Vs(),x=kT(x,1),x!==null&&(Ab(x,1,b),lo(x,b));break}}x=x.return}}function tle(b,x,T){var M=b.pingCache;M!==null&&M.delete(x),x=Vs(),b.pingedLanes|=b.suspendedLanes&T,ar===b&&(ss&T)===T&&(vr===4||vr===3&&(ss&130023424)===ss&&500>Dr()-vR?Jd(b,0):xR|=T),lo(b,x)}function rH(b,x){x===0&&(b.mode&1?(x=$S,$S<<=1,!($S&130023424)&&($S=4194304)):x=1);var T=Vs();b=kT(b,x),b!==null&&(Ab(b,x,T),lo(b,T))}function nle(b){var x=b.memoizedState,T=0;x!==null&&(T=x.retryLane),rH(b,T)}function ile(b,x){var T=0;switch(b.tag){case 13:var M=b.stateNode,R=b.memoizedState;R!==null&&(T=R.retryLane);break;case 19:M=b.stateNode;break;default:throw Error(o(314))}M!==null&&M.delete(x),rH(b,T)}var sH;sH=function(b,x,T){if(b!==null)if(b.memoizedProps!==x.pendingProps||Oi.current)Go=!0;else{if(!(b.lanes&T)&&!(x.flags&128))return Go=!1,Wae(b,x,T);Go=!!(b.flags&131072)}else Go=!1,gi&&x.flags&1048576&&H$(x,eT,x.index);switch(x.lanes=0,x.tag){case 2:var M=x.type;b!==null&&(b.alternate=null,x.alternate=null,x.flags|=2),b=x.pendingProps;var R=wa(x,xn.current);Lm(x,T),R=Qk(null,x,M,b,R,T);var L=qk();return x.flags|=1,typeof R=="object"&&R!==null&&typeof R.render=="function"&&R.$$typeof===void 0?(x.tag=1,x.memoizedState=null,x.updateQueue=null,Lr(M)?(L=!0,Pr(x)):L=!1,x.memoizedState=R.state!==null&&R.state!==void 0?R.state:null,zk(x),R.updater=QS,x.stateNode=R,R._reactInternals=x,Vk(x,M,b,T),x=oR(null,x,M,!0,L,T)):(x.tag=0,gi&&L&&Uk(x),Gs(null,x,R,T),x=x.child),x;case 16:M=x.elementType;e:{switch(b!==null&&(b.alternate=null,x.alternate=null,x.flags|=2),b=x.pendingProps,R=M._init,M=R(M._payload),x.type=M,R=x.tag=sle(M),b=ll(M,b),R){case 0:x=sR(null,x,M,b,T);break e;case 1:x=IW(null,x,M,b,T);break e;case 11:x=CW(null,x,M,b,T);break e;case 14:x=_W(null,x,M,ll(M.type,b),T);break e}throw Error(o(306,M,""))}return x;case 0:return M=x.type,R=x.pendingProps,R=x.elementType===M?R:ll(M,R),sR(b,x,M,R,T);case 1:return M=x.type,R=x.pendingProps,R=x.elementType===M?R:ll(M,R),IW(b,x,M,R,T);case 3:e:{if(kW(x),b===null)throw Error(o(387));M=x.pendingProps,L=x.memoizedState,R=L.element,B$(b,x),JS(x,M,null,T);var te=x.memoizedState;if(M=te.element,De&&L.isDehydrated)if(L={element:M,isDehydrated:!1,cache:te.cache,transitions:te.transitions},x.updateQueue.baseState=L,x.memoizedState=L,x.flags&256){R=Error(o(423)),x=RW(b,x,M,T,R);break e}else if(M!==R){R=Error(o(424)),x=RW(b,x,M,T,R);break e}else for(De&&(zo=rh(x.stateNode.containerInfo),Bo=x,gi=!0,ul=null,Eb=!1),T=J$(x,null,M,T),x.child=T;T;)T.flags=T.flags&-3|4096,T=T.sibling;else{if(Fm(),M===R){x=Ju(b,x,T);break e}Gs(b,x,M,T)}x=x.child}return x;case 5:return Q$(x),b===null&&Hk(x),M=x.type,R=x.pendingProps,L=b!==null?b.memoizedProps:null,te=R.children,ge(M,R)?te=null:L!==null&&ge(M,L)&&(x.flags|=32),EW(b,x),Gs(b,x,te,T),x.child;case 6:return b===null&&Hk(x),null;case 13:return NW(b,x,T);case 4:return Kk(x,x.stateNode.containerInfo),M=x.pendingProps,b===null?x.child=Om(x,null,M,T):Gs(b,x,M,T),x.child;case 11:return M=x.type,R=x.pendingProps,R=x.elementType===M?R:ll(M,R),CW(b,x,M,R,T);case 7:return Gs(b,x,x.pendingProps,T),x.child;case 8:return Gs(b,x,x.pendingProps.children,T),x.child;case 12:return Gs(b,x,x.pendingProps.children,T),x.child;case 10:e:{if(M=x.type._context,R=x.pendingProps,L=x.memoizedProps,te=R.value,O$(x,M,te),L!==null)if(tu(L.value,te)){if(L.children===R.children&&!Oi.current){x=Ju(b,x,T);break e}}else for(L=x.child,L!==null&&(L.return=x);L!==null;){var be=L.dependencies;if(be!==null){te=L.child;for(var Be=be.firstContext;Be!==null;){if(Be.context===M){if(L.tag===1){Be=Ku(-1,T&-T),Be.tag=2;var it=L.updateQueue;if(it!==null){it=it.shared;var _t=it.pending;_t===null?Be.next=Be:(Be.next=_t.next,_t.next=Be),it.pending=Be}}L.lanes|=T,Be=L.alternate,Be!==null&&(Be.lanes|=T),Bk(L.return,T,x),be.lanes|=T;break}Be=Be.next}}else if(L.tag===10)te=L.type===x.type?null:L.child;else if(L.tag===18){if(te=L.return,te===null)throw Error(o(341));te.lanes|=T,be=te.alternate,be!==null&&(be.lanes|=T),Bk(te,T,x),te=L.sibling}else te=L.child;if(te!==null)te.return=L;else for(te=L;te!==null;){if(te===x){te=null;break}if(L=te.sibling,L!==null){L.return=te.return,te=L;break}te=te.return}L=te}Gs(b,x,R.children,T),x=x.child}return x;case 9:return R=x.type,M=x.pendingProps.children,Lm(x,T),R=Sa(R),M=M(R),x.flags|=1,Gs(b,x,M,T),x.child;case 14:return M=x.type,R=ll(M,x.pendingProps),R=ll(M.type,R),_W(b,x,M,R,T);case 15:return MW(b,x,x.type,x.pendingProps,T);case 17:return M=x.type,R=x.pendingProps,R=x.elementType===M?R:ll(M,R),b!==null&&(b.alternate=null,x.alternate=null,x.flags|=2),x.tag=1,Lr(M)?(b=!0,Pr(x)):b=!1,Lm(x,T),$$(x,M,R),Vk(x,M,R,T),oR(null,x,M,!0,b,T);case 19:return FW(b,x,T);case 22:return AW(b,x,T)}throw Error(o(156,x.tag))};function oH(b,x){return Rk(b,x)}function rle(b,x,T,M){this.tag=b,this.key=T,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=x,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=M,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ea(b,x,T,M){return new rle(b,x,T,M)}function ER(b){return b=b.prototype,!(!b||!b.isReactComponent)}function sle(b){if(typeof b=="function")return ER(b)?1:0;if(b!=null){if(b=b.$$typeof,b===g)return 11;if(b===v)return 14}return 2}function dh(b,x){var T=b.alternate;return T===null?(T=Ea(b.tag,x,b.key,b.mode),T.elementType=b.elementType,T.type=b.type,T.stateNode=b.stateNode,T.alternate=b,b.alternate=T):(T.pendingProps=x,T.type=b.type,T.flags=0,T.subtreeFlags=0,T.deletions=null),T.flags=b.flags&14680064,T.childLanes=b.childLanes,T.lanes=b.lanes,T.child=b.child,T.memoizedProps=b.memoizedProps,T.memoizedState=b.memoizedState,T.updateQueue=b.updateQueue,x=b.dependencies,T.dependencies=x===null?null:{lanes:x.lanes,firstContext:x.firstContext},T.sibling=b.sibling,T.index=b.index,T.ref=b.ref,T}function NT(b,x,T,M,R,L){var te=2;if(M=b,typeof b=="function")ER(b)&&(te=1);else if(typeof b=="string")te=5;else e:switch(b){case c:return ep(T.children,R,L,x);case h:te=8,R|=8;break;case d:return b=Ea(12,T,x,R|2),b.elementType=d,b.lanes=L,b;case y:return b=Ea(13,T,x,R),b.elementType=y,b.lanes=L,b;case m:return b=Ea(19,T,x,R),b.elementType=m,b.lanes=L,b;case S:return LT(T,R,L,x);default:if(typeof b=="object"&&b!==null)switch(b.$$typeof){case p:te=10;break e;case f:te=9;break e;case g:te=11;break e;case v:te=14;break e;case w:te=16,M=null;break e}throw Error(o(130,b==null?b:typeof b,""))}return x=Ea(te,T,x,R),x.elementType=b,x.type=M,x.lanes=L,x}function ep(b,x,T,M){return b=Ea(7,b,M,x),b.lanes=T,b}function LT(b,x,T,M){return b=Ea(22,b,M,x),b.elementType=S,b.lanes=T,b.stateNode={},b}function IR(b,x,T){return b=Ea(6,b,null,x),b.lanes=T,b}function kR(b,x,T){return x=Ea(4,b.children!==null?b.children:[],b.key,x),x.lanes=T,x.stateNode={containerInfo:b.containerInfo,pendingChildren:null,implementation:b.implementation},x}function ole(b,x,T,M,R){this.tag=x,this.containerInfo=b,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Ue,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Ik(0),this.expirationTimes=Ik(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ik(0),this.identifierPrefix=M,this.onRecoverableError=R,De&&(this.mutableSourceEagerHydrationData=null)}function aH(b,x,T,M,R,L,te,be,Be){return b=new ole(b,x,T,be,Be),x===1?(x=1,L===!0&&(x|=8)):x=0,L=Ea(3,null,null,x),b.current=L,L.stateNode=b,L.memoizedState={element:M,isDehydrated:T,cache:null,transitions:null},zk(L),b}function lH(b){if(!b)return va;b=b._reactInternals;e:{if(E(b)!==b||b.tag!==1)throw Error(o(170));var x=b;do{switch(x.tag){case 3:x=x.stateNode.context;break e;case 1:if(Lr(x.type)){x=x.stateNode.__reactInternalMemoizedMergedChildContext;break e}}x=x.return}while(x!==null);throw Error(o(171))}if(b.tag===1){var T=b.type;if(Lr(T))return km(b,T,x)}return x}function uH(b){var x=b._reactInternals;if(x===void 0)throw typeof b.render=="function"?Error(o(188)):(b=Object.keys(b).join(","),Error(o(268,b)));return b=V(x),b===null?null:b.stateNode}function cH(b,x){if(b=b.memoizedState,b!==null&&b.dehydrated!==null){var T=b.retryLane;b.retryLane=T!==0&&T<x?T:x}}function RR(b,x){cH(b,x),(b=b.alternate)&&cH(b,x)}function ale(b){return b=V(b),b===null?null:b.stateNode}function lle(){return null}return t.attemptContinuousHydration=function(b){if(b.tag===13){var x=Vs();Aa(b,134217728,x),RR(b,134217728)}},t.attemptHydrationAtCurrentPriority=function(b){if(b.tag===13){var x=Vs(),T=ch(b);Aa(b,T,x),RR(b,T)}},t.attemptSynchronousHydration=function(b){switch(b.tag){case 3:var x=b.stateNode;if(x.current.memoizedState.isDehydrated){var T=Mb(x.pendingLanes);T!==0&&(kk(x,T|1),lo(x,Dr()),!(fn&6)&&($m(),nu()))}break;case 13:var M=Vs();QW(function(){return Aa(b,1,M)}),RR(b,1)}},t.batchedUpdates=function(b,x){var T=fn;fn|=1;try{return b(x)}finally{fn=T,fn===0&&($m(),XS&&nu())}},t.createComponentSelector=function(b){return{$$typeof:bT,value:b}},t.createContainer=function(b,x,T,M,R,L,te){return aH(b,x,!1,null,T,M,R,L,te)},t.createHasPseudoClassSelector=function(b){return{$$typeof:xT,value:b}},t.createHydrationContainer=function(b,x,T,M,R,L,te,be,Be){return b=aH(T,M,!0,b,R,L,te,be,Be),b.context=lH(null),T=b.current,M=Vs(),R=ch(T),L=Ku(M,R),L.callback=x??null,ah(T,L),b.current.lanes=R,Ab(b,R,M),lo(b,M),b},t.createPortal=function(b,x,T){var M=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:u,key:M==null?null:""+M,children:b,containerInfo:x,implementation:T}},t.createRoleSelector=function(b){return{$$typeof:vT,value:b}},t.createTestNameSelector=function(b){return{$$typeof:wT,value:b}},t.createTextSelector=function(b){return{$$typeof:ST,value:b}},t.deferredUpdates=function(b){var x=Ln,T=ji.transition;try{return ji.transition=null,Ln=16,b()}finally{Ln=x,ji.transition=T}},t.discreteUpdates=function(b,x,T,M,R){var L=Ln,te=ji.transition;try{return ji.transition=null,Ln=1,b(x,T,M,R)}finally{Ln=L,ji.transition=te,fn===0&&$m()}},t.findAllNodes=yR,t.findBoundingRects=function(b,x){if(!yt)throw Error(o(363));x=yR(b,x),b=[];for(var T=0;T<x.length;T++)b.push(ye(x[T]));for(x=b.length-1;0<x;x--){T=b[x];for(var M=T.x,R=M+T.width,L=T.y,te=L+T.height,be=x-1;0<=be;be--)if(x!==be){var Be=b[be],it=Be.x,_t=it+Be.width,qt=Be.y,zt=qt+Be.height;if(M>=it&&L>=qt&&R<=_t&&te<=zt){b.splice(x,1);break}else if(M!==it||T.width!==Be.width||zt<L||qt>te){if(!(L!==qt||T.height!==Be.height||_t<M||it>R)){it>M&&(Be.width+=it-M,Be.x=M),_t<R&&(Be.width=R-it),b.splice(x,1);break}}else{qt>L&&(Be.height+=qt-L,Be.y=L),zt<te&&(Be.height=te-qt),b.splice(x,1);break}}}return b},t.findHostInstance=uH,t.findHostInstanceWithNoPortals=function(b){return b=P(b),b=b!==null?F(b):null,b===null?null:b.stateNode},t.findHostInstanceWithWarning=function(b){return uH(b)},t.flushControlled=function(b){var x=fn;fn|=1;var T=ji.transition,M=Ln;try{ji.transition=null,Ln=1,b()}finally{Ln=M,ji.transition=T,fn=x,fn===0&&($m(),nu())}},t.flushPassiveEffects=qd,t.flushSync=QW,t.focusWithin=function(b,x){if(!yt)throw Error(o(363));for(b=fR(b),x=jW(b,x),x=Array.from(x),b=0;b<x.length;){var T=x[b++];if(!D(T)){if(T.tag===5&&Ie(T.stateNode))return!0;for(T=T.child;T!==null;)x.push(T),T=T.sibling}}return!1},t.getCurrentUpdatePriority=function(){return Ln},t.getFindAllNodesFailureDescription=function(b,x){if(!yt)throw Error(o(363));var T=0,M=[];b=[fR(b),0];for(var R=0;R<b.length;){var L=b[R++],te=b[R++],be=x[te];if((L.tag!==5||!D(L))&&(mR(L,be)&&(M.push(gR(be)),te++,te>T&&(T=te)),te<x.length))for(L=L.child;L!==null;)b.push(L,te),L=L.sibling}if(T<x.length){for(b=[];T<x.length;T++)b.push(gR(x[T]));return`findAllNodes was able to match part of the selector:
  `+(M.join(" > ")+`

No matching component was found for:
  `)+b.join(" > ")}return null},t.getPublicRootInstance=function(b){if(b=b.current,!b.child)return null;switch(b.child.tag){case 5:return J(b.child.stateNode);default:return b.child.stateNode}},t.injectIntoDevTools=function(b){if(b={bundleType:b.bundleType,version:b.version,rendererPackageName:b.rendererPackageName,rendererConfig:b.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:a.ReactCurrentDispatcher,findHostInstanceByFiber:ale,findFiberByHostInstance:b.findFiberByHostInstance||lle,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")b=!1;else{var x=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(x.isDisabled||!x.supportsFiber)b=!0;else{try{HS=x.inject(b),eu=x}catch{}b=!!x.checkDCE}}return b},t.isAlreadyRendering=function(){return!1},t.observeVisibleRects=function(b,x,T,M){if(!yt)throw Error(o(363));b=yR(b,x);var R=Me(b,T,M).disconnect;return{disconnect:function(){R()}}},t.registerMutableSourceForHydration=function(b,x){var T=x._getVersion;T=T(x._source),b.mutableSourceEagerHydrationData==null?b.mutableSourceEagerHydrationData=[x,T]:b.mutableSourceEagerHydrationData.push(x,T)},t.runWithPriority=function(b,x){var T=Ln;try{return Ln=b,x()}finally{Ln=T}},t.shouldError=function(){return null},t.shouldSuspend=function(){return!1},t.updateContainer=function(b,x,T,M){var R=x.current,L=Vs(),te=ch(R);return T=lH(T),x.context===null?x.context=T:x.pendingContext=T,x=Ku(L,te),x.payload={element:b},M=M===void 0?null:M,M!==null&&(x.callback=M),ah(R,x),b=Aa(R,te,L),b!==null&&YS(b,R,te),te},t};gee.exports=QRe;var qRe=gee.exports;const eNe=Zy(qRe),tNe=n=>typeof n=="object"&&typeof n.then=="function",Kp=[];function xee(n,e,t=(i,r)=>i===r){if(n===e)return!0;if(!n||!e)return!1;const i=n.length;if(e.length!==i)return!1;for(let r=0;r<i;r++)if(!t(n[r],e[r]))return!1;return!0}function vee(n,e=null,t=!1,i={}){e===null&&(e=[n]);for(const s of Kp)if(xee(e,s.keys,s.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(s,"error"))throw s.error;if(Object.prototype.hasOwnProperty.call(s,"response"))return i.lifespan&&i.lifespan>0&&(s.timeout&&clearTimeout(s.timeout),s.timeout=setTimeout(s.remove,i.lifespan)),s.response;if(!t)throw s.promise}const r={keys:e,equal:i.equal,remove:()=>{const s=Kp.indexOf(r);s!==-1&&Kp.splice(s,1)},promise:(tNe(n)?n:n(...e)).then(s=>{r.response=s,i.lifespan&&i.lifespan>0&&(r.timeout=setTimeout(r.remove,i.lifespan))}).catch(s=>r.error=s)};if(Kp.push(r),!t)throw r.promise}const nNe=(n,e,t)=>vee(n,e,!1,t),iNe=(n,e,t)=>void vee(n,e,!0,t),rNe=n=>{if(n===void 0||n.length===0)Kp.splice(0,Kp.length);else{const e=Kp.find(t=>xee(n,t.keys,t.equal));e&&e.remove()}},Mz={},sNe=n=>void Object.assign(Mz,n);function oNe(n,e){function t(c,{args:h=[],attach:d,...p},f){let g=`${c[0].toUpperCase()}${c.slice(1)}`,y;if(c==="primitive"){if(p.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const m=p.object;y=bg(m,{type:c,root:f,attach:d,primitive:!0})}else{const m=Mz[g];if(!m)throw new Error(`R3F: ${g} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(h))throw new Error("R3F: The args prop must be an array!");y=bg(new m(...h),{type:c,root:f,attach:d,memoizedProps:{args:h}})}return y.__r3f.attach===void 0&&(y instanceof rn?y.__r3f.attach="geometry":y instanceof Pi&&(y.__r3f.attach="material")),g!=="inject"&&_L(y,p),y}function i(c,h){let d=!1;if(h){var p,f;(p=h.__r3f)!=null&&p.attach?CL(c,h,h.__r3f.attach):h.isObject3D&&c.isObject3D&&(c.add(h),d=!0),d||(f=c.__r3f)==null||f.objects.push(h),h.__r3f||bg(h,{}),h.__r3f.parent=c,W3(h),xg(h)}}function r(c,h,d){let p=!1;if(h){var f,g;if((f=h.__r3f)!=null&&f.attach)CL(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){h.parent=c,h.dispatchEvent({type:"added"});const y=c.children.filter(v=>v!==h),m=y.indexOf(d);c.children=[...y.slice(0,m),h,...y.slice(m)],p=!0}p||(g=c.__r3f)==null||g.objects.push(h),h.__r3f||bg(h,{}),h.__r3f.parent=c,W3(h),xg(h)}}function s(c,h,d=!1){c&&[...c].forEach(p=>o(h,p,d))}function o(c,h,d){if(h){var p,f,g;if(h.__r3f&&(h.__r3f.parent=null),(p=c.__r3f)!=null&&p.objects&&(c.__r3f.objects=c.__r3f.objects.filter(S=>S!==h)),(f=h.__r3f)!=null&&f.attach)wK(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){var y;c.remove(h),(y=h.__r3f)!=null&&y.root&&mNe(h.__r3f.root,h)}const v=(g=h.__r3f)==null?void 0:g.primitive,w=!v&&(d===void 0?h.dispose!==null:d);if(!v){var m;s((m=h.__r3f)==null?void 0:m.objects,h,w),s(h.children,h,w)}if(delete h.__r3f,w&&h.dispose&&h.type!=="Scene"){const S=()=>{try{h.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?U3.unstable_scheduleCallback(U3.unstable_IdlePriority,S):S()}xg(c)}}function a(c,h,d,p){var f;const g=(f=c.__r3f)==null?void 0:f.parent;if(!g)return;const y=t(h,d,c.__r3f.root);if(c.children){for(const m of c.children)m.__r3f&&i(y,m);c.children=c.children.filter(m=>!m.__r3f)}c.__r3f.objects.forEach(m=>i(y,m)),c.__r3f.objects=[],c.__r3f.autoRemovedBeforeAppend||o(g,c),y.parent&&(y.__r3f.autoRemovedBeforeAppend=!0),i(g,y),y.raycast&&y.__r3f.eventCount&&y.__r3f.root.getState().internal.interaction.push(y),[p,p.alternate].forEach(m=>{m!==null&&(m.stateNode=y,m.ref&&(typeof m.ref=="function"?m.ref(y):m.ref.current=y))})}const l=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:eNe({createInstance:t,removeChild:o,appendChild:i,appendInitialChild:i,insertBefore:r,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(c,h)=>{if(!h)return;const d=c.getState().scene;d.__r3f&&(d.__r3f.root=c,i(d,h))},removeChildFromContainer:(c,h)=>{h&&o(c.getState().scene,h)},insertInContainerBefore:(c,h,d)=>{if(!h||!d)return;const p=c.getState().scene;p.__r3f&&r(p,h,d)},getRootHostContext:()=>null,getChildHostContext:c=>c,finalizeInitialChildren(c){var h;return!!((h=c==null?void 0:c.__r3f)!=null?h:{}).handlers},prepareUpdate(c,h,d,p){var f;if(((f=c==null?void 0:c.__r3f)!=null?f:{}).primitive&&p.object&&p.object!==c)return[!0];{const{args:y=[],children:m,...v}=p,{args:w=[],children:S,...C}=d;if(!Array.isArray(y))throw new Error("R3F: the args prop must be an array!");if(y.some((A,I)=>A!==w[I]))return[!0];const _=Aee(c,v,C,!0);return _.changes.length?[!1,_]:null}},commitUpdate(c,[h,d],p,f,g,y){h?a(c,p,g,y):_L(c,d)},commitMount(c,h,d,p){var f;const g=(f=c.__r3f)!=null?f:{};c.raycast&&g.handlers&&g.eventCount&&c.__r3f.root.getState().internal.interaction.push(c)},getPublicInstance:c=>c,prepareForCommit:()=>null,preparePortalMount:c=>bg(c.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(c){var h;const{attach:d,parent:p}=(h=c.__r3f)!=null?h:{};d&&p&&wK(p,c,d),c.isObject3D&&(c.visible=!1),xg(c)},unhideInstance(c,h){var d;const{attach:p,parent:f}=(d=c.__r3f)!=null?d:{};p&&f&&CL(f,c,p),(c.isObject3D&&h.visible==null||h.visible)&&(c.visible=!0),xg(c)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():Xg.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&ui.fun(performance.now)?performance.now:ui.fun(Date.now)?Date.now:()=>0,scheduleTimeout:ui.fun(setTimeout)?setTimeout:void 0,cancelTimeout:ui.fun(clearTimeout)?clearTimeout:void 0}),applyProps:_L}}var yK,bK;const TL=n=>"colorSpace"in n||"outputColorSpace"in n,wee=()=>{var n;return(n=Mz.ColorManagement)!=null?n:null},See=n=>n&&n.isOrthographicCamera,aNe=n=>n&&n.hasOwnProperty("current"),Q1=typeof window<"u"&&((yK=window.document)!=null&&yK.createElement||((bK=window.navigator)==null?void 0:bK.product)==="ReactNative")?K.useLayoutEffect:K.useEffect;function Tee(n){const e=K.useRef(n);return Q1(()=>void(e.current=n),[n]),e}function lNe({set:n}){return Q1(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}class Cee extends K.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}Cee.getDerivedStateFromError=()=>({error:!0});const _ee="__default",xK=new Map,uNe=n=>n&&!!n.memoized&&!!n.changes;function Mee(n){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],t),n[1]):n}const yx=n=>{var e;return(e=n.__r3f)==null?void 0:e.root.getState()},ui={obj:n=>n===Object(n)&&!ui.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:i="reference",strict:r=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(ui.str(n)||ui.num(n))return n===e;const s=ui.obj(n);if(s&&i==="reference")return n===e;const o=ui.arr(n);if(o&&t==="reference")return n===e;if((o||s)&&n===e)return!0;let a;for(a in n)if(!(a in e))return!1;if(s&&t==="shallow"&&i==="shallow"){for(a in r?e:n)if(!ui.equ(n[a],e[a],{strict:r,objects:"reference"}))return!1}else for(a in r?e:n)if(n[a]!==e[a])return!1;if(ui.und(a)){if(o&&n.length===0&&e.length===0||s&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function cNe(n){const e={nodes:{},materials:{}};return n&&n.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material)}),e}function hNe(n){n.dispose&&n.type!=="Scene"&&n.dispose();for(const e in n)e.dispose==null||e.dispose(),delete n[e]}function bg(n,e){const t=n;return t.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},n}function $3(n,e){let t=n;if(e.includes("-")){const i=e.split("-"),r=i.pop();return t=i.reduce((s,o)=>s[o],n),{target:t,key:r}}else return{target:t,key:e}}const vK=/-\d+$/;function CL(n,e,t){if(ui.str(t)){if(vK.test(t)){const s=t.replace(vK,""),{target:o,key:a}=$3(n,s);Array.isArray(o[a])||(o[a]=[])}const{target:i,key:r}=$3(n,t);e.__r3f.previousAttach=i[r],i[r]=e}else e.__r3f.previousAttach=t(n,e)}function wK(n,e,t){var i,r;if(ui.str(t)){const{target:s,key:o}=$3(n,t),a=e.__r3f.previousAttach;a===void 0?delete s[o]:s[o]=a}else(i=e.__r3f)==null||i.previousAttach==null||i.previousAttach(n,e);(r=e.__r3f)==null||delete r.previousAttach}function Aee(n,{children:e,key:t,ref:i,...r},{children:s,key:o,ref:a,...l}={},u=!1){var c;const h=(c=n==null?void 0:n.__r3f)!=null?c:{},d=Object.entries(r),p=[];if(u){const g=Object.keys(l);for(let y=0;y<g.length;y++)r.hasOwnProperty(g[y])||d.unshift([g[y],_ee+"remove"])}d.forEach(([g,y])=>{var m;if((m=n.__r3f)!=null&&m.primitive&&g==="object"||ui.equ(y,l[g]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(g))return p.push([g,y,!0,[]]);let v=[];g.includes("-")&&(v=g.split("-")),p.push([g,y,!1,v]);for(const w in r){const S=r[w];w.startsWith(`${g}-`)&&p.push([w,S,!1,w.split("-")])}});const f={...r};return h.memoizedProps&&h.memoizedProps.args&&(f.args=h.memoizedProps.args),h.memoizedProps&&h.memoizedProps.attach&&(f.attach=h.memoizedProps.attach),{memoized:f,changes:p}}const dNe=typeof process<"u"&&!1;function _L(n,e){var t,i,r;const s=(t=n.__r3f)!=null?t:{},o=s.root,a=(i=o==null||o.getState==null?void 0:o.getState())!=null?i:{},{memoized:l,changes:u}=uNe(e)?e:Aee(n,e),c=s.eventCount;n.__r3f&&(n.__r3f.memoizedProps=l);for(let d=0;d<u.length;d++){let[p,f,g,y]=u[d];if(TL(n)){const S="srgb",C="srgb-linear";p==="encoding"?(p="colorSpace",f=f===3001?S:C):p==="outputEncoding"&&(p="outputColorSpace",f=f===3001?S:C)}let m=n,v=m[p];if(y.length&&(v=y.reduce((w,S)=>w[S],n),!(v&&v.set))){const[w,...S]=y.reverse();m=S.reverse().reduce((C,_)=>C[_],n),p=w}if(f===_ee+"remove")if(m.constructor){let w=xK.get(m.constructor);w||(w=new m.constructor,xK.set(m.constructor,w)),f=w[p]}else f=0;if(g)f?s.handlers[p]=f:delete s.handlers[p],s.eventCount=Object.keys(s.handlers).length;else if(v&&v.set&&(v.copy||v instanceof sf)){if(Array.isArray(f))v.fromArray?v.fromArray(f):v.set(...f);else if(v.copy&&f&&f.constructor&&(dNe?v.constructor.name===f.constructor.name:v.constructor===f.constructor))v.copy(f);else if(f!==void 0){const w=v instanceof lt;!w&&v.setScalar?v.setScalar(f):v instanceof sf&&f instanceof sf?v.mask=f.mask:v.set(f),!wee()&&!a.linear&&w&&v.convertSRGBToLinear()}}else if(m[p]=f,m[p]instanceof ni&&m[p].format===xo&&m[p].type===Eu){const w=m[p];TL(w)&&TL(a.gl)?w.colorSpace=a.gl.outputColorSpace:w.encoding=a.gl.outputEncoding}xg(n)}if(s.parent&&a.internal&&n.raycast&&c!==s.eventCount){const d=a.internal.interaction.indexOf(n);d>-1&&a.internal.interaction.splice(d,1),s.eventCount&&a.internal.interaction.push(n)}return!(u.length===1&&u[0][0]==="onUpdate")&&u.length&&(r=n.__r3f)!=null&&r.parent&&W3(n),n}function xg(n){var e,t;const i=(e=n.__r3f)==null||(t=e.root)==null||t.getState==null?void 0:t.getState();i&&i.internal.frames===0&&i.invalidate()}function W3(n){n.onUpdate==null||n.onUpdate(n)}function pNe(n,e){n.manual||(See(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function ZC(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function fNe(){var n;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return Xg.DefaultEventPriority;switch((n=e.event)==null?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Xg.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Xg.ContinuousEventPriority;default:return Xg.DefaultEventPriority}}function Eee(n,e,t,i){const r=t.get(e);r&&(t.delete(e),t.size===0&&(n.delete(i),r.target.releasePointerCapture(i)))}function mNe(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(i=>i!==e),t.initialHits=t.initialHits.filter(i=>i!==e),t.hovered.forEach((i,r)=>{(i.eventObject===e||i.object===e)&&t.hovered.delete(r)}),t.capturedMap.forEach((i,r)=>{Eee(t.capturedMap,e,i,r)})}function gNe(n){function e(l){const{internal:u}=n.getState(),c=l.offsetX-u.initialClick[0],h=l.offsetY-u.initialClick[1];return Math.round(Math.sqrt(c*c+h*h))}function t(l){return l.filter(u=>["Move","Over","Enter","Out","Leave"].some(c=>{var h;return(h=u.__r3f)==null?void 0:h.handlers["onPointer"+c]}))}function i(l,u){const c=n.getState(),h=new Set,d=[],p=u?u(c.internal.interaction):c.internal.interaction;for(let m=0;m<p.length;m++){const v=yx(p[m]);v&&(v.raycaster.camera=void 0)}c.previousRoot||c.events.compute==null||c.events.compute(l,c);function f(m){const v=yx(m);if(!v||!v.events.enabled||v.raycaster.camera===null)return[];if(v.raycaster.camera===void 0){var w;v.events.compute==null||v.events.compute(l,v,(w=v.previousRoot)==null?void 0:w.getState()),v.raycaster.camera===void 0&&(v.raycaster.camera=null)}return v.raycaster.camera?v.raycaster.intersectObject(m,!0):[]}let g=p.flatMap(f).sort((m,v)=>{const w=yx(m.object),S=yx(v.object);return!w||!S?m.distance-v.distance:S.events.priority-w.events.priority||m.distance-v.distance}).filter(m=>{const v=ZC(m);return h.has(v)?!1:(h.add(v),!0)});c.events.filter&&(g=c.events.filter(g,c));for(const m of g){let v=m.object;for(;v;){var y;(y=v.__r3f)!=null&&y.eventCount&&d.push({...m,eventObject:v}),v=v.parent}}if("pointerId"in l&&c.internal.capturedMap.has(l.pointerId))for(let m of c.internal.capturedMap.get(l.pointerId).values())h.has(ZC(m.intersection))||d.push(m.intersection);return d}function r(l,u,c,h){const d=n.getState();if(l.length){const p={stopped:!1};for(const f of l){const g=yx(f.object)||d,{raycaster:y,pointer:m,camera:v,internal:w}=g,S=new Y(m.x,m.y,0).unproject(v),C=k=>{var P,V;return(P=(V=w.capturedMap.get(k))==null?void 0:V.has(f.eventObject))!=null?P:!1},_=k=>{const P={intersection:f,target:u.target};w.capturedMap.has(k)?w.capturedMap.get(k).set(f.eventObject,P):w.capturedMap.set(k,new Map([[f.eventObject,P]])),u.target.setPointerCapture(k)},A=k=>{const P=w.capturedMap.get(k);P&&Eee(w.capturedMap,f.eventObject,P,k)};let I={};for(let k in u){let P=u[k];typeof P!="function"&&(I[k]=P)}let E={...f,...I,pointer:m,intersections:l,stopped:p.stopped,delta:c,unprojectedPoint:S,ray:y.ray,camera:v,stopPropagation(){const k="pointerId"in u&&w.capturedMap.get(u.pointerId);if((!k||k.has(f.eventObject))&&(E.stopped=p.stopped=!0,w.hovered.size&&Array.from(w.hovered.values()).find(P=>P.eventObject===f.eventObject))){const P=l.slice(0,l.indexOf(f));s([...P,f])}},target:{hasPointerCapture:C,setPointerCapture:_,releasePointerCapture:A},currentTarget:{hasPointerCapture:C,setPointerCapture:_,releasePointerCapture:A},nativeEvent:u};if(h(E),p.stopped===!0)break}}return l}function s(l){const{internal:u}=n.getState();for(const c of u.hovered.values())if(!l.length||!l.find(h=>h.object===c.object&&h.index===c.index&&h.instanceId===c.instanceId)){const d=c.eventObject.__r3f,p=d==null?void 0:d.handlers;if(u.hovered.delete(ZC(c)),d!=null&&d.eventCount){const f={...c,intersections:l};p.onPointerOut==null||p.onPointerOut(f),p.onPointerLeave==null||p.onPointerLeave(f)}}}function o(l,u){for(let c=0;c<u.length;c++){const h=u[c].__r3f;h==null||h.handlers.onPointerMissed==null||h.handlers.onPointerMissed(l)}}function a(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>s([]);case"onLostPointerCapture":return u=>{const{internal:c}=n.getState();"pointerId"in u&&c.capturedMap.has(u.pointerId)&&requestAnimationFrame(()=>{c.capturedMap.has(u.pointerId)&&(c.capturedMap.delete(u.pointerId),s([]))})}}return function(c){const{onPointerMissed:h,internal:d}=n.getState();d.lastEvent.current=c;const p=l==="onPointerMove",f=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",y=i(c,p?t:void 0),m=f?e(c):0;l==="onPointerDown"&&(d.initialClick=[c.offsetX,c.offsetY],d.initialHits=y.map(w=>w.eventObject)),f&&!y.length&&m<=2&&(o(c,d.interaction),h&&h(c)),p&&s(y);function v(w){const S=w.eventObject,C=S.__r3f,_=C==null?void 0:C.handlers;if(C!=null&&C.eventCount)if(p){if(_.onPointerOver||_.onPointerEnter||_.onPointerOut||_.onPointerLeave){const A=ZC(w),I=d.hovered.get(A);I?I.stopped&&w.stopPropagation():(d.hovered.set(A,w),_.onPointerOver==null||_.onPointerOver(w),_.onPointerEnter==null||_.onPointerEnter(w))}_.onPointerMove==null||_.onPointerMove(w)}else{const A=_[l];A?(!f||d.initialHits.includes(S))&&(o(c,d.interaction.filter(I=>!d.initialHits.includes(I))),A(w)):f&&d.initialHits.includes(S)&&o(c,d.interaction.filter(I=>!d.initialHits.includes(I)))}}r(y,c,m,v)}}return{handlePointer:a}}const Iee=n=>!!(n!=null&&n.render),kee=K.createContext(null),yNe=(n,e)=>{const t=JRe((a,l)=>{const u=new Y,c=new Y,h=new Y;function d(m=l().camera,v=c,w=l().size){const{width:S,height:C,top:_,left:A}=w,I=S/C;v instanceof Y?h.copy(v):h.set(...v);const E=m.getWorldPosition(u).distanceTo(h);if(See(m))return{width:S/m.zoom,height:C/m.zoom,top:_,left:A,factor:1,distance:E,aspect:I};{const k=m.fov*Math.PI/180,P=2*Math.tan(k/2)*E,V=P*(S/C);return{width:V,height:P,top:_,left:A,factor:S/V,distance:E,aspect:I}}}let p;const f=m=>a(v=>({performance:{...v.performance,current:m}})),g=new Ge;return{set:a,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(m=1)=>n(l(),m),advance:(m,v)=>e(m,v,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new vz,pointer:g,mouse:g,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const m=l();p&&clearTimeout(p),m.performance.current!==m.performance.min&&f(m.performance.min),p=setTimeout(()=>f(l().performance.max),m.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:d},setEvents:m=>a(v=>({...v,events:{...v.events,...m}})),setSize:(m,v,w,S,C)=>{const _=l().camera,A={width:m,height:v,top:S||0,left:C||0,updateStyle:w};a(I=>({size:A,viewport:{...I.viewport,...d(_,c,A)}}))},setDpr:m=>a(v=>{const w=Mee(m);return{viewport:{...v.viewport,dpr:w,initialDpr:v.viewport.initialDpr||w}}}),setFrameloop:(m="always")=>{const v=l().clock;v.stop(),v.elapsedTime=0,m!=="never"&&(v.start(),v.elapsedTime=0),a(()=>({frameloop:m}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:K.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(m,v,w)=>{const S=l().internal;return S.priority=S.priority+(v>0?1:0),S.subscribers.push({ref:m,priority:v,store:w}),S.subscribers=S.subscribers.sort((C,_)=>C.priority-_.priority),()=>{const C=l().internal;C!=null&&C.subscribers&&(C.priority=C.priority-(v>0?1:0),C.subscribers=C.subscribers.filter(_=>_.ref!==m))}}}}}),i=t.getState();let r=i.size,s=i.viewport.dpr,o=i.camera;return t.subscribe(()=>{const{camera:a,size:l,viewport:u,gl:c,set:h}=t.getState();if(l.width!==r.width||l.height!==r.height||u.dpr!==s){var d;r=l,s=u.dpr,pNe(a,l),c.setPixelRatio(u.dpr);const p=(d=l.updateStyle)!=null?d:typeof HTMLCanvasElement<"u"&&c.domElement instanceof HTMLCanvasElement;c.setSize(l.width,l.height,p)}a!==o&&(o=a,h(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(a)}})))}),t.subscribe(a=>n(a)),t};let jC,bNe=new Set,xNe=new Set,vNe=new Set;function ML(n,e){if(n.size)for(const{callback:t}of n.values())t(e)}function bx(n,e){switch(n){case"before":return ML(bNe,e);case"after":return ML(xNe,e);case"tail":return ML(vNe,e)}}let AL,EL;function IL(n,e,t){let i=e.clock.getDelta();for(e.frameloop==="never"&&typeof n=="number"&&(i=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),AL=e.internal.subscribers,jC=0;jC<AL.length;jC++)EL=AL[jC],EL.ref.current(EL.store.getState(),i,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function wNe(n){let e=!1,t,i,r;function s(l){i=requestAnimationFrame(s),e=!0,t=0,bx("before",l);for(const c of n.values()){var u;r=c.store.getState(),r.internal.active&&(r.frameloop==="always"||r.internal.frames>0)&&!((u=r.gl.xr)!=null&&u.isPresenting)&&(t+=IL(l,r))}if(bx("after",l),t===0)return bx("tail",l),e=!1,cancelAnimationFrame(i)}function o(l,u=1){var c;if(!l)return n.forEach(h=>o(h.store.getState()),u);(c=l.gl.xr)!=null&&c.isPresenting||!l.internal.active||l.frameloop==="never"||(l.internal.frames=Math.min(60,l.internal.frames+u),e||(e=!0,requestAnimationFrame(s)))}function a(l,u=!0,c,h){if(u&&bx("before",l),c)IL(l,c,h);else for(const d of n.values())IL(l,d.store.getState());u&&bx("after",l)}return{loop:s,invalidate:o,advance:a}}function Ree(){const n=K.useContext(kee);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function Zo(n=t=>t,e){return Ree()(n,e)}function Az(n,e=0){const t=Ree(),i=t.getState().internal.subscribe,r=Tee(n);return Q1(()=>i(r,e,t),[e,i,t]),null}const SK=new WeakMap;function Nee(n,e){return function(t,...i){let r=SK.get(t);return r||(r=new t,SK.set(t,r)),n&&n(r),Promise.all(i.map(s=>new Promise((o,a)=>r.load(s,l=>{l.scene&&Object.assign(l,cNe(l.scene)),o(l)},e,l=>a(new Error(`Could not load ${s}: ${l==null?void 0:l.message}`)))))).finally(()=>r.dispose==null?void 0:r.dispose())}}function q1(n,e,t,i){const r=Array.isArray(e)?e:[e],s=nNe(Nee(t,i),[n,...r],{equal:ui.equ});return Array.isArray(e)?s:s[0]}q1.preload=function(n,e,t){const i=Array.isArray(e)?e:[e];return iNe(Nee(t),[n,...i])};q1.clear=function(n,e){const t=Array.isArray(e)?e:[e];return rNe([n,...t])};const Iy=new Map,{invalidate:TK,advance:CK}=wNe(Iy),{reconciler:XM,applyProps:pg}=oNe(Iy,fNe),fg={objects:"shallow",strict:!1},SNe=(n,e)=>{const t=typeof n=="function"?n(e):n;return Iee(t)?t:new kE({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...n})};function TNe(n,e){const t=typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement;if(e){const{width:i,height:r,top:s,left:o,updateStyle:a=t}=e;return{width:i,height:r,top:s,left:o,updateStyle:a}}else if(typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:i,height:r,top:s,left:o}=n.parentElement.getBoundingClientRect();return{width:i,height:r,top:s,left:o,updateStyle:t}}else if(typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0,updateStyle:t};return{width:0,height:0,top:0,left:0}}function CNe(n){const e=Iy.get(n),t=e==null?void 0:e.fiber,i=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const r=typeof reportError=="function"?reportError:console.error,s=i||yNe(TK,CK),o=t||XM.createContainer(s,Xg.ConcurrentRoot,null,!1,null,"",r,null);e||Iy.set(n,{fiber:o,store:s});let a,l=!1,u;return{configure(c={}){let{gl:h,size:d,scene:p,events:f,onCreated:g,shadows:y=!1,linear:m=!1,flat:v=!1,legacy:w=!1,orthographic:S=!1,frameloop:C="always",dpr:_=[1,2],performance:A,raycaster:I,camera:E,onPointerMissed:k}=c,P=s.getState(),V=P.gl;P.gl||P.set({gl:V=SNe(h,n)});let U=P.raycaster;U||P.set({raycaster:U=new _z});const{params:F,...$}=I||{};if(ui.equ($,U,fg)||pg(U,{...$}),ui.equ(F,U.params,fg)||pg(U,{params:{...U.params,...F}}),!P.camera||P.camera===u&&!ui.equ(u,E,fg)){u=E;const Z=E instanceof H1,ce=Z?E:S?new Al(0,0,0,0,.1,1e3):new ci(75,0,.1,1e3);Z||(ce.position.z=5,E&&pg(ce,E),!P.camera&&!(E!=null&&E.rotation)&&ce.lookAt(0,0,0)),P.set({camera:ce}),U.camera=ce}if(!P.scene){let Z;p instanceof Ey?Z=p:(Z=new Ey,p&&pg(Z,p)),P.set({scene:bg(Z)})}if(!P.xr){var J;const Z=(ge,Ne)=>{const Fe=s.getState();Fe.frameloop!=="never"&&CK(ge,!0,Fe,Ne)},ce=()=>{const ge=s.getState();ge.gl.xr.enabled=ge.gl.xr.isPresenting,ge.gl.xr.setAnimationLoop(ge.gl.xr.isPresenting?Z:null),ge.gl.xr.isPresenting||TK(ge)},fe={connect(){const ge=s.getState().gl;ge.xr.addEventListener("sessionstart",ce),ge.xr.addEventListener("sessionend",ce)},disconnect(){const ge=s.getState().gl;ge.xr.removeEventListener("sessionstart",ce),ge.xr.removeEventListener("sessionend",ce)}};typeof((J=V.xr)==null?void 0:J.addEventListener)=="function"&&fe.connect(),P.set({xr:fe})}if(V.shadowMap){const Z=V.shadowMap.enabled,ce=V.shadowMap.type;if(V.shadowMap.enabled=!!y,ui.boo(y))V.shadowMap.type=uv;else if(ui.str(y)){var q;const fe={basic:mQ,percentage:SE,soft:uv,variance:xl};V.shadowMap.type=(q=fe[y])!=null?q:uv}else ui.obj(y)&&Object.assign(V.shadowMap,y);(Z!==V.shadowMap.enabled||ce!==V.shadowMap.type)&&(V.shadowMap.needsUpdate=!0)}const O=wee();O&&("enabled"in O?O.enabled=!w:"legacyMode"in O&&(O.legacyMode=w)),pg(V,{outputEncoding:m?3e3:3001,toneMapping:v?Au:zB}),P.legacy!==w&&P.set(()=>({legacy:w})),P.linear!==m&&P.set(()=>({linear:m})),P.flat!==v&&P.set(()=>({flat:v})),h&&!ui.fun(h)&&!Iee(h)&&!ui.equ(h,V,fg)&&pg(V,h),f&&!P.events.handlers&&P.set({events:f(s)});const z=TNe(n,d);return ui.equ(z,P.size,fg)||P.setSize(z.width,z.height,z.updateStyle,z.top,z.left),_&&P.viewport.dpr!==Mee(_)&&P.setDpr(_),P.frameloop!==C&&P.setFrameloop(C),P.onPointerMissed||P.set({onPointerMissed:k}),A&&!ui.equ(A,P.performance,fg)&&P.set(Z=>({performance:{...Z.performance,...A}})),a=g,l=!0,this},render(c){return l||this.configure(),XM.updateContainer(K.createElement(_Ne,{store:s,children:c,onCreated:a,rootElement:n}),o,null,()=>{}),s},unmount(){Lee(n)}}}function _Ne({store:n,children:e,onCreated:t,rootElement:i}){return Q1(()=>{const r=n.getState();r.set(s=>({internal:{...s.internal,active:!0}})),t&&t(r),n.getState().events.connected||r.events.connect==null||r.events.connect(i)},[]),K.createElement(kee.Provider,{value:n},e)}function Lee(n,e){const t=Iy.get(n),i=t==null?void 0:t.fiber;if(i){const r=t==null?void 0:t.store.getState();r&&(r.internal.active=!1),XM.updateContainer(null,i,null,()=>{r&&setTimeout(()=>{try{var s,o,a,l;r.events.disconnect==null||r.events.disconnect(),(s=r.gl)==null||(o=s.renderLists)==null||o.dispose==null||o.dispose(),(a=r.gl)==null||a.forceContextLoss==null||a.forceContextLoss(),(l=r.gl)!=null&&l.xr&&r.xr.disconnect(),hNe(r),Iy.delete(n),e&&e(n)}catch{}},500)})}}XM.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:K.version});function ky(){return ky=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},ky.apply(this,arguments)}function H3(n,e,t){var i,r,s,o,a;e==null&&(e=100);function l(){var c=Date.now()-o;c<e&&c>=0?i=setTimeout(l,e-c):(i=null,t||(a=n.apply(s,r),s=r=null))}var u=function(){s=this,r=arguments,o=Date.now();var c=t&&!i;return i||(i=setTimeout(l,e)),c&&(a=n.apply(s,r),s=r=null),a};return u.clear=function(){i&&(clearTimeout(i),i=null)},u.flush=function(){i&&(a=n.apply(s,r),s=r=null,clearTimeout(i),i=null)},u}H3.debounce=H3;var MNe=H3;const _K=Zy(MNe);function ANe(n){let{debounce:e,scroll:t,polyfill:i,offsetSize:r}=n===void 0?{debounce:0,scroll:!1,offsetSize:!1}:n;const s=i||(typeof window>"u"?class{}:window.ResizeObserver);if(!s)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[o,a]=K.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),l=K.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:o}),u=e?typeof e=="number"?e:e.scroll:null,c=e?typeof e=="number"?e:e.resize:null,h=K.useRef(!1);K.useEffect(()=>(h.current=!0,()=>void(h.current=!1)));const[d,p,f]=K.useMemo(()=>{const v=()=>{if(!l.current.element)return;const{left:w,top:S,width:C,height:_,bottom:A,right:I,x:E,y:k}=l.current.element.getBoundingClientRect(),P={left:w,top:S,width:C,height:_,bottom:A,right:I,x:E,y:k};l.current.element instanceof HTMLElement&&r&&(P.height=l.current.element.offsetHeight,P.width=l.current.element.offsetWidth),Object.freeze(P),h.current&&!RNe(l.current.lastBounds,P)&&a(l.current.lastBounds=P)};return[v,c?_K(v,c):v,u?_K(v,u):v]},[a,r,u,c]);function g(){l.current.scrollContainers&&(l.current.scrollContainers.forEach(v=>v.removeEventListener("scroll",f,!0)),l.current.scrollContainers=null),l.current.resizeObserver&&(l.current.resizeObserver.disconnect(),l.current.resizeObserver=null)}function y(){l.current.element&&(l.current.resizeObserver=new s(f),l.current.resizeObserver.observe(l.current.element),t&&l.current.scrollContainers&&l.current.scrollContainers.forEach(v=>v.addEventListener("scroll",f,{capture:!0,passive:!0})))}const m=v=>{!v||v===l.current.element||(g(),l.current.element=v,l.current.scrollContainers=Pee(v),y())};return INe(f,!!t),ENe(p),K.useEffect(()=>{g(),y()},[t,f,p]),K.useEffect(()=>g,[]),[m,o,d]}function ENe(n){K.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function INe(n,e){K.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function Pee(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:i,overflowY:r}=window.getComputedStyle(n);return[t,i,r].some(s=>s==="auto"||s==="scroll")&&e.push(n),[...e,...Pee(n.parentElement)]}const kNe=["x","y","top","bottom","left","right","width","height"],RNe=(n,e)=>kNe.every(t=>n[t]===e[t]);var NNe=Object.defineProperty,LNe=Object.defineProperties,PNe=Object.getOwnPropertyDescriptors,MK=Object.getOwnPropertySymbols,DNe=Object.prototype.hasOwnProperty,FNe=Object.prototype.propertyIsEnumerable,AK=(n,e,t)=>e in n?NNe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,EK=(n,e)=>{for(var t in e||(e={}))DNe.call(e,t)&&AK(n,t,e[t]);if(MK)for(var t of MK(e))FNe.call(e,t)&&AK(n,t,e[t]);return n},ONe=(n,e)=>LNe(n,PNe(e));function Dee(n,e,t){if(!n)return;if(t(n)===!0)return n;let i=e?n.return:n.child;for(;i;){const r=Dee(i,e,t);if(r)return r;i=e?null:i.sibling}}function Fee(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const Ez=Fee(K.createContext(null));class Oee extends K.Component{render(){return K.createElement(Ez.Provider,{value:this._reactInternals},this.props.children)}}const{ReactCurrentOwner:IK,ReactCurrentDispatcher:kK}=K.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function BNe(){const n=K.useContext(Ez);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=K.useId();return K.useMemo(()=>{for(const i of[IK==null?void 0:IK.current,n,n==null?void 0:n.alternate]){if(!i)continue;const r=Dee(i,!1,s=>{let o=s.memoizedState;for(;o;){if(o.memoizedState===e)return!0;o=o.next}});if(r)return r}},[n,e])}function zNe(){var n,e;const t=BNe(),[i]=K.useState(()=>new Map);i.clear();let r=t;for(;r;){const s=(n=r.type)==null?void 0:n._context;s&&s!==Ez&&!i.has(s)&&i.set(s,(e=kK==null?void 0:kK.current)==null?void 0:e.readContext(Fee(s))),r=r.return}return i}function GNe(){const n=zNe();return K.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>i=>K.createElement(e,null,K.createElement(t.Provider,ONe(EK({},i),{value:n.get(t)}))),e=>K.createElement(Oee,EK({},e))),[n])}const kL={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function VNe(n){const{handlePointer:e}=gNe(n);return{priority:1,enabled:!0,compute(t,i,r){i.pointer.set(t.offsetX/i.size.width*2-1,-(t.offsetY/i.size.height)*2+1),i.raycaster.setFromCamera(i.pointer,i.camera)},connected:void 0,handlers:Object.keys(kL).reduce((t,i)=>({...t,[i]:e(i)}),{}),update:()=>{var t;const{events:i,internal:r}=n.getState();(t=r.lastEvent)!=null&&t.current&&i.handlers&&i.handlers.onPointerMove(r.lastEvent.current)},connect:t=>{var i;const{set:r,events:s}=n.getState();s.disconnect==null||s.disconnect(),r(o=>({events:{...o.events,connected:t}})),Object.entries((i=s.handlers)!=null?i:[]).forEach(([o,a])=>{const[l,u]=kL[o];t.addEventListener(l,a,{passive:u})})},disconnect:()=>{const{set:t,events:i}=n.getState();if(i.connected){var r;Object.entries((r=i.handlers)!=null?r:[]).forEach(([s,o])=>{if(i&&i.connected instanceof HTMLElement){const[a]=kL[s];i.connected.removeEventListener(a,o)}}),t(s=>({events:{...s.events,connected:void 0}}))}}}}const UNe=K.forwardRef(function({children:e,fallback:t,resize:i,style:r,gl:s,events:o=VNe,eventSource:a,eventPrefix:l,shadows:u,linear:c,flat:h,legacy:d,orthographic:p,frameloop:f,dpr:g,performance:y,raycaster:m,camera:v,scene:w,onPointerMissed:S,onCreated:C,..._},A){K.useMemo(()=>sNe(ZRe),[]);const I=GNe(),[E,k]=ANe({scroll:!0,debounce:{scroll:50,resize:0},...i}),P=K.useRef(null),V=K.useRef(null);K.useImperativeHandle(A,()=>P.current);const U=Tee(S),[F,$]=K.useState(!1),[J,q]=K.useState(!1);if(F)throw F;if(J)throw J;const O=K.useRef(null);Q1(()=>{const j=P.current;k.width>0&&k.height>0&&j&&(O.current||(O.current=CNe(j)),O.current.configure({gl:s,events:o,shadows:u,linear:c,flat:h,legacy:d,orthographic:p,frameloop:f,dpr:g,performance:y,raycaster:m,camera:v,scene:w,size:k,onPointerMissed:(...z)=>U.current==null?void 0:U.current(...z),onCreated:z=>{z.events.connect==null||z.events.connect(a?aNe(a)?a.current:a:V.current),l&&z.setEvents({compute:(Z,ce)=>{const fe=Z[l+"X"],ge=Z[l+"Y"];ce.pointer.set(fe/ce.size.width*2-1,-(ge/ce.size.height)*2+1),ce.raycaster.setFromCamera(ce.pointer,ce.camera)}}),C==null||C(z)}}),O.current.render(K.createElement(I,null,K.createElement(Cee,{set:q},K.createElement(K.Suspense,{fallback:K.createElement(lNe,{set:$})},e)))))}),K.useEffect(()=>{const j=P.current;if(j)return()=>Lee(j)},[]);const X=a?"none":"auto";return K.createElement("div",ky({ref:V,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:X,...r}},_),K.createElement("div",{ref:E,style:{width:"100%",height:"100%"}},K.createElement("canvas",{ref:P,style:{display:"block"}},t)))}),Bee=K.forwardRef(function(e,t){return K.createElement(Oee,null,K.createElement(UNe,ky({},e,{ref:t})))});function $Ne(n){return function(e){n.forEach(function(t){typeof t=="function"?t(e):t!=null&&(t.current=e)})}}function RK(n,e){if(e===KB)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===Af||e===U1){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const i=t.count-2,r=[];if(t)if(e===Af)for(let o=1;o<=i;o++)r.push(t.getX(0)),r.push(t.getX(o)),r.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2===0?(r.push(t.getX(o)),r.push(t.getX(o+1)),r.push(t.getX(o+2))):(r.push(t.getX(o+2)),r.push(t.getX(o+1)),r.push(t.getX(o)));r.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=n.clone();return s.setIndex(r),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}const WNe=parseInt(z1.replace(/\D+/g,""));var HNe=Object.defineProperty,XNe=(n,e,t)=>e in n?HNe(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Kt=(n,e,t)=>(XNe(n,typeof e!="symbol"?e+"":e,t),t);const YC=new sm,NK=new uc,KNe=Math.cos(70*(Math.PI/180)),LK=(n,e)=>(n%e+e)%e;let ZNe=class extends Wu{constructor(e,t){super(),Kt(this,"object"),Kt(this,"domElement"),Kt(this,"enabled",!0),Kt(this,"target",new Y),Kt(this,"minDistance",0),Kt(this,"maxDistance",1/0),Kt(this,"minZoom",0),Kt(this,"maxZoom",1/0),Kt(this,"minPolarAngle",0),Kt(this,"maxPolarAngle",Math.PI),Kt(this,"minAzimuthAngle",-1/0),Kt(this,"maxAzimuthAngle",1/0),Kt(this,"enableDamping",!1),Kt(this,"dampingFactor",.05),Kt(this,"enableZoom",!0),Kt(this,"zoomSpeed",1),Kt(this,"enableRotate",!0),Kt(this,"rotateSpeed",1),Kt(this,"enablePan",!0),Kt(this,"panSpeed",1),Kt(this,"screenSpacePanning",!0),Kt(this,"keyPanSpeed",7),Kt(this,"zoomToCursor",!1),Kt(this,"autoRotate",!1),Kt(this,"autoRotateSpeed",2),Kt(this,"reverseOrbit",!1),Kt(this,"reverseHorizontalOrbit",!1),Kt(this,"reverseVerticalOrbit",!1),Kt(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),Kt(this,"mouseButtons",{LEFT:Cp.ROTATE,MIDDLE:Cp.DOLLY,RIGHT:Cp.PAN}),Kt(this,"touches",{ONE:_p.ROTATE,TWO:_p.DOLLY_PAN}),Kt(this,"target0"),Kt(this,"position0"),Kt(this,"zoom0"),Kt(this,"_domElementKeyEvents",null),Kt(this,"getPolarAngle"),Kt(this,"getAzimuthalAngle"),Kt(this,"setPolarAngle"),Kt(this,"setAzimuthalAngle"),Kt(this,"getDistance"),Kt(this,"listenToKeyEvents"),Kt(this,"stopListenToKeyEvents"),Kt(this,"saveState"),Kt(this,"reset"),Kt(this,"update"),Kt(this,"connect"),Kt(this,"dispose"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>c.phi,this.getAzimuthalAngle=()=>c.theta,this.setPolarAngle=le=>{let Oe=LK(le,2*Math.PI),je=c.phi;je<0&&(je+=2*Math.PI),Oe<0&&(Oe+=2*Math.PI);let Ke=Math.abs(Oe-je);2*Math.PI-Ke<Ke&&(Oe<je?Oe+=2*Math.PI:je+=2*Math.PI),h.phi=Oe-je,i.update()},this.setAzimuthalAngle=le=>{let Oe=LK(le,2*Math.PI),je=c.theta;je<0&&(je+=2*Math.PI),Oe<0&&(Oe+=2*Math.PI);let Ke=Math.abs(Oe-je);2*Math.PI-Ke<Ke&&(Oe<je?Oe+=2*Math.PI:je+=2*Math.PI),h.theta=Oe-je,i.update()},this.getDistance=()=>i.object.position.distanceTo(i.target),this.listenToKeyEvents=le=>{le.addEventListener("keydown",Ve),this._domElementKeyEvents=le},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Ve),this._domElementKeyEvents=null},this.saveState=()=>{i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=()=>{i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(r),i.update(),l=a.NONE},this.update=(()=>{const le=new Y,Oe=new Y(0,1,0),je=new Li().setFromUnitVectors(e.up,Oe),Ke=je.clone().invert(),Pt=new Y,G=new Li,re=2*Math.PI;return function(){const de=i.object.position;je.setFromUnitVectors(e.up,Oe),Ke.copy(je).invert(),le.copy(de).sub(i.target),le.applyQuaternion(je),c.setFromVector3(le),i.autoRotate&&l===a.NONE&&F(V()),i.enableDamping?(c.theta+=h.theta*i.dampingFactor,c.phi+=h.phi*i.dampingFactor):(c.theta+=h.theta,c.phi+=h.phi);let Te=i.minAzimuthAngle,Je=i.maxAzimuthAngle;isFinite(Te)&&isFinite(Je)&&(Te<-Math.PI?Te+=re:Te>Math.PI&&(Te-=re),Je<-Math.PI?Je+=re:Je>Math.PI&&(Je-=re),Te<=Je?c.theta=Math.max(Te,Math.min(Je,c.theta)):c.theta=c.theta>(Te+Je)/2?Math.max(Te,c.theta):Math.min(Je,c.theta)),c.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,c.phi)),c.makeSafe(),i.enableDamping===!0?i.target.addScaledVector(p,i.dampingFactor):i.target.add(p),i.zoomToCursor&&E||i.object.isOrthographicCamera?c.radius=Z(c.radius):c.radius=Z(c.radius*d),le.setFromSpherical(c),le.applyQuaternion(Ke),de.copy(i.target).add(le),i.object.lookAt(i.target),i.enableDamping===!0?(h.theta*=1-i.dampingFactor,h.phi*=1-i.dampingFactor,p.multiplyScalar(1-i.dampingFactor)):(h.set(0,0,0),p.set(0,0,0));let rt=!1;if(i.zoomToCursor&&E){let ht=null;if(i.object instanceof ci&&i.object.isPerspectiveCamera){const pt=le.length();ht=Z(pt*d);const vt=pt-ht;i.object.position.addScaledVector(A,vt),i.object.updateMatrixWorld()}else if(i.object.isOrthographicCamera){const pt=new Y(I.x,I.y,0);pt.unproject(i.object),i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/d)),i.object.updateProjectionMatrix(),rt=!0;const vt=new Y(I.x,I.y,0);vt.unproject(i.object),i.object.position.sub(vt).add(pt),i.object.updateMatrixWorld(),ht=le.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),i.zoomToCursor=!1;ht!==null&&(i.screenSpacePanning?i.target.set(0,0,-1).transformDirection(i.object.matrix).multiplyScalar(ht).add(i.object.position):(YC.origin.copy(i.object.position),YC.direction.set(0,0,-1).transformDirection(i.object.matrix),Math.abs(i.object.up.dot(YC.direction))<KNe?e.lookAt(i.target):(NK.setFromNormalAndCoplanarPoint(i.object.up,i.target),YC.intersectPlane(NK,i.target))))}else i.object instanceof Al&&i.object.isOrthographicCamera&&(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/d)),i.object.updateProjectionMatrix(),rt=!0);return d=1,E=!1,rt||Pt.distanceToSquared(i.object.position)>u||8*(1-G.dot(i.object.quaternion))>u?(i.dispatchEvent(r),Pt.copy(i.object.position),G.copy(i.object.quaternion),rt=!1,!0):!1}})(),this.connect=le=>{le===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),i.domElement=le,i.domElement.style.touchAction="none",i.domElement.addEventListener("contextmenu",at),i.domElement.addEventListener("pointerdown",Lt),i.domElement.addEventListener("pointercancel",D),i.domElement.addEventListener("wheel",Me)},this.dispose=()=>{var le,Oe,je,Ke,Pt,G;(le=i.domElement)==null||le.removeEventListener("contextmenu",at),(Oe=i.domElement)==null||Oe.removeEventListener("pointerdown",Lt),(je=i.domElement)==null||je.removeEventListener("pointercancel",D),(Ke=i.domElement)==null||Ke.removeEventListener("wheel",Me),(Pt=i.domElement)==null||Pt.ownerDocument.removeEventListener("pointermove",ye),(G=i.domElement)==null||G.ownerDocument.removeEventListener("pointerup",H),i._domElementKeyEvents!==null&&i._domElementKeyEvents.removeEventListener("keydown",Ve)};const i=this,r={type:"change"},s={type:"start"},o={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=a.NONE;const u=1e-6,c=new V3,h=new V3;let d=1;const p=new Y,f=new Ge,g=new Ge,y=new Ge,m=new Ge,v=new Ge,w=new Ge,S=new Ge,C=new Ge,_=new Ge,A=new Y,I=new Ge;let E=!1;const k=[],P={};function V(){return 2*Math.PI/60/60*i.autoRotateSpeed}function U(){return Math.pow(.95,i.zoomSpeed)}function F(le){i.reverseOrbit||i.reverseHorizontalOrbit?h.theta+=le:h.theta-=le}function $(le){i.reverseOrbit||i.reverseVerticalOrbit?h.phi+=le:h.phi-=le}const J=(()=>{const le=new Y;return function(je,Ke){le.setFromMatrixColumn(Ke,0),le.multiplyScalar(-je),p.add(le)}})(),q=(()=>{const le=new Y;return function(je,Ke){i.screenSpacePanning===!0?le.setFromMatrixColumn(Ke,1):(le.setFromMatrixColumn(Ke,0),le.crossVectors(i.object.up,le)),le.multiplyScalar(je),p.add(le)}})(),O=(()=>{const le=new Y;return function(je,Ke){const Pt=i.domElement;if(Pt&&i.object instanceof ci&&i.object.isPerspectiveCamera){const G=i.object.position;le.copy(G).sub(i.target);let re=le.length();re*=Math.tan(i.object.fov/2*Math.PI/180),J(2*je*re/Pt.clientHeight,i.object.matrix),q(2*Ke*re/Pt.clientHeight,i.object.matrix)}else Pt&&i.object instanceof Al&&i.object.isOrthographicCamera?(J(je*(i.object.right-i.object.left)/i.object.zoom/Pt.clientWidth,i.object.matrix),q(Ke*(i.object.top-i.object.bottom)/i.object.zoom/Pt.clientHeight,i.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}})();function X(le){i.object instanceof ci&&i.object.isPerspectiveCamera||i.object instanceof Al&&i.object.isOrthographicCamera?d/=le:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function j(le){i.object instanceof ci&&i.object.isPerspectiveCamera||i.object instanceof Al&&i.object.isOrthographicCamera?d*=le:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function z(le){if(!i.zoomToCursor||!i.domElement)return;E=!0;const Oe=i.domElement.getBoundingClientRect(),je=le.clientX-Oe.left,Ke=le.clientY-Oe.top,Pt=Oe.width,G=Oe.height;I.x=je/Pt*2-1,I.y=-(Ke/G)*2+1,A.set(I.x,I.y,1).unproject(i.object).sub(i.object.position).normalize()}function Z(le){return Math.max(i.minDistance,Math.min(i.maxDistance,le))}function ce(le){f.set(le.clientX,le.clientY)}function fe(le){z(le),S.set(le.clientX,le.clientY)}function ge(le){m.set(le.clientX,le.clientY)}function Ne(le){g.set(le.clientX,le.clientY),y.subVectors(g,f).multiplyScalar(i.rotateSpeed);const Oe=i.domElement;Oe&&(F(2*Math.PI*y.x/Oe.clientHeight),$(2*Math.PI*y.y/Oe.clientHeight)),f.copy(g),i.update()}function Fe(le){C.set(le.clientX,le.clientY),_.subVectors(C,S),_.y>0?X(U()):_.y<0&&j(U()),S.copy(C),i.update()}function We(le){v.set(le.clientX,le.clientY),w.subVectors(v,m).multiplyScalar(i.panSpeed),O(w.x,w.y),m.copy(v),i.update()}function Ue(le){z(le),le.deltaY<0?j(U()):le.deltaY>0&&X(U()),i.update()}function Ye(le){let Oe=!1;switch(le.code){case i.keys.UP:O(0,i.keyPanSpeed),Oe=!0;break;case i.keys.BOTTOM:O(0,-i.keyPanSpeed),Oe=!0;break;case i.keys.LEFT:O(i.keyPanSpeed,0),Oe=!0;break;case i.keys.RIGHT:O(-i.keyPanSpeed,0),Oe=!0;break}Oe&&(le.preventDefault(),i.update())}function $e(){if(k.length==1)f.set(k[0].pageX,k[0].pageY);else{const le=.5*(k[0].pageX+k[1].pageX),Oe=.5*(k[0].pageY+k[1].pageY);f.set(le,Oe)}}function ee(){if(k.length==1)m.set(k[0].pageX,k[0].pageY);else{const le=.5*(k[0].pageX+k[1].pageX),Oe=.5*(k[0].pageY+k[1].pageY);m.set(le,Oe)}}function De(){const le=k[0].pageX-k[1].pageX,Oe=k[0].pageY-k[1].pageY,je=Math.sqrt(le*le+Oe*Oe);S.set(0,je)}function _e(){i.enableZoom&&De(),i.enablePan&&ee()}function ze(){i.enableZoom&&De(),i.enableRotate&&$e()}function Re(le){if(k.length==1)g.set(le.pageX,le.pageY);else{const je=sn(le),Ke=.5*(le.pageX+je.x),Pt=.5*(le.pageY+je.y);g.set(Ke,Pt)}y.subVectors(g,f).multiplyScalar(i.rotateSpeed);const Oe=i.domElement;Oe&&(F(2*Math.PI*y.x/Oe.clientHeight),$(2*Math.PI*y.y/Oe.clientHeight)),f.copy(g)}function nt(le){if(k.length==1)v.set(le.pageX,le.pageY);else{const Oe=sn(le),je=.5*(le.pageX+Oe.x),Ke=.5*(le.pageY+Oe.y);v.set(je,Ke)}w.subVectors(v,m).multiplyScalar(i.panSpeed),O(w.x,w.y),m.copy(v)}function Ze(le){const Oe=sn(le),je=le.pageX-Oe.x,Ke=le.pageY-Oe.y,Pt=Math.sqrt(je*je+Ke*Ke);C.set(0,Pt),_.set(0,Math.pow(C.y/S.y,i.zoomSpeed)),X(_.y),S.copy(C)}function st(le){i.enableZoom&&Ze(le),i.enablePan&&nt(le)}function yt(le){i.enableZoom&&Ze(le),i.enableRotate&&Re(le)}function Lt(le){var Oe,je;i.enabled!==!1&&(k.length===0&&((Oe=i.domElement)==null||Oe.ownerDocument.addEventListener("pointermove",ye),(je=i.domElement)==null||je.ownerDocument.addEventListener("pointerup",H)),Ot(le),le.pointerType==="touch"?ct(le):oe(le))}function ye(le){i.enabled!==!1&&(le.pointerType==="touch"?qe(le):Ie(le))}function H(le){var Oe,je,Ke;Xt(le),k.length===0&&((Oe=i.domElement)==null||Oe.releasePointerCapture(le.pointerId),(je=i.domElement)==null||je.ownerDocument.removeEventListener("pointermove",ye),(Ke=i.domElement)==null||Ke.ownerDocument.removeEventListener("pointerup",H)),i.dispatchEvent(o),l=a.NONE}function D(le){Xt(le)}function oe(le){let Oe;switch(le.button){case 0:Oe=i.mouseButtons.LEFT;break;case 1:Oe=i.mouseButtons.MIDDLE;break;case 2:Oe=i.mouseButtons.RIGHT;break;default:Oe=-1}switch(Oe){case Cp.DOLLY:if(i.enableZoom===!1)return;fe(le),l=a.DOLLY;break;case Cp.ROTATE:if(le.ctrlKey||le.metaKey||le.shiftKey){if(i.enablePan===!1)return;ge(le),l=a.PAN}else{if(i.enableRotate===!1)return;ce(le),l=a.ROTATE}break;case Cp.PAN:if(le.ctrlKey||le.metaKey||le.shiftKey){if(i.enableRotate===!1)return;ce(le),l=a.ROTATE}else{if(i.enablePan===!1)return;ge(le),l=a.PAN}break;default:l=a.NONE}l!==a.NONE&&i.dispatchEvent(s)}function Ie(le){if(i.enabled!==!1)switch(l){case a.ROTATE:if(i.enableRotate===!1)return;Ne(le);break;case a.DOLLY:if(i.enableZoom===!1)return;Fe(le);break;case a.PAN:if(i.enablePan===!1)return;We(le);break}}function Me(le){i.enabled===!1||i.enableZoom===!1||l!==a.NONE&&l!==a.ROTATE||(le.preventDefault(),i.dispatchEvent(s),Ue(le),i.dispatchEvent(o))}function Ve(le){i.enabled===!1||i.enablePan===!1||Ye(le)}function ct(le){switch(Qe(le),k.length){case 1:switch(i.touches.ONE){case _p.ROTATE:if(i.enableRotate===!1)return;$e(),l=a.TOUCH_ROTATE;break;case _p.PAN:if(i.enablePan===!1)return;ee(),l=a.TOUCH_PAN;break;default:l=a.NONE}break;case 2:switch(i.touches.TWO){case _p.DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;_e(),l=a.TOUCH_DOLLY_PAN;break;case _p.DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;ze(),l=a.TOUCH_DOLLY_ROTATE;break;default:l=a.NONE}break;default:l=a.NONE}l!==a.NONE&&i.dispatchEvent(s)}function qe(le){switch(Qe(le),l){case a.TOUCH_ROTATE:if(i.enableRotate===!1)return;Re(le),i.update();break;case a.TOUCH_PAN:if(i.enablePan===!1)return;nt(le),i.update();break;case a.TOUCH_DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;st(le),i.update();break;case a.TOUCH_DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;yt(le),i.update();break;default:l=a.NONE}}function at(le){i.enabled!==!1&&le.preventDefault()}function Ot(le){k.push(le)}function Xt(le){delete P[le.pointerId];for(let Oe=0;Oe<k.length;Oe++)if(k[Oe].pointerId==le.pointerId){k.splice(Oe,1);return}}function Qe(le){let Oe=P[le.pointerId];Oe===void 0&&(Oe=new Ge,P[le.pointerId]=Oe),Oe.set(le.pageX,le.pageY)}function sn(le){const Oe=le.pointerId===k[0].pointerId?k[1]:k[0];return P[Oe.pointerId]}t!==void 0&&this.connect(t),this.update()}},Iz=class extends fs{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new qNe(t)}),this.register(function(t){return new aLe(t)}),this.register(function(t){return new lLe(t)}),this.register(function(t){return new uLe(t)}),this.register(function(t){return new tLe(t)}),this.register(function(t){return new nLe(t)}),this.register(function(t){return new iLe(t)}),this.register(function(t){return new rLe(t)}),this.register(function(t){return new QNe(t)}),this.register(function(t){return new sLe(t)}),this.register(function(t){return new eLe(t)}),this.register(function(t){return new oLe(t)}),this.register(function(t){return new YNe(t)}),this.register(function(t){return new cLe(t)}),this.register(function(t){return new hLe(t)})}load(e,t,i,r){const s=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=oa.extractUrlBase(e),this.manager.itemStart(e);const a=function(u){r?r(u):console.error(u),s.manager.itemError(e),s.manager.itemEnd(e)},l=new Qs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{s.parse(u,o,function(c){t(c),s.manager.itemEnd(e)},a)}catch(c){a(c)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,r){let s;const o={},a={};if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(oa.decodeText(new Uint8Array(e.slice(0,4)))===zee){try{o[_n.KHR_BINARY_GLTF]=new dLe(e)}catch(c){r&&r(c);return}s=JSON.parse(o[_n.KHR_BINARY_GLTF].content)}else s=JSON.parse(oa.decodeText(new Uint8Array(e)));else s=e;if(s.asset===void 0||s.asset.version[0]<2){r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new _Le(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const c=this.pluginCallbacks[u](l);a[c.name]=c,o[c.name]=!0}if(s.extensionsUsed)for(let u=0;u<s.extensionsUsed.length;++u){const c=s.extensionsUsed[u],h=s.extensionsRequired||[];switch(c){case _n.KHR_MATERIALS_UNLIT:o[c]=new JNe;break;case _n.KHR_DRACO_MESH_COMPRESSION:o[c]=new pLe(s,this.dracoLoader);break;case _n.KHR_TEXTURE_TRANSFORM:o[c]=new fLe;break;case _n.KHR_MESH_QUANTIZATION:o[c]=new mLe;break;default:h.indexOf(c)>=0&&a[c]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+c+'".')}}l.setExtensions(o),l.setPlugins(a),l.parse(i,r)}parseAsync(e,t){const i=this;return new Promise(function(r,s){i.parse(e,t,r,s)})}};function jNe(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const _n={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};let YNe=class{constructor(e){this.parser=e,this.name=_n.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,r=t.length;i<r;i++){const s=t[i];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let r=t.cache.get(i);if(r)return r;const s=t.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let u;const c=new lt(16777215);l.color!==void 0&&c.fromArray(l.color);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new e2(c),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new qE(c),u.distance=h;break;case"spot":u=new QE(c),u.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,kh(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=t.createUniqueName(l.name||"light_"+e),r=Promise.resolve(u),t.cache.add(i,r),r}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,s=i.json.nodes[e],a=(s.extensions&&s.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return i._getNodeRef(t.cache,a,l)})}},JNe=class{constructor(){this.name=_n.KHR_MATERIALS_UNLIT}getMaterialType(){return dr}extendParams(e,t,i){const r=[];e.color=new lt(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}s.baseColorTexture!==void 0&&r.push(i.assignTexture(e,"map",s.baseColorTexture,3001))}return Promise.all(r)}},QNe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}},qNe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Ge(a,a)}return Promise.all(s)}},eLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}},tLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_SHEEN}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new lt(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=r.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,3001)),o.sheenRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}},nLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}},iLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_VOLUME}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new lt(a[0],a[1],a[2]),Promise.all(s)}},rLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_IOR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}},sLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_SPECULAR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new lt(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&s.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,3001)),Promise.all(s)}},oLe=class{constructor(e){this.parser=e,this.name=_n.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(i.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}},aLe=class{constructor(e){this.parser=e,this.name=_n.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,r=i.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const s=r.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}},lLe=class{constructor(e){this.parser=e,this.name=_n.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const u=i.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}},uLe=class{constructor(e){this.parser=e,this.name=_n.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const u=i.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}},cLe=class{constructor(e){this.name=_n.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const r=i.extensions[this.name],s=this.parser.getDependency("buffer",r.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(a){const l=r.byteOffset||0,u=r.byteLength||0,c=r.count,h=r.byteStride,d=new Uint8Array(a,l,u);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(c,h,d,r.mode,r.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(c*h);return o.decodeGltfBuffer(new Uint8Array(p),c,h,d,r.mode,r.filter),p})})}else return null}},hLe=class{constructor(e){this.name=_n.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const r=t.meshes[i.mesh];for(const u of r.primitives)if(u.mode!==Oa.TRIANGLES&&u.mode!==Oa.TRIANGLE_STRIP&&u.mode!==Oa.TRIANGLE_FAN&&u.mode!==void 0)return null;const o=i.extensions[this.name].attributes,a=[],l={};for(const u in o)a.push(this.parser.getDependency("accessor",o[u]).then(c=>(l[u]=c,l[u])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(u=>{const c=u.pop(),h=c.isGroup?c.children:[c],d=u[0].count,p=[];for(const f of h){const g=new Ft,y=new Y,m=new Li,v=new Y(1,1,1),w=new PE(f.geometry,f.material,d);for(let S=0;S<d;S++)l.TRANSLATION&&y.fromBufferAttribute(l.TRANSLATION,S),l.ROTATION&&m.fromBufferAttribute(l.ROTATION,S),l.SCALE&&v.fromBufferAttribute(l.SCALE,S),w.setMatrixAt(S,g.compose(y,m,v));for(const S in l)S!=="TRANSLATION"&&S!=="ROTATION"&&S!=="SCALE"&&f.geometry.setAttribute(S,l[S]);yn.prototype.copy.call(w,f),this.parser.assignFinalMaterial(w),p.push(w)}return c.isGroup?(c.clear(),c.add(...p),c):p[0]}))}};const zee="glTF",xx=12,PK={JSON:1313821514,BIN:5130562};let dLe=class{constructor(e){this.name=_n.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,xx);if(this.header={magic:oa.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==zee)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-xx,r=new DataView(e,xx);let s=0;for(;s<i;){const o=r.getUint32(s,!0);s+=4;const a=r.getUint32(s,!0);if(s+=4,a===PK.JSON){const l=new Uint8Array(e,xx+s,o);this.content=oa.decodeText(l)}else if(a===PK.BIN){const l=xx+s;this.body=e.slice(l,l+o)}s+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}},pLe=class{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=_n.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,r=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},u={};for(const c in o){const h=X3[c]||c.toLowerCase();a[h]=o[c]}for(const c in e.attributes){const h=X3[c]||c.toLowerCase();if(o[c]!==void 0){const d=i.accessors[e.attributes[c]],p=oy[d.componentType];u[h]=p.name,l[h]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(c){return new Promise(function(h){r.decodeDracoFile(c,function(d){for(const p in d.attributes){const f=d.attributes[p],g=l[p];g!==void 0&&(f.normalized=g)}h(d)},a,u)})})}},fLe=class{constructor(){this.name=_n.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}},mLe=class{constructor(){this.name=_n.KHR_MESH_QUANTIZATION}},Gee=class extends lm{constructor(e,t,i,r){super(e,t,i,r)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r*3+r;for(let o=0;o!==r;o++)t[o]=i[s+o];return t}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,u=a*3,c=r-t,h=(i-t)/c,d=h*h,p=d*h,f=e*u,g=f-u,y=-2*p+3*d,m=p-d,v=1-y,w=m-d+h;for(let S=0;S!==a;S++){const C=o[g+S+a],_=o[g+S+l]*c,A=o[f+S+a],I=o[f+S]*c;s[S]=v*C+w*_+y*A+m*I}return s}};const gLe=new Li;let yLe=class extends Gee{interpolate_(e,t,i,r){const s=super.interpolate_(e,t,i,r);return gLe.fromArray(s).normalize().toArray(s),s}};const Oa={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},oy={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},DK={9728:Ei,9729:Zn,9984:_y,9985:V1,9986:nf,9987:qa},FK={33071:$r,33648:Tf,10497:Ul},RL={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},X3={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...WNe>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},wh={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},bLe={CUBICSPLINE:void 0,LINEAR:Fc,STEP:Mf},NL={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function xLe(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new am({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Vl})),n.DefaultMaterial}function dp(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}function kh(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function vLe(n,e,t){let i=!1,r=!1,s=!1;for(let u=0,c=e.length;u<c;u++){const h=e[u];if(h.POSITION!==void 0&&(i=!0),h.NORMAL!==void 0&&(r=!0),h.COLOR_0!==void 0&&(s=!0),i&&r&&s)break}if(!i&&!r&&!s)return Promise.resolve(n);const o=[],a=[],l=[];for(let u=0,c=e.length;u<c;u++){const h=e[u];if(i){const d=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):n.attributes.position;o.push(d)}if(r){const d=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):n.attributes.normal;a.push(d)}if(s){const d=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):n.attributes.color;l.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(u){const c=u[0],h=u[1],d=u[2];return i&&(n.morphAttributes.position=c),r&&(n.morphAttributes.normal=h),s&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}function wLe(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,r=t.length;i<r;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function SLe(n){let e;const t=n.extensions&&n.extensions[_n.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+LL(t.attributes):e=n.indices+":"+LL(n.attributes)+":"+n.mode,n.targets!==void 0)for(let i=0,r=n.targets.length;i<r;i++)e+=":"+LL(n.targets[i]);return e}function LL(n){let e="";const t=Object.keys(n).sort();for(let i=0,r=t.length;i<r;i++)e+=t[i]+":"+n[t[i]]+";";return e}function K3(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function TLe(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const CLe=new Ft;let _Le=class{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new jNe,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,r=!1,s=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,r=navigator.userAgent.indexOf("Firefox")>-1,s=r?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||i||r&&s<98?this.textureLoader=new mz(this.options.manager):this.textureLoader=new bz(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Qs(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,r=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const a={scene:o[0][r.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:r.asset,parser:i,userData:{}};dp(s,a,r),kh(a,r),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let r=0,s=t.length;r<s;r++){const o=t[r].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let r=0,s=e.length;r<s;r++){const o=e[r];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const r=i.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[u,c]of o.children.entries())s(c,a.children[u])};return s(i,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let r=0;r<t.length;r++){const s=e(t[r]);s&&i.push(s)}return i}getDependency(e,t){const i=e+":"+t;let r=this.cache.get(i);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":r=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":r=this.loadCamera(t);break;default:if(r=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!r)throw new Error("Unknown type: "+e);break}this.cache.add(i,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(s,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[_n.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(s,o){i.load(oa.resolveURL(t.uri,r.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const r=t.byteLength||0,s=t.byteOffset||0;return i.slice(s,s+r)})}loadAccessor(e){const t=this,i=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0){const o=RL[r.type],a=oy[r.componentType],l=r.normalized===!0,u=new a(r.count*o);return Promise.resolve(new En(u,o,l))}const s=[];return r.bufferView!==void 0?s.push(this.getDependency("bufferView",r.bufferView)):s.push(null),r.sparse!==void 0&&(s.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=RL[r.type],u=oy[r.componentType],c=u.BYTES_PER_ELEMENT,h=c*l,d=r.byteOffset||0,p=r.bufferView!==void 0?i.bufferViews[r.bufferView].byteStride:void 0,f=r.normalized===!0;let g,y;if(p&&p!==h){const m=Math.floor(d/p),v="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+m+":"+r.count;let w=t.cache.get(v);w||(g=new u(a,m*p,r.count*p/c),w=new n0(g,p/c),t.cache.add(v,w)),y=new Oc(w,l,d%p/c,f)}else a===null?g=new u(r.count*l):g=new u(a,d,r.count*l),y=new En(g,l,f);if(r.sparse!==void 0){const m=RL.SCALAR,v=oy[r.sparse.indices.componentType],w=r.sparse.indices.byteOffset||0,S=r.sparse.values.byteOffset||0,C=new v(o[1],w,r.sparse.count*m),_=new u(o[2],S,r.sparse.count*l);a!==null&&(y=new En(y.array.slice(),y.itemSize,y.normalized));for(let A=0,I=C.length;A<I;A++){const E=C[A];if(y.setX(E,_[A*l]),l>=2&&y.setY(E,_[A*l+1]),l>=3&&y.setZ(E,_[A*l+2]),l>=4&&y.setW(E,_[A*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return y})}loadTexture(e){const t=this.json,i=this.options,s=t.textures[e].source,o=t.images[s];let a=this.textureLoader;if(o.uri){const l=i.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,t,i){const r=this,s=this.json,o=s.textures[e],a=s.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(t,i).then(function(c){c.flipY=!1,c.name=o.name||a.name||"",c.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(c.name=a.uri);const d=(s.samplers||{})[o.sampler]||{};return c.magFilter=DK[d.magFilter]||Zn,c.minFilter=DK[d.minFilter]||qa,c.wrapS=FK[d.wrapS]||Ul,c.wrapT=FK[d.wrapT]||Ul,r.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,t){const i=this,r=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const o=r.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",u=!1;if(o.bufferView!==void 0)l=i.getDependency("bufferView",o.bufferView).then(function(h){u=!0;const d=new Blob([h],{type:o.mimeType});return l=a.createObjectURL(d),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(h){return new Promise(function(d,p){let f=d;t.isImageBitmapLoader===!0&&(f=function(g){const y=new ni(g);y.needsUpdate=!0,d(y)}),t.load(oa.resolveURL(h,s.path),f,void 0,p)})}).then(function(h){return u===!0&&a.revokeObjectURL(l),h.userData.mimeType=o.mimeType||TLe(o.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),h});return this.sourceCache[e]=c,c}assignTexture(e,t,i,r){const s=this;return this.getDependency("texture",i.index).then(function(o){if(!o)return null;if(i.texCoord!==void 0&&i.texCoord>0&&(o=o.clone(),o.channel=i.texCoord),s.extensions[_n.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[_n.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[_n.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return r!==void 0&&("colorSpace"in o?o.colorSpace=r===3001?"srgb":"srgb-linear":o.encoding=r),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const r=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Z1,Pi.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(a,l)),i=l}else if(e.isLine){const a="LineBasicMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new ps,Pi.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,this.cache.add(a,l)),i=l}if(r||s||o){let a="ClonedMaterial:"+i.uuid+":";r&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=i.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),r&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(i))),i=l}e.material=i}getMaterialType(){return am}loadMaterial(e){const t=this,i=this.json,r=this.extensions,s=i.materials[e];let o;const a={},l=s.extensions||{},u=[];if(l[_n.KHR_MATERIALS_UNLIT]){const h=r[_n.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),u.push(h.extendParams(a,s,t))}else{const h=s.pbrMetallicRoughness||{};if(a.color=new lt(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}h.baseColorTexture!==void 0&&u.push(t.assignTexture(a,"map",h.baseColorTexture,3001)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),u.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=$a);const c=s.alphaMode||NL.OPAQUE;if(c===NL.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,c===NL.MASK&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==dr&&(u.push(t.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new Ge(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;a.normalScale.set(h,h)}return s.occlusionTexture!==void 0&&o!==dr&&(u.push(t.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==dr&&(a.emissive=new lt().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&o!==dr&&u.push(t.assignTexture(a,"emissiveMap",s.emissiveTexture,3001)),Promise.all(u).then(function(){const h=new o(a);return s.name&&(h.name=s.name),kh(h,s),t.associations.set(h,{materials:e}),s.extensions&&dp(r,h,s),h})}createUniqueName(e){const t=Cn.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,r=this.primitiveCache;function s(a){return i[_n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return OK(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const u=e[a],c=SLe(u),h=r[c];if(h)o.push(h.promise);else{let d;u.extensions&&u.extensions[_n.KHR_DRACO_MESH_COMPRESSION]?d=s(u):d=OK(new rn,u,t),r[c]={primitive:u,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,r=this.extensions,s=i.meshes[e],o=s.primitives,a=[];for(let l=0,u=o.length;l<u;l++){const c=o[l].material===void 0?xLe(this.cache):this.getDependency("material",o[l].material);a.push(c)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const u=l.slice(0,l.length-1),c=l[l.length-1],h=[];for(let p=0,f=c.length;p<f;p++){const g=c[p],y=o[p];let m;const v=u[p];if(y.mode===Oa.TRIANGLES||y.mode===Oa.TRIANGLE_STRIP||y.mode===Oa.TRIANGLE_FAN||y.mode===void 0)m=s.isSkinnedMesh===!0?new LE(g,v):new pr(g,v),m.isSkinnedMesh===!0&&m.normalizeSkinWeights(),y.mode===Oa.TRIANGLE_STRIP?m.geometry=RK(m.geometry,U1):y.mode===Oa.TRIANGLE_FAN&&(m.geometry=RK(m.geometry,Af));else if(y.mode===Oa.LINES)m=new il(g,v);else if(y.mode===Oa.LINE_STRIP)m=new Fu(g,v);else if(y.mode===Oa.LINE_LOOP)m=new DE(g,v);else if(y.mode===Oa.POINTS)m=new FE(g,v);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(m.geometry.morphAttributes).length>0&&wLe(m,s),m.name=t.createUniqueName(s.name||"mesh_"+e),kh(m,s),y.extensions&&dp(r,m,y),t.assignFinalMaterial(m),h.push(m)}for(let p=0,f=h.length;p<f;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return s.extensions&&dp(r,h[0],s),h[0];const d=new Ks;s.extensions&&dp(r,d,s),t.associations.set(d,{meshes:e});for(let p=0,f=h.length;p<f;p++)d.add(h[p]);return d})}loadCamera(e){let t;const i=this.json.cameras[e],r=i[i.type];if(!r){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?t=new ci(Wp.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):i.type==="orthographic"&&(t=new Al(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),kh(t,i),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],i=[];for(let r=0,s=t.joints.length;r<s;r++)i.push(this._loadNodeShallow(t.joints[r]));return t.inverseBindMatrices!==void 0?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(r){const s=r.pop(),o=r,a=[],l=[];for(let u=0,c=o.length;u<c;u++){const h=o[u];if(h){a.push(h);const d=new Ft;s!==null&&d.fromArray(s.array,u*16),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new i0(a,l)})}loadAnimation(e){const i=this.json.animations[e],r=i.name?i.name:"animation_"+e,s=[],o=[],a=[],l=[],u=[];for(let c=0,h=i.channels.length;c<h;c++){const d=i.channels[c],p=i.samplers[d.sampler],f=d.target,g=f.node,y=i.parameters!==void 0?i.parameters[p.input]:p.input,m=i.parameters!==void 0?i.parameters[p.output]:p.output;f.node!==void 0&&(s.push(this.getDependency("node",g)),o.push(this.getDependency("accessor",y)),a.push(this.getDependency("accessor",m)),l.push(p),u.push(f))}return Promise.all([Promise.all(s),Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(u)]).then(function(c){const h=c[0],d=c[1],p=c[2],f=c[3],g=c[4],y=[];for(let m=0,v=h.length;m<v;m++){const w=h[m],S=d[m],C=p[m],_=f[m],A=g[m];if(w===void 0)continue;w.updateMatrix();let I;switch(wh[A.path]){case wh.weights:I=gd;break;case wh.rotation:I=Ou;break;case wh.position:case wh.scale:default:I=yd;break}const E=w.name?w.name:w.uuid,k=_.interpolation!==void 0?bLe[_.interpolation]:Fc,P=[];wh[A.path]===wh.weights?w.traverse(function(U){U.morphTargetInfluences&&P.push(U.name?U.name:U.uuid)}):P.push(E);let V=C.array;if(C.normalized){const U=K3(V.constructor),F=new Float32Array(V.length);for(let $=0,J=V.length;$<J;$++)F[$]=V[$]*U;V=F}for(let U=0,F=P.length;U<F;U++){const $=new I(P[U]+"."+wh[A.path],S.array,V,k);_.interpolation==="CUBICSPLINE"&&($.createInterpolant=function(q){const O=this instanceof Ou?yLe:Gee;return new O(this.times,this.values,this.getValueSize()/3,q)},$.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),y.push($)}}return new kf(r,void 0,y)})}createNodeMesh(e){const t=this.json,i=this,r=t.nodes[e];return r.mesh===void 0?null:i.getDependency("mesh",r.mesh).then(function(s){const o=i._getNodeRef(i.meshCache,r.mesh,s);return r.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,u=r.weights.length;l<u;l++)a.morphTargetInfluences[l]=r.weights[l]}),o})}loadNode(e){const t=this.json,i=this,r=t.nodes[e],s=i._loadNodeShallow(e),o=[],a=r.children||[];for(let u=0,c=a.length;u<c;u++)o.push(i.getDependency("node",a[u]));const l=r.skin===void 0?Promise.resolve(null):i.getDependency("skin",r.skin);return Promise.all([s,Promise.all(o),l]).then(function(u){const c=u[0],h=u[1],d=u[2];d!==null&&c.traverse(function(p){p.isSkinnedMesh&&p.bind(d,CLe)});for(let p=0,f=h.length;p<f;p++)c.add(h[p]);return c})}_loadNodeShallow(e){const t=this.json,i=this.extensions,r=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],o=s.name?r.createUniqueName(s.name):"",a=[],l=r._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(r.getDependency("camera",s.camera).then(function(u){return r._getNodeRef(r.cameraCache,s.camera,u)})),r._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){a.push(u)}),this.nodeCache[e]=Promise.all(a).then(function(u){let c;if(s.isBone===!0?c=new K1:u.length>1?c=new Ks:u.length===1?c=u[0]:c=new yn,c!==u[0])for(let h=0,d=u.length;h<d;h++)c.add(u[h]);if(s.name&&(c.userData.name=s.name,c.name=o),kh(c,s),s.extensions&&dp(i,c,s),s.matrix!==void 0){const h=new Ft;h.fromArray(s.matrix),c.applyMatrix4(h)}else s.translation!==void 0&&c.position.fromArray(s.translation),s.rotation!==void 0&&c.quaternion.fromArray(s.rotation),s.scale!==void 0&&c.scale.fromArray(s.scale);return r.associations.has(c)||r.associations.set(c,{}),r.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],r=this,s=new Ks;i.name&&(s.name=r.createUniqueName(i.name)),kh(s,i),i.extensions&&dp(t,s,i);const o=i.nodes||[],a=[];for(let l=0,u=o.length;l<u;l++)a.push(r.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let c=0,h=l.length;c<h;c++)s.add(l[c]);const u=c=>{const h=new Map;for(const[d,p]of r.associations)(d instanceof Pi||d instanceof ni)&&h.set(d,p);return c.traverse(d=>{const p=r.associations.get(d);p!=null&&h.set(d,p)}),h};return r.associations=u(s),s})}};function MLe(n,e,t){const i=e.attributes,r=new nl;if(i.POSITION!==void 0){const a=t.json.accessors[i.POSITION],l=a.min,u=a.max;if(l!==void 0&&u!==void 0){if(r.set(new Y(l[0],l[1],l[2]),new Y(u[0],u[1],u[2])),a.normalized){const c=K3(oy[a.componentType]);r.min.multiplyScalar(c),r.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const a=new Y,l=new Y;for(let u=0,c=s.length;u<c;u++){const h=s[u];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const g=K3(oy[d.componentType]);l.multiplyScalar(g)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(a)}n.boundingBox=r;const o=new ya;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,n.boundingSphere=o}function OK(n,e,t){const i=e.attributes,r=[];function s(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in i){const a=X3[o]||o.toLowerCase();a in n.attributes||r.push(s(i[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});r.push(o)}return kh(n,e),MLe(n,e,t),Promise.all(r).then(function(){return e.targets!==void 0?vLe(n,e.targets,t):n})}const PL=new WeakMap;class ALe extends fs{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,i,r){const s=new Qs(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,o=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(o,a).then(t).catch(r)},i,r)}decodeDracoFile(e,t,i,r){const s={attributeIDs:i||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!i};this.decodeGeometry(e,s).then(t)}decodeGeometry(e,t){for(const l in t.attributeTypes){const u=t.attributeTypes[l];u.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[l]=u.name)}const i=JSON.stringify(t);if(PL.has(e)){const l=PL.get(e);if(l.key===i)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const s=this.workerNextTaskID++,o=e.byteLength,a=this._getWorker(s,o).then(l=>(r=l,new Promise((u,c)=>{r._callbacks[s]={resolve:u,reject:c},r.postMessage({type:"decode",id:s,taskConfig:t,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return a.catch(()=>!0).then(()=>{r&&s&&this._releaseTask(r,s)}),PL.set(e,{key:i,promise:a}),a}_createGeometry(e){const t=new rn;e.index&&t.setIndex(new En(e.index.array,1));for(let i=0;i<e.attributes.length;i++){const r=e.attributes[i],s=r.name,o=r.array,a=r.itemSize;t.setAttribute(s,new En(o,a))}return t}_loadLibrary(e,t){const i=new Qs(this.manager);return i.setPath(this.decoderPath),i.setResponseType(t),i.setWithCredentials(this.withCredentials),new Promise((r,s)=>{i.load(e,r,void 0,s)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(i=>{const r=i[0];e||(this.decoderConfig.wasmBinary=i[1]);const s=ELe.toString(),o=["/* draco decoder */",r,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([o]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const r=new Worker(this.workerSourceURL);r._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(s){const o=s.data;switch(o.type){case"decode":r._callbacks[o.id].resolve(o);break;case"error":r._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(r)}else this.workerPool.sort(function(r,s){return r._taskLoad>s._taskLoad?-1:1});const i=this.workerPool[this.workerPool.length-1];return i._taskCosts[e]=t,i._taskLoad+=t,i})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function ELe(){let n,e;onmessage=function(o){const a=o.data;switch(a.type){case"init":n=a.decoderConfig,e=new Promise(function(c){n.onModuleLoaded=function(h){c({draco:h})},DracoDecoderModule(n)});break;case"decode":const l=a.buffer,u=a.taskConfig;e.then(c=>{const h=c.draco,d=new h.Decoder,p=new h.DecoderBuffer;p.Init(new Int8Array(l),l.byteLength);try{const f=t(h,d,p,u),g=f.attributes.map(y=>y.array.buffer);f.index&&g.push(f.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:f},g)}catch(f){console.error(f),self.postMessage({type:"error",id:a.id,error:f.message})}finally{h.destroy(p),h.destroy(d)}});break}};function t(o,a,l,u){const c=u.attributeIDs,h=u.attributeTypes;let d,p;const f=a.GetEncodedGeometryType(l);if(f===o.TRIANGULAR_MESH)d=new o.Mesh,p=a.DecodeBufferToMesh(l,d);else if(f===o.POINT_CLOUD)d=new o.PointCloud,p=a.DecodeBufferToPointCloud(l,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const g={index:null,attributes:[]};for(const y in c){const m=self[h[y]];let v,w;if(u.useUniqueIDs)w=c[y],v=a.GetAttributeByUniqueId(d,w);else{if(w=a.GetAttributeId(d,o[c[y]]),w===-1)continue;v=a.GetAttribute(d,w)}g.attributes.push(r(o,a,d,y,m,v))}return f===o.TRIANGULAR_MESH&&(g.index=i(o,a,d)),o.destroy(d),g}function i(o,a,l){const c=l.num_faces()*3,h=c*4,d=o._malloc(h);a.GetTrianglesUInt32Array(l,h,d);const p=new Uint32Array(o.HEAPF32.buffer,d,c).slice();return o._free(d),{array:p,itemSize:1}}function r(o,a,l,u,c,h){const d=h.num_components(),f=l.num_points()*d,g=f*c.BYTES_PER_ELEMENT,y=s(o,c),m=o._malloc(g);a.GetAttributeDataArrayForAllPoints(l,h,y,g,m);const v=new c(o.HEAPF32.buffer,m,f).slice();return o._free(m),{name:u,array:v,itemSize:d}}function s(o,a){switch(a){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}}let JC;const DL=()=>{if(JC)return JC;const n="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),i=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let r=n;WebAssembly.validate(t)&&(r=e);let s;const o=WebAssembly.instantiate(a(r),{}).then(h=>{s=h.instance,s.exports.__wasm_call_ctors()});function a(h){const d=new Uint8Array(h.length);for(let f=0;f<h.length;++f){const g=h.charCodeAt(f);d[f]=g>96?g-71:g>64?g-65:g>47?g+4:g>46?63:62}let p=0;for(let f=0;f<h.length;++f)d[p++]=d[f]<60?i[d[f]]:(d[f]-60)*64+d[++f];return d.buffer.slice(0,p)}function l(h,d,p,f,g,y){const m=s.exports.sbrk,v=p+3&-4,w=m(v*f),S=m(g.length),C=new Uint8Array(s.exports.memory.buffer);C.set(g,S);const _=h(w,p,f,S,g.length);if(_===0&&y&&y(w,v,f),d.set(C.subarray(w,w+p*f)),m(w-m(0)),_!==0)throw new Error(`Malformed buffer data: ${_}`)}const u={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},c={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return JC={ready:o,supported:!0,decodeVertexBuffer(h,d,p,f,g){l(s.exports.meshopt_decodeVertexBuffer,h,d,p,f,s.exports[u[g]])},decodeIndexBuffer(h,d,p,f){l(s.exports.meshopt_decodeIndexBuffer,h,d,p,f)},decodeIndexSequence(h,d,p,f){l(s.exports.meshopt_decodeIndexSequence,h,d,p,f)},decodeGltfBuffer(h,d,p,f,g,y){l(s.exports[c[g]],h,d,p,f,s.exports[u[y]])}},JC};let QC=null,Vee="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function Uee(n,e,t){return i=>{t&&t(i),n&&(QC||(QC=new ALe),QC.setDecoderPath(typeof n=="string"?n:Vee),i.setDRACOLoader(QC)),e&&i.setMeshoptDecoder(typeof DL=="function"?DL():DL)}}function dm(n,e=!0,t=!0,i){return q1(Iz,n,Uee(e,t,i))}dm.preload=(n,e=!0,t=!0,i)=>q1.preload(Iz,n,Uee(e,t,i));dm.clear=n=>q1.clear(Iz,n);dm.setDecoderPath=n=>{Vee=n};function ILe(n,e,t){const i=Zo(d=>d.size),r=Zo(d=>d.viewport),s=typeof n=="number"?n:i.width*r.dpr,o=typeof e=="number"?e:i.height*r.dpr,a=(typeof n=="number"?t:n)||{},{samples:l=0,depth:u,...c}=a,h=K.useMemo(()=>{const d=new el(s,o,{minFilter:Zn,magFilter:Zn,type:Cf,...c});return u&&(d.depthTexture=new iz(s,o,Ml)),d.samples=l,d},[]);return K.useLayoutEffect(()=>{h.setSize(s,o),l&&(h.samples=l)},[l,h,s,o]),K.useEffect(()=>()=>h.dispose(),[]),h}const kLe=n=>typeof n=="function",$ee=K.forwardRef(({envMap:n,resolution:e=256,frames:t=1/0,makeDefault:i,children:r,...s},o)=>{const a=Zo(({set:y})=>y),l=Zo(({camera:y})=>y),u=Zo(({size:y})=>y),c=K.useRef(null),h=K.useRef(null),d=ILe(e);K.useLayoutEffect(()=>{s.manual||(c.current.aspect=u.width/u.height)},[u,s]),K.useLayoutEffect(()=>{c.current.updateProjectionMatrix()});let p=0,f=null;const g=kLe(r);return Az(y=>{g&&(t===1/0||p<t)&&(h.current.visible=!1,y.gl.setRenderTarget(d),f=y.scene.background,n&&(y.scene.background=n),y.gl.render(y.scene,c.current),y.scene.background=f,y.gl.setRenderTarget(null),h.current.visible=!0,p++)}),K.useLayoutEffect(()=>{if(i){const y=l;return a(()=>({camera:c.current})),()=>a(()=>({camera:y}))}},[c,i,a]),K.createElement(K.Fragment,null,K.createElement("perspectiveCamera",ky({ref:$Ne([c,o])},s),!g&&r),K.createElement("group",{ref:h},g&&r(d.texture)))}),RLe=K.forwardRef(({makeDefault:n,camera:e,regress:t,domElement:i,enableDamping:r=!0,keyEvents:s=!1,onChange:o,onStart:a,onEnd:l,...u},c)=>{const h=Zo(_=>_.invalidate),d=Zo(_=>_.camera),p=Zo(_=>_.gl),f=Zo(_=>_.events),g=Zo(_=>_.setEvents),y=Zo(_=>_.set),m=Zo(_=>_.get),v=Zo(_=>_.performance),w=e||d,S=i||f.connected||p.domElement,C=K.useMemo(()=>new ZNe(w),[w]);return Az(()=>{C.enabled&&C.update()},-1),K.useEffect(()=>(s&&C.connect(s===!0?S:s),C.connect(S),()=>void C.dispose()),[s,S,t,C,h]),K.useEffect(()=>{const _=E=>{h(),t&&v.regress(),o&&o(E)},A=E=>{a&&a(E)},I=E=>{l&&l(E)};return C.addEventListener("change",_),C.addEventListener("start",A),C.addEventListener("end",I),()=>{C.removeEventListener("start",A),C.removeEventListener("end",I),C.removeEventListener("change",_)}},[o,a,l,C,h,g]),K.useEffect(()=>{if(n){const _=m().controls;return y({controls:C}),()=>y({controls:_})}},[n,C]),K.createElement("primitive",ky({ref:c,object:C,enableDamping:r},u))});function NLe(n,e){const t=K.useRef(),[i]=K.useState(()=>e?e instanceof yn?{current:e}:e:t),[r]=K.useState(()=>new Tz(void 0));K.useLayoutEffect(()=>{e&&(i.current=e instanceof yn?e:e.current),r._root=i.current});const s=K.useRef({}),o=K.useMemo(()=>{const a={};return n.forEach(l=>Object.defineProperty(a,l.name,{enumerable:!0,get(){if(i.current)return s.current[l.name]||(s.current[l.name]=r.clipAction(l,i.current))},configurable:!0})),{ref:i,clips:n,actions:a,names:n.map(l=>l.name),mixer:r}},[n]);return Az((a,l)=>r.update(l)),K.useEffect(()=>{const a=i.current;return()=>{s.current={},r.stopAllAction(),Object.values(o.actions).forEach(l=>{a&&r.uncacheAction(l,a)})}},[n]),o}function LLe(n){const e=K.useRef(),{nodes:t,materials:i,animations:r}=dm("/waving.glb"),{actions:s}=NLe(r,e);return Is.useEffect(()=>{s["Armature|mixamo.com|Layer0"].play()},[s]),se.jsx("group",{ref:e,...n,dispose:null,children:se.jsx("group",{name:"Scene",children:se.jsxs("group",{name:"Armature",rotation:[Math.PI/2,0,0],scale:.01,children:[se.jsx("primitive",{object:t.mixamorigHips}),se.jsx("skinnedMesh",{name:"Wolf3D_Body",geometry:t.Wolf3D_Body.geometry,material:i["Wolf3D_Body.001"],skeleton:t.Wolf3D_Body.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Hair",geometry:t.Wolf3D_Hair.geometry,material:i["Wolf3D_Hair.001"],skeleton:t.Wolf3D_Hair.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Outfit_Bottom",geometry:t.Wolf3D_Outfit_Bottom.geometry,material:i["Wolf3D_Outfit_Bottom.001"],skeleton:t.Wolf3D_Outfit_Bottom.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Outfit_Footwear",geometry:t.Wolf3D_Outfit_Footwear.geometry,material:i["Wolf3D_Outfit_Footwear.001"],skeleton:t.Wolf3D_Outfit_Footwear.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Outfit_Top",geometry:t.Wolf3D_Outfit_Top.geometry,material:i["Wolf3D_Outfit_Top.001"],skeleton:t.Wolf3D_Outfit_Top.skeleton}),se.jsx("skinnedMesh",{name:"EyeLeft",geometry:t.EyeLeft.geometry,material:i["Wolf3D_Eye.001"],skeleton:t.EyeLeft.skeleton}),se.jsx("skinnedMesh",{name:"EyeRight",geometry:t.EyeRight.geometry,material:i["Wolf3D_Eye.001"],skeleton:t.EyeRight.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Head",geometry:t.Wolf3D_Head.geometry,material:i["Wolf3D_Skin.001"],skeleton:t.Wolf3D_Head.skeleton}),se.jsx("skinnedMesh",{name:"Wolf3D_Teeth",geometry:t.Wolf3D_Teeth.geometry,material:i["Wolf3D_Teeth.001"],skeleton:t.Wolf3D_Teeth.skeleton})]})})})}dm.preload("/waving.glb");function Z3({lookRight:n=!1}){return se.jsxs(Bee,{shadows:!0,children:[se.jsx($ee,{makeDefault:!0,position:[0,1.5,2.2]}),se.jsx(RLe,{target:[0,.9,0],minPolarAngle:Math.PI/2,maxPolarAngle:Math.PI/2,enablePan:!1,enableZoom:!1}),se.jsx(LLe,{rotation:[0,n?Math.PI/8:-Math.PI/8,0]}),se.jsx("ambientLight",{intensity:2,color:"#EFEFEF"})]})}const PLe=uQ().shape({name:O_().required("Name is required"),email:O_().email("Invalid email address").required("Email is required"),message:O_().required("Message is required")});function DLe(){const n=uCe({initialValues:{name:"",email:"",message:""},validationSchema:PLe,onSubmit:e=>{d_e.send("service_e2sbfi5","template_ybjdyod",{from_name:e.name,from_email:e.email,message:e.message},"Jex7CmoNVzlb1zQ35").then(()=>{alert("Message sent successfully!")},()=>{alert("Error sending message")})}});return se.jsxs("div",{className:hl.container,id:"contact",children:[se.jsxs(On.div,{className:hl.formContainer,initial:{x:-100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:[se.jsx("h1",{children:"Get In Touch"}),se.jsx("p",{children:"Have a question or want to work together?"}),se.jsxs("form",{className:hl.form,onSubmit:n.handleSubmit,children:[se.jsxs("div",{className:hl.formGroup,children:[se.jsx("label",{htmlFor:"name",children:"Name"}),se.jsx("input",{type:"text",id:"name",name:"name",onChange:n.handleChange,onBlur:n.handleBlur,value:n.values.name}),n.touched.name&&n.errors.name?se.jsx("div",{className:hl.error,children:n.errors.name}):null]}),se.jsxs("div",{className:hl.formGroup,children:[se.jsx("label",{htmlFor:"email",children:"Email"}),se.jsx("input",{type:"email",id:"email",name:"email",onChange:n.handleChange,onBlur:n.handleBlur,value:n.values.email}),n.touched.email&&n.errors.email?se.jsx("div",{className:hl.error,children:n.errors.email}):null]}),se.jsxs("div",{className:hl.formGroup,children:[se.jsx("label",{htmlFor:"message",children:"Message"}),se.jsx("textarea",{id:"message",name:"message",rows:"5",onChange:n.handleChange,onBlur:n.handleBlur,value:n.values.message}),n.touched.message&&n.errors.message?se.jsx("div",{className:hl.error,children:n.errors.message}):null]}),se.jsx("button",{type:"submit",className:hl.formButton,children:"Submit"})]})]}),se.jsx(On.div,{className:hl.hero,initial:{x:100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:se.jsx(Z3,{})})]})}const FLe="_container_1vb4i_1",OLe="_bento_1vb4i_29",BLe="_bento1_1vb4i_49 _bento_1vb4i_29",zLe="_bento2_1vb4i_123 _bento1_1vb4i_49 _bento_1vb4i_29",GLe="_bento3_1vb4i_133 _bento_1vb4i_29",VLe="_company_1vb4i_149",ULe="_bento4_1vb4i_153 _bento_1vb4i_29",$Le="_divider_1vb4i_167",WLe="_bento5_1vb4i_203 _primaryButton_s2sxs_1",sc={container:FLe,bento:OLe,bento1:BLe,bento2:zLe,bento3:GLe,company:VLe,bento4:ULe,divider:$Le,bento5:WLe};function HLe(){const n={rest:{scale:.8},inView:{scale:1}},e=t=>({transition:{type:"spring",duration:.8,delay:t},variants:n});return se.jsxs(On.div,{className:sc.container,initial:"rest",whileInView:"inView",children:[se.jsxs(On.div,{className:sc.bento1,...e(.1),children:[se.jsxs("h2",{children:["6",se.jsx("span",{children:"+"})]}),se.jsx("p",{children:"Seasoned Expertise"})]}),se.jsxs(On.div,{className:sc.bento2,...e(.2),children:[se.jsx("h2",{children:"2"}),se.jsx("p",{children:"Companies"})]}),se.jsxs(On.div,{className:sc.bento3,...e(0),children:[se.jsxs("div",{className:sc.company,children:[se.jsx("h2",{children:"Software Engineer (Full Stack Developer)"}),se.jsx("p",{children:"Bourke Technologies  Full-time"}),se.jsx("p",{children:"Sep 2017 - Jan 2021  3 yrs 5 mos"})]}),se.jsx("hr",{className:sc.divider}),se.jsxs("div",{className:sc.company,children:[se.jsx("h2",{children:"Lead Web Developer"}),se.jsx("p",{children:"ShopShareTV  Full-time"}),se.jsx("p",{children:"Jan 2021 - Present  2 yrs 7 mos"})]})]}),se.jsx(On.div,{className:sc.bento4,...e(.3),children:se.jsxs("p",{children:["B.Eng. (Hons) Software Engineering",se.jsx("br",{})," Informatics Institute of Technology (LK) Affiliated with University of Westminster (UK) ",se.jsx("br",{}),"2018 - 2023"]})}),se.jsxs(R1,{to:"/about",className:sc.bento5,children:["Experience ",se.jsx(iy,{})]})]})}const XLe="/assets/main_new-35160b35.png",KLe="_container_xfcje_5",ZLe="_avatarContainer_xfcje_29",jLe="_avatarImgContainer_xfcje_51",YLe="_content_xfcje_67",JLe="_background_xfcje_77",QLe="_title_xfcje_101",qLe="_subtitle_xfcje_117",ePe="_subtitleHighlight_xfcje_133",tPe="_btnContainer_xfcje_141",nPe="_btn_xfcje_141",iPe="_avatar_xfcje_29",Wo={container:KLe,avatarContainer:ZLe,avatarImgContainer:jLe,content:YLe,background:JLe,title:QLe,subtitle:qLe,subtitleHighlight:ePe,btnContainer:tPe,btn:nPe,avatar:iPe};function rPe(n){return{x:n.clientX||n.touches&&n.touches[0].clientX,y:n.clientY||n.touches&&n.touches[0].clientY}}function sPe(n,e,t){let i=0,r=0,s,o,a,l,u={x:window.innerWidth,y:window.innerHeight};return n<=u.x/2&&(s=u.x/2-n,o=s/(u.x/2)*100,i=t*o/100*-1),n>=u.x/2&&(s=n-u.x/2,o=s/(u.x/2)*100,i=t*o/100),e<=u.y/2&&(a=u.y/2-e,l=a/(u.y/2)*100,r=t*.5*l/100*-1),e>=u.y/2&&(a=e-u.y/2,l=a/(u.y/2)*100,r=t*l/100),{x:i,y:r}}function oPe(n,e,t){let i=sPe(n.x,n.y,t);e.rotation.y=Wp.degToRad(Wp.clamp(i.x,-26,26)),e.rotation.x=Wp.degToRad(Wp.clamp(i.y,-20,16))}function aPe(n){const{nodes:e,materials:t}=dm("/head_only.glb"),i=e.Head;return K.useEffect(()=>{const r=s=>{const o=rPe(s);i&&oPe(o,i,50)};return document.addEventListener("mousemove",r),()=>{document.removeEventListener("mousemove",r)}},[i]),se.jsxs("group",{...n,dispose:null,children:[se.jsx("primitive",{object:e.Hips}),se.jsx("mesh",{geometry:e.Wolf3D_Outfit_Top.geometry,material:t.Wolf3D_Outfit_Top}),se.jsx("skinnedMesh",{geometry:e.Wolf3D_Hair.geometry,material:t.Wolf3D_Hair,skeleton:e.Wolf3D_Hair.skeleton}),se.jsx("skinnedMesh",{geometry:e.EyeLeft.geometry,material:t.Wolf3D_Eye,skeleton:e.EyeLeft.skeleton}),se.jsx("skinnedMesh",{geometry:e.EyeRight.geometry,material:t.Wolf3D_Eye,skeleton:e.EyeRight.skeleton}),se.jsx("skinnedMesh",{geometry:e.Wolf3D_Head.geometry,material:t.Wolf3D_Skin,skeleton:e.Wolf3D_Head.skeleton})]})}dm.preload("/head_only.glb");function lPe(){return se.jsxs("div",{className:Wo.container,children:[se.jsx("div",{className:Wo.background}),se.jsxs("div",{className:Wo.content,children:[se.jsxs("div",{className:Wo.avatarContainer,children:[se.jsxs(Bee,{children:[se.jsx($ee,{makeDefault:!0,position:[0,1.7,.66]}),se.jsx("ambientLight",{intensity:2,color:"#EFEFEF"}),se.jsx(aPe,{})]}),se.jsx("div",{className:Wo.avatarImgContainer,children:se.jsx("img",{className:Wo.avatar,src:XLe,alt:"avatar"})})]}),se.jsx(On.h1,{className:Wo.title,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5},children:"Anushka Madushanka"}),se.jsxs(On.h2,{className:Wo.subtitle,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5,delay:.2},children:[se.jsx("span",{className:Wo.subtitleHighlight,children:"Full stack"})," Developer"]}),se.jsxs(On.div,{className:Wo.btnContainer,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5,delay:.4},children:[se.jsx(On.a,{href:"/",className:Wo.btn,whileHover:{scale:1.1,transition:{duration:.2}},whileTap:{scale:.9},children:se.jsx(uve,{})}),se.jsx(On.a,{href:"https://www.linkedin.com/in/anushka-madushanka/",target:"_blank",className:Wo.btn,whileHover:{scale:1.1,transition:{duration:.2}},whileTap:{scale:.9},children:se.jsx(ove,{})}),se.jsx(On.a,{href:"https://github.com/AnushkaMadushanka/",target:"_blank",className:Wo.btn,whileHover:{scale:1.1,transition:{duration:.2}},whileTap:{scale:.9},children:se.jsx(sve,{})})]})]})]})}const uPe="/assets/grad-a460c525.jpg",cPe="_primaryButton_s2sxs_1",kz={primaryButton:cPe},hPe="_container_dzopj_1",dPe="_avatar_dzopj_19",pPe="_content_dzopj_53",fPe="_btn_dzopj_87",FL={container:hPe,avatar:dPe,content:pPe,btn:fPe};function mPe(){return se.jsxs("div",{className:FL.container,id:"about",children:[se.jsx(On.div,{className:FL.avatar,initial:{x:-100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:se.jsx("img",{src:uPe,alt:"avatar"})}),se.jsxs(On.div,{className:FL.content,initial:{x:100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:[se.jsx("h2",{children:"My Story"}),se.jsxs("p",{children:["I am a skilled software engineer specializing in"," ",se.jsx("span",{children:"desktop, web, and game development."})," I have excellent problem-solving abilities, a passion for learning, and a commitment to delivering exceptional outcomes. I write clean, efficient, and well-organized code that adheres to industry best practices."]}),se.jsx(R1,{to:"/about",children:se.jsxs(On.a,{className:kz.primaryButton,whileHover:{scale:1.05,transition:{duration:.2}},whileTap:{scale:.95},children:["Learn More ",se.jsx(iy,{})]})})]})]})}const gPe="_container_xfv50_1",yPe="_header_xfv50_25",bPe="_projects_xfv50_37",xPe="_projectCard_xfv50_49",vPe="_projectImage_xfv50_67",wPe="_projectInfo_xfv50_77",SPe="_projectLinks_xfv50_117",Sh={container:gPe,header:yPe,projects:bPe,projectCard:xPe,projectImage:vPe,projectInfo:wPe,projectLinks:SPe},BK=[{title:"Ludo Shooter",description:"A wave-based shooter where you have to destroy the board pieces coming to kill you. But every time you reload, the dice will roll and add a random modifier to your game",githubLink:"https://github.com/AnushkaMadushanka/ludo-shooter",staticImageUrl:"https://img.itch.zone/aW1hZ2UvMTYyMTkzNS85NDkzMTE4LnBuZw==/347x500/M9Yxah.png",releaseLink:"https://anushka-madushanka.itch.io/ludo-shooter",youtubeSource:"https://youtu.be/VAIWMgyLycM"},{title:"Nightmarescape",description:"The First Person Endless Runner where you can test your reflexes as you try to escape from the creature that is following you through the tunnels",githubLink:"https://github.com/AnushkaMadushanka/nightmarescape",staticImageUrl:"https://i.ibb.co/4YmHSpb/Frame-7.png",releaseLink:"https://play.google.com/store/apps/details?id=com.anushka.nightmarescape",youtubeSource:"https://www.youtube.com/watch/b6FQ_OjQ8X0"},{title:"Operation Alone",description:"A top-down shooter game about finding your way out through tunnels filled with zombies",githubLink:"https://github.com/AnushkaMadushanka/Operation-Alone",staticImageUrl:"http://i3.ytimg.com/vi/b6FQ_OjQ8X0/maxresdefault.jpg",releaseLink:"https://anushka-madushanka.itch.io/operation-alone",youtubeSource:"https://www.youtube.com/watch/b6FQ_OjQ8X0"},{title:"MoCap using HPE",description:"A low-cost vision based motion capture system using 3D human pose estimation that will accept a video with human motion and process that human motion into a 3D animation that can be used in their preferred 3d program such as Blender, 3Ds Max",githubLink:"https://github.com/AnushkaMadushanka/mocap-hpe",staticImageUrl:"https://i.ibb.co/9qgvq3Z/Frame-5.png",youtubeSource:"https://www.youtube.com/watch?v=rZU_7MSCpr0",releaseLink:"https://www.youtube.com/watch?v=rZU_7MSCpr0"},{title:"Simple Forum using CodeIgniter",description:"A simple forum application developed using CodeIgniter framework. This is a simple forum application that allows users to most of the basic forum functionalities.",githubLink:"https://github.com/AnushkaMadushanka/cw-forum",staticImageUrl:"https://i.ibb.co/mD0prbc/Frame-6.png",youtubeSource:"https://youtu.be/GWy1kGbydBM",releaseLink:"https://youtu.be/GWy1kGbydBM"},{title:"SQL Dummy Data Generator",description:"A C# program that creates dummy data for your SQL databases. With few clicks you can create sample databases with data for your specific needs",staticImageUrl:"http://i3.ytimg.com/vi/b3AlZ1YqNBw/maxresdefault.jpg",githubLink:"https://github.com/AnushkaMadushanka/SQL-Dummy-Data-Generator",releaseLink:"https://github.com/AnushkaMadushanka/SQL-Dummy-Data-Generator/releases",youtubeSource:"https://www.youtube.com/watch/b3AlZ1YqNBw"},{title:"Auto Extension Reloader",description:"This plugin allows developers to see the current status of the building process of their specific extension. get notification when the status change and it will reload the extension after a build",githubLink:"https://github.com/AnushkaMadushanka/auto-extension-reloader",releaseLink:"https://www.npmjs.com/package/auto-extension-reloader",staticImageUrl:"http://i3.ytimg.com/vi/gczjrjCIrVU/maxresdefault.jpg",youtubeSource:"https://www.youtube.com/watch/gczjrjCIrVU"},{title:"Audio Visualization Project #1",description:"Testing the broads of audio visualization in unity 3d",githubLink:"https://github.com/AnushkaMadushanka/Audio-Visualization",staticImageUrl:"https://i.ytimg.com/vi/NCvmuG4uP6A/hqdefault.jpg?sqp=-oaymwEZCNACELwBSFXyq4qpAwsIARUAAIhCGAFwAQ==&rs=AOn4CLDJSSHGVk9pimq1GAMT8RkbCn_ZNg",releaseLink:"https://www.youtube.com/watch?v=NCvmuG4uP6A",youtubeSource:"https://www.youtube.com/watch/NCvmuG4uP6A"},{title:"Audio Visualization Project #2",description:"Testing the broads of audio visualization in unity 3d",staticImageUrl:"https://i.ytimg.com/vi/ll_8dB-HIwE/hqdefault.jpg?sqp=-oaymwEZCNACELwBSFXyq4qpAwsIARUAAIhCGAFwAQ==&rs=AOn4CLAcpXmH6M7rbgv2Hwura7T0xdknqg",githubLink:"https://github.com/AnushkaMadushanka/Audio-Visualization",releaseLink:"https://www.youtube.com/watch?v=ll_8dB-HIwE",youtubeSource:"https://www.youtube.com/watch/ll_8dB-HIwE"}];function TPe(){const[n,e]=K.useState(3),t=BK.slice(0,n);return se.jsxs("div",{className:Sh.container,id:"projects",children:[se.jsx(On.h1,{className:Sh.header,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5},children:"Projects"}),se.jsx("div",{className:Sh.projects,children:t.map((i,r)=>se.jsxs(On.div,{className:Sh.projectCard,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5,delay:r*.1},children:[se.jsxs("div",{className:Sh.main,children:[se.jsx("div",{className:Sh.projectImage,children:se.jsx("img",{src:i.staticImageUrl,alt:i.title})}),se.jsxs("div",{className:Sh.projectInfo,children:[se.jsx("h2",{children:i.title}),se.jsx("p",{children:i.description})]})]}),se.jsxs("div",{className:Sh.projectLinks,children:[se.jsxs("a",{href:i.githubLink,target:"_blank",rel:"noopener noreferrer",children:["Github ",se.jsx(iy,{})]}),se.jsxs("a",{href:i.releaseLink,target:"_blank",rel:"noopener noreferrer",children:["Demo ",se.jsx(iy,{})]})]})]},r))}),n<BK.length&&se.jsxs("button",{className:kz.primaryButton,onClick:()=>{e(n+3)},children:["Load More ",se.jsx(iy,{})]})]})}function CPe(n){return Nd({tag:"svg",attr:{version:"1.1",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"M3.516 7c1.933 0 3.5 1.567 3.5 3.5s-1.567 3.5-3.5 3.5-3.5-1.567-3.5-3.5l-0.016-0.5c0-3.866 3.134-7 7-7v2c-1.336 0-2.591 0.52-3.536 1.464-0.182 0.182-0.348 0.375-0.497 0.578 0.179-0.028 0.362-0.043 0.548-0.043zM12.516 7c1.933 0 3.5 1.567 3.5 3.5s-1.567 3.5-3.5 3.5-3.5-1.567-3.5-3.5l-0.016-0.5c0-3.866 3.134-7 7-7v2c-1.336 0-2.591 0.52-3.536 1.464-0.182 0.182-0.348 0.375-0.497 0.578 0.179-0.028 0.362-0.043 0.549-0.043z"}}]})(n)}const _Pe="_container_1p5xb_1",MPe="_header_1p5xb_25",APe="_testimonials_1p5xb_37",EPe="_testimonialCard_1p5xb_49",IPe="_icon_1p5xb_69",kPe="_testimonialText_1p5xb_79",RPe="_testimonialInfo_1p5xb_99",NPe="_avatar_1p5xb_111",LPe="_info_1p5xb_123",oc={container:_Pe,header:MPe,testimonials:APe,testimonialCard:EPe,icon:IPe,testimonialText:kPe,testimonialInfo:RPe,avatar:NPe,info:LPe},zK=[{name:"Sarah Johnson",job_title:"CEO at TechSolutions Inc.",testimonial:"Anushka's expertise as a full stack developer has been invaluable to our projects. His attention to detail and problem-solving skills consistently deliver high-quality solutions.",avatar:"https://i.pravatar.cc/300?img=1"},{name:"Michael Lee",job_title:"Software Engineer at XYZ Tech",testimonial:"Working alongside Anushka has been a pleasure. His proficiency in both front-end and back-end development makes him an asset to any team. He's dedicated and always delivers exceptional results.",avatar:"https://i.pravatar.cc/300?img=2"},{name:"Emily Patel",job_title:"Project Manager at ABC Innovations",testimonial:"Anushka's commitment to understanding our project's requirements and delivering scalable solutions has been remarkable. His technical proficiency and collaborative approach significantly contributed to our project's success.",avatar:"https://i.pravatar.cc/300?img=3"},{name:"Javier Rodriguez",job_title:"CTO at Digital Nexus",testimonial:"Anushka's skill set as a full stack developer is impressive. His ability to adapt to new technologies and swiftly resolve complex issues demonstrates his exceptional capabilities in the field.",avatar:"https://i.pravatar.cc/300?img=4"},{name:"Priya Gupta",job_title:"Lead Developer at SoftwareXpert",testimonial:"Anushka's proficiency across the full stack spectrum is commendable. His innovative solutions and reliable code have been instrumental in enhancing our product's performance and functionality.",avatar:"https://i.pravatar.cc/300?img=5"}];function PPe(){const[n,e]=K.useState(3),t=zK.slice(0,n);return se.jsxs("div",{className:oc.container,id:"testimonials",children:[se.jsx(On.h1,{className:oc.header,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5},children:"Testimonials"}),se.jsx("div",{className:oc.testimonials,children:t.map((i,r)=>se.jsxs(On.div,{className:oc.testimonialCard,initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.5,delay:r*.1},children:[se.jsxs("div",{className:oc.testimonialText,children:[se.jsx("div",{className:oc.icon,children:se.jsx(CPe,{})}),se.jsx("p",{children:i.testimonial})]}),se.jsxs("div",{className:oc.testimonialInfo,children:[se.jsx("div",{className:oc.avatar,children:se.jsx("img",{src:i.avatar,alt:i.name})}),se.jsxs("div",{className:oc.info,children:[se.jsx("h2",{children:i.name}),se.jsx("p",{children:i.job_title})]})]})]},r))}),n<zK.length&&se.jsxs("button",{className:kz.primaryButton,onClick:()=>{e(n+3)},children:["Load More ",se.jsx(iy,{})]})]})}function DPe(){return se.jsxs(se.Fragment,{children:[se.jsx(lPe,{}),se.jsx(mPe,{}),se.jsx(HLe,{}),se.jsx(TPe,{}),se.jsx(PPe,{}),se.jsx(DLe,{})]})}const FPe="_container_zprnf_1",OPe="_section_zprnf_13",BPe="_hero_zprnf_25",zPe="_content_zprnf_49",pp={container:FPe,section:OPe,hero:BPe,content:zPe};function GPe(){return se.jsxs("div",{className:pp.container,children:[se.jsxs("div",{className:pp.section,children:[se.jsx(On.div,{className:pp.hero,initial:{x:-100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:se.jsx(Z3,{lookRight:!0})}),se.jsxs(On.div,{className:pp.content,initial:{x:100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:[se.jsx("h2",{children:"My Story"}),se.jsxs("p",{children:["Hi, Im Anushka Madushanka, a full stack developer with over 6 years of experience in the industry. Im passionate about creating web and mobile applications that are user-friendly, scalable, and secure. I have a bachelors degree in computer software engineering from the University of Westminster and a strong knowledge of various programming languages and frameworks, such as NodeJs, SQL, MongoDB, C#, JavaScript, Angular, and ReactJs. I also have expertise in HTML and CSS and can hand-code a given design into pixel-perfect CSS.",se.jsx("br",{}),se.jsx("br",{})," I have worked on several projects for different clients, ranging from social commerce platforms to live video conferencing apps to indoor navigation systems.",se.jsx("br",{}),se.jsx("br",{})," You can check out more of my projects on my GitHub profile. Im always eager to learn new technologies and take on new challenges. Im also open to new opportunities and collaborations. If you are interested in working with me or have any questions, feel free to contact me through my LinkedIn profile or email me at anushka.madushanka@gmail.com. I look forward to hearing from you. Thank you for visiting my portfolio website."]})]})]}),se.jsxs("div",{className:pp.section,children:[se.jsxs(On.div,{className:pp.content,initial:{x:100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:[se.jsx("h2",{children:"Experience"}),se.jsxs("p",{children:["Software Engineer (Full Stack Developer) Bourke Technologies  Full-time Sep 2017 - Jan 2021  3 yrs 5 mos",se.jsxs("ul",{children:[se.jsxs("li",{children:["Shopshare.tv - social commerce platform for shoppers to get help, guidance, and inspiration as they shop online. ",se.jsx("br",{}),"Technologies: React, NodeJs, GraphQL, AWS, PostgreSQL, Sequalize"]}),se.jsxs("li",{children:["Shopcast.tv - Widget that shows up on online shopping sites to get help, guidance on specific products.",se.jsx("br",{}),"Technologies: React (NextJS), NodeJs, GraphQL, AWS, PostgreSQL, Sequalize"]}),se.jsxs("li",{children:["Hospital Communication System - Live video conferencing app to use inside hospitals for better. communication.",se.jsx("br",{}),"Technologies: React Native, .NET WEB API, Genie, Microsoft SQL Server"]}),se.jsxs("li",{children:["Bunnings- Indoor navigation system for supermarkets.",se.jsx("br",{}),"Technologies: Angular, .NET WEB API, Genie, Microsoft SQL Server, Unity"]}),se.jsxs("li",{children:["Burgercafe - POS system and admin panel for managing your products.",se.jsx("br",{}),"Technologies: .NET MVC, Genie, Microsoft SQL Server, WPF, Firebase"]}),se.jsxs("li",{children:["Buckingham Tea - Tea e-commerce website",se.jsx("br",{}),"Technologies: Angular, .NET WEB API, Genie, Microsoft SQL Server, Stripe Payment APIs, Firebase"]})]}),"Lead Web Developer ShopShareTV - Customised Shopping Videos  Full-time Jan 2021 - Present  2 yrs 7 mos"]})]}),se.jsx(On.div,{className:pp.hero,initial:{x:-100,opacity:0},whileInView:{x:0,opacity:1},transition:{duration:.5},children:se.jsx(Z3,{lookRight:!0})})]})]})}var pm=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function VPe(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function UPe(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function i(){if(this instanceof i){var r=[null];r.push.apply(r,arguments);var s=Function.bind.apply(e,r);return new s}return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(i){var r=Object.getOwnPropertyDescriptor(n,i);Object.defineProperty(t,i,r.get?r:{enumerable:!0,get:function(){return n[i]}})}),t}const GK=(n,e)=>{const t=2*Math.PI*e*n;return t/(t+1)},VK=(n,e,t)=>n*e+(1-n)*t;class $Pe{constructor({minCutOff:e,beta:t}){this.minCutOff=e,this.beta=t,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(e,t){if(!this.initialized)return this.initialized=!0,this.xPrev=t,this.dxPrev=t.map(()=>0),this.tPrev=e,t;const{xPrev:i,tPrev:r,dxPrev:s}=this,o=e-r,a=GK(o,this.dCutOff),l=[],u=[],c=[];for(let h=0;h<t.length;h++){l[h]=(t[h]-i[h])/o,u[h]=VK(a,l[h],s[h]);const d=this.minCutOff+this.beta*Math.abs(u[h]),p=GK(o,d);c[h]=VK(p,t[h],i[h])}return this.xPrev=c,this.dxPrev=u,this.tPrev=e,c}}const WPe=`<div class="mindar-ui-overlay mindar-ui-loading">
  <div class="loader"/>
</div>
`,HPe=`<div class="mindar-ui-overlay mindar-ui-compatibility">
  <div class="content">
    <h1>Failed to launch :(</h1>
    <p>
      Looks like your device/browser is not compatible.
    </p>

    <br/>
    <br/>
    <p>
      Please try the following recommended browsers:
    </p>
    <p>
      For Android device - Chrome
    </p>
    <p>
      For iOS device - Safari
    </p>
  </div>
</div>
`,XPe=`<div class="mindar-ui-overlay mindar-ui-scanning">
  <div class="scanning">
    <div class="inner">
      <div class="scanline"/>
    </div>
  </div>
</div>
`,KPe=".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}";let ZPe=class{constructor({uiLoading:e,uiScanning:t,uiError:i}){const r=document.createElement("style");r.innerText=KPe,document.head.appendChild(r),e==="yes"?this.loadingModal=this._loadHTML(WPe):e!=="no"&&(this.loadingModal=document.querySelector(e)),i==="yes"?this.compatibilityModal=this._loadHTML(HPe):i!=="no"&&(this.compatibilityModal=document.querySelector(i)),t==="yes"?this.scanningMask=this._loadHTML(XPe):t!=="no"&&(this.scanningMask=document.querySelector(t)),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove("hidden")}hideLoading(){this.loadingModal&&this.loadingModal.classList.add("hidden")}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove("hidden")}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add("hidden")}showScanning(){this.scanningMask&&this.scanningMask.classList.remove("hidden")}hideScanning(){this.scanningMask&&this.scanningMask.classList.add("hidden")}_loadHTML(e){const t=document.createElement("template");t.innerHTML=e.trim();const i=t.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(i),i}};function jPe(n,e){for(var t=0;t<e.length;t++){const i=e[t];if(typeof i!="string"&&!Array.isArray(i)){for(const r in i)if(r!=="default"&&!(r in n)){const s=Object.getOwnPropertyDescriptor(i,r);s&&Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:()=>i[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YPe=1e-7,JPe=1e-4;let Rz=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},n2=class{refCount(e){return ho("refCount")}incRef(e){return ho("incRef")}timerAvailable(){return!0}time(e){return ho("time")}read(e){return ho("read")}readSync(e){return ho("readSync")}readToGPU(e,t){return ho("readToGPU")}numDataIds(){return ho("numDataIds")}disposeData(e,t){return ho("disposeData")}write(e,t,i){return ho("write")}move(e,t,i,r,s){return ho("move")}createTensorFromGPUData(e,t,i){return ho("createTensorFromGPUData")}memory(){return ho("memory")}floatPrecision(){return ho("floatPrecision")}epsilon(){return this.floatPrecision()===32?YPe:JPe}dispose(){return ho("dispose")}};function ho(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nz(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,fc(n,e,t)}function QPe(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,i=0;for(;t>0;)i=Math.random()*t|0,t--,fc(n,t,i),fc(e,t,i)}function bd(n,e,t){return Math.max(n,Math.min(e,t))}function i2(n){return n%2===0?n:n+1}function fc(n,e,t){const i=n[e];n[e]=n[t],n[t]=i}function Wee(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function qPe(n,e){const t=Math.random();return e*t+(1-t)*n}function eDe(n,e){let t=0;for(let i=0;i<n.length;i++){const r=Number(n[i])-Number(e[i]);t+=r*r}return t}function B(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function qr(n,e,t=""){B(bn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function fm(n){B(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ke(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function tDe(n){return n.length===0}function bn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Nf(n){return n%1===0}function nDe(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function KM(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function iDe(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return Nz(e),e}function af(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function j3(n,e=r=>0,t,i){return new Promise((r,s)=>{let o=0;const a=()=>{if(n()){r();return}o++;const l=e(o);if(t!=null&&o>=t){s();return}i!=null?i(a,l):setTimeout(a,l)};a()})}function Lz(n,e){let t=1,i=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(i!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${s}`);i=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(i===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[i]=e/t,r}function un(n,e){const t=e.length;return n=n==null?e.map((i,r)=>r):[].concat(n),B(n.every(i=>i>=-t&&i<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),B(n.every(i=>Nf(i)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(i=>i<0?t+i:i)}function jc(n,e){const t=[],i=[],r=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||r?null:un(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[o]==null||s[o]>a)&&n[a]===1&&(t.push(n[a]),i.push(a)),s[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),i.push(a))}return{newShape:t,keptDims:i}}function br(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Wi(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Hee(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${e} being uploaded contains ${i}.`)}}function Xee(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Pz(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function r1(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Kee(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function vu(n){return typeof n=="string"||n instanceof String}function Zee(n){return typeof n=="boolean"}function ZM(n){return typeof n=="number"}function s0(n){return Array.isArray(n)?s0(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":ZM(n)?"float32":vu(n)?"string":Zee(n)?"bool":"float32"}function xd(n){return!!(n&&n.constructor&&n.call&&n.apply)}function jM(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function kt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let i=e-3;i>=0;--i)t[i]=t[i+1]*n[i+1];return t}function jee(n,e,t,i=!1){const r=new Array;if(e.length===1){const s=e[0]*(i?2:1);for(let o=0;o<s;o++)r[o]=t[n+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(i?2:1);for(let l=0;l<s;l++)r[l]=jee(n+l*a,o,t,i)}return r}function aa(n,e,t=!1){if(n.length===0)return e[0];const i=n.reduce((r,s)=>r*s)*(t?2:1);if(i===0)return[];if(i!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return jee(0,n,e,t)}function Yee(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function r2(n,e){const t=jr(n,e);for(let i=0;i<t.length;i++)t[i]=1;return t}function jr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Dz(n,e){const t=n.reduce((i,r)=>i*r,1);if(e==null||e==="float32")return aa(n,new Float32Array(t));if(e==="int32")return aa(n,new Int32Array(t));if(e==="bool")return aa(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Do(n){n.forEach(e=>{B(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Pl(n,e,t){if(e===0)return 0;if(e===1)return n[0];let i=n[n.length-1];for(let r=0;r<n.length-1;++r)i+=t[r]*n[r];return i}function mm(n,e,t){if(e===0)return[];if(e===1)return[n];const i=new Array(e);for(let r=0;r<i.length-1;++r)i[r]=Math.floor(n/t[r]),n-=i[r]*t[r];return i[i.length-1]=n,i}function Bc(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UK="tfjsflags";class Jee{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=rDe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ve().getBool("IS_TEST")||ve().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,i){if(this.flagRegistry[e]={evaluationFn:t,setHook:i},this.urlFlags[e]!=null){const r=this.urlFlags[e];ve().getBool("IS_TEST")||ve().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Bc(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);UK in e&&e[UK].split(",").forEach(t=>{const[i,r]=t.split(":");this.urlFlags[i]=oDe(i,r)})}}function rDe(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...i)=>(sDe(e,i[0],i[1]),i.join("="))),e}function sDe(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function oDe(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function ve(){return Fz}let Fz=null;function aDe(n){Fz=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OL;function Qee(){if(OL==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");OL=n}return OL}function lDe(){const n=Qee();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Oz(n,e){const t=lDe();if(t.has(n))return t.get(n);{const i=e();return t.set(n,i),t.get(n)}}const ew="Abs",o0="Acos",a0="Acosh",gm="Add",tw="AddN",s2="All",o2="Any",nw="ArgMax",iw="ArgMin",l0="Asin",u0="Asinh",c0="Atan",h0="Atanh",d0="Atan2",rw="AvgPool",a2="AvgPoolGrad",sw="AvgPool3D",l2="AvgPool3DGrad",ow="BatchMatMul",aw="BatchToSpaceND",u2="Bincount",qee="BroadcastTo",c2="BroadcastArgs",p0="Cast",f0="Ceil",m0="ClipByValue",h2="Complex",lw="ComplexAbs",uw="Concat",cw="Conv2D",d2="Conv2DBackpropFilter",hw="Conv2DBackpropInput",dw="Conv3D",p2="Conv3DBackpropFilterV2",f2="Conv3DBackpropInputV2",g0="Cos",y0="Cosh",m2="Cumprod",pw="Cumsum",g2="CropAndResize",y2="DenseBincount",b2="DepthToSpace",fw="DepthwiseConv2dNative",x2="DepthwiseConv2dNativeBackpropFilter",v2="DepthwiseConv2dNativeBackpropInput",w2="Diag",mw="Dilation2D",YM="Dilation2DBackpropInput",JM="Dilation2DBackpropFilter",b0="RealDiv",S2="Einsum",x0="Elu",T2="EluGrad",v0="Erf",gw="Equal",w0="Exp",yw="ExpandDims",S0="Expm1",C2="FFT",_2="Fill",M2="FlipLeftRight",T0="Floor",C0="FloorDiv",bw="FusedBatchNorm",xw="GatherV2",A2="GatherNd",vw="Greater",_0="GreaterEqual",M0="Identity",E2="IFFT",I2="Imag",A0="IsFinite",E0="IsInf",I0="IsNan",ww="LeakyRelu",Sw="Less",Tw="LessEqual",k2="LinSpace",k0="Log",R0="Log1p",Cw="LogicalAnd",_w="LogicalNot",Mw="LogicalOr",uDe="LogicalXor",ete="LogSoftmax",cDe="LowerBound",Aw="LRN",R2="LRNGrad",Ew="Max",N0="Maximum",Iw="MaxPool",N2="MaxPoolGrad",kw="MaxPool3D",L2="MaxPool3DGrad",P2="MaxPoolWithArgmax",Rw="Mean",Nw="Min",L0="Minimum",Lw="MirrorPad",P0="Mod",D2="Multinomial",D0="Multiply",Pw="Neg",Dw="NotEqual",F2="NonMaxSuppressionV3",O2="NonMaxSuppressionV4",B2="NonMaxSuppressionV5",Fw="OnesLike",Ow="OneHot",Bw="Pack",zw="PadV2",hDe="Pool",F0="Pow",Gw="Prelu",Vw="Prod",z2="RaggedGather",G2="RaggedRange",V2="RaggedTensorToTensor",U2="Range",$2="Real",O0="Reciprocal",B0="Relu",Uw="Reshape",$w="ResizeNearestNeighbor",W2="ResizeNearestNeighborGrad",Ww="ResizeBilinear",H2="ResizeBilinearGrad",z0="Relu6",Hw="Reverse",G0="Round",V0="Rsqrt",X2="ScatterNd",K2="SearchSorted",Xw="Select",U0="Selu",Kw="Slice",$0="Sin",W0="Sinh",H0="Sign",X0="Sigmoid",K0="Softplus",Z0="Sqrt",Zw="Sum",jw="SpaceToBatchND",Yw="SplitV",Jw="Softmax",Z2="SparseFillEmptyRows",j2="SparseReshape",Y2="SparseSegmentMean",J2="SparseSegmentSum",Q2="SparseToDense",j0="SquaredDifference",q2="Square",eI="StridedSlice",tI="StringNGrams",nI="StringSplit",iI="StringToHashBucketFast",Y0="Sub",J0="Tan",Q0="Tanh",q0="Tile",rI="TopK",sI="Transform",lf="Transpose",oI="Unique",Qw="Unpack",qw="UnsortedSegmentSum",dDe="UpperBound",eS="ZerosLike",eb="Step",QM="FromPixels",aI="RotateWithOffset",s1="_FusedMatMul",o1="FusedConv2D",a1="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(...n){ve().getBool("IS_TEST")||ve().getBool("PROD")||console.warn(...n)}function pDe(...n){ve().getBool("IS_TEST")||ve().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ry=Oz("kernelRegistry",()=>new Map),l1=Oz("gradRegistry",()=>new Map);function qM(n,e){const t=Bz(n,e);return Ry.get(t)}function Y3(n){return l1.get(n)}function eA(n){const e=Ry.entries(),t=[];for(;;){const{done:i,value:r}=e.next();if(i)break;const[s,o]=r,[a]=s.split("_");a===n&&t.push(o)}return t}function so(n){const{kernelName:e,backendName:t}=n,i=Bz(e,t);Ry.has(i)&&Yo(`The kernel '${e}' for backend '${t}' is already registered`),Ry.set(i,n)}function tte(n){const{kernelName:e}=n;l1.has(e)&&ve().getBool("DEBUG")&&Yo(`Overriding the gradient for '${e}'`),l1.set(e,n)}function fDe(n,e){const t=Bz(n,e);if(!Ry.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Ry.delete(t)}function mDe(n){if(!l1.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);l1.delete(n)}function gDe(n,e){eA(n).forEach(t=>{const i=Object.assign({},t,{backendName:e});so(i)})}function Bz(n,e){return`${e}_${n}`}var nte=ii,Ha=null;try{Ha=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function ii(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}ii.prototype.__isLong__;Object.defineProperty(ii.prototype,"__isLong__",{value:!0});function Fo(n){return(n&&n.__isLong__)===!0}ii.isLong=Fo;var $K={},WK={};function ym(n,e){var t,i,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(i=WK[n],i)?i:(t=ri(n,(n|0)<0?-1:0,!0),r&&(WK[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(i=$K[n],i)?i:(t=ri(n,n<0?-1:0,!1),r&&($K[n]=t),t))}ii.fromInt=ym;function Xa(n,e){if(isNaN(n))return e?Zp:Ka;if(e){if(n<0)return Zp;if(n>=ite)return ote}else{if(n<=-XK)return Co;if(n+1>=XK)return ste}return n<0?Xa(-n,e).neg():ri(n%Ny|0,n/Ny|0,e)}ii.fromNumber=Xa;function ri(n,e,t){return new ii(n,e,t)}ii.fromBits=ri;var tA=Math.pow;function zz(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Ka;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var i;if((i=n.indexOf("-"))>0)throw Error("interior hyphen");if(i===0)return zz(n.substring(1),e,t).neg();for(var r=Xa(tA(t,8)),s=Ka,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var u=Xa(tA(t,a));s=s.mul(u).add(Xa(l))}else s=s.mul(r),s=s.add(Xa(l))}return s.unsigned=e,s}ii.fromString=zz;function Zl(n,e){return typeof n=="number"?Xa(n,e):typeof n=="string"?zz(n,e):ri(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}ii.fromValue=Zl;var HK=65536,yDe=1<<24,Ny=HK*HK,ite=Ny*Ny,XK=ite/2,KK=ym(yDe),Ka=ym(0);ii.ZERO=Ka;var Zp=ym(0,!0);ii.UZERO=Zp;var Kg=ym(1);ii.ONE=Kg;var rte=ym(1,!0);ii.UONE=rte;var J3=ym(-1);ii.NEG_ONE=J3;var ste=ri(-1,2147483647,!1);ii.MAX_VALUE=ste;var ote=ri(-1,-1,!0);ii.MAX_UNSIGNED_VALUE=ote;var Co=ri(0,-2147483648,!1);ii.MIN_VALUE=Co;var ut=ii.prototype;ut.toInt=function(){return this.unsigned?this.low>>>0:this.low};ut.toNumber=function(){return this.unsigned?(this.high>>>0)*Ny+(this.low>>>0):this.high*Ny+(this.low>>>0)};ut.toString=function(n){if(n=n||10,n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Co)){var e=Xa(n),t=this.div(e),i=t.mul(e).sub(this);return t.toString(n)+i.toInt().toString(n)}else return"-"+this.neg().toString(n);for(var r=Xa(tA(n,6),this.unsigned),s=this,o="";;){var a=s.div(r),l=s.sub(a.mul(r)).toInt()>>>0,u=l.toString(n);if(s=a,s.isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}};ut.getHighBits=function(){return this.high};ut.getHighBitsUnsigned=function(){return this.high>>>0};ut.getLowBits=function(){return this.low};ut.getLowBitsUnsigned=function(){return this.low>>>0};ut.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Co)?64:this.neg().getNumBitsAbs();for(var n=this.high!=0?this.high:this.low,e=31;e>0&&!(n&1<<e);e--);return this.high!=0?e+33:e+1};ut.isZero=function(){return this.high===0&&this.low===0};ut.eqz=ut.isZero;ut.isNegative=function(){return!this.unsigned&&this.high<0};ut.isPositive=function(){return this.unsigned||this.high>=0};ut.isOdd=function(){return(this.low&1)===1};ut.isEven=function(){return(this.low&1)===0};ut.equals=function(n){return Fo(n)||(n=Zl(n)),this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1?!1:this.high===n.high&&this.low===n.low};ut.eq=ut.equals;ut.notEquals=function(n){return!this.eq(n)};ut.neq=ut.notEquals;ut.ne=ut.notEquals;ut.lessThan=function(n){return this.comp(n)<0};ut.lt=ut.lessThan;ut.lessThanOrEqual=function(n){return this.comp(n)<=0};ut.lte=ut.lessThanOrEqual;ut.le=ut.lessThanOrEqual;ut.greaterThan=function(n){return this.comp(n)>0};ut.gt=ut.greaterThan;ut.greaterThanOrEqual=function(n){return this.comp(n)>=0};ut.gte=ut.greaterThanOrEqual;ut.ge=ut.greaterThanOrEqual;ut.compare=function(n){if(Fo(n)||(n=Zl(n)),this.eq(n))return 0;var e=this.isNegative(),t=n.isNegative();return e&&!t?-1:!e&&t?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1};ut.comp=ut.compare;ut.negate=function(){return!this.unsigned&&this.eq(Co)?Co:this.not().add(Kg)};ut.neg=ut.negate;ut.add=function(n){Fo(n)||(n=Zl(n));var e=this.high>>>16,t=this.high&65535,i=this.low>>>16,r=this.low&65535,s=n.high>>>16,o=n.high&65535,a=n.low>>>16,l=n.low&65535,u=0,c=0,h=0,d=0;return d+=r+l,h+=d>>>16,d&=65535,h+=i+a,c+=h>>>16,h&=65535,c+=t+o,u+=c>>>16,c&=65535,u+=e+s,u&=65535,ri(h<<16|d,u<<16|c,this.unsigned)};ut.subtract=function(n){return Fo(n)||(n=Zl(n)),this.add(n.neg())};ut.sub=ut.subtract;ut.multiply=function(n){if(this.isZero())return Ka;if(Fo(n)||(n=Zl(n)),Ha){var e=Ha.mul(this.low,this.high,n.low,n.high);return ri(e,Ha.get_high(),this.unsigned)}if(n.isZero())return Ka;if(this.eq(Co))return n.isOdd()?Co:Ka;if(n.eq(Co))return this.isOdd()?Co:Ka;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(KK)&&n.lt(KK))return Xa(this.toNumber()*n.toNumber(),this.unsigned);var t=this.high>>>16,i=this.high&65535,r=this.low>>>16,s=this.low&65535,o=n.high>>>16,a=n.high&65535,l=n.low>>>16,u=n.low&65535,c=0,h=0,d=0,p=0;return p+=s*u,d+=p>>>16,p&=65535,d+=r*u,h+=d>>>16,d&=65535,d+=s*l,h+=d>>>16,d&=65535,h+=i*u,c+=h>>>16,h&=65535,h+=r*l,c+=h>>>16,h&=65535,h+=s*a,c+=h>>>16,h&=65535,c+=t*u+i*l+r*a+s*o,c&=65535,ri(d<<16|p,c<<16|h,this.unsigned)};ut.mul=ut.multiply;ut.divide=function(n){if(Fo(n)||(n=Zl(n)),n.isZero())throw Error("division by zero");if(Ha){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1)return this;var e=(this.unsigned?Ha.div_u:Ha.div_s)(this.low,this.high,n.low,n.high);return ri(e,Ha.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Zp:Ka;var t,i,r;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return Zp;if(n.gt(this.shru(1)))return rte;r=Zp}else{if(this.eq(Co)){if(n.eq(Kg)||n.eq(J3))return Co;if(n.eq(Co))return Kg;var s=this.shr(1);return t=s.div(n).shl(1),t.eq(Ka)?n.isNegative()?Kg:J3:(i=this.sub(n.mul(t)),r=t.add(i.div(n)),r)}else if(n.eq(Co))return this.unsigned?Zp:Ka;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();r=Ka}for(i=this;i.gte(n);){t=Math.max(1,Math.floor(i.toNumber()/n.toNumber()));for(var o=Math.ceil(Math.log(t)/Math.LN2),a=o<=48?1:tA(2,o-48),l=Xa(t),u=l.mul(n);u.isNegative()||u.gt(i);)t-=a,l=Xa(t,this.unsigned),u=l.mul(n);l.isZero()&&(l=Kg),r=r.add(l),i=i.sub(u)}return r};ut.div=ut.divide;ut.modulo=function(n){if(Fo(n)||(n=Zl(n)),Ha){var e=(this.unsigned?Ha.rem_u:Ha.rem_s)(this.low,this.high,n.low,n.high);return ri(e,Ha.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};ut.mod=ut.modulo;ut.rem=ut.modulo;ut.not=function(){return ri(~this.low,~this.high,this.unsigned)};ut.and=function(n){return Fo(n)||(n=Zl(n)),ri(this.low&n.low,this.high&n.high,this.unsigned)};ut.or=function(n){return Fo(n)||(n=Zl(n)),ri(this.low|n.low,this.high|n.high,this.unsigned)};ut.xor=function(n){return Fo(n)||(n=Zl(n)),ri(this.low^n.low,this.high^n.high,this.unsigned)};ut.shiftLeft=function(n){return Fo(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?ri(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):ri(0,this.low<<n-32,this.unsigned)};ut.shl=ut.shiftLeft;ut.shiftRight=function(n){return Fo(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?ri(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):ri(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};ut.shr=ut.shiftRight;ut.shiftRightUnsigned=function(n){if(Fo(n)&&(n=n.toInt()),n&=63,n===0)return this;var e=this.high;if(n<32){var t=this.low;return ri(t>>>n|e<<32-n,e>>>n,this.unsigned)}else return n===32?ri(e,0,this.unsigned):ri(e>>>n-32,0,this.unsigned)};ut.shru=ut.shiftRightUnsigned;ut.shr_u=ut.shiftRightUnsigned;ut.toSigned=function(){return this.unsigned?ri(this.low,this.high,!1):this};ut.toUnsigned=function(){return this.unsigned?this:ri(this.low,this.high,!0)};ut.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()};ut.toBytesLE=function(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};ut.toBytesBE=function(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};ii.fromBytes=function(n,e,t){return t?ii.fromBytesLE(n,e):ii.fromBytesBE(n,e)};ii.fromBytesLE=function(n,e){return new ii(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,e)};ii.fromBytesBE=function(n,e){return new ii(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],e)};const ate=VPe(nte),bDe=jPe({__proto__:null,default:ate},[nte]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Np=ate||bDe;function tS(n){return Np.fromString(n,!0,16)}const lte=tS("c3a5c85c97cb3127"),Ep=tS("b492b66fbe98f273"),_s=tS("9ae16a3b2f90404f");function Q3(n){return n.xor(n.shru(47))}function ute(n,e,t){const i=n.slice(e,e+t);return Np.fromBytes(Array.from(i),!0,!0)}function Kn(n,e){return ute(n,e,8)}function ZK(n,e){return ute(n,e,4)}function Sr(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function sd(n,e,t=tS("9ddfea08eb382d69")){let i=n.xor(e).mul(t);i=i.xor(i.shru(47));let r=e.xor(i).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function xDe(n,e,t,i,r,s){r=r.add(n),s=Sr(s.add(r).add(i),21);const o=r;return r=r.add(e),r=r.add(t),s=s.add(Sr(r,44)),[r.add(i),s.add(o)]}function qC(n,e,t,i){return xDe(Kn(n,e),Kn(n,e+8),Kn(n,e+16),Kn(n,e+24),t,i)}function vDe(n,e=n.length){if(e>=8){const t=_s.add(e*2),i=Kn(n,0).add(_s),r=Kn(n,e-8),s=Sr(r,37).mul(t).add(i),o=Sr(i,25).add(r).mul(t);return sd(s,o,t)}if(e>=4){const t=_s.add(e*2),i=ZK(n,0);return sd(i.shl(3).add(e),ZK(n,e-4),t)}if(e>0){const t=n[0],i=n[e>>1],r=n[e-1],s=t+(i<<8),o=e+(r<<2);return Q3(_s.mul(s).xor(lte.mul(o))).mul(_s)}return _s}function wDe(n,e=n.length){const t=_s.add(e*2),i=Kn(n,0).mul(Ep),r=Kn(n,8),s=Kn(n,e-8).mul(t),o=Kn(n,e-16).mul(_s);return sd(Sr(i.add(r),43).add(Sr(s,30)).add(o),i.add(Sr(r.add(_s),18)).add(s),t)}function SDe(n,e=n.length){const t=_s.add(e*2),i=Kn(n,0).mul(_s),r=Kn(n,8),s=Kn(n,e-8).mul(t),o=Kn(n,e-16).mul(_s),a=Sr(i.add(r),43).add(Sr(s,30)).add(o),l=sd(a,i.add(Sr(r.add(_s),18)).add(s),t),u=Kn(n,16).mul(t),c=Kn(n,24),h=a.add(Kn(n,e-32)).mul(t),d=l.add(Kn(n,e-24)).mul(t);return sd(Sr(u.add(c),43).add(Sr(h,30)).add(d),u.add(Sr(c.add(i),18)).add(h),t)}function cte(n,e=n.length){const t=Np.fromNumber(81,!0);if(e<=32)return e<=16?vDe(n,e):wDe(n,e);if(e<=64)return SDe(n,e);let i=t,r=t.mul(Ep).add(113),s=Q3(r.mul(_s).add(113)).mul(_s),o=[Np.UZERO,Np.UZERO],a=[Np.UZERO,Np.UZERO];i=i.mul(_s).add(Kn(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do i=Sr(i.add(r).add(o[0]).add(Kn(n,l+8)),37).mul(Ep),r=Sr(r.add(o[1]).add(Kn(n,l+48)),42).mul(Ep),i=i.xor(a[1]),r=r.add(o[0]).add(Kn(n,l+40)),s=Sr(s.add(a[0]),33).mul(Ep),o=qC(n,l,o[1].mul(Ep),i.add(a[0])),a=qC(n,l+32,s.add(a[1]),r.add(Kn(n,l+16))),[s,i]=[i,s],l+=64;while(l!==u);const h=Ep.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),i=Sr(i.add(r).add(o[0]).add(Kn(n,l+8)),37).mul(h),r=Sr(r.add(o[1]).add(Kn(n,l+48)),42).mul(h),i=i.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Kn(n,l+40))),s=Sr(s.add(a[0]),33).mul(h),o=qC(n,l,o[1].mul(h),i.add(a[0])),a=qC(n,l+32,s.add(a[1]),r.add(Kn(n,l+16))),[s,i]=[i,s],sd(sd(o[0],a[0],h).add(Q3(r).mul(lte)).add(s),sd(o[1],a[1],h).add(i),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yc(n,e){return e==="string"?ku(n):Od([n],e)}function TDe(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Od(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Bu(n)),ve().getBool("DEBUG")&&Hee(n,e),TDe(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let i=0;i<t.length;++i)Math.round(n[i])!==0&&(t[i]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Ur(){return ve().platform.now()}function hte(n,e){return ve().platform.fetch(n,e)}function ku(n,e="utf-8"){return e=e||"utf-8",ve().platform.encode(n,e)}function zc(n,e="utf-8"){return e=e||"utf-8",ve().platform.decode(n,e)}function Tr(n){return ve().platform.isTypedArray(n)}function Bu(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Bc(n)||n==null||Tr(n)&&t)e.push(n);else if(Array.isArray(n)||Tr(n))for(let i=0;i<n.length;++i)Bu(n[i],e,t);else{let i=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(i=Math.max(i,Number(r)));for(let r=0;r<=i;r++)Bu(n[r],e,t)}return e}const CDe=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:bn,assert:B,assertNonNegativeIntegerDimensions:Do,assertNonNull:fm,assertShapesMatch:qr,bytesFromStringArray:Kee,bytesPerElement:r1,checkConversionForErrors:Hee,clamp:bd,computeStrides:kt,convertBackendValuesAndArrayBuffer:Yee,createScalarValue:Yc,createShuffledIndices:iDe,decodeString:zc,distSquared:eDe,encodeString:ku,fetch:hte,fingerPrint64:cte,flatten:Bu,getArrayFromDType:Wi,getTypedArrayFromDType:br,hasEncodingLoss:Pz,hexToLong:tS,indexToLoc:mm,inferDtype:s0,inferFromImplicitShape:Lz,isBoolean:Zee,isFunction:xd,isInt:Nf,isNumber:ZM,isPromise:Bc,isScalarShape:tDe,isString:vu,isTypedArray:Tr,isValidDtype:Xee,locToIndex:Pl,makeOnesTypedArray:r2,makeZerosNestedTypedArray:Dz,makeZerosTypedArray:jr,nearestDivisor:jM,nearestLargerEven:i2,now:Ur,parseAxisParam:un,randUniform:qPe,repeatedTry:j3,rightPad:af,shuffle:Nz,shuffleCombo:QPe,sizeFromShape:ke,sizeToSquarishShape:KM,squeezeShape:jc,sum:Wee,swap:fc,tanh:nDe,toNestedArray:aa,toTypedArray:Od},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _De{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new ADe)}profileKernel(e,t,i){let r;const s=()=>{r=i()};let o;const a=Ur();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const l of r)l.dataSync();o=Promise.resolve({kernelMs:Ur()-a})}if(ve().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const u=r[l];u.data().then(c=>{MDe(c,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:i,timeMs:r,inputs:s,extraInfo:o}=e;i.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],s,l[2])})})}}function MDe(n,e,t){if(e!=="float32")return!1;for(let i=0;i<n.length;i++){const r=n[i];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class ADe{logKernelProfile(e,t,i,r,s,o){const a=typeof r=="number"?af(`${r}ms`,9):r.error,l=af(e,25),u=t.rank,c=t.size,h=af(t.shape.toString(),14);let d="";for(const p in s){const f=s[p];if(f!=null){const g=f.shape||t.shape,y=g.length;d+=`${p}: ${y}D ${y>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EDe(n,e,t){const i={},r={};for(let l=0;l<e.length;l++)i[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let f=0;f<e.length;f++)if(i[d.id]){u.outputs.forEach(g=>i[g.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const s={};s[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(s[u.outputs[h].id]){for(const d in c)s[c[d].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&o[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];i[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function IDe(n,e,t,i){for(let r=e.length-1;r>=0;r--){const s=e[r],o=[];if(s.outputs.forEach(l=>{const u=n[l.id];u!=null?o.push(u):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=s.inputs[l];if(!bn(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=i(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jK=20,vx=3,BL=7;function kDe(n,e,t,i){const r=kt(e),s=RDe(n,e,t,r),o=e.length,a=X_(n,e,t,r,s),l=["Tensor"];return i&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function RDe(n,e,t,i){const r=ke(e),s=i[i.length-1],o=new Array(s).fill(0),a=e.length,l=t==="complex64"?Ox(n):n;if(a>1)for(let u=0;u<r/s;u++){const c=u*s;for(let h=0;h<s;h++)o[h]=Math.max(o[h],Fx(l[c+h],0,t).length)}return o}function Fx(n,e,t){let i;return Array.isArray(n)?i=`${parseFloat(n[0].toFixed(BL))} + ${parseFloat(n[1].toFixed(BL))}j`:vu(n)?i=`'${n}'`:t==="bool"?i=dte(n):i=parseFloat(n.toFixed(BL)).toString(),af(i,e)}function dte(n){return n===0?"false":"true"}function X_(n,e,t,i,r,s=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const g=Ox(n);return[Fx(g[0],0,t)]}return t==="bool"?[dte(n[0])]:[n[0].toString()]}if(l===1){if(a>jK){const g=vx*o;let y=Array.from(n.slice(0,g)),m=Array.from(n.slice((a-vx)*o,a*o));return t==="complex64"&&(y=Ox(y),m=Ox(m)),["["+y.map((v,w)=>Fx(v,r[w],t)).join(", ")+", ..., "+m.map((v,w)=>Fx(v,r[a-vx+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?Ox(n):Array.from(n)).map((g,y)=>Fx(g,r[y],t)).join(", ")+"]"]}const u=e.slice(1),c=i.slice(1),h=i[0]*o,d=[];if(a>jK){for(let g=0;g<vx;g++){const y=g*h,m=y+h;d.push(...X_(n.slice(y,m),u,t,c,r,!1))}d.push("...");for(let g=a-vx;g<a;g++){const y=g*h,m=y+h;d.push(...X_(n.slice(y,m),u,t,c,r,g===a-1))}}else for(let g=0;g<a;g++){const y=g*h,m=y+h;d.push(...X_(n.slice(y,m),u,t,c,r,g===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function Ox(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mr{constructor(e,t,i){if(this.dtype=t,this.shape=e.slice(),this.size=ke(e),i!=null){const r=i.length;B(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||Wi(t,this.size),this.strides=kt(e)}set(e,...t){t.length===0&&(t=[0]),B(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const i=this.locToIndex(t);this.values[i]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let i=e[e.length-1];for(let r=0;r<e.length-1;++r)i+=this.strides[r]*e[r];return this.values[i]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let i=0;i<t.length-1;++i)t[i]=Math.floor(e/this.strides[i]),e-=t[i]*this.strides[i];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Cl().makeTensor(this.values,this.shape,this.dtype)}}let Cl=null,vg=null;function NDe(n){Cl=n}function LDe(n){vg=n}let An=class{constructor(e,t,i,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ke(e),this.strides=kt(e),this.dataId=i,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return vg.buffer(this.shape,this.dtype,e)}bufferSync(){return vg.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return aa(this.shape,e,this.dtype==="complex64")}arraySync(){return aa(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Cl().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(i=>zc(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Cl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Cl().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>zc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Cl().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Cl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return vg.print(this,e)}clone(){return this.throwIfDisposed(),vg.clone(this)}toString(e=!1){const t=this.dataSync();return kDe(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),vg.cast(this,e)}variable(e=!0,t,i){return this.throwIfDisposed(),Cl().makeVariable(this,e,t,i)}};Object.defineProperty(An,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Le(){return Oz("Tensor",()=>An)}Le();class u1 extends An{constructor(e,t,i,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=i}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!bn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Cl().disposeTensor(this),this.dataId=e.dataId,Cl().incRef(this,null)}dispose(){Cl().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(u1,Symbol.hasInstance,{value:n=>n instanceof An&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var q3;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(q3||(q3={}));var eF;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(eF||(eF={}));var tF;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(tF||(tF={}));var nF;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(nF||(nF={}));var iF;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(iF||(iF={}));const PDe={float32:nF,int32:eF,bool:tF,complex64:iF};function qs(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return PDe[n][e]}function lI(n){return qs(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Si(n,e){if(n.dtype===e.dtype)return[n,e];const t=qs(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function pte(n,e){B(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function uI(n,e){return e.some(t=>t.id===n.id)}function Gc(n){const e=[];return fte(n,e,new Set),e}function fte(n,e,t){if(n==null)return;if(n instanceof An){e.push(n);return}if(!DDe(n))return;const i=n;for(const r in i){const s=i[r];t.has(s)||(t.add(s),fte(s,e,t))}}function DDe(n){return Array.isArray(n)||typeof n=="object"}const FDe=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:pte,getTensorsInContainer:Gc,isTensorInList:uI,makeTypesMatch:Si},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(n){return n.kernelName!=null}class YK{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ly{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new YK}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const i=e[t];if(await this.initializeBackend(i).success){await this.setBackend(i);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,i=1){return e in this.registryFactory?(Yo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:i},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:i}=this.initializeBackend(e);if(!(i?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new _De(this.backendInstance),!0}setupRegisteredKernels(){eA(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){eA(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const i=t.factory();if(i&&!(i instanceof n2)&&typeof i.then=="function"){const r=++this.pendingBackendInitId,s=i.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Yo(`Initialization of backend ${e} failed`),Yo(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=i,{success:!0,asyncInit:!1}}catch(i){return Yo(`Initialization of backend ${e} failed`),Yo(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const i=e[t],{success:r,asyncInit:s}=this.initializeBackend(i);if(s||r)return{name:i,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const i=this.state.tensorInfo.get(t),r=i.backend,s=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),i.backend=e,e.move(t,s,i.shape,i.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let i=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=e}let r;return this.scopedRun(()=>this.startScope(i),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,i){e();try{const r=i();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Ly.nextTensorId++}nextVariableId(){return Ly.nextVariableId++}clone(e){const t=ne.runKernel(M0,{x:e}),i={x:e},r=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return ne.runKernel(p0,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,i,[t],r,s,{}),t}runKernel(e,t,i){if(this.backendName==null&&this.backend,qM(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,i){const r=this.backend.numDataIds();let s=0;i.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,i=[];const r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=zL(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(zL(e)){const{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const m=qM(f,this.backendName);B(m!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const v=this.backend.numDataIds();l=m.kernelFunc({inputs:g,attrs:y,backend:this.backend});const w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,v,w);const S=w.map(C=>C.rank!=null?C:this.makeTensorFromTensorInfo(C));if(r){const C=this.getTensorsForGradient(f,g,S);i=this.saveTensorsForBackwardMode(C)}return S}}else{const{forwardFunc:f}=e,g=y=>{r&&(i=y.map(m=>this.keep(this.clone(m))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));const m=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,m),m}}const{inputs:c,attrs:h}=e,d=zL(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,c,t,d,i,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,i){const r=Y3(e);if(r!=null){const s=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(B(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=s.map(u=>t[u]);const l=i.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,t,i,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");i=i||"float32",r=r||this.backend;let s=e;i==="string"&&vu(e[0])&&(s=e.map(l=>ku(l)));const o=r.write(s,t,i),a=new An(t,i,o,this.nextTensorId());if(this.trackTensor(a,r),i==="string"){const l=this.state.tensorInfo.get(o),u=Kee(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,i,r){i=i||"float32";const s={dataId:e,shape:t,dtype:i};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:i,shape:r,dtype:s}=e,o=new An(r,s,i,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,i,r){i=i||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const s=new u1(e,t,i,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let i=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(i=e.size*r1(e.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:i})),e instanceof u1||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const i=e.size*r1(e.dtype);this.state.numBytes-=i}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,i=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-i;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,i,r,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:i,saved:s},l=Y3(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=i[h],p=jr(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),r(u.length>1?u:u[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Gc(e),i=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!i.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,i,r=!1){if(B(t.length>0,()=>"gradients() received an empty list of xs."),i!=null&&i.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));B(s instanceof An,()=>"The result y returned by f() must be a tensor.");const o=EDe(this.state.activeTape,t,s);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=i??ODe(s.shape),IDe(a,o,u=>this.tidy(u),BDe);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return B(xd(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{B(t.every(a=>a instanceof An),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let i;const r={};t.forEach((a,l)=>{r[l]=a});const s=(a,l)=>(i=e(...t,l),B(i.value instanceof An,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),B(xd(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),o=(a,l)=>{const u=i.gradFunc(a,l),c=Array.isArray(u)?u:[u];B(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),B(c.every(d=>d instanceof An),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Ur(),i=await this.backend.time(e);return i.wallMs=Ur()-t,i}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new YK;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ly.nextTensorId=0;Ly.nextVariableId=0;function ODe(n){const e=r2(ke(n),"float32");return ne.makeTensor(e,n,"float32")}function mte(){const n=Qee();if(n._tfengine==null){const e=new Jee(n);n._tfengine=new Ly(e)}return aDe(n._tfengine.ENV),NDe(()=>n._tfengine),n._tfengine}const ne=mte();function BDe(n,e){const t={a:n,b:e};return ne.runKernel(gm,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zDe(){return typeof navigator<"u"&&navigator!=null}let rF;function GDe(n){rF=n}function Gz(n){if(rF!==void 0)return rF;if(n||zDe()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Vz(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const VDe=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:Vz,isMobile:Gz,mockIsMobile:GDe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ha=ve();ha.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ha.registerFlag("IS_BROWSER",()=>Vz());ha.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ha.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ha.registerFlag("PROD",()=>!1);ha.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ha.getBool("DEBUG"));ha.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ha.registerFlag("IS_TEST",()=>!1);ha.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ha.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ha.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ha.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(n,e){let t=n;if(Tr(n))return e==="string"?[]:[n.length];if(typeof n=="object"){if("texture"in n){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if("buffer"in n&&!(n.buffer instanceof ArrayBuffer))return[n.buffer.size/(e==null?4:r1(e))]}if(!Array.isArray(n))return[];const i=[];for(;Array.isArray(t)||Tr(t)&&e!=="string";)i.push(t.length),t=t[0];return Array.isArray(n)&&ve().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&gte(n,i,[]),i}function gte(n,e,t){if(t=t||[],!Array.isArray(n)&&!Tr(n)){B(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}B(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),B(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const i=e.slice(1);for(let r=0;r<n.length;++r)gte(n[r],i,t.concat(r))}function JK(n,e,t,i){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${i}' must be ${n} tensor, but got ${e} tensor`)}}function W(n,e,t,i="numeric"){if(n instanceof An)return JK(i,n.dtype,e,t),n;let r=s0(n);if(r!=="string"&&["bool","int32","float32"].indexOf(i)>=0&&(r=i),JK(i,r,e,t),n==null||!Tr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const a=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${a}'`)}const s=zu(n,r);!Tr(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?Od(n,r):Bu(n,[],!0);return ne.makeTensor(o,s,r)}function c1(n,e,t,i="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,s)=>W(r,`${e}[${s}]`,t,i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uz="__op";function ie(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const i=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Uz;const r=(...s)=>{ne.startScope(t);try{const o=i(...s);return Bc(o)&&console.error("Cannot return a Promise inside of tidy."),ne.endScope(o),o}catch(o){throw ne.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UDe(n,e){const t=W(n,"real","complex"),i=W(e,"imag","complex");qr(t.shape,i.shape,`real and imag shapes, ${t.shape} and ${i.shape}, must match in call to tf.complex().`);const r={real:t,imag:i};return ne.runKernel(h2,r)}const Vc=ie({complex_:UDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bd(n,e,t,i){if(i==null)i=s0(n);else if(i==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof n=="object"&&("texture"in n||"buffer"in n&&!(n.buffer instanceof ArrayBuffer))){if(i!=="float32"&&i!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return ne.backend.createTensorFromGPUData(n,e||t,i)}if(!Tr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Do(e);const r=ke(e),s=ke(t);B(r===s,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${s}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==ke(e.slice(o)):!0;B(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Tr(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=i!=="string"?Od(n,i):Bu(n,[],!0),ne.makeTensor(n,e,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi(n,e,t){const i=zu(n,t);return Bd(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sF={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nA=4;async function oF(n,e){const t=[],i=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((y,m)=>y+m.length,0)+nA*d.length,f=new Uint8Array(p);let g=0;for(let y=0;y<d.length;y++){const m=d[y],v=new Uint8Array(new Uint32Array([m.length]).buffer);f.set(v,g),g+=nA,f.set(m,g),g+=m.length}h(f)});i.push(c)}else i.push(l.data());e!=null&&(u.group=e),t.push(u)}const s=await Promise.all(i);return{data:$De(s),specs:t}}function $z(n,e){const t={};let i,r=0;for(const s of e){const o=s.name,a=s.dtype,l=s.shape,u=ke(l);let c;if("quantization"in s){const h=s.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${s.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=sF[h.dtype],p=n.slice(r,r+u*d),f=h.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];c[g]=y*h.scale+h.min}}else if(h.dtype==="float16")i===void 0&&(i=jDe()),c=i(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];c[g]=Math.round(y*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=u*d}else if(a==="string"){const h=ke(s.shape);c=[];for(let d=0;d<h;d++){const p=new Uint32Array(n.slice(r,r+nA))[0];r+=nA;const f=new Uint8Array(n.slice(r,r+p));c.push(f),r+=p}}else{const h=sF[a],d=n.slice(r,r+u*h);if(a==="float32")c=new Float32Array(d);else if(a==="int32")c=new Int32Array(d);else if(a==="bool")c=new Uint8Array(d);else if(a==="complex64"){c=new Float32Array(d);const p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let m=0;m<p.length;m++)p[m]=c[m*2],f[m]=c[m*2+1];const g=hi(p,l,"float32"),y=hi(f,l,"float32");t[o]=Vc(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=u*h}a!=="complex64"&&(t[o]=hi(c,l,a))}return t}function $De(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const i=new Uint8Array(e);let r=0;return t.forEach(s=>{i.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),i.buffer}const Wz=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function QK(n){return Wz?Buffer.byteLength(n):new Blob([n]).size}function WDe(n){if(Wz)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);return btoa(t)}function HDe(n){if(Wz){const i=Buffer.from(n,"base64");return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let i=0;i<e.length;++i)t.set([e.charCodeAt(i)],i);return t.buffer}function cI(n){if(n.length===1)return n[0];let e=0;n.forEach(r=>{e+=r.byteLength});const t=new Uint8Array(e);let i=0;return n.forEach(r=>{t.set(new Uint8Array(r),i),i+=r.byteLength}),t.buffer}function qK(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function yte(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Hz(n,e,t){const i={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(i.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");i.weightSpecs=e,i.weightData=t}return n.signature!=null&&(i.signature=n.signature),n.userDefinedMetadata!=null&&(i.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(i.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(i.initializerSignature=n.initializerSignature),i}async function Xz(n,e){let t,i;return n.weightsManifest!=null&&([t,i]=await e(n.weightsManifest)),Hz(n,t,i)}function nS(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:QK(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:QK(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Kz(n){const e=[];for(const t of n)e.push(...t.weights);return e}function XDe(){const n=t=>{let i=t<<13,r=0;for(;!(i&8388608);)r-=8388608,i<<=1;return i&=-8388609,r+=947912704,i|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function KDe(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function ZDe(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function jDe(){const n=XDe(),e=KDe(),t=ZDe();return i=>{const r=new ArrayBuffer(4*i.length),s=new Uint32Array(r);for(let o=0;o<i.length;o++){const a=i[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];s[o]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yi{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return yi.instance==null&&(yi.instance=new yi),yi.instance}static registerSaveRouter(e){yi.getInstance().saveRouters.push(e)}static registerLoadRouter(e){yi.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return yi.getHandlers(e,"save")}static getLoadHandlers(e,t){return yi.getHandlers(e,"load",t)}static getHandlers(e,t,i){const r=[];return(t==="load"?yi.getInstance().loadRouters:yi.getInstance().saveRouters).forEach(s=>{const o=s(e,i);o!==null&&r.push(o)}),r}}const YDe=n=>yi.registerSaveRouter(n),JDe=n=>yi.registerLoadRouter(n),bte=n=>yi.getSaveHandlers(n),xte=(n,e)=>yi.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF="tensorflowjs",lF=1,jp="models_store",Gh="model_info_store";function vte(){if(!ve().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function uF(n){const e=n.result;e.createObjectStore(jp,{keyPath:"modelPath"}),e.createObjectStore(Gh,{keyPath:"modelPath"})}class Lf{constructor(e){if(this.indexedDB=vte(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((i,r)=>{const s=this.indexedDB.open(aF,lF);s.onupgradeneeded=()=>uF(s),s.onsuccess=()=>{const o=s.result;if(t==null){const a=o.transaction(jp,"readonly"),l=a.objectStore(jp).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(l.result.modelArtifacts)},l.onerror=u=>(o.close(),r(l.error)),a.oncomplete=()=>o.close()}else{const a=nS(t),l=o.transaction(Gh,"readwrite");let u=l.objectStore(Gh);const c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;c.onsuccess=()=>{h=o.transaction(jp,"readwrite");const d=h.objectStore(jp).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>i({modelArtifactsInfo:a}),d.onerror=p=>{u=l.objectStore(Gh);const f=u.delete(this.modelPath);f.onsuccess=()=>(o.close(),r(d.error)),f.onerror=g=>(o.close(),r(d.error))}},c.onerror=d=>(o.close(),r(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},s.onerror=o=>r(s.error)})}}Lf.URL_SCHEME="indexeddb://";const wte=n=>ve().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Lf.URL_SCHEME)?QDe(n.slice(Lf.URL_SCHEME.length)):null;yi.registerSaveRouter(wte);yi.registerLoadRouter(wte);function QDe(n){return new Lf(n)}function qDe(n){return n.startsWith(Lf.URL_SCHEME)?n.slice(Lf.URL_SCHEME.length):n}class e3e{constructor(){this.indexedDB=vte()}async listModels(){return new Promise((e,t)=>{const i=this.indexedDB.open(aF,lF);i.onupgradeneeded=()=>uF(i),i.onsuccess=()=>{const r=i.result,s=r.transaction(Gh,"readonly"),o=s.objectStore(Gh).getAll();o.onsuccess=()=>{const a={};for(const l of o.result)a[l.modelPath]=l.modelArtifactsInfo;e(a)},o.onerror=a=>(r.close(),t(o.error)),s.oncomplete=()=>r.close()},i.onerror=r=>t(i.error)})}async removeModel(e){return e=qDe(e),new Promise((t,i)=>{const r=this.indexedDB.open(aF,lF);r.onupgradeneeded=()=>uF(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Gh,"readwrite"),a=o.objectStore(Gh),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return s.close(),i(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=s.transaction(jp,"readwrite");const d=u.objectStore(jp).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>i(l.error)};c.onsuccess=h,c.onerror=d=>(h(),s.close(),i(l.error))}},l.onerror=c=>(s.close(),i(l.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},r.onerror=s=>i(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mc="/",wg="tensorflowjs_models",Ste="info",t3e="model_topology",n3e="weight_specs",i3e="weight_data",r3e="model_metadata";function Tte(n){return{info:[wg,n,Ste].join(mc),topology:[wg,n,t3e].join(mc),weightSpecs:[wg,n,n3e].join(mc),weightData:[wg,n,i3e].join(mc),modelMetadata:[wg,n,r3e].join(mc)}}function Cte(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function s3e(n){const e=n.split(mc);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(mc)}function o3e(n){return n.startsWith(Pf.URL_SCHEME)?n.slice(Pf.URL_SCHEME.length):n}class Pf{constructor(e){if(!ve().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Tte(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),r=nS(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,i),this.LS.setItem(this.keys.weightData,WDe(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw Cte(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},i=JSON.parse(this.LS.getItem(this.keys.topology));if(i==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=i;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=HDe(o),t}}Pf.URL_SCHEME="localstorage://";const _te=n=>ve().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Pf.URL_SCHEME)?a3e(n.slice(Pf.URL_SCHEME.length)):null;yi.registerSaveRouter(_te);yi.registerLoadRouter(_te);function a3e(n){return new Pf(n)}class l3e{constructor(){B(ve().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),B(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=wg+mc,i=mc+Ste;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(i)){const o=s3e(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=o3e(e);const t=Tte(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const i=JSON.parse(this.LS.getItem(t.info));return Cte(t),i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ay="://";class Ts{constructor(){this.managers={}}static getInstance(){return Ts.instance==null&&(Ts.instance=new Ts),Ts.instance}static registerManager(e,t){B(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ay)&&(e=e.slice(0,e.indexOf(ay))),B(e.length>0,()=>"scheme must not be an empty string.");const i=Ts.getInstance();B(i.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),i.managers[e]=t}static getManager(e){const t=Ts.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ts.getInstance().managers)}}function K_(n){if(n.indexOf(ay)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ts.getSchemes().join(",")}`);return{scheme:n.split(ay)[0],path:n.split(ay)[1]}}async function Mte(n,e,t=!1){B(n!==e,()=>`Old path and new path are the same: '${n}'`);const i=yi.getLoadHandlers(n);B(i.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),B(i.length<2,()=>`Copying failed because more than one (${i.length}) load handlers for source URL ${n}.`);const r=i[0],s=yi.getSaveHandlers(e);B(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),B(s.length<2,()=>`Copying failed because more than one (${i.length}) save handlers for destination URL ${e}.`);const o=s[0],a=K_(n).scheme,l=K_(n).path,u=a===K_(n).scheme,c=await r.load();t&&u&&await Ts.getManager(a).removeModel(l);const h=await o.save(c);return t&&!u&&await Ts.getManager(a).removeModel(l),h.modelArtifactsInfo}async function u3e(){const n=Ts.getSchemes(),e={};for(const t of n){const i=await Ts.getManager(t).listModels();for(const r in i){const s=t+ay+r;e[s]=i[r]}}return e}async function c3e(n){const e=K_(n);return Ts.getManager(e.scheme).removeModel(e.path)}async function h3e(n,e){return Mte(n,e,!1)}async function d3e(n,e){return Mte(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p3e{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ve().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",i=>{if(i.source===window&&i.data.name===this.messageName){i.stopPropagation();const r=this.functionRefs[i.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if(ve().get("IS_BROWSER")){ve().setPlatform("browser",new p3e);try{Ts.registerManager(Pf.URL_SCHEME,new l3e)}catch{}try{Ts.registerManager(Lf.URL_SCHEME,new e3e)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f3e={importFetch:()=>require("node-fetch")};let GL;class m3e{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ve().global.fetch!=null?ve().global.fetch(e,t):(GL==null&&(GL=f3e.importFetch()),GL(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ve().get("IS_NODE")&&!ve().get("IS_BROWSER")&&ve().setPlatform("node",new m3e);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nn(n,e="float32",t){return e=e||"float32",Do(n),new mr(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3e(n,e){const t=W(n,"x","cast");if(!Xee(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const i={x:t},r={dtype:e};return ne.runKernel(p0,i,r)}const ot=ie({cast_:g3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3e(n){const e={x:W(n,"x","clone","string_or_numeric")};return ne.runKernel(M0,e)}const Ru=ie({clone_:y3e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */mte();const b3e={buffer:nn,cast:ot,clone:Ru,print:Zz};LDe(b3e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3e(){ve().set("PROD",!0)}function v3e(){ve().set("DEBUG",!0)}function w3e(){ve().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function S3e(n){ve().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function T3e(){ne.disposeVariables()}function Wn(){return ne}function h1(){return ne.memory()}function C3e(n){return ne.profile(n)}function me(n,e){return ne.tidy(n,e)}function jt(n){Gc(n).forEach(e=>e.dispose())}function Ri(n){return ne.keep(n)}function _3e(n){return ne.time(n)}function M3e(n){return ne.setBackend(n)}function A3e(){return ne.ready()}function E3e(){return ne.backendName}function I3e(n){ne.removeBackend(n)}function k3e(n){return ne.findBackend(n)}function R3e(n){return ne.findBackendFactory(n)}function jz(n,e,t=1){return ne.registerBackend(n,e,t)}function vc(){return ne.backend}function N3e(n,e){ve().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3e(n,e){let t=W(n,"a","add"),i=W(e,"b","add");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(gm,r)}const He=ie({add_:L3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3e(n,e){let t=W(n,"a","floorDiv"),i=W(e,"b","floorDiv");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(C0,r)}const hI=ie({floorDiv_:P3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3e(n,e){let t=W(n,"a","div"),i=W(e,"b","div");if([t,i]=Si(t,i),t.dtype==="int32"&&i.dtype==="int32")return hI(t,i);const r={a:t,b:i},s={};return ne.runKernel(b0,r,s)}const At=ie({div_:D3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F3e(n,e){let t=W(n,"a","mul"),i=W(e,"b","mul");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(D0,r)}const ae=ie({mul_:F3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3e(n){const e=W(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ne.runKernel(lw,t)}else{const t={x:e};return ne.runKernel(ew,t)}}const qi=ie({abs_:O3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3e(n){const e={x:W(n,"x","acos")};return ne.runKernel(o0,e)}const Yz=ie({acos_:B3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3e(n){const e={x:W(n,"x","acosh")};return ne.runKernel(a0,e)}const Jz=ie({acosh_:z3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3e(n,e=null,t=!1){const i={x:W(n,"x","all","bool")},r={axis:e,keepDims:t};return ne.runKernel(s2,i,r)}const dI=ie({all_:G3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3e(n,e=null,t=!1){const i={x:W(n,"x","any","bool")},r={axis:e,keepDims:t};return ne.runKernel(o2,i,r)}const d1=ie({any_:V3e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3e(n,e=0){const t={x:W(n,"x","argMax")},i={axis:e};return ne.runKernel(nw,t,i)}const Df=ie({argMax_:U3e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3e(n,e=0){const t={x:W(n,"x","argMin")},i={axis:e};return ne.runKernel(iw,t,i)}const Qz=ie({argMin_:$3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3e(n){const e={x:W(n,"x","asin")};return ne.runKernel(l0,e)}const qz=ie({asin_:W3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3e(n){const e={x:W(n,"x","asinh")};return ne.runKernel(u0,e)}const eG=ie({asinh_:H3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3e(n){const e={x:W(n,"x","atan")};return ne.runKernel(c0,e)}const tG=ie({atan_:X3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K3e(n,e){let t=W(n,"a","atan2"),i=W(e,"b","atan2");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(d0,r)}const nG=ie({atan2_:K3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(n){const e={x:W(n,"x","atanh")};return ne.runKernel(h0,e)}const iG=ie({atanh_:Z3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(n,e,t,i,r="NHWC",s){const o=n[3],a=[...e,o],l=Qc(r);return Ir(n,a,t,s,i,null,null,l)}function rl(n,e,t,i,r,s,o="channelsLast"){const[a,l]=p1(e);let u;if(o==="channelsLast")u=[a,l,n[3],n[3]];else if(o==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ir(n,u,t,i,r,s,!1,o)}function Jc(n,e,t,i,r,s,o="NDHWC"){const[a,l,u]=cF(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[a,l,u,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return zd(n,c,t,i,r,!1,h,s)}function Ir(n,e,t,i,r,s,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[g,y]=p1(t),[m,v]=p1(i),w=ly(d,m),S=ly(p,v),{padInfo:C,outHeight:_,outWidth:A}=J3e(r,u,c,g,y,w,S,s,a),I=o?f*h:f;let E;return a==="channelsFirst"?E=[l,I,_,A]:a==="channelsLast"&&(E=[l,_,A,I]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:_,outWidth:A,outChannels:I,padInfo:C,strideHeight:g,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:S,dilationHeight:m,dilationWidth:v,inShape:n,outShape:E,filterShape:e}}function zd(n,e,t,i,r,s=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h,d]=n;else if(o==="channelsFirst")[l,d,u,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,g,,y]=e,[m,v,w]=cF(t),[S,C,_]=cF(i),A=ly(p,S),I=ly(f,C),E=ly(g,_),{padInfo:k,outDepth:P,outHeight:V,outWidth:U}=Q3e(r,u,c,h,m,v,w,A,I,E,a),F=s?y*d:y;let $;return o==="channelsFirst"?$=[l,F,P,V,U]:o==="channelsLast"&&($=[l,P,V,U,F]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:P,outHeight:V,outWidth:U,outChannels:F,padInfo:k,strideDepth:m,strideHeight:v,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:A,effectiveFilterHeight:I,effectiveFilterWidth:E,dilationDepth:S,dilationHeight:C,dilationWidth:_,inShape:n,outShape:$,filterShape:e}}function j3e(n,e,t,i,r){i==null&&(i=rG(n,e,t));const s=n[0],o=n[1],a=f1((s-e+2*i)/t+1,r),l=f1((o-e+2*i)/t+1,r);return[a,l]}function Y3e(n,e,t,i,r,s){r==null&&(r=rG(n,e[0],i[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(o[a]=f1((n[a]-e[a]+2*r)/i[a]+1,s));return o}function rG(n,e,t,i=1){const r=ly(e,i);return Math.floor((n[0]*(t-1)-t+r)/2)}function p1(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function cF(n){return typeof n=="number"?[n,n,n]:n}function ly(n,e){return e<=1?n:n+(n-1)*(e-1)}function J3e(n,e,t,i,r,s,o,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=j3e([e,t],s,i,n,a);c=d[0],h=d[1]}else if(n==="same"){c=Math.ceil(e/i),h=Math.ceil(t/r);const d=Math.max(0,(c-1)*i+s-e),p=Math.max(0,(h-1)*r+o-t),f=Math.floor(d/2),g=d-f,y=Math.floor(p/2),m=p-y;u={top:f,bottom:g,left:y,right:m,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/i),h=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],g=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},c=f1((e-s+d+p)/i+1,a),h=f1((t-o+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function Q3e(n,e,t,i,r,s,o,a,l,u,c){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=Y3e([e,t,i,1],[a,l,u],1,[r,s,o],n,c);d=g[0],p=g[1],f=g[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/s),f=Math.ceil(i/o);const g=(d-1)*r+a-e,y=(p-1)*s+l-t,m=(f-1)*o+u-i,v=Math.floor(g/2),w=g-v,S=Math.floor(y/2),C=y-S,_=Math.floor(m/2),A=m-_;h={top:S,bottom:C,left:_,right:A,front:v,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function f1(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function vd(n){const[e,t,i]=p1(n);return e===1&&t===1&&i===1}function es(n,e){return vd(n)||vd(e)}function Ff(n){return p1(n).every(e=>e>0)}function Qc(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Ds(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")B(Nf(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(i=>{i.forEach(r=>{B(Nf(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3e(n,e){const t={x:W(n,"x","reshape","string_or_numeric")},i={shape:e};return ne.runKernel(Uw,t,i)}const ue=ie({reshape_:q3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eFe(n,e,t,i,r){const s=W(n,"x","avgPool","float32"),o=1;B(es(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]])),B(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Ds("avgPool",i,r);const u={x:a},c={filterSize:e,strides:t,pad:i,dimRoundingMode:r};let h=ne.runKernel(rw,u,c);return h=ot(h,s.dtype),l?ue(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const rS=ie({avgPool_:eFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tFe(n,e,t,i,r,s="NDHWC"){const o=W(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),B(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),B(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Ds("avgPool3d",i,r);const u={x:a},c={filterSize:e,strides:t,pad:i,dimRoundingMode:r,dataFormat:s};let h=ne.runKernel(sw,u,c);return h=ot(h,a.dtype),l?ue(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const sG=ie({avgPool3d_:tFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nFe(n,e=0){B(n.length>=1,()=>"Pass at least one tensor to concat");const t=c1(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Ru(t[0]);const i=t,r={axis:e};return ne.runKernel(uw,i,r)}const Hi=ie({concat_:nFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iFe(n,e,t=!1,i=!1){let r=W(n,"a","matMul"),s=W(e,"b","matMul");[r,s]=Si(r,s);const o={a:r,b:s},a={transposeA:t,transposeB:i};return ne.runKernel(ow,o,a)}const ln=ie({matMul_:iFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(n){const e={x:W(n,"x","sigmoid","float32")};return ne.runKernel(X0,e)}const Dl=ie({sigmoid_:rFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sFe(n,e,t){const i=W(n,"x","slice","string_or_numeric");if(i.rank===0)throw new Error("Slicing scalar is not possible");const r={x:i},s={begin:e,size:t};return ne.runKernel(Kw,r,s)}const vn=ie({slice_:sFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oFe(n){const e={x:W(n,"x","tanh","float32")};return ne.runKernel(Q0,e)}const Of=ie({tanh_:oFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aFe(n,e,t){const i=W(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);B(i.rank>=1+e.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`),B(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),B(i.shape[0]%r===0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const s={x:i},o={blockShape:e,crops:t};return ne.runKernel(aw,s,o)}const sS=ie({batchToSpaceND_:aFe});function lFe(n){let e;return n.rank===0||n.rank===1?e=ue(n,[1,1,1,n.size]):n.rank===2?e=ue(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ue(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uFe(n,e,t,i,r,s){s==null&&(s=.001);const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),l=W(t,"variance","batchNorm");let u;r!=null&&(u=W(r,"scale","batchNorm"));let c;i!=null&&(c=W(i,"offset","batchNorm")),B(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:lFe(o),scale:u,offset:c,mean:a,variance:l},d={varianceEpsilon:s},p=ne.runKernel(bw,h,d);return ue(p,o.shape)}const tb=ie({batchNorm_:uFe});function cFe(n,e,t,i,r,s){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),l=W(t,"variance","batchNorm");let u;r!=null&&(u=W(r,"scale","batchNorm"));let c;return i!=null&&(c=W(i,"offset","batchNorm")),B(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),B(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),B(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&B(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),tb(o,a,l,c,u,s)}const oG=ie({batchNorm2d_:cFe});function hFe(n,e,t,i,r,s){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),l=W(t,"variance","batchNorm");let u;r!=null&&(u=W(r,"scale","batchNorm"));let c;return i!=null&&(c=W(i,"offset","batchNorm")),B(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),B(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),B(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&B(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),tb(o,a,l,c,u,s)}const aG=ie({batchNorm3d_:hFe});function dFe(n,e,t,i,r,s){const o=W(n,"x","batchNorm"),a=W(e,"mean","batchNorm"),l=W(t,"variance","batchNorm");let u;r!=null&&(u=W(r,"scale","batchNorm"));let c;return i!=null&&(c=W(i,"offset","batchNorm")),B(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),B(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),B(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&B(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&B(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),tb(o,a,l,c,u,s)}const lG=ie({batchNorm4d_:dFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(n,e,t){const i=W(n,"x","bincount"),r=W(e,"weights","bincount");B(i.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(r.size===i.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${r.shape}.`);const s={x:i,weights:r},o={size:t};return ne.runKernel(u2,s,o)}const uG=ie({bincount_:pFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fFe(n,e){let t=W(n,"broadcastTo","x");const i=t.shape;if(Do(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=ue(t,l)}const r=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Ru(t);const o={x:t},a={reps:s};return ne.runKernel(q0,o,a)}const uf=ie({broadcastTo_:fFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mFe(n){const e={x:W(n,"x","ceil","float32")};return ne.runKernel(f0,e)}const cG=ie({ceil_:mFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bm(n,e,t){Do(n);const i={shape:n,value:e,dtype:t};return ne.runKernel(_2,{},i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gFe(n,e,t){const i=W(n,"x","clipByValue");if(B(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return bm(i.shape,e,i.dtype);const r={x:i},s={clipValueMin:e,clipValueMax:t};return ne.runKernel(m0,r,s)}const eo=ie({clipByValue_:gFe});function yFe(n){return Hi(n,0)}const hG=ie({concat1d_:yFe});function bFe(n,e){return Hi(n,e)}const dG=ie({concat2d_:bFe});function xFe(n,e){return Hi(n,e)}const pG=ie({concat3d_:xFe});function vFe(n,e){return Hi(n,e)}const fG=ie({concat4d_:vFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wFe(n,e,t,i,r="NHWC",s=[1,1],o){const a=W(n,"x","conv2d","float32"),l=W(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),B(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),B(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Ds("conv2d",i,o);const h=r==="NHWC"?u.shape[3]:u.shape[1];B(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),B(es(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),B(Ff(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),B(Ff(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},f=ne.runKernel(cw,d,p);return c?ue(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Uc=ie({conv2d_:wFe});function SFe(n,e,t,i,r="NWC",s=1,o){const a=W(n,"x","conv1d"),l=W(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=ue(a,[1,a.shape[0],a.shape[1]])),B(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),B(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Ds("conv1d",i,o),B(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),B(es(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),B(Ff(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),B(Ff(t),()=>"Error in conv1D: Stride should be larger than 0."),B(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=ue(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ue(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Uc(d,h,[1,t],i,"NHWC",[1,s],o);return c?ue(p,[p.shape[2],p.shape[3]]):ue(p,[p.shape[0],p.shape[2],p.shape[3]])}const pI=ie({conv1d_:SFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TFe(n,e,t,i,r,s="NHWC",o){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),B(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),B(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),B(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=s==="NHWC"?a[3]:a[1],h=s==="NHWC"?l.shape[3]:l.shape[1];B(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),B(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Ds("conv2dDerInput",r,o);const d={dy:l,filter:t},p={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:a},f=ne.runKernel(hw,d,p);return u?ue(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const mG=ie({conv2DBackpropInput_:TFe});function CFe(n,e,t,i,r,s){const o=W(n,"x","conv2dTranspose"),a=W(e,"filter","conv2dTranspose");return mG(t,o,a,i,r,"NHWC",s)}const fI=ie({conv2dTranspose_:CFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Fe(n,e,t,i,r="NDHWC",s=[1,1,1]){const o=W(n,"x","conv3d"),a=W(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),B(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),B(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),B(es(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),B(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),B(Ff(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),B(Ff(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:i,dataFormat:r,dilations:s},d=ne.runKernel(dw,c,h);return u?ue(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const gG=ie({conv3d_:_Fe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MFe(n,e,t,i,r){B(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let s=n,o=e,a=!1;e.rank===4&&(a=!0,o=ue(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const l=s[4],u=o.shape[4];B(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),B(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),B(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),B(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),B(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},h={pad:r,strides:i,inputShape:s},d=ne.runKernel(f2,c,h);return a?ue(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Ate=ie({conv3DBackpropInput_:MFe});function AFe(n,e,t,i,r){const s=W(n,"x","conv3dTranspose"),o=W(e,"filter","conv3dTranspose");return Ate(t,s,o,i,r)}const yG=ie({conv3dTranspose_:AFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EFe(n){const e={x:W(n,"x","cos","float32")};return ne.runKernel(g0,e)}const oS=ie({cos_:EFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IFe(n){const e={x:W(n,"x","cosh","float32")};return ne.runKernel(y0,e)}const mI=ie({cosh_:IFe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kFe(n,e=0,t=!1,i=!1){const r={x:W(n,"x","cumprod")},s={axis:e,exclusive:t,reverse:i};return ne.runKernel(m2,r,s)}const m1=ie({cumprod_:kFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RFe(n,e=0,t=!1,i=!1){const r={x:W(n,"x","cumsum")},s={axis:e,exclusive:t,reverse:i};return ne.runKernel(pw,r,s)}const gI=ie({cumsum_:RFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NFe(n,e,t,i=!1){const r=W(n,"x","denseBincount"),s=W(e,"weights","denseBincount");B(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),B(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),B(t>=0,()=>`size must be non-negative, but got ${t}.`),B(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},a={size:t,binaryOutput:i};return ne.runKernel(y2,o,a)}const iA=ie({denseBincount_:NFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LFe(n,e,t="NHWC"){const i=W(n,"x","depthToSpace","float32"),r=t==="NHWC"?i.shape[1]:i.shape[2],s=t==="NHWC"?i.shape[2]:i.shape[3],o=t==="NHWC"?i.shape[3]:i.shape[1];B(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),B(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${i.shape}`),B(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${i.shape}`),B(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${i.shape}`);const a={x:i},l={blockSize:e,dataFormat:t};return ne.runKernel(b2,a,l)}const bG=ie({depthToSpace_:LFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PFe(n,e,t,i,r="NHWC",s=[1,1],o){const a=W(n,"x","depthwiseConv2d","float32"),l=W(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),B(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),B(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];B(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ds("depthwiseConv2d",i,o);const d={x:u,filter:l},p={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},f=ne.runKernel(fw,d,p);return c?ue(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const nb=ie({depthwiseConv2d_:PFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DFe(n,e,t,i,r=[1,1],s="NHWC"){const o=W(n,"x","dilation2d"),a=W(e,"filter","dilation2d");B(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),B(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),B(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,u=!1;o.rank===3&&(l=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),B(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:i,dilations:r},d=ne.runKernel(mw,c,h);return u?ue(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const xG=ie({dilation2d_:DFe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(n,e){const t=n.length,i=[];for(let r=0;r<t;r++){const s=t-1-r,o=n[s]||1;(e[e.length-1-r]||1)>1&&o===1&&i.unshift(s)}return i}function rr(n,e){const t=[];for(let i=0;i<e.length;i++){const r=n[n.length-i-1],s=e.length-i-1,o=e[s];(r==null||r===1&&o>1)&&t.unshift(s)}return t}function Yt(n,e){const t=[],i=Math.max(n.length,e.length);for(let r=0;r<i;r++){let s=n[n.length-r-1];s==null&&(s=1);let o=e[e.length-r-1];if(o==null&&(o=1),s===1)t.unshift(o);else if(o===1)t.unshift(s);else if(s!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(s)}return t}const FFe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Yt,getBroadcastDims:Bf,getReductionAxes:rr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OFe(n,e){let t=W(n,"a","equal","string_or_numeric"),i=W(e,"b","equal","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(gw,r)}const ko=ie({equal_:OFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BFe(n,e,t){const i=W(e,"a","where"),r=W(t,"b","where"),s=W(n,"condition","where","bool"),o=Yt(Yt(s.shape,i.shape),r.shape),a=uf(s,o),l=uf(i,o),u=uf(r,o),c={condition:a,t:l,e:u};return ne.runKernel(Xw,c)}const ds=ie({where_:BFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zFe(n){const e={x:W(n,"x","zerosLike")};return ne.runKernel(eS,e)}const wn=ie({zerosLike_:zFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GFe(n,e){let t=W(n,"a","div"),i=W(e,"b","div");[t,i]=Si(t,i);const r=At(t,i),s=wn(r),o=ko(i,s);return ds(o,s,r)}const vG=ie({divNoNan_:GFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VFe(n,e){const t=W(n,"t1","dot"),i=W(e,"t2","dot");B((t.rank===1||t.rank===2)&&(i.rank===1||i.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${i.rank}.`);const r=t.rank===1?t.size:t.shape[1],s=i.rank===1?i.size:i.shape[0];if(B(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),t.rank===1&&i.rank===1){const o=ue(t,[1,-1]),a=ue(i,[-1,1]),l=ln(o,a);return ue(l,[])}else if(t.rank===1&&i.rank===2){const o=ue(t,[1,-1]),a=ue(i,[i.shape[0],i.shape[1]]),l=ln(o,a);return ue(l,[l.size])}else if(t.rank===2&&i.rank===1){const o=ue(i,[-1,1]),a=ln(t,o);return ue(a,[a.size])}else{const o=ue(i,[i.shape[0],i.shape[1]]);return ln(t,o)}}const wG=ie({dot_:VFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UFe(n){const e={x:W(n,"x","elu","float32")};return ne.runKernel(x0,e)}const ib=ie({elu_:UFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Fe(n){let e=W(n,"x","erf");B(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ot(e,"float32"));const t={x:e};return ne.runKernel(v0,t)}const SG=ie({erf_:$Fe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Ete(n,e,t){const i=n.length+e.length,r=[];let s=0,o=0;for(let a=0;a<i;a++)t.indexOf(a)===-1?r.push(n[s++]):r.push(e[o++]);return r}function kr(n,e){const t=[],i=n.length;for(let s=0;s<i;s++)e.indexOf(s)===-1&&t.push(n[s]);const r=e.map(s=>n[s]);return[t,r]}function Xi(n,e){const t=e.map(i=>1);return Ete(n,t,e)}function ts(n,e,t){B(TG(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Ti(n,e){if(TG(n,e))return null;const t=[];for(let i=0;i<e;++i)n.indexOf(i)===-1&&t.push(i);return n.forEach(i=>t.push(i)),t}function Gd(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Ki(n,e){const t=[];for(let i=e-n;i<e;++i)t.push(i);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WFe(n,e=null,t=!1){const i={x:W(n,"x","max")},r={reductionIndices:e,keepDims:t};return ne.runKernel(Ew,i,r)}const la=ie({max_:WFe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HFe(n,e=null,t=!1){const i={x:W(n,"x","min")},r={axis:e,keepDims:t};return ne.runKernel(Nw,i,r)}const Py=ie({min_:HFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XFe(n,e){let t=W(n,"base","pow"),i=W(e,"exp","pow");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(F0,r)}const $c=ie({pow_:XFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nt(n,e){if((Tr(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Tr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Bd(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KFe(n){const e={x:W(n,"x","sqrt","float32")};return ne.runKernel(Z0,e)}const Yr=ie({sqrt_:KFe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZFe(n){const e=W(n,"x","square"),t={};return ne.runKernel("Square",{x:e},t)}const Vn=ie({square_:ZFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(n,e=null,t=!1){let i=W(n,"x","sum");i.dtype==="bool"&&(i=ot(i,"int32"));const r={x:i},s={axis:e,keepDims:t};return ne.runKernel(Zw,r,s)}const wt=ie({sum_:jFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YFe(n,e="euclidean",t=null,i=!1){n=W(n,"x","norm");const r=Ite(n,e,t);let s=r.shape;if(i){const o=un(t,n.shape);s=Xi(r.shape,o)}return ue(r,s)}function Ite(n,e,t=null){if(n.rank===0)return qi(n);if(n.rank!==1&&t===null)return Ite(ue(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return wt(qi(n),t);if(e===1/0)return la(qi(n),t);if(e===-1/0)return Py(qi(n),t);if(e==="euclidean"||e===2)return Yr(wt($c(qi(n),Nt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return la(wt(qi(n),t[0]),t[1]-1);if(e===1/0)return la(wt(qi(n),t[1]),t[0]);if(e===-1/0)return Py(wt(qi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Yr(wt(Vn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const rb=ie({norm_:YFe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JFe(n,e=null,t=!1){return rb(n,"euclidean",e,t)}const CG=ie({euclideanNorm_:JFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QFe(n){const e={x:W(n,"x","exp")};return ne.runKernel(w0,e)}const Ro=ie({exp_:QFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qFe(n,e=0){const t=W(n,"x","expandDims","string_or_numeric");B(e<=t.rank,()=>"Axis must be <= rank of the tensor");const i={input:t},r={dim:e};return ne.runKernel(yw,i,r)}const as=ie({expandDims_:qFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eOe(n){const e={x:W(n,"x","expm1")};return ne.runKernel(S0,e)}const _G=ie({expm1_:eOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tOe(n,e){const t=W(n,"x","tile","string_or_numeric");B(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const i={x:t},r={reps:e};return ne.runKernel(q0,i,r)}const Qo=ie({tile_:tOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nOe(n,e,t,i="float32"){e==null&&(e=n);const r=nn([n,e],i),s=n<=e?n:e;for(let a=0;a<s;++a)r.set(1,a,a);const o=ue(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Qo(as(o,0),[t[0],1,1]);if(t.length===2)return Qo(as(as(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Qo(as(as(as(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const yI=ie({eye_:nOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iOe(n){const e={x:W(n,"x","floor","float32")};return ne.runKernel(T0,e)}const sb=ie({floor_:iOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rOe(n,e,t=0,i=0){const r=W(n,"x","gather"),s=W(e,"indices","gather","int32"),o={x:r,indices:s},a={axis:t,batchDims:i};return ne.runKernel(xw,o,a)}const ob=ie({gather_:rOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sOe(n,e){let t=W(n,"a","greater","string_or_numeric"),i=W(e,"b","greater","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(vw,r)}const Fs=ie({greater_:sOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oOe(n,e){let t=W(n,"a","greaterEqual","string_or_numeric"),i=W(e,"b","greaterEqual","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(_0,r)}const qc=ie({greaterEqual_:oOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aOe(n){const e={input:W(n,"input","imag")};return ne.runKernel(I2,e)}const aS=ie({imag_:aOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lOe(n){const e={x:W(n,"x","isFinite")};return ne.runKernel(A0,e)}const MG=ie({isFinite_:lOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uOe(n){const e={x:W(n,"x","isInf")};return ne.runKernel(E0,e)}const AG=ie({isInf_:uOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cOe(n){const e={x:W(n,"x","isNaN")};return ne.runKernel(I0,e)}const EG=ie({isNaN_:cOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hOe(n,e=.2){const t={x:W(n,"x","leakyRelu")},i={alpha:e};return ne.runKernel(ww,t,i)}const lS=ie({leakyRelu_:hOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dOe(n,e){let t=W(n,"a","less","string_or_numeric"),i=W(e,"b","less","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(Sw,r)}const bI=ie({less_:dOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pOe(n,e){let t=W(n,"a","lessEqual","string_or_numeric"),i=W(e,"b","lessEqual","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(Tw,r)}const Vd=ie({lessEqual_:pOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fOe(n,e=5,t=1,i=1,r=.5){const s=W(n,"x","localResponseNormalization");B(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),B(Nf(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;s.rank===3&&(a=!0,o=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},u={depthRadius:e,bias:t,alpha:i,beta:r},c=ne.runKernel(Aw,l,u);return a?ue(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const IG=ie({localResponseNormalization_:fOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mOe(n){const e={x:W(n,"x","log","float32")};return ne.runKernel(k0,e)}const No=ie({log_:mOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gOe(n){const e={x:W(n,"x","log1p")};return ne.runKernel(R0,e)}const uS=ie({log1p_:gOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOe(n){return B(xd(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const i=W(e,"x","tf.grad","string_or_numeric"),r=t!=null?W(t,"dy","tf.grad"):null;return ne.tidy(()=>{const{value:s,grads:o}=ne.gradients(()=>n(i),[i],r);return r!=null&&qr(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),xI(o),o[0]})}}function bOe(n){return B(xd(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{B(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const i=c1(e,"args","tf.grads","string_or_numeric"),r=t!=null?W(t,"dy","tf.grads"):null;return ne.tidy(()=>{const{value:s,grads:o}=ne.gradients(()=>n(...i),i,r);return r!=null&&qr(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xI(o),o})}}function xOe(n){return B(xd(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{B(e instanceof An,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),B(t==null||t instanceof An,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:i,value:r}=ne.gradients(()=>n(e),[e],t);return xI(i),{grad:i[0],value:r}}}function vOe(n){return B(xd(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{B(Array.isArray(e)&&e.every(r=>r instanceof An),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),B(t==null||t instanceof An,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const i=ne.gradients(()=>n(...e),e,t);return t!=null&&qr(i.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xI(i.grads),i}}function kte(n,e){B(xd(n),()=>"The f passed in variableGrads(f) must be a function"),B(e==null||Array.isArray(e)&&e.every(u=>u instanceof u1),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in ne.registeredVariables)e.push(ne.registeredVariables[u])}const i=t?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),B(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const s=!0,{value:o,grads:a}=ne.gradients(n,e,null,s);B(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),B(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),i!=null&&i.forEach(u=>l[u.name]=null),{value:o,grads:l}}function Gu(n){return ne.customGrad(n)}function xI(n){if(n.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wOe(n){const e={x:W(n,"x","neg")};return ne.runKernel(Pw,e)}const si=ie({neg_:wOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SOe(n){const e={x:W(n,"x","softplus")};return ne.runKernel(K0,e)}const xm=ie({softplus_:SOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TOe(n){const e=W(n,"x","logSigmoid");return Gu(t=>({value:si(xm(si(t))),gradFunc:i=>ae(i,Dl(si(t)))}))(e)}const kG=ie({logSigmoid_:TOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function COe(n,e){let t=W(n,"a","sub"),i=W(e,"b","sub");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(Y0,r)}const xt=ie({sub_:COe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Oe(n,e=-1){const t=W(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Gu((i,r)=>{const s=la(i,e,!0),o=xt(i,s),a=xt(ot(o,"float32"),No(wt(Ro(o),e,!0)));return r([a]),{value:a,gradFunc:(l,u)=>{const[c]=u,h=!0,d=Ro(c);return xt(l,ae(wt(l,e,h),d))}}})(t)}const vI=ie({logSoftmax_:_Oe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MOe(n,e=null,t=!1){const i=W(n,"x","logSumExp"),r=un(e,i.shape),s=la(i,r,!0),o=xt(i,s),a=Ro(o),l=wt(a,r),u=No(l),c=He(ue(s,u.shape),u);if(t){const h=Xi(c.shape,r);return ue(c,h)}return c}const wI=ie({logSumExp_:MOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AOe(n,e){const t=W(n,"a","logicalAnd","bool"),i=W(e,"b","logicalAnd","bool");Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(Cw,r)}const tl=ie({logicalAnd_:AOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EOe(n){const e={x:W(n,"x","logicalNot","bool")};return ne.runKernel(_w,e)}const cS=ie({logicalNot_:EOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IOe(n,e){const t=W(n,"a","logicalOr","bool"),i=W(e,"b","logicalOr","bool");Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(Mw,r)}const SI=ie({logicalOr_:IOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kOe(n,e){const t=W(n,"a","logicalXor","bool"),i=W(e,"b","logicalXor","bool");return Yt(t.shape,i.shape),tl(SI(n,e),cS(tl(n,e)))}const RG=ie({logicalXor_:kOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ROe(n,e,t,i,r){const s=W(n,"x","maxPool"),o=1;let a=s,l=!1;s.rank===3&&(l=!0,a=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]])),B(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),B(es(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Ds("maxPool",i,r);const u={x:a},c={filterSize:e,strides:t,pad:i,dimRoundingMode:r},h=ne.runKernel(Iw,u,c);return l?ue(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const hS=ie({maxPool_:ROe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NOe(n,e=[1,1,1],t,i,r,s="NDHWC"){const o=W(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),B(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Ds("maxPool3d",i,r);const u={x:a},c={filterSize:e,strides:t,pad:i,dimRoundingMode:r,dataFormat:s},h=ne.runKernel(kw,u,c);return l?ue(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const NG=ie({maxPool3d_:NOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LOe(n,e){let t=W(n,"a","maximum"),i=W(e,"b","maximum");[t,i]=Si(t,i),t.dtype==="bool"&&(t=ot(t,"int32"),i=ot(i,"int32")),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(N0,r)}const Hu=ie({maximum_:LOe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function POe(n,e=null,t=!1){const i={x:W(n,"x","mean")},r={axis:e,keepDims:t};return ne.runKernel(Rw,i,r)}const vi=ie({mean_:POe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(n,e="float32"){if(Do(n),e==="complex64"){const i=tr(n,"float32"),r=tr(n,"float32");return Vc(i,r)}const t=jr(ke(n),e);return ne.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(n,e="float32"){if(Do(n),e==="complex64"){const i=_o(n,"float32"),r=tr(n,"float32");return Vc(i,r)}const t=r2(ke(n),e);return ne.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DOe(n,e){let t=W(n,"a","minimum"),i=W(e,"b","minimum");[t,i]=Si(t,i),t.dtype==="bool"&&(t=ot(t,"int32"),i=ot(i,"int32")),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(L0,r)}const ab=ie({minimum_:DOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOe(n,e,t){B(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const i=W(n,"x","mirrorPad");if(i.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");B(e.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<i.rank;a++)B(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),B(e[a][0]>=0&&e[a][0]<=i.shape[a]-r&&e[a][1]>=0&&e[a][1]<=i.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${i.shape[a]-r} or less than 0 for input of shape ${i.shape}`);const s={paddings:e,mode:t},o={x:i};return ne.runKernel(Lw,o,s)}const LG=ie({mirrorPad_:FOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OOe(n,e){let t=W(n,"a","mod"),i=W(e,"b","mod");[t,i]=Si(t,i);const r={a:t,b:i};return ne.runKernel(P0,r)}const PG=ie({mod_:OOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BOe(n,e=null,t=!1){n=W(n,"x","moments");const i=un(e,n.shape),r=vi(n,i,t);let s=r.shape;t||(s=Xi(r.shape,i));const o=Vn(xt(ot(n,"float32"),ue(r,s))),a=vi(o,i,t);return{mean:r,variance:a}}const dS=ie({moments_:BOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOe(n,e){let t=W(n,"a","notEqual","string_or_numeric"),i=W(e,"b","notEqual","string_or_numeric");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i};return ne.runKernel(Dw,r)}const zf=ie({notEqual_:zOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GOe(n,e,t=1,i=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:W(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:i};return ne.runKernel(Ow,s,o)}const Dy=ie({oneHot_:GOe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VOe(n){const e={x:W(n,"x","onesLike")};return ne.runKernel(Fw,e)}const Lo=ie({onesLike_:VOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UOe(n,e,t=0){const i=W(n,"x","pad");if(i.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},s={x:i};return ne.runKernel(zw,s,r)}const eh=ie({pad_:UOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Oe(n,e,t){const i=W(n,"x","spaceToBatchND");B(i.rank>=1+e.length,()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`),B(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),B(i.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:i},s={blockShape:e,paddings:t};return ne.runKernel(jw,r,s)}const pS=ie({spaceToBatchND_:$Oe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WOe(n,e,t,i,r,s,o){r==null&&(r=[1,1]),s==null&&(s=1),i===0&&(i="valid");const a=W(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),B(es(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);const c=rl(l.shape,e,s,r,i),h=[c.dilationHeight,c.dilationWidth];let d;i==="same"?d=XOe([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,g]=HOe([c.inHeight,c.inWidth],h,d),y=p?i:"valid",m=p?l:pS(l,h,f),v=(t==="avg"?()=>rS(m,e,s,y,o):()=>hS(m,e,s,y,o))(),w=p?v:sS(v,h,g);return u?ue(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function HOe(n,e,t){const i=t.map(c=>c[0]),r=t.map(c=>c[1]),s=n.concat(i,r),o=e.map((c,h)=>(c-s[h]%c)%c),a=r.map((c,h)=>c+o[h]),l=e.map((c,h)=>[i[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function XOe(n,e){const t=n.map((s,o)=>s+(s-1)*(e[o]-1)).map(s=>s-1),i=t.map(s=>Math.floor(s/2)),r=t.map((s,o)=>s-i[o]);return t.map((s,o)=>[i[o],r[o]])}const DG=ie({pool_:WOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KOe(n,e){const t=W(n,"x","prelu"),i=W(e,"alpha","prelu"),r={x:t,alpha:i};return ne.runKernel(Gw,r)}const fS=ie({prelu_:KOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZOe(n,e=null,t=!1){let i=W(n,"x","prod");i.dtype==="bool"&&(i=ot(i,"int32"));const r={x:i},s={axis:e,keepDims:t};return ne.runKernel(Vw,r,s)}const FG=ie({prod_:ZOe});var Rte={exports:{}};(function(n){(function(e,t,i){function r(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function s(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&s(h,c),d.state=function(){return s(c,{})}),d}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.alea=o})(pm,n,!1)})(Rte);var jOe=Rte.exports,Nte={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xor128=o})(pm,n,!1)})(Nte);var YOe=Nte.exports,Lte={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xorwow=o})(pm,n,!1)})(Lte);var JOe=Lte.exports,Pte={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xorshift7=o})(pm,n,!1)})(Pte);var QOe=Pte.exports,Dte={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,g,y,m=[],v=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,v=Math.max(v,h.length)),f=0,g=-32;g<v;++g)h&&(p^=h.charCodeAt((g+32)%h.length)),g===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(y=y+1640531527|0,d=m[g&127]^=p+y,f=d==0?f+1:0);for(f>=128&&(m[(h&&h.length||0)&127]=-1),f=127,g=4*128;g>0;--g)p=m[f+34&127],d=m[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,m[f]=p^d;c.w=y,c.X=m,c.i=f}u(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.xor4096=o})(pm,n,!1)})(Dte);var qOe=Dte.exports,Fte={exports:{}};(function(n){(function(e,t,i){function r(a){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}t&&t.exports?t.exports=o:i&&i.amd?i(function(){return o}):this.tychei=o})(pm,n,!1)})(Fte);var eBe=Fte.exports,Ote={exports:{}};const tBe={},nBe=Object.freeze(Object.defineProperty({__proto__:null,default:tBe},Symbol.toStringTag,{value:"Module"})),iBe=UPe(nBe);(function(n){(function(e,t,i){var r=256,s=6,o=52,a="random",l=i.pow(r,s),u=i.pow(2,o),c=u*2,h=r-1,d;function p(S,C,_){var A=[];C=C==!0?{entropy:!0}:C||{};var I=m(y(C.entropy?[S,w(t)]:S??v(),3),A),E=new f(A),k=function(){for(var P=E.g(s),V=l,U=0;P<u;)P=(P+U)*r,V*=r,U=E.g(1);for(;P>=c;)P/=2,V/=2,U>>>=1;return(P+U)/V};return k.int32=function(){return E.g(4)|0},k.quick=function(){return E.g(4)/4294967296},k.double=k,m(w(E.S),t),(C.pass||_||function(P,V,U,F){return F&&(F.S&&g(F,E),P.state=function(){return g(E,{})}),U?(i[a]=P,V):P})(k,I,"global"in C?C.global:this==i,C.state)}function f(S){var C,_=S.length,A=this,I=0,E=A.i=A.j=0,k=A.S=[];for(_||(S=[_++]);I<r;)k[I]=I++;for(I=0;I<r;I++)k[I]=k[E=h&E+S[I%_]+(C=k[I])],k[E]=C;(A.g=function(P){for(var V,U=0,F=A.i,$=A.j,J=A.S;P--;)V=J[F=h&F+1],U=U*r+J[h&(J[F]=J[$=h&$+V])+(J[$]=V)];return A.i=F,A.j=$,U})(r)}function g(S,C){return C.i=S.i,C.j=S.j,C.S=S.S.slice(),C}function y(S,C){var _=[],A=typeof S,I;if(C&&A=="object")for(I in S)try{_.push(y(S[I],C-1))}catch{}return _.length?_:A=="string"?S:S+"\0"}function m(S,C){for(var _=S+"",A,I=0;I<_.length;)C[h&I]=h&(A^=C[h&I]*19)+_.charCodeAt(I++);return w(C)}function v(){try{var S;return d&&(S=d.randomBytes)?S=S(r):(S=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(S)),w(S)}catch{var C=e.navigator,_=C&&C.plugins;return[+new Date,e,_,e.screen,w(t)]}}function w(S){return String.fromCharCode.apply(0,S)}if(m(i.random(),t),n.exports){n.exports=p;try{d=iBe}catch{}}else i["seed"+a]=p})(typeof self<"u"?self:pm,[],Math)})(Ote);var rBe=Ote.exports,sBe=jOe,oBe=YOe,aBe=JOe,lBe=QOe,uBe=qOe,cBe=eBe,vm=rBe;vm.alea=sBe;vm.xor128=oBe;vm.xorwow=aBe;vm.xorshift7=lBe;vm.xor4096=uBe;vm.tychei=cBe;var lb=vm;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OG{constructor(e,t,i,r,s){this.mean=e,this.stdDev=t,this.dtype=i,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=lb.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,i=!1;for(;!i;){let r,s,o;do r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(i=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class hBe{constructor(e,t,i,r){this.alpha=e,this.beta=1/t,this.dtype=i;const s=r||Math.random();this.randu=lb.alea(s.toString()),this.randn=new OG(0,1,i,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,i,r,s,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,i=.5*e+this.d*(1-o+Math.log(o)),s=this.randu(),s<t||Math.log(s)<i)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class dBe{constructor(e=0,t=1,i,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=i,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=lb.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pBe(n,e=0,t=1,i,r){if(Do(n),i!=null&&i==="bool")throw new Error(`Unsupported data type ${i}`);const s=new OG(e,t,i,!1,r),o=nn(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const TI=ie({randomNormal_:pBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fBe(n,e=0,t=1,i="float32",r){Do(n);const s=nn(n,i),o=new dBe(e,t,null,r);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}const ub=ie({randomUniform_:fBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(n,e,t=1,i="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:i};return ne.runKernel(U2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mBe(n){const e={input:W(n,"input","real")};return ne.runKernel($2,e)}const Fy=ie({real_:mBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gBe(n){const e={x:W(n,"x","reciprocal")};return ne.runKernel(O0,e)}const BG=ie({reciprocal_:gBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yBe(n){const e={x:W(n,"x","relu")};return ne.runKernel(B0,e)}const jl=ie({relu_:yBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bBe(n){const e={x:W(n,"x","relu6")};return ne.runKernel(z0,e)}const CI=ie({relu6_:bBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xBe(n,e){const t={x:W(n,"x","reverse")},i={dims:e};return ne.runKernel(Hw,t,i)}const da=ie({reverse_:xBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vBe(n){const e={x:W(n,"x","round")};return ne.runKernel(G0,e)}const _I=ie({round_:vBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wBe(n){const e={x:W(n,"x","rsqrt","float32")};return ne.runKernel(V0,e)}const MI=ie({rsqrt_:wBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SBe(n){const e={x:W(n,"x","selu")};return ne.runKernel(U0,e)}const AI=ie({selu_:SBe});function TBe(n,e,t,i,r,s=[1,1],o="NHWC"){const a=W(n,"x","separableConv2d"),l=W(e,"depthwiseFilter","separableConv2d"),u=W(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");B(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),B(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),B(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),B(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),B(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];B(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=nb(c,l,i,r,o,s),g=Uc(f,u,1,"valid",o);return h?ue(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const EI=ie({separableConv2d_:TBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CBe(n){const e={x:W(n,"x","sign")};return ne.runKernel(H0,e)}const zG=ie({sign_:CBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Be(n){const e={x:W(n,"x","sin","float32")};return ne.runKernel($0,e)}const II=ie({sin_:_Be});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MBe(n){const e={x:W(n,"x","sinh")};return ne.runKernel(W0,e)}const kI=ie({sinh_:MBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ABe(n,e,t){const i=W(n,"x","slice1d");return B(i.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`),vn(i,[e],[t])}const mS=ie({slice1d_:ABe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EBe(n,e,t){const i=W(n,"x","slice2d");return B(i.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`),vn(i,e,t)}const RI=ie({slice2d_:EBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IBe(n,e,t){const i=W(n,"x","slice3d");return B(i.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`),vn(i,e,t)}const gS=ie({slice3d_:IBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kBe(n,e,t){const i=W(n,"x","slice4d");return B(i.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`),vn(i,e,t)}const Oy=ie({slice4d_:kBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RBe(n,e=-1){const t=W(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const i={logits:t},r={dim:e};return ne.runKernel(Jw,i,r)}const yS=ie({softmax_:RBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NBe(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ne.runKernel(C2,e)}const bS=ie({fft_:NBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LBe(n){B(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ne.runKernel(E2,e)}const By=ie({ifft_:LBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PBe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let i;if(e<=2){const r=ue(n,[t,e]);i=By(r)}else{const r=[t,2*(e-1)],s=ue(Fy(n),[t,e]),o=ue(aS(n),[t,e]),a=da(vn(s,[0,1],[t,e-2]),1),l=ae(da(vn(o,[0,1],[t,e-2]),1),Nt(-1)),u=Hi([s,a],1),c=Hi([o,l],1),h=ue(Vc(u,c),[r[0],r[1]]);i=By(h)}if(i=Fy(i),n.rank===3&&n.shape[0]!==0){const r=i,s=n.shape[0];i=ue(i,[s,i.shape[0]/s,i.shape[1]]),r.dispose()}return i}const NI=ie({irfft_:PBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DBe(n,e,t=0){const i={x:W(n,"x","split")},r={numOrSizeSplits:e,axis:t};return ne.runKernel(Yw,i,r)}const Js=ie({split_:DBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FBe(n,e){B(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const i=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,r=vn(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,r=Hi([n,tr(f)],n.shape.length-1),t=e}else r=n;const s=wn(r),o=ue(Vc(r,s),[i,t]),a=bS(o),l=Math.floor(t/2)+1,u=Fy(a),c=aS(a),h=Js(u,[l,t-l],u.shape.length-1),d=Js(c,[l,t-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,ue(Vc(h[0],d[0]),p)}const xS=ie({rfft_:FBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OBe(n,e){let t=W(n,"a","squaredDifference"),i=W(e,"b","squaredDifference");[t,i]=Si(t,i),Yt(t.shape,i.shape);const r={a:t,b:i},s={};return ne.runKernel(j0,r,s)}const LI=ie({squaredDifference_:OBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BBe(n,e){const t=W(n,"x","squeeze","string_or_numeric");return ue(t,jc(t.shape,e).newShape)}const Ud=ie({squeeze_:BBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zBe(n,e=0){const t=c1(n,"tensors","stack","string_or_numeric");B(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&B(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const i=t,r={axis:e};return ne.runKernel(Bw,i,r)}const Ls=ie({stack_:zBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GBe(n,e=0){const t={x:W(n,"x","step")},i={alpha:e};return ne.runKernel(eb,t,i)}const wm=ie({step_:GBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VBe(n,e,t,i,r=0,s=0,o=0,a=0,l=0){const u={x:W(n,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:i,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ne.runKernel(eI,u,c)}const GG=ie({stridedSlice_:VBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UBe(n){const e={x:W(n,"x","tan","float32")};return ne.runKernel(J0,e)}const VG=ie({tan_:UBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n,e){fm(n);const t=zu(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Bd(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function od(n,e,t){if(fm(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const i=zu(n,t);if(i.length!==2&&i.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Bd(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UG(n,e,t){if(fm(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const i=zu(n,t);if(i.length!==3&&i.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Bd(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Be(n,e=1,t=!0){const i=W(n,"x","topk");if(i.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=i.shape[i.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const s={x:i},o={k:e,sorted:t},[a,l]=ne.runKernel(rI,s,o);return{values:a,indices:l}}const $G=ie({topk_:$Be});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WBe(n,e=0,t=1,i,r){if(Do(n),i!=null&&i==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new OG(e,t,i,!0,r),o=nn(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const PI=ie({truncatedNormal_:WBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HBe(n,e=0){const t=W(n,"x","unique","string_or_numeric");B(t.rank>0,()=>"The input tensor must be at least 1D");const i={x:t},r={axis:e},[s,o]=ne.runKernel(oI,i,r);return{values:s,indices:o}}const WG=ie({unique_:HBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XBe(n,e,t){const i=W(n,"x","unsortedSegmentSum"),r=W(e,"segmentIds","unsortedSegmentSum","int32");B(Nf(t),()=>"numSegments must be of dtype int");const s={x:i,segmentIds:r},o={numSegments:t};return ne.runKernel(qw,s,o)}const DI=ie({unsortedSegmentSum_:XBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KBe(n,e=0){const t=W(n,"x","unstack","string_or_numeric");B(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const i={value:t},r={axis:e};return ne.runKernel(Qw,i,r)}const pa=ie({unstack_:KBe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(n,e=!0,t,i){return ne.makeVariable(n,e,t,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const i=nn(n,"int32"),r=nn([t.length,n.length],"int32");for(let s=0;s<t.length;s++){const o=i.indexToLoc(t[s]),a=s*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZBe(n,e,t){const i=W(n,"x","transpose");if(e==null&&(e=i.shape.map((o,a)=>a).reverse()),B(i.rank===e.length,()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${e}.`),e.forEach(o=>{B(o>=0&&o<i.rank,()=>`All entries in 'perm' must be between 0 and ${i.rank-1} but got ${e}`)}),i.rank<=1)return i.clone();const r={x:i},s={perm:e};return i.dtype==="complex64"?me(()=>{let o=Fy(i),a=aS(i);return o=ne.runKernel(lf,{x:o},s),a=ne.runKernel(lf,{x:a},s),t&&(a=si(a)),Vc(o,a)}):ne.runKernel(lf,r,s)}const gn=ie({transpose_:ZBe});function XG(n,e,t){const i=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${i}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(s+` update.rank < ${r}. `);if(n.length<i+(t.rank-r))throw new Error(s+` Output shape length < ${i+(t.rank-r)}`);if(t.rank!==r+n.length-i)throw new Error(s+` update.rank != ${r+n.length-i}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+i])throw new Error(s+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function KG(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}XG(t,e,n)}function cb(n,e,t){const i=e.shape.length,r=i>1?e.shape[i-1]:1,s=t.length;let o=1;for(let h=r;h<s;++h)o*=t[h];const a=r<1?1:r,l=ke(e.shape)/a,u=[...kt(t.slice(0,r)),1],c=ke(t);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}const jBe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:cb,validateInput:KG,validateUpdateShape:XG},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YBe(n,e){if(e==null)return n.shape.slice();if(bn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let i=0;i<n.shape.length;i++)e[i]==null&&n.shape[i]!=null?t.push(n.shape[i]):t.push(e[i]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JBe(n,e,t,i){const r=W(n,"x","dropout");if(B(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),B(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof An?r.clone():r;const s=YBe(r,t),o=1-e,a=At(sb(He(ub(s,0,1,"float32",i),o)),o);return ae(r,a)}const ZG=ie({dropout_:JBe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function OI(n,e,t){const i=1-n%2,r=new Float32Array(n);for(let s=0;s<n;++s){const o=2*Math.PI*s/(n+i-1);r[s]=e-t*Math.cos(o)}return ls(r,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QBe(n,e,t,i,r,s="NHWC",o){let a=n;n.rank===3&&(a=ue(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]])),B(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),B(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),B(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];B(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),B(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Ds("conv2dDerFilter",r,o);const h={x:a,dy:l},d={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:t};return ne.runKernel(d2,h,d)}const YG=ie({conv2DBackpropFilter_:QBe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ae(n,wm(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function zI(n,e){let t=e;const i=rr(n.shape,e.shape);return i.length>0&&(t=wt(t,i)),ue(t,n.shape)}function GI(n,e,t,i){if(e==="linear")return n;if(e==="relu")return jl(n);if(e==="elu")return ib(n);if(e==="relu6")return CI(n);if(e==="prelu")return fS(n,t);if(e==="leakyrelu")return lS(n,i);if(e==="sigmoid")return Dl(n);throw new Error(`Unknown fused activation ${e}.`)}const VI=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qBe({x:n,filter:e,strides:t,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",VI(ne.state.gradientDepth,l)===!1){B(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=Uc(n,e,t,i,r,s,o);return a!=null&&(_=He(_,a)),GI(_,l,u,c)}const h=W(n,"x","conv2d","float32"),d=W(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=ue(h,[1,h.shape[0],h.shape[1],h.shape[2]])),B(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),B(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Ds("fused conv2d",i,o);const g=r==="NHWC"?p.shape[3]:p.shape[1];B(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),B(es(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const y=Ir(p.shape,d.shape,t,s,i,o);let m;a!=null&&(m=W(a,"bias","fused conv2d"),[m]=Si(m,h),r==="NHWC"?Yt(y.outShape,m.shape):(B(m.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`),B(m.shape.length===0||m.shape[0]===y.outChannels||m.shape[0]===1,()=>`Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let v;if(u!=null){const _=u.shape;if(B(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)B(_[0]===1||_[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${y.outChannels}).`);else if(_.length===3)try{Yt(_,y.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(A)}v=W(u,"prelu weights","fused conv2d")}const w=(_,A)=>{B(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[I,E,k,P]=A,V=BI(_,k,l);B(vd(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const U=mG(E.shape,V,I,t,i),F=YG(E,V,I.shape,t,i),$=[U,F];if(P!=null){const J=zI(P,V);$.push(J)}return $},S={x:p,filter:d,bias:m,preluActivationWeights:v},C={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Gu((_,A,I)=>{let E=ne.runKernel(o1,S,C);return I([A,_,E]),f&&(E=ue(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:w}})(p,d):Gu((_,A,I,E)=>{let k=ne.runKernel(o1,S,C);return E([A,_,k,I]),f&&(k=ue(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:w}})(p,d,m)}const Bte=ie({fusedConv2d_:qBe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eze(n,e,t,i,r,s=[1,1],o){let a=n;n.rank===3&&(a=ue(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:i,pad:r,dimRoundingMode:o,dilations:s,filterShape:t};return ne.runKernel(x2,u,c)}const zte=ie({depthwiseConv2dNativeBackpropFilter_:eze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tze(n,e,t,i,r,s=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:i,pad:r,dimRoundingMode:o,dilations:s,inputShape:n},h=ne.runKernel(v2,u,c);return l?ue(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Gte=ie({depthwiseConv2dNativeBackpropInput_:tze});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nze({a:n,b:e,transposeA:t=!1,transposeB:i=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(VI(ne.state.gradientDepth,s)===!1){let k=ln(n,e,t,i);return r!=null&&(k=He(k,r)),GI(k,s,o,a)}let l=W(n,"a","fused matMul"),u=W(e,"b","fused matMul");[l,u]=Si(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=i?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=i?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=ke(f),m=ke(g);B(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${i} must match.`);const v=Yt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),w=t?ue(l,[y,c,d]):ue(l,[y,d,c]),S=i?ue(u,[m,p,h]):ue(u,[m,h,p]);let C;r!=null&&(C=W(r,"bias","fused matMul"),[C]=Si(C,l),Yt(v,C.shape));let _;o!=null&&(_=W(o,"prelu weights","fused matMul"));const A=(k,P)=>{const[V,U,F,$]=P,J=BI(ue(k,F.shape),F,s);let q,O;if(!t&&!i?(q=ln(J,U,!1,!0),O=ln(V,J,!0,!1)):!t&&i?(q=ln(J,U,!1,!1),O=ln(J,V,!0,!1)):t&&!i?(q=ln(U,J,!1,!0),O=ln(V,J,!1,!1)):(q=ln(U,J,!0,!0),O=ln(J,V,!0,!0)),r!=null){const X=zI($,J);return[q,O,X]}else return[q,O]},I={a:w,b:S,bias:C,preluActivationWeights:_},E={transposeA:t,transposeB:i,activation:s,leakyreluAlpha:a};return r==null?Gu((k,P,V)=>{const U=ne.runKernel(s1,I,E);return V([k,P,U]),{value:ue(U,v),gradFunc:A}})(w,S):Gu((k,P,V,U)=>{const F=ne.runKernel(s1,I,E);return U([k,P,F,V]),{value:ue(F,v),gradFunc:A}})(w,S,C)}const hF=ie({fusedMatMul_:nze});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ize(n){return OI(n,.54,.46)}const rze=ie({hammingWindow_:ize});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sze(n){return OI(n,.5,.5)}const Vte=ie({hannWindow_:sze});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oze(n,e,t,i=!1,r=0){let s=0;const o=[];for(;s+e<=n.size;)o.push(vn(n,s,e)),s+=t;if(i)for(;s<n.size;){const a=s+e-n.size,l=Hi([vn(n,s,e-a),bm([a],r)]);o.push(l),s+=t}return o.length===0?od([],[0,e]):ue(Hi(o),[o.length,e])}const Ute=ie({frame_:oze});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aze(n,e,t,i,r=Vte){i==null&&(i=jG(e));const s=Ute(n,e,t),o=ae(s,r(e));return xS(o,i)}const lze=ie({stft_:aze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uze(n,e,t,i,r="bilinear",s=0){const o=W(n,"image","cropAndResize"),a=W(e,"boxes","cropAndResize","float32"),l=W(t,"boxInd","cropAndResize","int32"),u=a.shape[0];B(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),B(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),B(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),B(i.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`),B(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),B(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:s,cropSize:i};return ne.runKernel(g2,c,h)}const cze=ie({cropAndResize_:uze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hze(n){const e=W(n,"image","flipLeftRight","float32");B(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ne.runKernel(M2,t,{})}const dze=ie({flipLeftRight_:hze});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pze(n){const e=W(n,"image","grayscaleToRGB"),t=e.rank-1,i=e.shape[t];B(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),B(i===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Qo(e,r)}const fze=ie({grayscaleToRGB_:pze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mze(n,e,t=0,i=.5){const r=W(n,"image","rotateWithOffset","float32");B(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const s={image:r},o={radians:e,fillValue:t,center:i};return ne.runKernel(aI,s,o)}const gze=ie({rotateWithOffset_:mze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hb(n,e,t,i,r,s){i==null&&(i=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=n.shape[0];return t=Math.min(t,o),B(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),B(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),B(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),B(e.rank===1,()=>"scores must be a 1D tensor"),B(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),B(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:i,scoreThreshold:r,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yze(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY){const s=W(n,"boxes","nonMaxSuppression","float32"),o=W(e,"scores","nonMaxSuppression","float32"),a=hb(s,o,t,i,r);t=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:i,scoreThreshold:r};return ne.runKernel(F2,{boxes:s,scores:o},l)}const bze=ie({nonMaxSuppression_:yze});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xze(n,e,t){const i=vze(n,e,t),r=i<0?-(i+1):i;n.splice(r,0,e)}function vze(n,e,t){return Sze(n,e,t||wze)}function wze(n,e){return n>e?1:n<e?-1:0}function Sze(n,e,t){let i=0,r=n.length,s=0,o=!1;for(;i<r;){s=i+(r-i>>>1);const a=t(e,n[s]);a>0?i=s+1:(r=s,o=!a)}return o?i:-i-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UI(n,e,t,i,r){return JG(n,e,t,i,r,0)}function $I(n,e,t,i,r,s){return JG(n,e,t,i,r,0,!1,s,!0)}function WI(n,e,t,i,r,s){return JG(n,e,t,i,r,s,!0)}function JG(n,e,t,i,r,s,o=!1,a=!1,l=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>r&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(eZ);const c=s>0?-.5/s:0,h=[],d=[];for(;h.length<t&&u.length>0;){const y=u.pop(),{score:m,boxIndex:v,suppressBeginIndex:w}=y;if(m<r)break;let S=!1;for(let C=h.length-1;C>=w;--C){const _=Tze(n,v,h[C]);if(_>=i){S=!0;break}if(y.score=y.score*Cze(i,c,_),y.score<=r)break}y.suppressBeginIndex=h.length,S||(y.score===m?(h.push(v),d.push(y.score)):y.score>r&&xze(u,y,eZ))}const p=h.length,f=t-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function Tze(n,e,t){const i=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),s=Math.min(i[0],i[2]),o=Math.min(i[1],i[3]),a=Math.max(i[0],i[2]),l=Math.max(i[1],i[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-s)*(l-o),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(s,u),y=Math.max(o,c),m=Math.min(a,h),v=Math.min(l,d),w=Math.max(m-g,0)*Math.max(v-y,0);return w/(p+f-w)}function Cze(n,e,t){const i=Math.exp(e*t*t);return t<=n?i:0}function eZ(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _ze(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY){const s=W(n,"boxes","nonMaxSuppressionAsync"),o=W(e,"scores","nonMaxSuppressionAsync"),a=hb(s,o,t,i,r);t=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=UI(u,c,t,i,r);return s!==n&&s.dispose(),o!==e&&o.dispose(),ls(h,"int32")}const Mze=_ze;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aze(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=W(n,"boxes","nonMaxSuppression"),a=W(e,"scores","nonMaxSuppression"),l=hb(o,a,t,i,r,s);t=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:t,iouThreshold:i,scoreThreshold:r,softNmsSigma:s},h=ne.runKernel(B2,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const Eze=ie({nonMaxSuppressionWithScore_:Aze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ize(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=W(n,"boxes","nonMaxSuppressionAsync"),a=W(e,"scores","nonMaxSuppressionAsync"),l=hb(o,a,t,i,r,s);t=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=WI(c,h,t,i,r,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(d,"int32"),selectedScores:ls(p)}}const kze=Ize;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rze(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=W(n,"boxes","nonMaxSuppression"),a=W(e,"scores","nonMaxSuppression"),l=hb(o,a,t,i,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:s},f=ne.runKernel(O2,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const Nze=ie({nonMaxSuppressionPadded_:Rze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Lze(n,e,t,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=W(n,"boxes","nonMaxSuppressionAsync"),a=W(e,"scores","nonMaxSuppressionAsync"),l=hb(o,a,t,i,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:g}=$I(d,p,u,c,h,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(f,"int32"),validOutputs:Nt(g,"int32")}}const Pze=Lze;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dze(n,e,t=!1,i=!1){const r=W(n,"images","resizeBilinear");B(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),B(i===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;r.rank===3&&(o=!0,s=ue(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:i,size:e},u=ne.runKernel(Ww,a,l);return o?ue(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const $te=ie({resizeBilinear_:Dze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fze(n,e,t=!1,i=!1){const r=W(n,"images","resizeNearestNeighbor");B(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),B(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),B(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),B(i===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,o=!1;r.rank===3&&(o=!0,s=ue(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:i,size:e},u=ne.runKernel($w,a,l);return o?ue(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Wte=ie({resizeNearestNeighbor_:Fze});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oze(n,e="binary",t=!1,i=.5){const r=W(n,"image","threshold"),s=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let u=ae(ls([i]),255),c,h,d,p;if(B(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),B(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),B(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),B(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=Js(r,[1,1,1],-1);const g=ae(c,s),y=ae(h,o),m=ae(d,a);p=He(He(g,y),m)}else p=n;if(e==="otsu"){const g=uG(ot(_I(p),"int32"),hi([]),256);u=Bze(g,l)}const f=t?Vd(p,u):Fs(p,u);return ot(ae(f,255),"int32")}function Bze(n,e){let t=ls([-1]),i=ls([0]),r=ls([0]),s,o,a,l,u,c;for(let h=0;h<n.size-1;h++){s=vn(n,0,h+1),o=vn(n,h+1),u=At(wt(s),e),c=At(wt(o),e);const d=wt(ae(s,Gf(0,s.size)));a=At(d,wt(s));const p=bm(o.shape,s.size),f=He(Gf(0,o.size),p),g=ae(o,f);l=At(wt(g),wt(o));const y=xt(a,l),m=xt(a,l),v=ae(u,c);r=ae(ae(v,y),m);const w=Fs(r,i);i=ds(w,r,i),t=ds(w,ls([h]),t)}return t}const zze=ie({threshold_:Oze});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gze(n,e,t="nearest",i="constant",r=0,s){const o=W(n,"image","transform","float32"),a=W(e,"transforms","transform","float32");B(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),B(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),B(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:o,transforms:a},u={interpolation:t,fillMode:i,fillValue:r,outputShape:s};return ne.runKernel(sI,l,u)}const Vze=ie({transform_:Gze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uze(n,e,t){B(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),B(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const i=W(n,"a","bandPart");B(i.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`);const r=i.shape,[s,o]=i.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),t<0&&(t=o);const a=ue(Gf(0,s,1,"int32"),[-1,1]),l=Gf(0,o,1,"int32"),u=xt(a,l),c=tl(Vd(u,Nt(+e,"int32")),qc(u,Nt(-t,"int32"))),h=tr([s,o],i.dtype);return ue(Ls(pa(ue(i,[-1,s,o])).map(d=>ds(c,d,h))),r)}const $ze=ie({bandPart_:Uze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wze(n){let e;if(Array.isArray(n)){e=!1,B(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let s=1;s<n.length;++s)B(n[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${r})`)}else e=!0,n=Js(n,n.shape[0],0).map(r=>Ud(r,[0]));B(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],i=n;for(let r=0;r<n.length;++r)t.push(ne.tidy(()=>{let s=i[r];if(r>0)for(let o=0;o<r;++o){const a=ae(wt(ae(t[o],s)),t[o]);s=xt(s,a)}return At(s,rb(s,"euclidean"))}));return e?Ls(t,0):t}const Hze=ie({gramSchmidt_:Wze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xze(n,e=!1){if(B(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return tZ(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),i=pa(ue(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],s=[];i.forEach(l=>{const[u,c]=tZ(l,e);r.push(u),s.push(c)});const o=ue(Ls(r,0),n.shape),a=ue(Ls(s,0),n.shape);return[o,a]}}function tZ(n,e=!1){return ne.tidy(()=>{B(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],i=n.shape[1];let r=yI(t),s=Ru(n);const o=od([[1]],[1,1]);let a=Ru(o);const l=t>=i?i:t;for(let u=0;u<l;++u){const c=s,h=a,d=r;[a,s,r]=ne.tidy(()=>{const p=vn(s,[u,u],[t-u,1]),f=rb(p),g=vn(s,[u,u],[1,1]),y=ds(Fs(g,0),od([[-1]]),od([[1]])),m=xt(g,ae(y,f)),v=At(p,m);v.shape[0]===1?a=Ru(o):a=Hi([o,vn(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const w=si(At(ln(y,m),f)),S=vn(s,[u,0],[t-u,i]),C=ae(w,a),_=gn(a);if(u===0)s=xt(S,ln(C,ln(_,S)));else{const E=xt(S,ln(C,ln(_,S)));s=Hi([vn(s,[0,0],[u,i]),E],0)}const A=gn(C),I=vn(r,[0,u],[t,r.shape[1]-u]);if(u===0)r=xt(I,ln(ln(I,a),A));else{const E=xt(I,ln(ln(I,a),A));r=Hi([vn(r,[0,0],[t,u]),E],1)}return[a,s,r]}),jt([c,h,d])}return!e&&t>i&&(r=vn(r,[0,0],[t,i]),s=vn(s,[0,0],[i,i])),[r,s]})}const Kze=ie({qr_:Xze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ms;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ms||(Ms={}));function Zze(n,e,t=Ms.SUM_BY_NONZERO_WEIGHTS){const i=W(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=W(e,"weights","computeWeightedLoss"));const s=r==null?i:ae(i,r);if(t===Ms.NONE)return s;if(t===Ms.SUM)return wt(s);if(t===Ms.MEAN){if(r==null)return vi(s);{const o=i.size/r.size,a=At(wt(s),wt(r));return o>1?At(a,Nt(o)):a}}if(t===Ms.SUM_BY_NONZERO_WEIGHTS){if(r==null)return At(wt(s),Nt(i.size));{const o=ae(r,_o(i.shape)),a=ot(wt(zf(o,Nt(0))),"float32");return At(wt(s),a)}}throw Error(`Unknown reduction: ${t}`)}const th=ie({computeWeightedLoss_:Zze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jze(n,e,t,i=Ms.SUM_BY_NONZERO_WEIGHTS){const r=W(n,"labels","absoluteDifference"),s=W(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=W(t,"weights","absoluteDifference")),qr(r.shape,s.shape,"Error in absoluteDifference: ");const a=qi(xt(r,s));return th(a,o,i)}const Yze=ie({absoluteDifference_:jze});function Jze(n,e,t,i,r=Ms.SUM_BY_NONZERO_WEIGHTS){const s=W(n,"labels","cosineDistance"),o=W(e,"predictions","cosineDistance");let a=null;i!=null&&(a=W(i,"weights","cosineDistance")),qr(s.shape,o.shape,"Error in cosineDistance: ");const l=Nt(1),u=xt(l,wt(ae(s,o),t,!0));return th(u,a,r)}const Qze=ie({cosineDistance_:Jze});function qze(n,e,t,i=Ms.SUM_BY_NONZERO_WEIGHTS){let r=W(n,"labels","hingeLoss");const s=W(e,"predictions","hingeLoss");let o=null;t!=null&&(o=W(t,"weights","hingeLoss")),qr(r.shape,s.shape,"Error in hingeLoss: ");const a=Nt(1);r=xt(ae(Nt(2),r),a);const l=jl(xt(a,ae(r,s)));return th(l,o,i)}const eGe=ie({hingeLoss_:qze});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tGe(n,e,t,i=1,r=Ms.SUM_BY_NONZERO_WEIGHTS){const s=W(n,"labels","huberLoss"),o=W(e,"predictions","huberLoss");let a=null;t!=null&&(a=W(t,"weights","huberLoss")),qr(s.shape,o.shape,"Error in huberLoss: ");const l=Nt(i),u=qi(xt(o,s)),c=ab(u,l),h=xt(u,c),d=He(ae(Nt(.5),Vn(c)),ae(l,h));return th(d,a,r)}const nGe=ie({huberLoss_:tGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iGe(n,e,t,i=1e-7,r=Ms.SUM_BY_NONZERO_WEIGHTS){const s=W(n,"labels","logLoss"),o=W(e,"predictions","logLoss");let a=null;t!=null&&(a=W(t,"weights","logLoss")),qr(s.shape,o.shape,"Error in logLoss: ");const l=Nt(1),u=Nt(i),c=si(ae(s,No(He(o,u)))),h=ae(xt(l,s),No(He(xt(l,o),u))),d=xt(c,h);return th(d,a,r)}const rGe=ie({logLoss_:iGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sGe(n,e,t,i=Ms.SUM_BY_NONZERO_WEIGHTS){const r=W(n,"labels","meanSquaredError"),s=W(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=W(t,"weights","meanSquaredError")),qr(r.shape,s.shape,"Error in meanSquaredError: ");const a=LI(r,s);return th(a,o,i)}const oGe=ie({meanSquaredError_:sGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aGe(n,e){const t=W(n,"labels","sigmoidCrossEntropyWithLogits"),i=W(e,"logits","sigmoidCrossEntropyWithLogits");qr(t.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=jl(i),s=ae(i,t),o=uS(Ro(si(qi(i))));return He(xt(r,s),o)}function lGe(n,e,t,i=0,r=Ms.SUM_BY_NONZERO_WEIGHTS){let s=W(n,"multiClassLabels","sigmoidCrossEntropy");const o=W(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=W(t,"weights","sigmoidCrossEntropy")),qr(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),i>0){const u=Nt(i),c=Nt(1),h=Nt(.5);s=He(ae(s,xt(c,u)),ae(h,u))}const l=aGe(s,o);return th(l,a,r)}const uGe=ie({sigmoidCrossEntropy_:lGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cGe(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Gu((i,r,s)=>{const o=wI(r,[t],!0),a=xt(ot(r,"float32"),o);s([i,a]);const l=si(ae(a,i));return{value:wt(l,[t]),gradFunc:(u,c)=>{const[h,d]=c,p=Xi(u.shape,[t]);return[ae(ue(u,p),xt(ot(h,"float32"),Ro(d))),ae(ue(u,p),xt(Ro(d),ot(h,"float32")))]}}})(n,e)}function hGe(n,e,t,i=0,r=Ms.SUM_BY_NONZERO_WEIGHTS){let s=W(n,"onehotLabels","softmaxCrossEntropy");const o=W(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=W(t,"weights","softmaxCrossEntropy")),qr(s.shape,o.shape,"Error in softmaxCrossEntropy: "),i>0){const u=Nt(i),c=Nt(1),h=Nt(s.shape[1]);s=He(ae(s,xt(c,u)),At(u,h))}const l=cGe(s,o);return th(l,a,r)}const dGe=ie({softmaxCrossEntropy_:hGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pGe(n,e,t,i){const r=W(n,"indices","sparseFillEmptyRows","int32"),s=W(e,"values","sparseFillEmptyRows"),o=W(t,"denseShape","sparseFillEmptyRows","int32"),a=W(i,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:s,denseShape:o,defaultValue:a},u=ne.runKernel(Z2,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const fGe=ie({sparseFillEmptyRows_:pGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mGe(n,e,t){const i=W(n,"inputIndices","sparseReshape","int32"),r=W(e,"inputShape","sparseReshape","int32"),s=W(t,"newShape","sparseReshape","int32");if(i.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:i,inputShape:r,newShape:s},a=ne.runKernel(j2,o);return{outputIndices:a[0],outputShape:a[1]}}const gGe=ie({sparseReshape_:mGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yGe(n,e,t){const i=W(n,"data","sparseSegmentMean"),r=W(e,"indices","sparseSegmentMean","int32"),s=W(t,"segmentIds","sparseSegmentMean","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return ne.runKernel(Y2,o)}const bGe=ie({sparseSegmentMean_:yGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xGe(n,e,t){const i=W(n,"data","sparseSegmentSum"),r=W(e,"indices","sparseSegmentSum","int32"),s=W(t,"segmentIds","sparseSegmentSum","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return ne.runKernel(J2,o)}const vGe=ie({sparseSegmentSum_:xGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wGe(n,e,t,i,r,s,o,a){const l=W(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=W(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:i,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:u},d=ne.runKernel(tI,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const SGe=ie({stringNGrams_:wGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TGe(n,e,t=!0){const i=W(n,"input","stringSplit","string"),r=W(e,"delimiter","stringSplit","string");if(i.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${i.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s={skipEmpty:t},o={input:i,delimiter:r},a=ne.runKernel(nI,o,s);return{indices:a[0],values:a[1],shape:a[2]}}const CGe=ie({stringSplit_:TGe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ge(n,e){const t=W(n,"input","stringToHashBucketFast","string"),i={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return ne.runKernel(iI,r,i)}const MGe=ie({stringToHashBucketFast_:_Ge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hte={fft:bS,ifft:By,rfft:xS,irfft:NI},Xte={hammingWindow:rze,hannWindow:Vte,frame:Ute,stft:lze},wu={flipLeftRight:dze,grayscaleToRGB:fze,resizeNearestNeighbor:Wte,resizeBilinear:$te,rotateWithOffset:gze,cropAndResize:cze,nonMaxSuppression:bze,nonMaxSuppressionAsync:Mze,nonMaxSuppressionWithScore:Eze,nonMaxSuppressionWithScoreAsync:kze,nonMaxSuppressionPadded:Nze,nonMaxSuppressionPaddedAsync:Pze,threshold:zze,transform:Vze},QG={bandPart:$ze,gramSchmidt:Hze,qr:Kze},Kte={absoluteDifference:Yze,computeWeightedLoss:th,cosineDistance:Qze,hingeLoss:eGe,huberLoss:nGe,logLoss:rGe,meanSquaredError:oGe,sigmoidCrossEntropy:uGe,softmaxCrossEntropy:dGe},Zte={sparseFillEmptyRows:fGe,sparseReshape:gGe,sparseSegmentMean:bGe,sparseSegmentSum:vGe},jte={stringNGrams:SGe,stringSplit:CGe,stringToHashBucketFast:MGe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sm{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}let Tm=class Sg{constructor(){this.classNameMap={}}static getMap(){return Sg.instance==null&&(Sg.instance=new Sg),Sg.instance}static register(e){Sg.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Xe(n){B(n.className!=null,()=>"Class being registered does not have the static className property defined."),B(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),B(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Tm.register(n)}const AGe=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Sm,SerializationMap:Tm,registerClass:Xe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nh extends Sm{minimize(e,t=!1,i){const{value:r,grads:s}=this.computeGradients(e,i);if(i!=null){const o=i.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(o)}else this.applyGradients(s);return jt(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return kte(e,t)}dispose(){this.iterations_!=null&&jt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Nt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(nh,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qG extends nh{constructor(e,t,i=null){super(),this.learningRate=e,this.rho=t,this.epsilon=i,this.accumulatedGrads=[],this.accumulatedUpdates=[],i==null&&(this.epsilon=ne.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,i)=>{const r=ne.registeredVariables[t],s=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${t}/accum_grad`,variable:me(()=>wn(r).variable(s))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${t}/accum_var`,variable:me(()=>wn(r).variable(s))});const o=Array.isArray(e)?e[i].tensor:e[t];if(o==null)return;const a=this.accumulatedGrads[i].variable,l=this.accumulatedUpdates[i].variable;me(()=>{const u=He(ae(a,this.rho),ae(Vn(o),1-this.rho)),c=ae(At(Yr(He(l,this.epsilon)),Yr(He(a,this.epsilon))),o),h=He(ae(l,this.rho),ae(Vn(c),1-this.rho));a.assign(u),l.assign(h);const d=He(ae(c,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(jt(this.accumulatedGrads.map(e=>e.variable)),jt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,i=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(i)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eV extends nh{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,i)=>{const r=ne.registeredVariables[t];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${t}/accumulator`,variable:me(()=>bm(r.shape,this.initialAccumulatorValue).variable(!1))});const s=Array.isArray(e)?e[i].tensor:e[t];if(s==null)return;const o=this.accumulatedGrads[i].variable;me(()=>{const a=He(o,Vn(s));o.assign(a);const l=He(ae(At(s,Yr(He(a,ne.backend.epsilon()))),-this.learningRate),r);r.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&jt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(i=>({originalName:i.name,variable:i.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tV extends nh{constructor(e,t,i,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=i,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],me(()=>{this.accBeta1=Nt(t).variable(),this.accBeta2=Nt(i).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);me(()=>{const i=xt(1,this.accBeta1),r=xt(1,this.accBeta2);t.forEach((s,o)=>{const a=ne.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:me(()=>wn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:me(()=>wn(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[s];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=He(ae(c,this.beta1),ae(u,1-this.beta1)),p=He(ae(h,this.beta2),ae(Vn(u),1-this.beta2)),f=At(d,i),g=At(p,r);c.assign(d),h.assign(p);const y=He(ae(At(f,He(Yr(g),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(ae(this.accBeta1,this.beta1)),this.accBeta2.assign(ae(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&jt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&jt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),me(()=>{this.accBeta1.assign($c(this.beta1,this.iterations_+1)),this.accBeta2.assign($c(this.beta2,this.iterations_+1))});const t=e.length/2,i=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(i)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nV extends nh{constructor(e,t,i,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=i,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],me(()=>{this.iteration=Nt(0).variable(),this.accBeta1=Nt(t).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);me(()=>{const i=xt(1,this.accBeta1),r=At(-this.learningRate,He(ae(this.iteration,this.decay),1));t.forEach((s,o)=>{const a=ne.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:wn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:wn(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[s];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=He(ae(c,this.beta1),ae(u,1-this.beta1)),p=ae(h,this.beta2),f=qi(u),g=Hu(p,f);c.assign(d),h.assign(g);const y=He(ae(At(r,i),At(d,He(g,this.epsilon))),a);a.assign(y)}),this.iteration.assign(He(this.iteration,1)),this.accBeta1.assign(ae(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&jt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&jt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HI extends nh{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,i)=>{const r=Array.isArray(e)?e[i].tensor:e[t];if(r==null)return;const s=ne.registeredVariables[t];me(()=>{const o=He(ae(this.c,r),s);s.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ri(Nt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iV extends HI{constructor(e,t,i=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=i,this.accumulations=[],this.m=Nt(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,i)=>{const r=ne.registeredVariables[t];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${t}/momentum`,variable:me(()=>wn(r).variable(!1))});const s=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[t];o!=null&&me(()=>{let a;const l=He(ae(this.m,s),o);this.useNesterov?a=He(ae(this.c,He(o,ae(l,this.m))),r):a=He(ae(this.c,l),r),s.assign(l),r.assign(a)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&jt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(i=>({originalName:i.name,variable:i.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rV extends nh{constructor(e,t=.9,i=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=i,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=ne.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,i)=>{const r=ne.registeredVariables[t],s=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${t}/rms`,variable:me(()=>wn(r).variable(s))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${t}/momentum`,variable:me(()=>wn(r).variable(s))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${t}/mg`,variable:me(()=>wn(r).variable(s))});const o=Array.isArray(e)?e[i].tensor:e[t];if(o==null)return;const a=this.accumulatedMeanSquares[i].variable,l=this.accumulatedMoments[i].variable;me(()=>{const u=He(ae(a,this.decay),ae(Vn(o),1-this.decay));if(this.centered){const c=this.accumulatedMeanGrads[i].variable,h=He(ae(c,this.decay),ae(o,1-this.decay)),d=At(ae(o,this.learningRate),Yr(xt(u,He(Vn(h),this.epsilon)))),p=He(ae(l,this.momentum),d);a.assign(u),c.assign(h),l.assign(p);const f=xt(r,p);r.assign(f)}else{const c=He(ae(a,this.decay),ae(Vn(o),1-this.decay)),h=He(ae(l,this.momentum),At(ae(o,this.learningRate),Yr(He(c,this.epsilon))));a.assign(c),l.assign(h);const d=xt(r,h);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&jt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&jt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&jt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,i=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(i)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(i)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(i)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EGe=[qG,eV,tV,nV,iV,rV,HI];function IGe(){for(const n of EGe)Xe(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(n,e,t,i){o(n),t=t??0,i=i??1,a(t,i);let r=0;const s=l=>(l.then(u=>{const c=t+ ++r/n.length*(i-t);return e(c),u}),l);function o(l){B(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){B(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),B(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),B(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Yte(n,e){e==null&&(e={});const t=e.fetchFunc==null?ve().platform.fetch:e.fetchFunc,i=n.map(u=>t(u,e.requestInit,{isBinary:!0})),r=0,s=.5,o=(e.onProgress==null?await Promise.all(i):await nZ(i,e.onProgress,r,s)).map(u=>u.arrayBuffer()),a=.5,l=1;return e.onProgress==null?await Promise.all(o):await nZ(o,e.onProgress,a,l)}async function Jte(n,e="",t,i){return Qte(r=>Yte(r,{requestInit:i}))(n,e,t)}function Qte(n){return async(e,t="",i)=>{const r=e.map(()=>!1),s={},o=i!=null?i.map(()=>!1):[],a=[];if(e.forEach((p,f)=>{let g=0;p.weights.forEach(y=>{const m="quantization"in y?y.quantization.dtype:y.dtype,v=sF[m]*ke(y.shape),w=()=>{r[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:y,groupOffset:g,sizeBytes:v})};i!=null?i.forEach((S,C)=>{S===y.name&&(w(),o[C]=!0)}):w(),a.push(y.name),g+=v})}),!o.every(p=>p)){const p=i.filter((f,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,f,g)=>(f&&p.push(g),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{const g=t+(t.endsWith("/")?"":"/")+f;u.push(g)})});const c=await n(u),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length;let g=0;for(let w=0;w<f;w++)g+=c[d+w].byteLength;const y=new ArrayBuffer(g),m=new Uint8Array(y);let v=0;for(let w=0;w<f;w++){const S=new Uint8Array(c[d+w]);m.set(S,v),v+=S.byteLength}s[p].forEach(w=>{const S=y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),C=$z(S,[w.manifestEntry]);for(const _ in C)h[_]=C[_]}),d+=f}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kGe="application/octet-stream",RGe="application/json";class sV{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(B(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ve().platform.fetch,B(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&B(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const i=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=yte(e,i);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:RGe}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:kGe}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:nS(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}const i=t.modelTopology,r=t.weightsManifest;if(i==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Xz(t,s=>this.loadWeights(s))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[i,r]=NGe(t),s=this.weightPathPrefix||i,o=Kz(e),a=[],l=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(s+h+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const u=await Yte(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,cI(u)]}}sV.URL_SCHEME_REGEX=/^https?:\/\//;function NGe(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),i=n.substring(0,e),r=t>e?n.substring(t):"";return[i+"/",r]}function dF(n){return n.match(sV.URL_SCHEME_REGEX)!=null}const qte=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(i=>dF(i)):t=dF(n),t)return oV(n,e)}return null};yi.registerSaveRouter(qte);yi.registerLoadRouter(qte);function oV(n,e){return new sV(n,e)}function ene(n,e){return oV(n,e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fp;function tne(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,i=!1,r=!1,s=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)i=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(qM(QM,ne.backendName)!=null){const d={pixels:n},p={numChannels:e};return ne.runKernel(QM,d,p)}const[l,u]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let c;if(o)c=n.getContext("2d").getImageData(0,0,l,u).data;else if(i||t)c=n.data;else if(s||r||a){if(fp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")fp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else fp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});fp.canvas.width=l,fp.canvas.height=u,fp.drawImage(n,0,0,l,u),c=fp.getImageData(0,0,l,u).data}let h;if(e===4)h=new Int32Array(c);else{const d=l*u;h=new Int32Array(d*e);for(let p=0;p<d;p++)for(let f=0;f<e;++f)h[p*e+f]=c[p*4+f]}return UG(h,[u,l,e],"int32")}function LGe(n){return n!=null&&n.data instanceof Uint8Array}function PGe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function DGe(n){return n!=null&&n.width!==0&&n.height!==0}function FGe(n){return PGe()&&!(n instanceof ImageBitmap)&&DGe(n)&&!LGe(n)}async function OGe(n,e=3){let t=null;if(ve().getBool("WRAP_TO_IMAGEBITMAP")&&FGe(n)){let i;try{i=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{i=null}i!=null&&i.width===n.width&&i.height===n.height?t=i:t=n}else t=n;return tne(t,e)}async function BGe(n,e){let t=W(n,"img","toPixels");if(!(n instanceof An)){const u=t;t=ot(u,"int32"),u.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[i,r]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*i*4);for(let u=0;u<i*r;++u){const c=[0,0,0,255];for(let d=0;d<s;d++){const p=o[u*s+d];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);s===1?(c[0]=p*a,c[1]=p*a,c[2]=p*a):c[d]=p*a}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(e!=null){e.width=r,e.height=i;const u=e.getContext("2d"),c=new ImageData(l,r,i);u.putImageData(c,0,0)}return t!==n&&t.dispose(),l}const aV=ie({fromPixels_:tne}),zGe=Object.freeze(Object.defineProperty({__proto__:null,fromPixels:aV,fromPixelsAsync:OGe,toPixels:BGe},Symbol.toStringTag,{value:"Module"}));function XI(n,e){const t=n.shape.length,i=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[i-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[i-1]} vs. ${t}`);if(ke(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=n.shape,l=r.slice();l.pop();let u=1;for(let h=s;h<t;++h)u*=a[h],l.push(a[h]);const c=[...kt(n.shape).map(h=>h/u),1].slice(0,s);return[l,o,u,c]}const GGe=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:XI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pF=-2,VGe=-1;function lV(n,e,t){const i=n.shape.length;B(i===e.length,()=>`Error in slice${i}D: Length of begin ${e} must match the rank of the array (${i}).`),B(i===t.length,()=>`Error in slice${i}D: Length of size ${t} must match the rank of the array (${i}).`);for(let r=0;r<i;++r)B(e[r]+t[r]<=n.shape[r],()=>`Error in slice${i}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function UGe(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function uV(n,e,t){const i=[];for(let r=0;r<n.length;r++)i[r]=Math.ceil((e[r]-n[r])/t[r]);return i}function nne(n,e,t,i){const r=[...n];for(let s=r.length;s<i.length;s++)r.push(1);for(let s=0;s<t;s++)s===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function ine(n,e,t){return t<=n?t:t-(e-1)}function rne(n,e){const t=[];for(let i=0;i<n;i++)t.push(e+i);return t}function $Ge(n,e,t,i,r,s,o,a,l){const u=n.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&t>0){const p=e[0],f=t+1;c=sne(o,p,f,i,n),h=one(a,p,f,r,n),d=nne(s,p,f,n)}else for(let p=0;p<u;p++)c[p]=lne(o,i,s,n,p,l),h[p]=une(a,r,s,n,p,l),d[p]=ane(s,p,l);return{begin:c,end:h,strides:d}}function sne(n,e,t,i,r){const s=[...r],o=rne(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const l=ine(e,t,a);let u=i[l];n&1<<l&&(u=0),s[a]=u}return s}function one(n,e,t,i,r){const s=[...r],o=rne(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const l=ine(e,t,a);let u=i[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){const l=r[a];s[a]<0&&(s[a]+=l),s[a]=bd(0,s[a],r[a])}return s}function ane(n,e,t){let i=n[e];return(t&1<<e||i==null)&&(i=1),i}function lne(n,e,t,i,r,s){let o=e[r];const a=t[r]||1;(n&1<<r||s&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),o=bd(0,o,l-1),o}function une(n,e,t,i,r,s){let o=e[r];const a=t[r]||1;(n&1<<r||s&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=i[r];return o<0&&(o+=l),a>0?o=bd(0,o,l):o=bd(-1,o,l-1),o}function cV(n,e,t){let i=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){i=r;break}for(let r=i+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function hV(n,e){let t=n.length>0?n[n.length-1]:1;for(let i=0;i<n.length-1;i++)t+=n[i]*e[i];return t}function KI(n,e,t){let i;const r=n.shape.length;typeof e=="number"?i=[e,...new Array(r-1).fill(0)]:e.length<r?i=e.concat(new Array(r-e.length).fill(0)):i=e.slice(),i.forEach(o=>{B(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(r).fill(-1):typeof t=="number"?s=[t,...new Array(r-1).fill(-1)]:t.length<r?s=t.concat(new Array(r-t.length).fill(-1)):s=t,s=s.map((o,a)=>o>=0?o:(B(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-i[a])),[i,s]}function dV(n,e,t,i,r,s,o,a,l){let u;if(i==null?(u=new Array(e.length),u.fill(1)):u=i,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)c&&1<<v&a&&h.numAddAxisAfterEllipsis++,1<<v&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};WGe(h,d);let p=!0,f=!0,g=!0;const y=[],m=[];for(let v=0;v<n.length;++v){if(d.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);const w=!!(d.shrinkAxisMask&1<<v),S=n[v];if(S===-1){y.push(w?1:-1);continue}const C=[d.beginMask&1<<v,d.endMask&1<<v],_=[d.strides[v]>0?0:-1,d.strides[v]>0?S:S-1];if(w&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[v]===1;const A=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(w){const P=d.begin[v]<0?S+d.begin[v]:d.begin[v];if(d.begin[v]=P,d.end[v]=d.begin[v]+1,P<0||P>=S)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=iZ(d.begin[v],0,d.strides[v],S,C,_),d.end[v]=iZ(d.end[v],1,d.strides[v],S,C,_);const k=d.strides[v]===1&&d.begin[v]===0&&d.end[v]===S;p=p&&k,f=f&&(v===0&&d.strides[v]===1||k)}else p=p&&d.strides[v]===1&&A,f=f&&(v===0&&d.strides[v]===1||A);let I,E=!1;if(d.beginValid&&d.endValid?(I=d.end[v]-d.begin[v],E=!0):w?(I=1,E=!0):A&&S>=0&&(d.strides[v]<0?I=-S:I=S,E=!0),E){let k;I===0||I<0!=d.strides[v]<0?k=0:k=Math.trunc(I/d.strides[v])+(I%d.strides[v]!==0?1:0),y.push(k)}else y.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const w=d.finalShapeGatherIndices[v];w>=0?m.push(y[w]):w===pF&&m.push(1)}return{finalShapeSparse:m.filter((v,w)=>d.finalShapeGatherIndices[w]!==pF),finalShape:m,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function WGe(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let i=0;i<n.dims;i++)if(1<<i&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-i)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=i}else if(1<<i&n.newAxisMask)e.finalShapeGatherIndices.push(pF),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[i]),n.end!=null&&(e.end[t]=n.end[i]),e.strides[t]=n.strides[i],n.beginMask&1<<i&&(e.beginMask|=1<<t),n.endMask&1<<i&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<i?(e.finalShapeGatherIndices.push(VGe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(i)),e.inputShapeGatherIndicesSparse[t]=i,t++}}function iZ(n,e,t,i,r,s){if(r[e])return t>0?s[e]:s[e+1&1];{const o=n<0?i+n:n;return o<s[0]?s[0]:o>s[1]?s[1]:o}}const cne=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:lV,computeFlatOffset:hV,computeOutShape:uV,getNormalizedAxes:$Ge,isSliceContinous:cV,maskToAxes:UGe,parseSliceParams:KI,sliceInfo:dV,startForAxis:lne,startIndicesWithElidedDims:sne,stopForAxis:une,stopIndicesWithElidedDims:one,stridesForAxis:ane,stridesWithElidedDims:nne},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hne{static sgd(e){return new HI(e)}static momentum(e,t,i=!1){return new iV(e,t,i)}static rmsprop(e,t=.9,i=0,r=null,s=!1){return new rV(e,t,i,r,s)}static adam(e=.001,t=.9,i=.999,r=null){return new tV(e,t,i,r)}static adadelta(e=.001,t=.95,i=null){return new qG(e,t,i)}static adamax(e=.002,t=.9,i=.999,r=null,s=0){return new nV(e,t,i,r,s)}static adagrad(e,t=.1){return new eV(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ip=hne;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HGe=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function vS(){return new Promise(n=>HGe(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pV(n,e){const t=n[0].length;n.forEach((r,s)=>{B(r.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),B(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const i=n[0];n.forEach((r,s)=>{for(let o=0;o<t;o++)B(o===e||r[o]===i[o],()=>`Error in concat${t}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${i}) along the non-concatenated axis ${s}.`)})}function Nu(n,e){const t=n[0].slice();for(let i=1;i<n.length;i++)t[e]+=n[i][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _l;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(_l||(_l={}));function dne(n,e,t){let i=new Array;if(t==null&&e==null)return i;if(e==null)for(;i.length<n+t.length;)i.push(-1);else i=e.slice();if(t==null)return i;if(n+t.length!==i.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${i.length}`);for(let r=1;r<t.length;++r){const s=t[r],o=i[i.length-t.length+r],a=i[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${s} but shape[${r+n}] = ${a}`)}else i[o]=s}return i}function pne(n){const e={FIRST_DIM_SIZE:_l.FIRST_DIM_SIZE,VALUE_ROWIDS:_l.VALUE_ROWIDS,ROW_LENGTHS:_l.ROW_LENGTHS,ROW_SPLITS:_l.ROW_SPLITS,ROW_LIMITS:_l.ROW_LIMITS,ROW_STARTS:_l.ROW_STARTS},t=[];for(const i of n)if(i in e)t.push(e[i]);else break;return t}function fne(n){return n.length===0?0:n[0]===_l.FIRST_DIM_SIZE?n.length-1:n.length}function mne(n,e){if(n==null||e==null)return;const t=n.length,i=e.length;if(t>=i)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${i})`);for(let r=0;r<Math.min(t,i-1);++r){const s=n[r],o=e[r+1];if(s>=0&&o>=0&&s!==1&&s!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${s} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fV=30;function ZI(n){return n<=fV?n:jM(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(n,e,t){const i=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[i,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e,t,i=!0){let r=[];if(i)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const s=e.length;for(let o=0;o<s;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(s+1))}return r}function SS(n,e,t=!0){const i=[];if(t){i.push(e);for(let r=e+1;r<n;++r)r<=2*e?(i.push(r),i.push(r-(e+1))):i.push(r)}else{const r=[],s=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?s.push(o):r.push(o);i.push(...r),i.push(0),i.push(...s)}return i}function TS(n,e,t,i=!0){const r=[];i?r.push(n[0]/t):r.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?i?r.push(e[s-1]*n[s]):r.push(n[s]/e[s-1]):r.push(n[s]);return r}function gV(n,e){const t=[0];for(let i=0;i<e;++i)t.push(n[i][0]);return t}function yV(n,e,t){const i=n.slice(0,1);for(let r=0;r<t;++r)i.push(n[r+1]-e[r][0]-e[r][1]);return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jI=1.7580993408473768,YI=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bV=.3275911,xV=.254829592,vV=-.284496736,wV=1.421413741,SV=-1.453152027,TV=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wc(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let i=0;i<t.length;i+=2)t[i]=n[i/2],t[i+1]=e[i/2];return t}function gne(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let i=0;i<n.length;i+=2)e[i/2]=n[i],t[i/2]=n[i+1];return{real:e,imag:t}}function yne(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),i=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:t,imag:i}}function bne(n){const e=Math.floor(n.length/4),t=new Float32Array(e),i=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],i[Math.floor(r/4)]=n[r+1];return{real:t,imag:i}}function CV(n,e){const t=n[e*2],i=n[e*2+1];return{real:t,imag:i}}function xne(n,e,t,i){n[i*2]=e,n[i*2+1]=t}function vne(n,e){const t=new Float32Array(n/2),i=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const s=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(s),i[r]=Math.sin(s)}return{real:t,imag:i}}function wne(n,e,t){const i=(t?2:-2)*Math.PI*(n/e),r=Math.cos(i),s=Math.sin(i);return{real:r,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VL="->",XGe=/->/g,rZ=",",sZ="...";function _V(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(XGe,"").length)/VL.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${VL}").`);const[i,r]=n.split(VL);B(i.indexOf(sZ)===-1,()=>`The ellipsis notation ("${sZ}") is not supported yet.`);const s=i.split(rZ),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!s.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<i.length;++d){const p=i[d];a.indexOf(p)===-1&&p!==rZ&&a.push(p)}const l=new Array(s.length);for(let d=0;d<o;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<s[d].length;++p)l[d].push(a.indexOf(s[d][p]))}const u=a.length,c=r.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function MV(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const i=[];for(let r=0;r<n;++r)t[r]===-1&&i.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:i}}function AV(n,e,t){const i=new Array(n);for(let r=0;r<t.length;++r){const s=t[r].shape;for(let o=0;o<e[r].length;++o)i[e[r][o]]===void 0?i[e[r][o]]=s[o]:B(i[e[r][o]]===s[o],()=>`Expected dimension ${i[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function EV(n,e){const t=n,i=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)i.push([]);const s=[];for(let o=0;o<t.length;++o){const a=t[o],l=KGe(e,a);for(const u of l)s.indexOf(u)===-1&&(i[o].push(u),s.push(u))}return{path:t,steps:i}}function IV(n){return n.every((e,t)=>e===t)}function KGe(n,e){const t=[];for(let i=0;i<n.length;++i)(n[i].length===0||n[i].indexOf(e)!==-1||e===-1)&&t.push(i);return t}function kV(n,e,t=0){let i=[];if(typeof e=="number")B(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),i=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);B(r<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[s]=n.shape[t]-o}B(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),i=e}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Tne(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Cne(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ne(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Mne(n,e){return`size ${n} must be non-negative, not ${e}`}function Ane(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Ene(n,e){const t=ke(n),i=ke(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${i}. inputShape=${n} outputShape= ${e}`}function Ine(n,e){const t=ke(n),i=ke(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${i}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(){return"segment ids must be >= 0"}function kne(){return"segment ids are not increasing"}function Rne(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Nne(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(n,e){let t=!1,i;for(n<=fV?(i=n,t=!0):i=jM(n,Math.floor(Math.sqrt(n)));!t;)i>e||i===n?t=!0:i=jM(n,i+1);return i}function Pne(n,e,t){const i=[],r=n.length;for(let s=0;s<r;s++)s!==e?i.push(n[s]):i.push(t);return i}function RV(n,e,t,i){const r=e.shape.length,s=n.shape.length;if(i!==0&&(i<-r||i>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${i}`);if(i<0&&(i+=r),i>s)throw new Error(`batchDims (${i}) must be less than rank(x) (
    ${s}).`);if(t<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${t}).`);for(let h=0;h<i;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<i;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=i;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=i;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<s;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}const ZGe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:RV,computeOutShape:Pne,segOpComputeOptimalWindowSize:Lne},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n){try{return n.map(e=>zc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Dne(n){return n.map(e=>ku(e))}const Fne=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:xV,ERF_A2:vV,ERF_A3:wV,ERF_A4:SV,ERF_A5:TV,ERF_P:bV,PARALLELIZE_THRESHOLD:fV,get RowPartitionType(){return _l},SELU_SCALE:YI,SELU_SCALEALPHA:jI,applyActivation:GI,assertAndGetBroadcastShape:Yt,assertAxesAreInnerMostDims:ts,assertParamsConsistent:pV,assignToTypedArray:xne,axesAreInnerMostDims:TG,calculateShapes:cb,checkEinsumDimSizes:AV,checkPadOnDimRoundingMode:Ds,combineLocations:Ete,combineRaggedTensorToTensorShapes:dne,complexWithEvenIndex:yne,complexWithOddIndex:bne,computeConv2DInfo:Ir,computeConv3DInfo:zd,computeDefaultPad:rG,computeDilation2DInfo:iS,computeOptimalWindowSize:ZI,computeOutAndReduceShapes:kr,computeOutShape:Nu,computePool2DInfo:rl,computePool3DInfo:Jc,convertConv2DDataFormat:Qc,decodeEinsumEquation:_V,eitherStridesOrDilationsAreOne:es,expandShapeToKeepDim:Xi,exponent:wne,exponents:vne,fromStringArrayToUint8:Dne,fromUint8ToStringArray:Vf,getAxesPermutation:Ti,getBroadcastDims:Bf,getComplexWithIndex:CV,getEinsumComputePath:EV,getEinsumPermutation:MV,getFusedBiasGradient:zI,getFusedDyActivation:BI,getImageCenter:mV,getInnerMostAxes:Ki,getPermuted:SS,getRaggedRank:fne,getReductionAxes:rr,getReshaped:wS,getReshapedPermuted:TS,getRowPartitionTypesHelper:pne,getSliceBeginCoords:gV,getSliceSize:yV,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Sne,getSparseFillEmptyRowsNegativeIndexErrorMessage:Tne,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Cne,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ane,getSparseReshapeInputOutputMismatchErrorMessage:Ine,getSparseReshapeInputOutputMultipleErrorMessage:Ene,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:_ne,getSparseReshapeNegativeOutputDimErrorMessage:Mne,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Nne,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:fF,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:kne,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Rne,getUndoAxesPermutation:Gd,isIdentityPermutation:IV,log:pDe,mergeRealAndImagArrays:Wc,prepareAndValidate:XI,prepareSplitSize:kV,segment_util:ZGe,shouldFuse:VI,slice_util:cne,splitRealAndImagArrays:gne,stridesOrDilationsArePositive:Ff,tupleValuesAreOne:vd,upcastType:qs,validateDefaultValueShape:mne,validateInput:KG,validateUpdateShape:XG,warn:Yo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */IGe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const One={kernelName:ew,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,wm(ot(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jGe={kernelName:o0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const i=Vn(ot(t,"float32")),r=Yr(xt(Nt(1),i));return si(At(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YGe={kernelName:a0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const i=Yr(xt(Vn(ot(t,"float32")),1));return At(n,i)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JGe={kernelName:gm,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{let s=n;const o=rr(t.shape,r);return o.length>0&&(s=wt(s,o)),ue(s,t.shape)},b:()=>{let s=n;const o=rr(i.shape,r);return o.length>0&&(s=wt(s,o)),ue(s,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QGe={kernelName:tw,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((i,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qGe={kernelName:nw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>wn(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eVe={kernelName:iw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>wn(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tVe={kernelName:l0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,Yr(xt(Nt(1),Vn(ot(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nVe={kernelName:u0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const i=Yr(He(Nt(1),Vn(ot(t,"float32"))));return At(n,i)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iVe={kernelName:d0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{const s=He(Vn(t),Vn(i));let o=ae(n,At(i,s));const a=rr(t.shape,r);return a.length>0&&(o=wt(o,a)),ue(o,t.shape)},b:()=>{const s=He(Vn(t),Vn(i));let o=si(ae(n,At(t,s)));const a=rr(i.shape,r);return a.length>0&&(o=wt(o,a)),ue(o,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rVe={kernelName:c0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,He(Vn(ot(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sVe={kernelName:h0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,xt(Nt(1),Vn(ot(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oVe(n,e,t,i,r,s){const o=W(n,"dy","avgPool3dGrad"),a=W(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;a.rank===4&&(c=!0,l=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=ue(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),B(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),B(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Ds("avgPool3dGrad",r,s);const h={dy:l,input:u},d={filterSize:t,strides:i,pad:r,dimRoundingMode:s},p=ne.runKernel(l2,h,d);return c?ue(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const aVe=ie({avgPool3dGrad_:oVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lVe={kernelName:sw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{filterSize:r,strides:s,pad:o,dimRoundingMode:a}=t;return{x:()=>aVe(n,i,r,s,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uVe(n,e,t,i,r){const s=W(n,"dy","avgPoolGrad"),o=W(e,"input","avgPoolGrad");B(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,l=s,u=!1;o.rank===3&&(u=!0,a=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]])),B(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),B(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:t,strides:i,pad:r},d=ne.runKernel(a2,c,h);return u?ue(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const cVe=ie({avgPoolGrad_:uVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hVe={kernelName:rw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{filterSize:r,strides:s,pad:o}=t;return{x:()=>cVe(n,i,r,s,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dVe={kernelName:ow,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[i,r]=e,{transposeA:s,transposeB:o}=t;return!s&&!o?{a:()=>ln(n,r,!1,!0),b:()=>ln(i,n,!0,!1)}:!s&&o?{a:()=>ln(n,r,!1,!1),b:()=>ln(n,i,!0,!1)}:s&&!o?{a:()=>ln(r,n,!1,!0),b:()=>ln(i,n,!1,!1)}:{a:()=>ln(r,n,!0,!0),b:()=>ln(n,i,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pVe={kernelName:aw,gradFunc:(n,e,t)=>{const{blockShape:i,crops:r}=t;return{x:()=>pS(n,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fVe={kernelName:qee,gradFunc:(n,e,t)=>{const i=t,r=i.inputShape,s=i.shape,o=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>wt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mVe={kernelName:p0,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gVe={kernelName:f0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yVe={kernelName:m0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{clipValueMin:r,clipValueMax:s}=t;return{x:()=>ds(tl(qc(i,r),Vd(i,s)),n,wn(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bVe={kernelName:lw,inputsToSave:["x"],gradFunc:One.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xVe={kernelName:uw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const i=e.map(a=>a.shape),{axis:r}=t,s=un(r,e[0].shape)[0],o=i.map(a=>a[s]);return Js(n,o,s).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vVe={kernelName:cw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[i,r]=e,{dilations:s,strides:o,pad:a,dataFormat:l}=t;return B(vd(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>mG(i.shape,n,r,o,a,l),filter:()=>YG(i,n,r.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wVe={kernelName:hw,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[i,r]=e,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Uc(n,r,s,o,a,1,l),filter:()=>YG(n,i,r.shape,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SVe(n,e,t,i,r){let s=n;n.rank===4&&(s=ue(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ue(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),B(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),B(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),B(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),B(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),B(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:s,dy:o},l={strides:i,pad:r,filterShape:t};return ne.runKernel(p2,a,l)}const TVe=ie({conv3DBackpropFilter_:SVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CVe={kernelName:dw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:i,strides:r,pad:s}=t;B(vd(i),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const[o,a]=e;return{x:()=>Ate(o.shape,n,a,r,s),filter:()=>TVe(o,n,a.shape,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ve={kernelName:g0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(si(II(ot(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MVe={kernelName:y0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(kI(ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AVe={kernelName:pw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{axis:r,exclusive:s,reverse:o}=t;return{x:()=>{const a=Ti([r],i.rank);let l=gI(n,r,s,!o);return a!=null&&(l=gn(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EVe={kernelName:fw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:i,strides:r,pad:s,dimRoundingMode:o}=t,a=i??[1,1];B(vd(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return B(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),B(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),B(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),B(es(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),Ds("depthwiseConv2d",s,o),{x:()=>Gte(l.shape,n,u,r,s,a,o),filter:()=>zte(l,n,u.shape,r,s,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IVe={kernelName:mw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[i,r]=e,s={x:i,filter:r,dy:n},o={x:i,filter:r,dy:n};return{x:()=>ne.runKernel(YM,s,t),filter:()=>ne.runKernel(JM,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kVe={kernelName:x0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,i={dy:n,y:t};return{x:()=>ne.runKernel(T2,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RVe={kernelName:v0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,i=ae(Ro(si(Vn(t))),2/Math.sqrt(Math.PI));return{x:()=>ae(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NVe={kernelName:w0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LVe={kernelName:yw,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ue(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PVe={kernelName:S0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,Ro(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DVe={kernelName:T0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FVe={kernelName:C0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{const s=At(n,ot(i,"float32")),o=rr(t.shape,r);return o.length>0?ue(wt(s,o),t.shape):s},b:()=>{let s=ae(n,ot(t,"float32"));const o=rr(i.shape,r);o.length>0&&(s=ue(wt(s,o),i.shape));const a=Vn(i);return si(At(s,ot(a,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OVe={kernelName:bw,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:i}=t,[r,s,o,a]=e,l=a??Nt(1),u=rr(s.shape,r.shape),c=[];if(s.rank===1){for(let g=0;g<r.shape.length-1;++g)c.push(r.shape[g]);c.push(1)}const h=xt(r,s),d=ae(n,l),p=MI(He(o,Nt(i))),f=ae(ae(ae(p,p),p),Nt(-.5));return{x:()=>s.rank===1?ue(ae(ae(n,Qo(ue(p,[1,1,1,s.shape[0]]),c)),l),r.shape):ue(ae(ae(n,p),l),r.shape),mean:()=>{let g=ae(ae(p,Nt(-1)),d);return s.rank===1&&(g=wt(g,u)),ue(g,s.shape)},variance:()=>{let g=ae(ae(f,h),d);return s.rank===1&&(g=wt(g,u)),ue(g,s.shape)},scale:()=>{const g=ae(h,p);let y=ae(n,g);return s.rank===1&&(y=wt(y,u)),ue(y,s.shape)},offset:()=>{let g=n;return s.rank===1&&(g=wt(g,u)),ue(g,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BVe={kernelName:xw,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[i,r]=e,{axis:s}=t,o=un(s,i.shape)[0];return{x:()=>{const a=i.shape,l=r.size,u=a.slice(0,o),c=u.length,h=a.slice(s,a.length).slice(1),d=h.length,p=oZ(0,c),f=oZ(c+1,c+1+d),g=aZ([u,[l],h]),y=ue(n,g),m=ue(r,[l]),v=aZ([[c],p,f]),w=gn(y,v);let S=DI(w,m,i.shape[o]);const C=Gd(v);return S=gn(S,C),S},indices:()=>r}}};function oZ(n,e){const t=[];for(let i=n;i<e;++i)t.push(i);return t}function aZ(n){const e=[];for(let t=0;t<n.length;++t)for(let i=0;i<n[t].length;++i)e.push(n[t][i]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zVe={kernelName:_0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e;return{a:()=>wn(t),b:()=>wn(i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GVe={kernelName:M0,gradFunc:n=>({x:()=>ot(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VVe={kernelName:A0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UVe={kernelName:E0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ve={kernelName:I0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WVe={kernelName:ww,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{alpha:r}=t,s=Fs(i,0);return{x:()=>ds(s,n,ae(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HVe={kernelName:R0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,He(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XVe={kernelName:k0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,ot(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KVe={kernelName:ete,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[i]=e,{axis:r}=t;return{logits:()=>{const s=Ro(i);return xt(n,ae(wt(n,r,!0),s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZVe(n,e,t,i=5,r=1,s=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:i,bias:r,alpha:s,beta:o};return ne.runKernel(R2,a,l)}const jVe=ie({localResponseNormalizationBackprop_:ZVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YVe={kernelName:Aw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[i,r]=e,{depthRadius:s,bias:o,alpha:a,beta:l}=t;return{x:()=>jVe(i,r,n,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(n,e,t,i){return e.rank<t.rank&&(e=ue(e,Xi(e.shape,i))),n.rank<t.rank&&(n=ue(n,Xi(n.shape,i))),{x:()=>ae(n,ot(ko(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZ={kernelName:Ew,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const i=t,{reductionIndices:r}=i,s=e[0],o=e[1],a=un(r,s.shape),l=Bne(n,o,s,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JVe={kernelName:N0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e;return{a:()=>ae(n,ot(qc(t,i),"float32")),b:()=>ae(n,ot(bI(t,i),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QVe(n,e,t,i,r,s,o){const a=W(n,"dy","maxPool3dGrad"),l=W(e,"input","maxPool3dGrad"),u=W(t,"output","maxPool3dGrad");let c=a,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=ue(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ue(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ue(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),B(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),B(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),B(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Ds("maxPool3dGrad",s,o);const f={dy:c,input:h,output:d},g={filterSize:i,strides:r,pad:s,dimRoundingMode:o},y=ne.runKernel(L2,f,g);return p?ue(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const qVe=ie({maxPool3dGrad_:QVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eUe={kernelName:kw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>qVe(n,i,r,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tUe(n,e,t,i,r,s,o){const a=W(n,"dy","maxPoolGrad"),l=W(e,"input","maxPoolGrad"),u=W(t,"output","maxPoolGrad");B(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),B(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),B(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Ds("maxPoolGrad",s,o);const c={dy:a,input:l,output:u},h={filterSize:i,strides:r,pad:s,dimRoundingMode:o};return ne.runKernel(N2,c,h)}const nUe=ie({maxPoolGrad_:tUe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iUe={kernelName:Iw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a}=t;return{x:()=>nUe(n,i,r,s,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rUe={kernelName:Rw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{axis:r}=t,s=un(r,i.shape),o=kr(i.shape,s)[1],a=ke(o);return{x:()=>{const l=i.shape.slice();s.forEach(c=>{l[c]=1});const u=ue(n,l);return At(ae(u,_o(i.shape,"float32")),a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sUe={kernelName:Nw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const i=t,{axis:r}=i,[s,o]=e,a=un(r,s.shape),l=Bne(n,o,s,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oUe={kernelName:L0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e;return{a:()=>ae(n,ot(Vd(t,i),"float32")),b:()=>ae(n,ot(Fs(t,i),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aUe={kernelName:Lw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const i=e[0],{paddings:r}=t,s=r.map(o=>o[0]);return{x:()=>vn(n,s,i.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lUe={kernelName:P0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{const s=rr(t.shape,r);return s.length>0?ue(wt(n,s),t.shape):n},b:()=>{const s=ae(n,si(sb(At(t,i)))),o=rr(i.shape,r);return o.length>0?ue(wt(s,o),i.shape):s}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uUe={kernelName:D0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{const s=ae(n,ot(i,"float32")),o=rr(t.shape,r);return o.length>0?ue(wt(s,o),t.shape):s},b:()=>{const s=ae(n,ot(t,"float32")),o=rr(i.shape,r);return o.length>0?ue(wt(s,o),i.shape):s}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cUe={kernelName:Pw,gradFunc:n=>({x:()=>si(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hUe={kernelName:Ow,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>tr(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dUe={kernelName:Fw,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pUe={kernelName:Bw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:i}=t;return pa(n,i).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uZ={kernelName:zw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const i=e[0],{paddings:r}=t,s=r.map(o=>o[0]);return{x:()=>vn(n,s,i.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fUe={kernelName:F0,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,i,r]=e,s=t,o=i,a=Yt(s.shape,o.shape);return{a:()=>{const l=ot(o,"float32");let u=ae(n,ae(l,$c(s,xt(l,Nt(1)))));const c=rr(s.shape,a);return c.length>0&&(u=wt(u,c)),ue(u,s.shape)},b:()=>{const l=Fs(s,0),u=ds(l,No(s),wn(s));let c=ae(n,ae(r,u));const h=rr(o.shape,a);return h.length>0&&(c=wt(c,h)),ue(c,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mUe={kernelName:Gw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,i]=e,r=Fs(t,0);return{x:()=>ds(r,n,ae(n,i)),alpha:()=>{let s=ds(r,wn(n),ae(n,t));const o=rr(i.shape,n.shape);return o.length>0&&(s=wt(s,o)),ue(s,i.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gUe(n,e,t){const i=n.shape.slice();i[t]=1;const r=ue(e,i),s=m1(n,t,!0,!1),o=m1(n,t,!0,!0),a=ae(s,o);return ae(r,a)}function yUe(n,e,t){const i=n.shape.length,r=i-t.length,s=Ti(t,i);let o=n;s!=null&&(o=gn(n,s));const a=o.shape.slice(),l=a.splice(i-t.length,t.length).reduce((h,d)=>h*d,1);a.push(l);const u=o.reshape(a);let c=gUe(u,e,r);if(c=c.reshape(o.shape),s!=null){const h=Gd(s);c=gn(c,h)}return c}const bUe={kernelName:Vw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{axis:r}=t;let s=[];return r==null?s=i.shape.map((o,a)=>a):typeof r=="number"?s=[r]:s=r,{x:()=>yUe(i,n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xUe={kernelName:b0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{const s=At(n,ot(i,"float32")),o=rr(t.shape,r);return o.length>0?ue(wt(s,o),t.shape):s},b:()=>{let s=ae(n,ot(t,"float32"));const o=rr(i.shape,r);o.length>0&&(s=ue(wt(s,o),i.shape));const a=Vn(i);return si(At(s,ot(a,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vUe={kernelName:O0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,si(Vn(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wUe={kernelName:z0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,i=ae(Vd(t,6),wm(t));return{x:()=>ae(n,ot(i,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SUe={kernelName:B0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,ot(wm(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TUe={kernelName:Uw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CUe={kernelName:Ww,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[i]=e,r={dy:n,images:i};return{images:()=>ne.runKernel(H2,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ue={kernelName:$w,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[i]=e,r={dy:n,images:i};return{images:()=>ne.runKernel(W2,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MUe={kernelName:Hw,gradFunc:(n,e,t)=>{const{dims:i}=t,r=un(i,n.shape);return{x:()=>da(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AUe={kernelName:G0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EUe={kernelName:V0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>si(At(n,ae($c(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IUe={kernelName:Xw,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>ot(wn(t),"float32"),t:()=>ae(n,ot(t,n.dtype)),e:()=>ae(n,ot(cS(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kUe={kernelName:U0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const i=Fs(t,Nt(0)),r=Nt(jI),s=Nt(YI),o=ae(n,s),a=ae(ae(n,r),Ro(ot(t,"float32")));return ds(i,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RUe={kernelName:X0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,ae(t,xt(Nt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NUe={kernelName:H0,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LUe={kernelName:$0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(oS(ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PUe={kernelName:W0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(mI(ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DUe={kernelName:Kw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{begin:r,size:s}=t,o=i.shape,[a,l]=KI(i,r,s),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>eh(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FUe={kernelName:Jw,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[i]=e,{dim:r}=t,s=!0,o=ae(n,i);return{logits:()=>xt(o,ae(wt(o,[r],s),i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OUe={kernelName:K0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,Dl(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ={kernelName:jw,gradFunc:(n,e,t)=>{const{blockShape:i,paddings:r}=t;return{x:()=>sS(n,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZ={kernelName:Yw,gradFunc:(n,e,t)=>{const{axis:i}=t;return{x:()=>Hi(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BUe={kernelName:Z0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,ae(Yr(ot(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zUe={kernelName:q2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,ae(ot(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GUe={kernelName:j0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Nt(2);return{a:()=>ae(n,ae(r,xt(t,i))),b:()=>ae(n,ae(r,xt(i,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VUe={kernelName:eb,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UUe={kernelName:Y0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,i]=e,r=Yt(t.shape,i.shape);return{a:()=>{let s=n;const o=rr(t.shape,r);return o.length>0&&(s=wt(s,o)),ue(s,t.shape)},b:()=>{let s=n;const o=rr(i.shape,r);return o.length>0&&(s=wt(s,o)),ue(si(s),i.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ue={kernelName:Zw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,r=i.shape.slice(),{axis:s}=t;un(s,i.shape).forEach(l=>{r[l]=1});const o=ue(n,r),a=ae(o,_o(i.shape,"float32"));return{x:()=>a}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WUe={kernelName:J0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>At(n,Vn(oS(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HUe={kernelName:Q0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(xt(Nt(1),Vn(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XUe={kernelName:q0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[i]=e,{reps:r}=t;return{x:()=>{let s=wn(i);if(i.rank===1)for(let o=0;o<r[0];++o)s=He(s,vn(n,[o*i.shape[0]],[i.shape[0]]));else if(i.rank===2)for(let o=0;o<r[0];++o)for(let a=0;a<r[1];++a)s=He(s,vn(n,[o*i.shape[0],a*i.shape[1]],[i.shape[0],i.shape[1]]));else if(i.rank===3)for(let o=0;o<r[0];++o)for(let a=0;a<r[1];++a)for(let l=0;l<r[2];++l)s=He(s,vn(n,[o*i.shape[0],a*i.shape[1],l*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else if(i.rank===4)for(let o=0;o<r[0];++o)for(let a=0;a<r[1];++a)for(let l=0;l<r[2];++l)for(let u=0;u<r[3];++u)s=He(s,vn(n,[o*i.shape[0],a*i.shape[1],l*i.shape[2],u*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${i.rank} tensors yet.`);return s}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KUe={kernelName:lf,gradFunc:(n,e,t)=>{const i=t,{perm:r}=i,s=Gd(r);return{x:()=>gn(n,s)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZUe={kernelName:Qw,gradFunc:(n,e,t)=>{const i=t,{axis:r}=i;return{value:()=>Ls(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jUe={kernelName:qw,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>YUe(n,t)}}};function YUe(n,e){const t=Hu(e,wn(e)),i=ob(n,t);let r=qc(e,Nt(0,"int32"));const s=i.rank-r.rank;for(let a=0;a<s;++a)r=as(r,a+1);r=tl(r,_o(i.shape,"bool"));const o=wn(i);return ds(r,i,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JUe={kernelName:eS,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QUe=[One,jGe,YGe,JGe,QGe,qGe,eVe,tVe,nVe,iVe,rVe,sVe,lVe,hVe,dVe,pVe,fVe,mVe,gVe,yVe,bVe,xVe,wVe,vVe,CVe,_Ve,MVe,AVe,EVe,IVe,xUe,kVe,RVe,NVe,LVe,PVe,FVe,DVe,OVe,BVe,zVe,GVe,VVe,UVe,$Ve,WVe,HVe,XVe,KVe,YVe,lZ,lZ,JVe,eUe,iUe,rUe,sUe,oUe,aUe,lUe,uUe,cUe,hUe,dUe,pUe,uZ,uZ,fUe,mUe,bUe,vUe,wUe,SUe,TUe,CUe,_Ue,MUe,AUe,EUe,IUe,kUe,RUe,NUe,LUe,PUe,DUe,FUe,OUe,cZ,cZ,hZ,hZ,BUe,GUe,zUe,VUe,UUe,$Ue,WUe,HUe,XUe,KUe,ZUe,jUe,JUe];for(const n of QUe)tte(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.abs=function(){return this.throwIfDisposed(),qi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.acos=function(){return this.throwIfDisposed(),Yz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.acosh=function(){return this.throwIfDisposed(),Jz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.add=function(n){return this.throwIfDisposed(),He(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.all=function(n,e){return this.throwIfDisposed(),dI(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.any=function(n,e){return this.throwIfDisposed(),d1(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.argMax=function(n){return this.throwIfDisposed(),Df(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.argMin=function(n){return this.throwIfDisposed(),Qz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.asScalar=function(){return this.throwIfDisposed(),B(this.size===1,()=>"The array must have only 1 element."),ue(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.asType=function(n){return this.throwIfDisposed(),ot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.as1D=function(){return this.throwIfDisposed(),ue(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.as2D=function(n,e){return this.throwIfDisposed(),ue(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ue(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.as4D=function(n,e,t,i){return this.throwIfDisposed(),ue(this,[n,e,t,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.as5D=function(n,e,t,i,r){return this.throwIfDisposed(),ue(this,[n,e,t,i,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.asin=function(){return this.throwIfDisposed(),qz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.asinh=function(){return this.throwIfDisposed(),eG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.atan=function(){return this.throwIfDisposed(),tG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.atan2=function(n){return this.throwIfDisposed(),nG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.atanh=function(){return this.throwIfDisposed(),iG(this)};Le().prototype.avgPool=function(n,e,t,i){return this.throwIfDisposed(),rS(this,n,e,t,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),sS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.batchNorm=function(n,e,t,i,r){return this.throwIfDisposed(),tb(this,n,e,t,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.broadcastTo=function(n){return this.throwIfDisposed(),uf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.cast=function(n){return this.throwIfDisposed(),ot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.ceil=function(){return this.throwIfDisposed(),cG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),eo(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof An&&(n=[n]),Hi([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.conv1d=function(n,e,t,i,r,s){return this.throwIfDisposed(),pI(this,n,e,t,i,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.conv2dTranspose=function(n,e,t,i,r){return this.throwIfDisposed(),fI(this,n,e,t,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.conv2d=function(n,e,t,i,r,s){return this.throwIfDisposed(),Uc(this,n,e,t,i,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.cos=function(){return this.throwIfDisposed(),oS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.cosh=function(){return this.throwIfDisposed(),mI(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),m1(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),gI(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),bG(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.depthwiseConv2d=function(n,e,t,i,r,s){return this.throwIfDisposed(),nb(this,n,e,t,i,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.dilation2d=function(n,e,t,i,r){return this.throwIfDisposed(),xG(this,n,e,t,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.divNoNan=function(n){return this.throwIfDisposed(),vG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.div=function(n){return this.throwIfDisposed(),At(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.dot=function(n){return this.throwIfDisposed(),wG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.elu=function(){return this.throwIfDisposed(),ib(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.equal=function(n){return this.throwIfDisposed(),ko(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.erf=function(){return this.throwIfDisposed(),SG(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),CG(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.exp=function(){return this.throwIfDisposed(),Ro(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.expandDims=function(n){return this.throwIfDisposed(),as(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.expm1=function(){return this.throwIfDisposed(),_G(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.fft=function(){return this.throwIfDisposed(),bS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.flatten=function(){return this.throwIfDisposed(),ue(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.floor=function(){return this.throwIfDisposed(),sb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.floorDiv=function(n){return this.throwIfDisposed(),hI(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.gather=function(n,e){return this.throwIfDisposed(),ob(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.greaterEqual=function(n){return this.throwIfDisposed(),qc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.greater=function(n){return this.throwIfDisposed(),Fs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.ifft=function(){return this.throwIfDisposed(),By(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.irfft=function(){return this.throwIfDisposed(),NI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.isFinite=function(){return this.throwIfDisposed(),MG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.isInf=function(){return this.throwIfDisposed(),AG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.isNaN=function(){return this.throwIfDisposed(),EG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.leakyRelu=function(n){return this.throwIfDisposed(),lS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.lessEqual=function(n){return this.throwIfDisposed(),Vd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.less=function(n){return this.throwIfDisposed(),bI(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.localResponseNormalization=function(n,e,t,i){return this.throwIfDisposed(),IG(this,n,e,t,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logSigmoid=function(){return this.throwIfDisposed(),kG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logSoftmax=function(n){return this.throwIfDisposed(),vI(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),wI(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.log=function(){return this.throwIfDisposed(),No(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.log1p=function(){return this.throwIfDisposed(),uS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logicalAnd=function(n){return this.throwIfDisposed(),tl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logicalNot=function(){return this.throwIfDisposed(),cS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logicalOr=function(n){return this.throwIfDisposed(),SI(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.logicalXor=function(n){return this.throwIfDisposed(),RG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),ln(this,n,e,t)};Le().prototype.maxPool=function(n,e,t,i){return this.throwIfDisposed(),hS(this,n,e,t,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.max=function(n,e){return this.throwIfDisposed(),la(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.maximum=function(n){return this.throwIfDisposed(),Hu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.mean=function(n,e){return this.throwIfDisposed(),vi(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.min=function(n,e){return this.throwIfDisposed(),Py(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.minimum=function(n){return this.throwIfDisposed(),ab(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),LG(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.mod=function(n){return this.throwIfDisposed(),PG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.mul=function(n){return this.throwIfDisposed(),ae(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.neg=function(){return this.throwIfDisposed(),si(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.norm=function(n,e,t){return this.throwIfDisposed(),rb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.notEqual=function(n){return this.throwIfDisposed(),zf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Dy(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.onesLike=function(){return this.throwIfDisposed(),Lo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.pad=function(n,e){return this.throwIfDisposed(),eh(this,n,e)};Le().prototype.pool=function(n,e,t,i,r,s){return this.throwIfDisposed(),DG(this,n,e,t,i,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.pow=function(n){return this.throwIfDisposed(),$c(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.prelu=function(n){return this.throwIfDisposed(),fS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.prod=function(n,e){return this.throwIfDisposed(),FG(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.reciprocal=function(){return this.throwIfDisposed(),BG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.relu=function(){return this.throwIfDisposed(),jl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.relu6=function(){return this.throwIfDisposed(),CI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ue(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.reshape=function(n){return this.throwIfDisposed(),ue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),$te(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Wte(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.reverse=function(n){return this.throwIfDisposed(),da(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.rfft=function(){return this.throwIfDisposed(),xS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.round=function(){return this.throwIfDisposed(),_I(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.rsqrt=function(){return this.throwIfDisposed(),MI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.selu=function(){return this.throwIfDisposed(),AI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.separableConv2d=function(n,e,t,i,r,s){return this.throwIfDisposed(),EI(this,n,e,t,i,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sigmoid=function(){return this.throwIfDisposed(),Dl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sign=function(){return this.throwIfDisposed(),zG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sin=function(){return this.throwIfDisposed(),II(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sinh=function(){return this.throwIfDisposed(),kI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.slice=function(n,e){return this.throwIfDisposed(),vn(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.softmax=function(n){return this.throwIfDisposed(),yS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.softplus=function(){return this.throwIfDisposed(),xm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),pS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.split=function(n,e){return this.throwIfDisposed(),Js(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sqrt=function(){return this.throwIfDisposed(),Yr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.square=function(){return this.throwIfDisposed(),Vn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.squaredDifference=function(n){return this.throwIfDisposed(),LI(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.squeeze=function(n){return this.throwIfDisposed(),Ud(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof An?[this,n]:[this,...n];return Ls(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.step=function(n){return this.throwIfDisposed(),wm(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.stridedSlice=function(n,e,t,i,r,s,o,a){return this.throwIfDisposed(),GG(this,n,e,t,i,r,s,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sub=function(n){return this.throwIfDisposed(),xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.sum=function(n,e){return this.throwIfDisposed(),wt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.tan=function(){return this.throwIfDisposed(),VG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.tanh=function(){return this.throwIfDisposed(),Of(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.tile=function(n){return this.throwIfDisposed(),Qo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.toBool=function(){return this.throwIfDisposed(),ot(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.toFloat=function(){return this.throwIfDisposed(),ot(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.toInt=function(){return this.throwIfDisposed(),ot(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.topk=function(n,e){return this.throwIfDisposed(),$G(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.transpose=function(n){return this.throwIfDisposed(),gn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.unique=function(n){return this.throwIfDisposed(),WG(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),DI(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.unstack=function(n){return this.throwIfDisposed(),pa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.where=function(n,e){return this.throwIfDisposed(),ds(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Le().prototype.zerosLike=function(){return this.throwIfDisposed(),wn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Rh=class zne extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zne.prototype)}},Su=class Gne extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gne.prototype)}};class he extends Error{constructor(e){super(e),Object.setPrototypeOf(this,he.prototype)}}let tn=class Vne extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Vne.prototype)}},qUe=class Une extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Une.prototype)}};/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $ne{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const i=this.cache.keys().next().value;this.cache.delete(i)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const i=this.cache.keys().next().value;this.cache.delete(i)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uf(n,e){if(Array.isArray(n)){let t=[];for(let i=0;i<e;i++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function gu(n,e){if(!n)throw new qUe(e)}function dZ(n,e){let t=0;for(const i of n)i===e&&t++;return t}function Xs(n){return n.length===1?n[0]:n}function qn(n){return Array.isArray(n)?n:[n]}function cc(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Lp(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Pa={};function NV(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function mF(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>mF(e));else{const e=Object.keys(n);for(const t of e){const i=n[t];i!=null&&typeof i=="object"&&(!Array.isArray(i)&&i.type==="ndarray"&&typeof i.value=="number"?n[t]=i.value:mF(i))}}}function CS(n,e={},t={},i="object",r=!1){if(typeof n=="string"){const s=n;let o;if(s in t)o=t[s];else if(s in Pa)o=Pa[s];else if(o=e[s],o==null)throw new he(`Unknown ${i}: ${n}. This may be due to one of the following reasons:
1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const s=n;if(s.className==null||s.config==null)throw new he(`${i}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);const o=s.className;let a,l;if(o in t?[a,l]=t[o]:o in Pa?[a,l]=Pa.className:o in e&&([a,l]=e[o]),a==null)throw new he(`Unknown ${i}: ${o}. This may be due to one of the following reasons:
1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Pa))u[p]=Pa[p];for(const p of Object.keys(t))u[p]=t[p];const c=s.config;c.customObjects=u;const h=Object.assign({},Pa);for(const p of Object.keys(t))Pa[p]=t[p];mF(s.config);const d=l(a,s.config,t,r);return Pa=Object.assign({},h),d}else{const u=Object.assign({},Pa);for(const h of Object.keys(t))Pa[h]=t[h];const c=new a(s.config);return Pa=Object.assign({},u),c}}}function e$e(n,e){return n<e?-1:n>e?1:0}function e_(n,e){return-1*e$e(n,e)}function ad(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function t$e(n){if(n==null)throw new he(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Cm(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new he(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function LV(n,e,t=0,i=1/0){return gu(t>=0),gu(i>=t),Array.isArray(n)&&n.length>=t&&n.length<=i&&n.every(r=>typeof r===e)}function _r(n,e){Array.isArray(n)?(B(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,i)=>_r(t,`element ${i+1} of ${e}`))):B(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Wne(n)}.`)}function Wne(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Wne(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function n$e(n,e,t){let i=t!=null?t():Ur(),r;return(...s)=>{const o=t!=null?t():Ur();return o-i<e||(i=o,r=n(...s)),r}}function Hne(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let i$e=0;function Xne(){return i$e++}const t_={};function JI(n=""){return n in t_||(t_[n]=0),t_[n]+=1,n+t_[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const r$e=["channelsFirst","channelsLast"],s$e=["nearest","bilinear"],o$e=["valid","same","causal"],a$e=["max","avg"],l$e=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const mg=new Map;function Zi(n){Cm(r$e,"DataFormat",n)}function u$e(n){Cm(s$e,"InterpolationFormat",n)}function ba(n){Cm(o$e,"PaddingMode",n)}function Kne(n){Cm(a$e,"PoolMode",n)}const fv=[],pZ="/";function cf(n,e){fv.push(n);try{const t=e();return fv.pop(),t}catch(t){throw fv.pop(),t}}function c$e(){return fv.length===0?"":fv.join(pZ)+pZ}function Zne(n){if(!Yne(n))throw new Error("Not a valid tensor name: '"+n+"'");return c$e()+n}function jne(n){if(!Yne(n))throw new Error("Not a valid tensor name: '"+n+"'");mg.has(n)||mg.set(n,0);const e=mg.get(n);if(mg.set(n,mg.get(n)+1),e>0){const t=`${n}_${e}`;return mg.set(t,1),t}else return n}const h$e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Yne(n){return!!n.match(h$e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function d$e(n){return n===parseInt(n.toString(),10)}function ld(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let i=1;for(let r=e;r<t;++r)i*=n[r];return i}function zy(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const i=n[t];i<e&&(e=i)}return e}function wd(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const i=n[t];i>e&&(e=i)}return e}function $l(n,e){if(e<n)throw new he(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let i=n;i<e;++i)t.push(i);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let UL;function fr(){return UL==null&&(UL=vc().epsilon()),UL}function Wl(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hc(n,e){return ot(n,e)}function _S(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ue(n,t)}function p$e(n,e){return me(()=>{if(n.shape.length!==2)throw new he(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=_S(n,1);return gF(t,[1,e,1])})}function f$e(n){const e=[ld(n.shape)];return ue(n,e)}function m$e(n){if(n.rank<=1)throw new he(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],ld(n.shape,1)];return ue(n,e)}function hf(n,e,t){return me(()=>{switch(n.rank){case 1:return mS(n,e,t);case 2:return RI(n,[e,0],[t,n.shape[1]]);case 3:return gS(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Oy(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return vn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return vn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new he(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function $L(n,e,t){return me(()=>{switch(n.rank){case 1:return mS(n,e,t);case 2:return RI(n,[0,e],[n.shape[0],t]);case 3:return gS(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Oy(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function n_(n,e,t,i){return me(()=>{switch(n.rank){case 1:return mS(n,e,t);case 2:switch(i){case 1:return hf(n,e,t);case 2:return $L(n,e,t);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}case 3:switch(i){case 1:return hf(n,e,t);case 2:return gS(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return $L(n,e,t);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}case 4:switch(i){case 1:return hf(n,e,t);case 2:return Oy(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Oy(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return $L(n,e,t);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function PV(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Hi(n,e)}function fZ(n,e){switch(n.rank){case 1:return hG([n,e]);case 2:return dG([n,e],0);case 3:return pG([n,e],0);case 4:return fG([n,e],0);default:throw new he(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function gF(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new he(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Qo(n,e)}function QI(n,e=0,t=1,i,r){return TI(n,e,t,i,r)}function Lu(n,e,t,i){if(n.rank<2||e.rank<2)throw new tn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(r!==s)throw new tn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return hF({a:n,b:e,transposeA:!1,transposeB:!1,bias:i?yF(n.rank,i,Wl()):null,activation:t});{const r=n.shape.slice(),s=r.pop();n=ue(n,[-1,s]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(d,p)=>p===0?e.rank-2:p<=e.rank-2?p-1:p);e=ue(gn(e,c),[l,-1]);const h=[...r,...u];return ue(hF({a:n,b:e,transposeA:!1,transposeB:!1,bias:i?yF(n.rank,i,Wl()):null,activation:t}),h)}}function Jne(n,e,t){return me(()=>(Array.isArray(e)?e=ls(e,"int32"):e=ot(e,"int32"),ob(n,e,t)))}function MS(n){return ae(n,n)}function yF(n,e,t){const i=e.shape;if(e.rank!==1&&e.rank!==n)throw new he(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return i.length===1?ue(e,[1,i[0],1,1,1]):ue(e,[1,i[3],i[0],i[1],i[2]]);if(t==="channelsLast")return i.length===1?ue(e,[1,1,1,1,i[0]]):ue(e,[1].concat(i))}else if(n===4){if(t==="channelsFirst")return i.length===1?ue(e,[1,i[0],1,1]):ue(e,[1,i[2],i[0],i[1]]);if(t==="channelsLast")return i.length===1?ue(e,[1,1,1,i[0]]):ue(e,[1].concat(i))}else if(n===3){if(t==="channelsFirst")return i.length===1?ue(e,[1,i[0],1]):ue(e,[1,i[1],i[0]]);if(t==="channelsLast")return i.length===1?ue(e,[1,1,i[0]]):ue(e,[1].concat(i))}else if(n<3)return e;throw new he(`Unsupported input rank by biasAdd: ${e.rank}`)}function Yl(n,e,t){return me(()=>(t==null&&(t=Wl()),Zi(t),He(n,yF(n.rank,e,t))))}function g$e(n,e=1){if(e!==1)throw new tn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return ib(n)}function y$e(n){return me(()=>At(n,He(qi(n),1)))}function Qne(n,e,t,i){return me(()=>ZG(n,e,t,i))}function b$e(n){return me(()=>{const e=He(.5,ae(.2,n));return eo(e,0,1)})}function AS(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const x$e=["fanIn","fanOut","fanAvg"],v$e=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function w$e(n){Cm(x$e,"FanMode",n)}function S$e(n){Cm(v$e,"Distribution",n)}let sl=class extends Sm{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}};class DV extends sl{apply(e,t){return tr(e,t)}}DV.className="Zeros";Xe(DV);let qI=class extends sl{apply(e,t){return _o(e,t)}};qI.className="Ones";Xe(qI);class FV extends sl{constructor(e){if(super(),typeof e!="object")throw new he(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new he(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return me(()=>ae(Nt(this.value),_o(e,t)))}getConfig(){return{value:this.value}}}FV.className="Constant";Xe(FV);class OV extends sl{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ub(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}OV.className="RandomUniform";Xe(OV);class BV extends sl{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new tn(`randomNormal does not support dType ${t}.`);return QI(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}BV.className="RandomNormal";Xe(BV);class zV extends sl{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new tn(`truncatedNormal does not support dType ${t}.`);return PI(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}zV.className="TruncatedNormal";Xe(zV);class GV extends sl{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return me(()=>{if(e.length!==2||e[0]!==e[1])throw new he("Identity matrix initializer can only be used for 2D square matrices.");return ae(this.gain,yI(e[0]))})}getConfig(){return{gain:this.gain}}}GV.className="Identity";Xe(GV);function T$e(n,e="channelsLast"){let t,i;if(Zi(e),n.length===2)t=n[0],i=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=ld(n,2);t=n[1]*r,i=n[0]*r}else if(e==="channelsLast"){const r=ld(n,0,n.length-2);t=n[n.length-2]*r,i=n[n.length-1]*r}}else{const r=ld(n);t=Math.sqrt(r),i=Math.sqrt(r)}return[t,i]}let to=class extends sl{constructor(e){if(super(),e.scale<0)throw new he(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,w$e(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,S$e(this.distribution),this.seed=e.seed}apply(e,t){const i=T$e(e),r=i[0],s=i[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,s):o/=Math.max(1,(r+s)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new tn(`${this.getClassName()} does not support dType ${t}.`);return PI(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return ub(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};to.className="VarianceScaling";Xe(to);let ek=class extends to{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return to.className}};ek.className="GlorotUniform";Xe(ek);let tk=class extends to{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return to.className}};tk.className="GlorotNormal";Xe(tk);let nk=class extends to{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return to.className}};nk.className="HeNormal";Xe(nk);let ik=class extends to{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return to.className}};ik.className="HeUniform";Xe(ik);let rk=class extends to{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return to.className}};rk.className="LeCunNormal";Xe(rk);let sk=class extends to{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return to.className}};sk.className="LeCunUniform";Xe(sk);class VV extends sl{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new tn("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return me(()=>{if(e.length<2)throw new tn("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const i=e[0]>e[1]?[e[1],e[0]]:e,r=QI(i,0,1,"float32");let s=QG.gramSchmidt(r);return e[0]>e[1]&&(s=gn(s)),ae(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}}VV.className="Orthogonal";Xe(VV);const mZ={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function gZ(n,e={}){return CS(n,Tm.getMap().classNameMap,e,"initializer")}function wi(n){return NV(n)}function fi(n){if(typeof n=="string"){const e=n in mZ?mZ[n]:n;if(e==="GlorotNormal")return new tk;if(e==="GlorotUniform")return new ek;if(e==="HeNormal")return new nk;if(e==="HeUniform")return new ik;if(e==="LeCunNormal")return new rk;if(e==="LeCunUniform")return new sk;{const t={};return t.className=e,t.config={},gZ(t)}}else return n instanceof sl?n:gZ(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bF(n){return Array.isArray(n)&&Array.isArray(n[0])}function rA(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Wt(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new he(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Rn(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new he(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sA(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((i,r)=>i*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const yZ="Variable";class qne{constructor(e,t="float32",i=yZ,r=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Xne(),i=i??yZ,this.originalName=Zne(i),this.name=jne(this.originalName),this.trainable_=r,this.constraint=s,this.val=HG(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),C$e(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function C$e(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function xF(n){return n.map(e=>e.read())}function UV(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ir{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}let El=class{constructor(e,t,i,r,s,o,a){this.dtype=e,this.shape=t,this.sourceLayer=i,this.inputs=r,this.callArgs=s,this.outputTensorIndex=a,this.id=Xne(),o!=null&&(this.originalName=Zne(o),this.name=jne(this.originalName)),this.rank=t.length}},_$e=0;class ok{constructor(e,t){this.callArgs=t,this.id=_$e++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const i of e.inboundLayers)i!=null&&i.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let M$e=0,pn=class extends Sm{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=M$e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const i=this.getClassName();t=cc(i)+"_"+JI(i)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let i;if(e.batchInputShape!=null)i=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),i=[s].concat(e.inputShape)}this.batchInputShape=i;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Su(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new he(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Xs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Xs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Rh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Rh(`Layer ${this.name} is not connected, no input to return.`);return Xs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Rh(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Rh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=qn(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=qn(this.inputSpec);if(e.length!==t.length)throw new he(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let i=0;i<e.length;i++){const r=e[i],s=t[i];if(s==null)continue;const o=r.rank;if(s.ndim!=null&&o!==s.ndim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${o}`);if(s.maxNDim!=null&&o>s.maxNDim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${o}`);if(s.minNDim!=null&&o<s.minNDim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${o}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new he(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const a=r.shape;for(const l in s.axes){const u=Number(l),c=s.axes[l],h=u>=0?a[u]:a[a.length+u];if(c!=null&&[c,null].indexOf(h)===-1)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){const l=s.shape[a],u=r.shape[a];if(l!=null&&u!=null&&l!==u)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const i=qn(e);let r=!0;for(const o of i)if(!(o instanceof El)){r=!1;break}let s=!0;for(const o of i)if(o instanceof El){s=!1;break}if(r===s)throw new he("Arguments to apply() must be all SymbolicTensors or all Tensors");return cf(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of qn(e))o.push(a.shape);this.build(Xs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let o=this.call(e,t);const a=qn(o),l=[];for(let u of a)i.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(o=Xs(l),this.activityRegularizer!=null)throw new tn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=A$e(e),a=this.computeOutputShape(o);let l;const u=E$e(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new El(u,c,this,qn(e),t,this.name,h)):l=new El(u,a,this,qn(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new tn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((i,r)=>{i!=null&&e[r]!=null&&e[r]!==i&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Rh(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const i=JSON.stringify(t.outputShapes);e.indexOf(i)===-1&&e.push(i)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Rh(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Su(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return sA(this.weights)}build(e){this.built=!0}getWeights(e=!1){return xF(e?this.trainableWeights:this.weights)}setWeights(e){me(()=>{const t=this.weights;if(t.length!==e.length)throw new he(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const i=[],r=xF(t);for(let s=0;s<r.length;++s){const o=r[s],a=t[s],l=e[s];if(!bn(o.shape,l.shape))throw new he(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);i.push([a,l])}UV(i)})}addWeight(e,t,i,r,s,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new he(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),i==null&&(i="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():fi("zeros"));const u=r.apply(t,i),c=new qne(u,i,e,o,a);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),o==null&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=qn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(i=>{if(i!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,i,r,s,o,a=null){const l=qn(e);t=qn(t),i=qn(i),r=qn(r),s=rA(s),o=rA(o);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new ok({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:i,outputMasks:r,inputShapes:s,outputShapes:o},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function A$e(n){n=qn(n);const e=[];for(const t of n)e.push(t.shape);return Xs(e)}function E$e(n){return"float32"}function eie(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const i=e.inboundNodes[t];if(i.inboundLayers.length===0)return i.inputTensors;{const r=[];for(let s=0;s<i.inboundLayers.length;s++){const o=i.inputTensors[s],a=i.inboundLayers[s],l=i.nodeIndices[s],u=eie(o,a,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class db extends pn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:JI("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new he("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new he("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new he("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=e.dtype||"float32";this.batchInputShape=t,this.dtype=i,this.inputSpec=[{shape:t}];const r=new El(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ok({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new he(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}db.className="InputLayer";Xe(db);function tie(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new he("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new db({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function I$e(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return ot(e,n.dtype)}catch{throw new he(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Vh{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Vh)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,i){if(this.id2Value[e.id]==null)this.id2Value[e.id]=I$e(e,t),this.name2Id[e.name]=e.id,i!=null&&(this.id2Mask[e.id]=i);else throw new he(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof El){if(this.id2Value[e.id]==null)throw new he(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new he(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof El){if(this.id2Value[e.id]==null)throw new he(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new he(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&jt(this.id2Mask)}}const oA=new $ne,aA=new $ne;function k$e(n){oA!=null&&oA.setMaxEntries(n),aA!=null&&aA.setMaxEntries(n)}function Bx(n,e,t,i){const r=t==null?!1:t.training,s=Array.isArray(n),o=s?n:[n],a=o.map(f=>f.name),l=[],u=e.names();for(const f of a)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);i!=null&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const c=a.join(",")+"|"+e.names().sort().join(",");let h=oA.get(c),d;if(h==null){const f=R$e(o,e);h=f.sorted,d=f.recipientCounts,oA.put(c,h),aA.put(c,d)}d={},r||Object.assign(d,aA.get(c));const p=new Vh(e);for(let f=0;f<h.length;++f){if(i!=null){const E=h1().numTensors;E>i.maxNumTensors&&(i.maxNumTensors=E),E<i.minNumTensors&&(i.minNumTensors=E)}const g=h[f],y=g.sourceLayer;if(y instanceof db)continue;const m=[],v=[],w=[];let S=!1;for(const E of g.inputs){const k=p.getValue(E),P=p.getMask(E);m.push(k),v.push(P),P!=null&&(S=!0),r||(d[E.name]--,d[E.name]===0&&!e.hasKey(E)&&a.indexOf(E.name)===-1&&!k.isDisposed&&E.sourceLayer.stateful!==!0&&w.push(k))}S&&(t=t||{},t.mask=v[0]);const C=qn(y.apply(m,t));let _=null;y.supportsMasking&&(_=y.computeMask(m,v));const A=L$e(g),I=Array.isArray(A)?A:[A];for(let E=0;E<I.length;++E){p.hasKey(I[E])||p.add(I[E],C[E],Array.isArray(_)?_[0]:_);const k=a.indexOf(I[E].name);k!==-1&&(l[k]=C[E])}r||jt(w)}return p.disposeMasks(),s?l:l[0]}function R$e(n,e){B(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],i={};if(n.length===1){const r=bZ(n[0],e);t=r.sorted,i=r.recipientMap}else{const r=new Set;for(const s of n){const{sorted:o,recipientMap:a}=bZ(s,e);for(const l of o)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in a)i[l]==null&&(i[l]=new Set),a[l].forEach(u=>i[l].add(u))}}return{sorted:t,recipientCounts:N$e(i)}}function N$e(n){const e={};for(const t in n)e[t]=n[t].size;return e}function bZ(n,e){const t=new Set,i=[],r={};for(const a of e.names())t.add(a);const s=[],o=[];for(s.push(n);s.length>0;){const a=s[s.length-1];if(t.has(a.name)){s.pop();continue}const l=o[o.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),i.push(a),t.add(a.name),l&&o.pop();else{o.push(s.length-1);for(const u of a.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(a.name),!t.has(u.name)&&s.push(u)}}return{sorted:i,recipientMap:r}}function L$e(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let i=0;i<n.sourceLayer.inboundNodes.length;++i)for(const r of n.sourceLayer.inboundNodes[i].outputTensors)if(r.id===n.id){t=i;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P$e=ve();P$e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,k$e);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $V(n,e){return me(()=>Yr(wt(ae(n,n),e,!0)))}class ES extends Sm{getConfig(){return{}}}class WV extends ES{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>{const t=$V(e,this.axis),i=eo(t,0,this.maxValue);return ae(e,At(i,He(fr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}WV.className="MaxNorm";Xe(WV);class HV extends ES{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>At(e,He(fr(),$V(e,this.axis))))}getConfig(){return{axis:this.axis}}}HV.className="UnitNorm";Xe(HV);class XV extends ES{apply(e){return jl(e)}}XV.className="NonNeg";Xe(XV);class KV extends ES{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return me(()=>{const t=$V(e,this.axis),i=He(ae(this.rate,eo(t,this.minValue,this.maxValue)),ae(1-this.rate,t));return ae(e,At(i,He(fr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}KV.className="MinMaxNorm";Xe(KV);const xZ={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function gr(n){return NV(n)}function vZ(n,e={}){return CS(n,Tm.getMap().classNameMap,e,"constraint")}function yr(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in xZ?xZ[n]:n,config:{}};return vZ(e)}else return n instanceof ES?n:vZ(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Mh(n){if(n==null)return;const e=[],t=[],i=[];for(const r in n){const s=n[r];if(typeof s!="number"){const o=s;e.push(o.data()),t.push(r),i.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let s=0;s<r.length;++s)n[t[s]]=r[s][0];jt(i)}}function nie(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var wZ;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(wZ||(wZ={}));const D$e=125;let Gy=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}};class iie{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const i of this.callbacks)await i.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const i of this.callbacks)await i.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const i of this.callbacks)await i.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const i of this.callbacks)await i.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class F$e extends Gy{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const i=t.size==null?0:t.size;this.seen+=i;for(const r in t){const s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*i;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=me(()=>He(this.totals[r],ae(s,i)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const i of this.params.metrics)this.totals[i]!=null&&(typeof this.totals[i]=="number"?t[i]=this.totals[i]/this.seen:me(()=>{const r=ae(At(1,this.seen),this.totals[i]);t[i]=r,this.totals[i].dispose(),Ri(t[i])}))}}class rie extends Gy{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const i in t)this.history[i]==null&&(this.history[i]=[]),this.history[i].push(t[i])}async syncData(){const e=[],t=[],i=[];for(const s in this.history){const o=this.history[s];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(s),i.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][i[s]].dispose(),this.history[t[s]][i[s]]=r[s][0]}}class sie extends Gy{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||vS,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=D$e),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ZM(this.yieldEvery)&&(this.maybeWait=n$e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,i){const r=[];this.yield!=null&&(await Mh(i),r.push(this.yield(e,t,i))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Mh(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const i=[];this.epochEnd!=null&&(await Mh(t),i.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&i.push(this.nextFrameFunc()),await Promise.all(i)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Mh(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const i=[];this.batchEnd!=null&&(await Mh(t),i.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?i.push(this.nextFrameFunc()):ZM(this.yieldEvery)&&i.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(i)}async onTrainBegin(e){this.trainBegin!=null&&(await Mh(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Mh(e),await this.trainEnd(e))}}function oie(n,e){return n==null&&(n={}),n instanceof Gy?[n]:Array.isArray(n)&&n[0]instanceof Gy?n:qn(n).map(t=>new sie(t,e))}let ZV=class cu{constructor(){}static registerCallbackConstructor(e,t){B(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),cu.checkForDuplicate(t),cu.constructors[e]==null&&(cu.constructors[e]=[]),cu.constructors[e].push(t)}static checkForDuplicate(e){for(const t in cu.constructors)cu.constructors[+t].forEach(i=>{if(i===e)throw new he("Duplicate callback constructor.")})}static clear(){cu.constructors={}}static createCallbacks(e){const t=[];for(const i in cu.constructors){const r=+i;e>=r&&t.push(...cu.constructors[r])}return t.map(i=>new i)}};ZV.constructors={};function aie(n,e,t,i,r,s,o,a,l){const u=new rie,c=[new F$e,...ZV.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new iie(c);return h.setParams({epochs:t,initialEpoch:i,samples:r,steps:s,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fl(n,e={},t=!1){return CS(n,Tm.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lA(n,e){return me(()=>{n.dtype!=="float32"&&(n=ot(n,"float32"));const t=wt(MS(n),e,!0),i=bm(t.shape,fr()),r=Yr(Hu(t,i));return At(n,r)})}function _m(n,e){return me(()=>vi(MS(xt(e,n)),-1))}function ak(n,e){return me(()=>vi(qi(xt(e,n)),-1))}function pb(n,e){return me(()=>{const t=xt(n,e),i=eo(qi(n),fr(),Number.MAX_VALUE),r=qi(At(t,i));return ae(100,vi(r,-1))})}function O$e(n,e){return me(()=>{const t=eo(e,fr(),Number.MAX_VALUE),i=No(He(1,t)),r=eo(n,fr(),Number.MAX_VALUE),s=No(He(1,r));return vi(MS(xt(i,s)),-1)})}function B$e(n,e){return me(()=>{const t=Hu(0,xt(1,ae(n,e)));return vi(MS(t),-1)})}function z$e(n,e){return me(()=>{const t=Hu(0,xt(1,ae(n,e)));return vi(t,-1)})}function G$e(n,e){return me(()=>{const t=wt(ae(n,e),-1),i=la(ae(xt(1,n),e),-1);return Hu(0,He(1,xt(i,t)))})}function V$e(n,e){return me(()=>{const t=Math.log(2),i=xt(e,n),r=xt(He(i,xm(ae(-2,i))),t);return vi(r,-1)})}function g1(n,e,t=!1){return me(()=>{if(t)e=yS(e);else{const i=wt(e,e.shape.length-1,!0);e=At(e,i)}return e=eo(e,fr(),1-fr()),si(wt(ae(ot(n,"float32"),No(e)),e.shape.length-1))})}function uA(n,e,t=!1){return me(()=>{const i=ot(sb(f$e(n)),"int32");e=eo(e,fr(),1-fr());const r=e.shape,s=ue(Dy(i,r[r.length-1]),r);return g1(s,e,t)})}function U$e(n,e){if(!bn(n.shape,e.shape))throw new he(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return me(()=>{const t=jl(e),i=si(qi(e));return He(xt(t,ae(e,n)),uS(Ro(i)))})}function lk(n,e){return me(()=>{let t;return t=eo(e,fr(),1-fr()),t=No(At(t,xt(1,t))),vi(U$e(n,t),-1)})}function $$e(n,e){return me(()=>{const t=eo(n,fr(),1),i=eo(e,fr(),1);return wt(ae(n,No(At(t,i))),-1)})}function W$e(n,e){return me(()=>{const t=No(He(fr(),e));return vi(xt(e,ae(n,t)),-1)})}function jV(n,e){return me(()=>{const t=lA(n,-1),i=lA(e,-1),r=ae(t,i);return si(wt(r,-1))})}const cA={meanSquaredError:_m,meanAbsoluteError:ak,meanAbsolutePercentageError:pb,meanSquaredLogarithmicError:O$e,squaredHinge:B$e,hinge:z$e,categoricalHinge:G$e,logcosh:V$e,categoricalCrossentropy:g1,sparseCategoricalCrossentropy:uA,binaryCrossentropy:lk,kullbackLeiblerDivergence:$$e,poisson:W$e,cosineProximity:jV};function WL(n){if(typeof n=="string"){if(n in cA)return cA[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new he(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function YV(n,e){return me(()=>{const t=ae(.5,Lo(e)),i=Hc(Fs(e,t),n.dtype);return vi(ko(n,i),-1)})}function JV(n,e){return me(()=>Hc(ko(Df(n,-1),Df(e,-1)),"float32"))}function lie(n,e){return me(()=>ot(wt(tl(ko(n,1),ko(e,1))),"float32"))}function H$e(n,e){return me(()=>ot(wt(tl(ko(n,1),ko(e,0))),"float32"))}function X$e(n,e){return me(()=>ot(wt(tl(ko(n,0),ko(e,1))),"float32"))}function uie(n,e){return me(()=>{const t=lie(n,e),i=X$e(n,e),r=He(t,i);return ot(ds(Fs(r,0),At(t,r),0),"float32")})}function K$e(n,e){return me(()=>{const t=lie(n,e),i=H$e(n,e),r=He(t,i);return ot(ds(Fs(r,0),At(t,r),0),"float32")})}function cie(n,e){return lk(n,e)}function hie(n,e){return n.rank===e.rank&&(n=Ud(n,[n.rank-1])),e=Df(e,-1),e.dtype!==n.dtype&&(e=ot(e,n.dtype)),ot(ko(n,e),"float32")}const Z$e=_m,j$e=_m,Y$e=ak,J$e=ak,Q$e=pb,q$e=pb,QV=g1,eWe=jV,die=uA,hA={binaryAccuracy:YV,categoricalAccuracy:JV,precision:uie,categoricalCrossentropy:QV,sparseCategoricalCrossentropy:die,mse:Z$e,MSE:j$e,mae:Y$e,MAE:J$e,mape:Q$e,MAPE:q$e,cosine:eWe};function tWe(n){if(typeof n=="string"&&n in hA)return hA[n];if(typeof n!="string"&&n!=null)return n;throw new he(`Unknown metric ${n}`)}function i_(n){if(gu(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(cA))if(cA[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(hA))if(hA[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nWe(n){const e={Adagrad:()=>Ip.adagrad(.01),Adadelta:()=>Ip.adadelta(1,.95,fr()),Adam:()=>Ip.adam(.001,.9,.999,fr()),Adamax:()=>Ip.adamax(.002,.9,.999,fr(),0),RMSProp:()=>Ip.rmsprop(.001,.9,0,fr()),SGD:()=>Ip.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new he(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const SZ=1*1024*1024;function TZ(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!vF(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const i=JSON.stringify(n);i.length>SZ&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${i.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${SZ}.`)}}function vF(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!vF(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!vF(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iWe(n,e,t,i=console.log){const r=sWe(n),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let o;if(!r){s.push("Receives inputs"),o=[];for(const c in n.nodesByDepth)o.push(...n.nodesByDepth[c])}i("_".repeat(e)),dA(s,t,i),i("=".repeat(e));const a=n.layers;for(let c=0;c<a.length;++c)r?oWe(a[c],t,i):aWe(a[c],t,o,i),i((c===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=rWe(n),u=sA(n.nonTrainableWeights);i(`Total params: ${l+u}`),i(`Trainable params: ${l}`),i(`Non-trainable params: ${u}`),i("_".repeat(e))}function rWe(n){let e;return n.collectedTrainableWeights!=null?e=sA(n.collectedTrainableWeights):e=sA(n.trainableWeights),e}function sWe(n){let e=!0;const t=[],i=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}i.push(...r)}if(e)for(const r of n.layers){let s=!1;for(const o of r.inboundNodes)if(i.indexOf(o)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function dA(n,e,t=console.log){let i="";for(let r=0;r<n.length;++r)r>0&&(i=i.slice(0,i.length-1)+" "),i+=n[r],i=i.slice(0,e[r]),i+=" ".repeat(e[r]-i.length);t(i)}function oWe(n,e,t){let i,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const s=n.name,o=n.getClassName(),a=[`${s} (${o})`,r,i,n.countParams().toString()];dA(a,e,t)}function aWe(n,e,t,i){let r,s;try{s=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],g=h.tensorIndices[d];o.push(`${p}[${f}][${g}]`)}const a=n.name,l=n.getClassName(),u=o.length===0?"":o[0],c=[`${a} (${l})`,s,r,n.countParams().toString(),u];dA(c,e,i);for(let h=1;h<o.length;++h)dA(["","","","",o[h]],e,i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pie(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function y1(n,e){if(n===null)return null;if(typeof n=="string")return Lp(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],i=n.length;for(let r=0;r<i;++r){const s=n[r];pie(e,r,s)?t.push(s):t.push(y1(s,e))}return t}else{const t={};for(const i of Object.keys(n)){const r=n[i];if(i==="name"&&typeof r=="string")t[i]=r;else{const s=Lp(i);t[s]=y1(r,s)}}return t}}function wF(n,e){if(n==null)return null;if(typeof n=="string")return cc(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],i=n.length;for(let r=0;r<i;++r){const s=n[r];pie(e,r,s)?t.push(s):t.push(wF(s,e))}return t}else{const t={};for(const i of Object.keys(n)){const r=n[i],s=cc(i);(i==="name"||i==="className")&&typeof r=="string"?t[s]=r:t[s]=wF(r,i)}return t}}/** @license See the LICENSE file. */const uk="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let lWe=class hu extends pn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const v=this.getClassName().toLowerCase();this.name=JI(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],ad(this.inputs).length!==this.inputs.length)throw new he(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);ad(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const w=v.sourceLayer,S=v.nodeIndex,C=v.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(S),this.outputLayersTensorIndices.push(C)}for(const v of this.inputs){const w=v.sourceLayer,S=v.nodeIndex,C=v.tensorIndex;gu(S===0,"input layer has >1 nodes"),gu(C===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(S),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const w=this.inputLayers[v];if(!(w instanceof db))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${v} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const t={},i={},r={},s={},o={},a=[],l=(v,w,S,C,_,A)=>{(C==null||_==null||A==null)&&(C=v.sourceLayer,_=v.nodeIndex,A=v.tensorIndex);const I=C.inboundNodes[_];if(S.indexOf(I)!==-1)throw new Su(`The tensor ${v.name} at layer "${C.name}" is part of a cycle.`);if(w.indexOf(I)!==-1)return;this.containerNodes.add(hu.nodeKey(C,_)),C.id in o||(o[C.id]=Object.keys(o).length),S.indexOf(I)===-1&&S.push(I);const E=I.inboundLayers.length;for(let k=0;k<E;k++){const P=I.inputTensors[k],V=I.inboundLayers[k],U=I.nodeIndices[k],F=I.tensorIndices[k];l(P,w,S,V,U,F)}for(w.push(I);S.indexOf(I)>=0;)S.splice(S.indexOf(I),1);a.push(I)},u=[],c=[];for(const v of this.outputs)l(v,u,c);const h=a.slice().reverse();for(const v of h){i[v.id]=v,v.id in t||(t[v.id]=0);let w=t[v.id];const S=r[v.outboundLayer.id]==null?0:r[v.outboundLayer.id];w=Math.max(w,S),r[v.outboundLayer.id]=w,s[v.outboundLayer.id]=v.outboundLayer,t[v.id]=w;for(let C=0;C<v.inboundLayers.length;C++){const _=v.inboundLayers[C],A=v.nodeIndices[C],I=_.inboundNodes[A],E=t[I.id]==null?0:t[I.id];t[I.id]=Math.max(w+1,E),i[I.id]=I}}const d={};for(const v in t){const w=t[v];w in d||(d[w]=[]),d[w].push(i[v])}const p={};for(const v in r){const w=r[v];w in p||(p[w]=[]),p[w].push(s[v])}let f=Object.keys(p).map(v=>parseInt(v,10)).sort(e_);this.layers=[];for(const v of f){const w=p[v];w.sort((S,C)=>{const _=o[S.id],A=o[C.id];return _<A?-1:_>A?1:0});for(const S of w)S instanceof hu&&this.internalContainerRefs.push(S),this.layers.push(S)}this.layersByDepth=p,f=Object.keys(d).map(v=>parseInt(v,10)).sort(e_);const g=this.inputs.slice(),y=[];for(const v of f)for(const w of d[v]){const S=w.outboundLayer;if(S!=null){for(const C of w.inputTensors)if(g.indexOf(C)===-1)throw new Su(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${S.name}". The following previous layers were accessed without issue: ${y}`);for(const C of w.outputTensors)g.push(C);y.push(S.name)}}this.nodesByDepth=d;const m=this.layers.map(v=>v.name);for(const v of m){const w=m.filter(S=>S===v).length;if(w!==1)throw new Su(`The name "${v}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new ok({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(i=>i.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new he("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const i of this.layers)t.push(...i.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const i={};let r=0;for(const o of this.layers)for(const a of o.weights){if(i[a.originalName]!=null)throw new he(`Duplicate weight name: ${a.originalName}`);i[a.originalName]=a,r++}const s=[];for(const o in e){let a=o;if(i[o]==null){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(i[a]!=null)s.push([i[a],e[o]]);else if(t)throw new he(`Provided weight data has no target variable: ${o}`);delete i[a]}if(t){const o=[];for(const a in i)o.push(a);if(o.length>0)throw new he(`${o.length} of ${r} weights are not set: ${o}`)}UV(s)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${uk}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const i=wF(this.updatedConfig());return t?JSON.stringify(i):i}call(e,t){return me(()=>{e=qn(e);const i=new Vh;for(let r=0;r<this.inputs.length;++r)i.add(this.inputs[r],e[r]);return Bx(this.outputs,i,t)})}computeMask(e,t){return me(()=>{e=qn(e);let i;return t==null?i=Uf(null,e.length):i=qn(t),this.runInternalGraph(e,i)[1]})}computeOutputShape(e){const t=rA(e);if(t.length!==this.inputLayers.length)throw new he(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const i={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],u=t[a],c=l.name+"_0_0";i[c]=u}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(e_);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const h=[];for(let g=0;g<u.inboundLayers.length;g++){const y=u.inboundLayers[g],m=u.nodeIndices[g],v=u.tensorIndices[g],w=`${y.name}_${m}_${v}`,S=i[w];h.push(S)}const d=c.computeOutputShape(Xs(h)),p=rA(d),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++){const y=`${c.name}_${f}_${g}`;i[y]=p[g]}}}const s=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];gu(l in i),s.push(i[l])}return Xs(s)}runInternalGraph(e,t){t==null&&(t=Uf(null,e.length));const i={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];i[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(e_);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(const g of d)g.id in i&&f.push(i[g.id]);if(f.length===d.length){let g={},y,m,v,w;if(c.callArgs!=null&&(g=c.callArgs),f.length===1){const[S,C]=f[0];g.mask==null&&(g.mask=C),v=qn(h.call(S,g)),w=qn(h.computeMask(S,C)),y=[S],m=[C]}else y=f.map(S=>S[0]),m=f.map(S=>S[1]),g.mask==null&&(g.mask=m),v=qn(h.call(y,g)),w=qn(h.computeMask(y,m));if(h.activityRegularizer)throw new tn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let S=0;S<p.length;++S){const C=p[S],_=v[S],A=w[S];i[C.id]=[_,A]}}}}const s=[],o=[],a=[];for(const l of this.outputs){gu(l.id in i,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=i[l.id];a.push(u.shape),s.push(u),o.push(c)}return[s,o,a]}buildNodeConversionMap(e){const t={};let i;for(const r of this.layers){i=r instanceof hu?1:0;for(let s=0;s<r.inboundNodes.length;s++){const o=hu.nodeKey(r,s);this.containerNodes.has(o)&&(t[o]=i,i+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new he(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new he("Provide either a layer name or layer index");for(const i of this.layers)if(i.name===e)return i;throw new he(`No such layer: ${e}`)}calculateLosses(){return me(()=>{const e=[];for(const t of this.layers)for(let i=0;i<t.inboundNodes.length;++i){const r=hu.nodeKey(t,i);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),i=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],p=hu.nodeKey(o,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const g=[];for(let y=0;y<d.inboundLayers.length;y++){const m=d.inboundLayers[y],v=d.nodeIndices[y],w=d.tensorIndices[y],S=hu.nodeKey(m,v);let C=t[S];C==null&&(C=0),g.push([m.name,C,w,f])}u.push(g)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,i.push(c)}e.layers=i;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],u=hu.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[o];r.push([a.name,c,h])}e.inputLayers=r;const s=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=hu.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[o];s.push([a.name,c,h])}return e.outputLayers=s,e}static fromConfig(e,t,i={},r=!1){const s={},o={};function a(y,m){y.name in o?o[y.name].push(m):o[y.name]=[m]}function l(y,m){const v=[];let w;for(const S of m){const C=S[0],_=S[1],A=S[2];if(w=S[3]==null?{}:S[3],!(C in s)){a(y,m);return}const I=s[C];if(I.inboundNodes.length<=_){a(y,m);return}const E=I.inboundNodes[_];v.push(E.outputTensors[A])}v.length>0&&y.apply(Xs(v),w)}function u(y){const m=y.name,v=Fl(y,t.customObjects!=null?t.customObjects:{});v.setFastWeightInitDuringBuild(r),s[m]=v,y.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new he(`Corrupted configuration, expected array for nodeData: ${w}`);a(v,w)})}const c=t.name,h=t.layers;for(const y of h)u(y);for(;!t$e(o);)for(const y of h){const m=s[y.name];if(m.name in o){const v=o[m.name];delete o[m.name];for(const w of v)l(m,w)}}const d=[],p=[],f=t.inputLayers;for(const y of f){const m=y[0],v=y[1],w=y[2];gu(m in s);const S=s[m].inboundNodes[v].outputTensors;d.push(S[w])}const g=t.outputLayers;for(const y of g){const m=y[0],v=y[1],w=y[2];gu(m in s);const S=s[m].inboundNodes[v].outputTensors;p.push(S[w])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new he("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){me(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uWe(n,e,t){const i=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(i===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==i)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${i} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(s=>{s in n?r.push(n[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${i}) outputs, so ${t} must be either an array with ${i} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function fie(n,e){return uWe(n,e,"classWeight")}async function mie(n,e,t,i){if(e!=null||i!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const r=me(()=>{if(n.shape.length===1)return Ru(n);if(n.shape.length===2){if(n.shape[1]>1)return Df(n,1);if(n.shape[1]===1)return ue(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());jt(r);const o=[];return s.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),ls(o,"float32")}else return null}function cWe(n,e){return ae(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hWe=32;function gie(n,e){let t,i;const r=e;t=r.xs,i=r.ys,B(t!=null&&i!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const s=CZ("input",n.inputNames,t),o=CZ("output",n.outputNames,i),a=s[0].shape[0];B(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),B(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<s.length;l++)B(s[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)B(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:s,ys:o}}function CZ(n,e,t){if(t instanceof An)return[t];if(Array.isArray(t))return B(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const i=[];for(const r of e){if(t[r]==null)throw new he(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);i.push(t[r])}return i}}function dWe(n){if(n.length===3)throw new tn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function pWe(n,e,t){const i=t.batchesPerEpoch!=null;if(B(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),B(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),B(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),B(!i||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),B(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let s,o;if(r)if(_Z(t.validationData))B(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const y=dWe(t.validationData);s=y.xs,o=y.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();const c=oie(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=aie(c,h,t.epochs,null,null,fWe(e,t),null,r,u);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;f<t.epochs;){const y={};await d.onEpochBegin(f);let m=0,v=0;for(i||(g=await e.iterator());!i||m<t.batchesPerEpoch;){const w=await g.next();if(i&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${m} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){const{xs:S,ys:C}=gie(n,w.value),_={};_.batch=v,_.size=S[0].shape[0],await d.onBatchBegin(v,_);const A=[];if(t.classWeight!=null){const k=fie(t.classWeight,n.outputNames);for(let P=0;P<k.length;++P)A.push(await mie(C[P],null,k[P]))}const I=S.concat(C).concat(A),E=a(I);jt(I);for(let k=0;k<l.length;++k){const P=l[k],V=E[k];_[P]=V,Ri(V)}await d.onBatchEnd(v,_),nie(_),v++,m++}if(i?m>=t.batchesPerEpoch:w.done){if(r){let S;_Z(t.validationData)?S=qn(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):S=qn(n.evaluate(s,o,{batchSize:t.validationBatchSize==null?hWe:t.validationBatchSize,verbose:0}));for(let C=0;C<n.metricsNames.length;++C)y[`val_${n.metricsNames[C]}`]=S[C]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,y),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function fWe(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function _Z(n){return typeof n.iterator=="function"}function mWe(n){return typeof n.next=="function"}async function gWe(n,e,t){t=t||{};const i=t.batches!=null,r=n.testFunction;let s=[];if(t.verbose>0)throw new tn("Verbose mode is not implemented yet.");B(!i||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=mWe(e)?e:await e.iterator();let a=0,l=0;for(;!i||l<t.batches;){const u=await o.next();if(s=me(()=>{if(u.value){const{xs:c,ys:h}=gie(n,u.value),d=c.concat(h),p=me(()=>r(d));if(jt(d),l===0)for(let g=0;g<p.length;++g)s.push(Nt(0));const f=d[0].shape[0];for(let g=0;g<p.length;++g){const y=p[g],m=s[g];s[g]=me(()=>He(s[g],ae(f,y))),l>0&&jt(m)}jt(p),a+=f,++l}return s}),u.done){i&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const c=s[u];s[u]=At(s[u],a),jt(c)}return Xs(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HL(n){B(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function wx(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(i=>hf(i,e,t-e)):hf(n,e,t-e)}function SF(n,e){return me(()=>n==null?null:Array.isArray(n)?n.map(t=>SF(t,e)):Jne(n,e.dtype==="int32"?e:ot(e,"int32")))}function XL(n,e){const t=[];let i=0,r=null;for(;i<n;)r=i+e,r>=n&&(r=n),t.push([i,r]),i=r;return t}function yie(n){const e=[];n instanceof An&&(n=[n]);for(let t=0;t<n.length;++t){const i=n[t];if(i.rank===1)e.push(_S(i,1));else{if(i.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(i)}}return e}function ml(n,e){if(n==null)return;const t=[];if(e instanceof An)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const s=e[r];t.push(s.id)}const i=[];if(n instanceof An)t.indexOf(n.id)===-1&&i.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&i.push(r)});else if(n!=null)for(const r in n){const s=n[r];t.indexOf(s.id)===-1&&i.push(s)}i.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yWe(n){return n instanceof An}function TF(n){return Array.isArray(n)}function MZ(n){return!yWe(n)&&!TF(n)}function AZ(n,e,t,i=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(TF(n)&&n.length>0)o=!0;else if(MZ(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new he(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let s;if(MZ(n)){n=n,s=[];for(const o of e){if(n[o]==null)throw new he(`No data provided for "${o}". Need data for each key in: ${e}`);s.push(n[o])}}else if(TF(n)){if(n=n,n.length!==e.length)throw new he(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(n=n,e.length>1)throw new he(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=yie(s),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=s[o];if(a.shape.length!==t[o].length)throw new he(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!i)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c>=0&&u!==c)throw new he(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function bWe(n,e,t){const i=ad(n.map(s=>s.shape[0]));i.sort();const r=ad(e.map(s=>s.shape[0]));if(r.sort(),i.length>1)throw new he(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>1)throw new he(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(i.length>0&&r.length>0&&!bn(i,r))throw new he(`Input Tensors should have the same number of samples as target Tensors. Found ${i[0]} input sample(s) and ${r[0]} target sample(s).`)}function xWe(n,e,t){const i=[_m,lk,g1];for(let r=0;r<n.length;++r){const s=n[r],o=e[r],a=t[r];if(o!=null){if(o===g1&&s.shape[s.shape.length-1]===1)throw new he(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(i.indexOf(o)!==-1){const l=s.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new he(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function EZ(n,e,t,i=!0,r=""){let s;if(Array.isArray(n)){if(n.length!==e.length)throw new he(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(e.length>1)throw new he(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=s[o];if(a.shape.length!==t[o].length)throw new he(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!i)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c!==u)throw new he(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function vWe(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(i=>t);{const i=[];for(const r of e){let s=t.hasOwnProperty(r)?t[r]:[];Array.isArray(s)||(s=[s]),i.push(s)}return i}}const wWe="layers-model";class Ic extends lWe{constructor(e){super(e),this.isTraining=!1}summary(e,t,i=console.log){if(!this.built)throw new he("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");iWe(this,e,t,i)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=nWe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof nh))throw new he("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new he(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(WL(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new he(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>WL(o))}else{const o=WL(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const i=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cf("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(i.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=vWe(e.metrics,this.outputNames),s=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};cf("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(i.indexOf(o)!==-1)continue;const a=r[o];(l=>{const u="";let c,h,d;for(const p of l){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===lk?["accuracy","acc"].indexOf(p)!==-1?h=YV:["crossentropy","ce"].indexOf(p)!==-1&&(h=cie):this.lossFunctions[o]===uA?["accuracy","acc"].indexOf(p)!==-1?h=hie:["crossentropy","ce"].indexOf(p)!==-1&&(h=die):["accuracy","acc"].indexOf(p)!==-1?h=JV:["crossentropy","ce"].indexOf(p)!==-1&&(h=QV);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=h,c=u+y}else d=tWe(p),c=u+i_(p);let f;cf(c,()=>{f=d}),s(o,c,f)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,i={}){const r=i.batchSize==null?32:i.batchSize;HL(r);const s=!0,o=this.standardizeUserDataXY(e,t,s,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,r,i.verbose,i.steps);return Xs(u)}finally{ml(o[0],e),ml(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),gWe(this,e,t)}checkNumSamples(e,t,i,r="steps"){let s;if(i!=null){if(s=null,t!=null)throw new he(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new he(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new he("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(t),r=i?t:[t],s=this.retrieveSymbolicTensors(r),o=new Vh;if(e instanceof An&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new he(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new he(`No value is provided for the model's input ${l.name}`);o.add(l,u)}const a=Bx(s,o);return i?a:a[0]}retrieveSymbolicTensors(e){const t=Uf(null,e.length);let i=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],o=s.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=s[l],i--),i===0)break}if(i===0)break}if(i>0){const r=[];throw t.forEach((s,o)=>{s==null&&r.push(e[o])}),new he(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,i=!1){return me(()=>{const r=this.checkNumSamples(e);if(i)throw new tn("Verbose predictLoop() is not implemented yet.");const s=XL(r,t),o=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)me(()=>{const l=s[a][0],u=s[a][1],c=wx(e,l,u),h=[];if(Array.isArray(c))for(let p=0;p<c.length;++p)h.push({key:this.inputs[p],value:c[p]});else h.push({key:this.inputs[0],value:c});const d=new Vh(h);return Bx(this.outputs,d)}).forEach((l,u)=>o[u].push(l));return Xs(o.map(a=>Hi(a,0)))})}predict(e,t={}){const i=yie(e);EZ(i,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return HL(r),this.predictLoop(i,r)}finally{ml(i,e)}}predictOnBatch(e){EZ(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,i=!0,r){if(this.optimizer_==null)throw new Su("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===uA?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(e=AZ(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=AZ(t,this.feedOutputNames,s,!1,"target"),bWe(e,t),xWe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new he(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,i,r,s=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,s,o);if(i!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=fie(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await mie(l[h],null,c[h]))}return[a,l,u]}testLoop(e,t,i,r=0,s){return me(()=>{const o=this.checkNumSamples(t,i,s,"steps"),a=[];if(r>0)throw new tn("Verbose mode is not implemented yet.");if(s!=null)throw new tn("steps mode in testLoop() is not implemented yet");{const l=XL(o,i),u=ls($l(0,o));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=hf(u,h,d-h),f=SF(t,p),g=e(f);if(c===0)for(let y=0;y<g.length;++y)a.push(Nt(0));for(let y=0;y<g.length;++y){const m=g[y];a[y]=He(a[y],ae(d-h,m))}}for(let c=0;c<a.length;++c)a[c]=At(a[c],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let i=0;i<e.length;++i){const r=e[i];let s=r;if(dZ(e,r)>1){const o=dZ(e.slice(0,i),r);s+=`_${o}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const c=[];for(let f=0;f<this.inputs.length;++f)c.push({key:this.inputs[f],value:i[f]});const h=new Vh(c),d=Bx(this.outputs,h,{training:!0});let p;for(let f=0;f<this.lossFunctions.length;++f){const g=this.lossFunctions[f];let y=g(r[f],d[f]);s[f]!=null&&(y=cWe(y,s[f]));const m=vi(y);t.push(m),f===0?p=y:p=He(p,y)}for(let f=0;f<this.metricsTensors.length;++f){let g;if(this.outputs.length>1&&f<this.outputs.length)g=t[f];else{const y=this.metricsTensors[f][0],m=this.metricsTensors[f][1];g=vi(y(r[m],d[m]))}Ri(g),o.push(g)}return p=vi(p),this.calculateLosses().forEach(f=>{p=He(p,f)}),p},l=this.collectedTrainableWeights.map(c=>c.read()),u=!0;return[this.optimizer_.minimize(a,u,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>me(()=>{const t=[];let i;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let u=0;u<this.inputs.length;++u)o.push({key:this.inputs[u],value:r[u]});const a=new Vh(o),l=Bx(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=vi(c(s[u],l[u]));u===0?i=h:i=He(i,h),t.push(i)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=vi(c(s[h],l[h]));t.push(d)}return t})}async fit(e,t,i={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,o,a,l,u,c,h,d;try{const p=i.batchSize==null?32:i.batchSize;HL(p);const f=!1,g=await this.standardizeUserData(e,t,i.sampleWeight,i.classWeight,f,p);r=g[0],s=g[1],d=g[2];let y=!1,m;if(i.validationData!=null&&i.validationData.length>0){if(y=!0,i.validationData.length===2)l=i.validationData[0],u=i.validationData[1];else throw i.validationData.length===3?new tn("validationData including sample weights is not supported yet."):new he(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);const I=!0,E=await this.standardizeUserData(l,u,null,null,I,p);c=E[0],h=E[1],m=c.concat(h)}else if(i.validationSplit!=null&&i.validationSplit>0&&i.validationSplit<1){y=!0;const I=Math.floor(r[0].shape[0]*(1-i.validationSplit)),E=r[0].shape[0];c=wx(r,I,E),o=r,r=wx(r,0,I),h=wx(s,I,E),a=s,s=wx(s,0,I),m=c.concat(h)}else i.validationSteps!=null&&(y=!0);const v=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();const w=this.makeTrainFunction(),S=this.getDedupedMetricsNames();let C,_;y?(this.makeTestFunction(),C=this.testFunction,_=S.slice().concat(S.map(I=>"val_"+I))):(C=null,m=[],_=S.slice());const A=oie(i.callbacks,i.yieldEvery);return await this.fitLoop(w,v,S,p,i.epochs,i.verbose,A,C,m,i.shuffle,_,i.initialEpoch,null,null)}finally{this.isTraining=!1,ml(r,e),ml(s,t),ml(o,e),ml(a,t),ml(c,l),ml(h,u),d!=null&&jt(d)}}async fitLoop(e,t,i,r,s,o,a,l,u,c,h,d,p,f){r==null&&(r=32),s==null&&(s=1),c==null&&(c=!0),d==null&&(d=0);let g=!1;if(l!=null&&u!=null&&(g=!0),f!=null&&(g=!0,p==null))throw new he("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(t,r,p,"steps_per_epoch");let m;y!=null&&(m=$l(0,y)),o==null&&(o=1);const{callbackList:v,history:w}=aie(a,o,s,d,y,p,r,g,h);v.setModel(this),this.history=w,await v.onTrainBegin(),this.stopTraining_=!1;for(let S=d;S<s;++S){await v.onEpochBegin(S);const C={};if(p!=null)throw new tn("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new tn("batch shuffling is not implemneted yet");c&&Nz(m);const _=ls(m),A=XL(y,r);for(let I=0;I<A.length;++I){const E={};if(await v.onBatchBegin(I,E),me(()=>{const k=A[I][0],P=A[I][1],V=hf(_,k,P-k);E.batch=I,E.size=P-k;const U=SF(t,V),F=e(U);for(let $=0;$<i.length;++$){const J=i[$],q=F[$];E[J]=q,Ri(q)}if(I===A.length-1&&g){const $=this.testLoop(l,u,r);for(let J=0;J<i.length;++J){const q=i[J],O=$[J];Ri(O),C["val_"+q]=O}}}),await v.onBatchEnd(I,E),nie(E),this.stopTraining_)break}_.dispose()}if(await v.onEpochEnd(S,C),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return pWe(this,e,t)}async trainOnBatch(e,t){const i=await this.standardizeUserData(e,t),r=i[0],s=i[1],o=this.makeTrainFunction()(r.concat(s)),a=[];for(const l of o){const u=await l.data();a.push(u[0])}return jt(o),ml(i[0],e),ml(i[1],t),Xs(a)}getNamedWeights(e){const t=[],i=e!=null&&e.trainableOnly,r=i?this.trainableWeights:this.weights,s=this.getWeights(i);for(let o=0;o<r.length;++o)i&&!r[o].trainable||t.push({name:r[o].originalName,tensor:s[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=h1().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-h1().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=cc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>cc(t))}else{const t=Object.keys(this.loss);e={};const i=this.loss;for(const r of t)if(typeof i[r]=="string")e[r]=cc(i[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[cc(i_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>cc(i_(e)));{const e={};for(const t in this.metrics)e[t]=cc(i_(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=y1(e.optimizer_config),i=Fl(t);let r;if(typeof e.loss=="string")r=Lp(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Lp(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Lp(e.loss[o])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(o=>Lp(o));else if(e.metrics!=null){s={};for(const o in e.metrics)s[o]=Lp(e.metrics[o])}this.compile({loss:r,metrics:s,optimizer:i})}async save(e,t){if(typeof e=="string"){const a=bte(e);if(a.length===0)throw new he(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new he(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new he("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=await oF(this.getNamedWeights(t)),r=!1,s=null,o={modelTopology:this.toJSON(s,r),format:wWe,generatedBy:`TensorFlow.js tfjs-layers v${uk}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const a="optimizer",{data:l,specs:u}=await oF(await this.optimizer.getWeights(),a);i.specs.push(...u),i.data=cI([i.data,l])}return this.userDefinedMetadata!=null&&(TZ(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=i.data,o.weightSpecs=i.specs,e.save(o)}setUserDefinedMetadata(e){TZ(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ic.className="Model";Xe(Ic);class bie extends Ic{}bie.className="Functional";Xe(bie);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function SWe(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const i=y1(t),r=Fl(i,e);if(n.weightsManifest!=null){const s=await Jte(n.weightsManifest,n.pathPrefix,r.weights.map(a=>a.originalName)),o={};for(const a of r.weights)o[a.originalName]=s[a.originalName];r.loadWeights(o),jt(s)}return r}async function TWe(n,e){if(e==null&&(e={}),typeof n=="string"){const t=xte(n,e);if(t.length===0)t.push(ene(n,e));else if(t.length>1)throw new he(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return CWe(n,void 0,e)}async function CWe(n,e,t){if(t==null&&(t={}),n.load==null)throw new he("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const i=await n.load();let r=i.modelTopology;r.model_config!=null&&(r=r.model_config);const s=t.strict==null?!0:t.strict,o=i.weightData!=null&&i.weightSpecs!=null&&s,a=Fl(y1(r),e,o),l=i.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),i.userDefinedMetadata!=null&&a.setUserDefinedMetadata(i.userDefinedMetadata),i.weightData!=null){if(i.weightSpecs==null)throw new he("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=_We(i.weightData,i.weightSpecs);a.loadWeights(u,s),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),jt(u),jt(c.map(h=>h.tensor))}return a}function _We(n,e){const t=$z(n,e),i={},r=[];return e.forEach(s=>{s.group==="optimizer"?r.push({name:s.name,tensor:t[s.name]}):i[s.name]=t[s.name]}),{modelWeights:i,optimizerWeights:r}}let ck=class CF extends Ic{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:JI("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new he(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof CF||e instanceof Ic;let i;if(t){if(i=e,i.outputs.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(i.inputs.length!==1)throw new he("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new he("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=tie({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=i.outputs,this.inputs=i.inputs;else{if(e.inboundNodes.length!==1)throw new he(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=eie(this.outputs[0])}this.inboundNodes=[],new ok({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Uf(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Rn(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ic({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,i=console.log){this.built||this.build(),super.summary(e,t,i)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,i={}){if(!this.built)throw new Su("The model needs to be compiled before being used.");return this.model.evaluate(e,t,i)}async evaluateDataset(e,t){if(!this.built)throw new Su("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,i={}){if(!this.built)throw new Su("The model needs to be compiled before being used.");return this.model.fit(e,t,i)}async fitDataset(e,t){if(!this.built)throw new Su("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,i={},r=!1){let s,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new he("Legacy serialization format not supported yet.");s=t}else B(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof CF))throw new tn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of s){const u=Fl(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new he("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new he("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const i={};i.className=t.getClassName(),i.config=t.getConfig(),e.push(i)}return{name:this.name,layers:e}}};ck.className="Sequential";Xe(ck);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let oo=class extends Sm{getConfig(){return{}}};class xie extends oo{apply(e,t=1){return g$e(e,t)}}xie.className="elu";Xe(xie);class vie extends oo{apply(e){return AI(e)}}vie.className="selu";Xe(vie);class wie extends oo{apply(e){return jl(e)}}wie.className="relu";Xe(wie);class Sie extends oo{apply(e){return me(()=>ab(6,jl(e)))}}Sie.className="relu6";Xe(Sie);class Tie extends oo{apply(e){return e}}Tie.className="linear";Xe(Tie);class Cie extends oo{apply(e){return Dl(e)}}Cie.className="sigmoid";Xe(Cie);class _ie extends oo{apply(e){return b$e(e)}}_ie.className="hardSigmoid";Xe(_ie);class Mie extends oo{apply(e){return xm(e)}}Mie.className="softplus";Xe(Mie);class Aie extends oo{apply(e){return y$e(e)}}Aie.className="softsign";Xe(Aie);class Eie extends oo{apply(e){return Of(e)}}Eie.className="tanh";Xe(Eie);let qV=class extends oo{apply(e,t=-1){return yS(e,t)}};qV.className="softmax";Xe(qV);class Iie extends oo{apply(e,t=-1){return vI(e,t)}}Iie.className="logSoftmax";Xe(Iie);class kie extends oo{apply(e,t=1){return me(()=>ae(Dl(ae(e,t)),e))}}kie.className="swish";Xe(kie);class Rie extends oo{apply(e){return me(()=>ae(e,Of(xm(e))))}}Rie.className="mish";Xe(Rie);function Sd(n){return n.getClassName()}function KL(n,e={}){return CS(n,Tm.getMap().classNameMap,e,"activation")}function Td(n){if(n==null){const e={};return e.className="linear",e.config={},KL(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},KL(e)}else return n instanceof oo?n:KL(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eU(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Nie extends Sm{}class IS extends Nie{constructor(e){super(),eU(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return me(()=>{let t=tr([1]);return this.hasL1&&(t=He(t,wt(ae(this.l1,qi(e))))),this.hasL2&&(t=He(t,wt(ae(this.l2,MS(e))))),ue(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}IS.className="L1L2";Xe(IS);function MWe(n){return eU(n),new IS({l1:n!=null?n.l1:null,l2:0})}function AWe(n){return eU(n),new IS({l2:n!=null?n.l2:null,l1:0})}const IZ={l1l2:"L1L2"};function Hn(n){return NV(n)}function kZ(n,e={}){return CS(n,Tm.getMap().classNameMap,e,"regularizer")}function mi(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in IZ?IZ[n]:n,config:{}};return kZ(e)}else return n instanceof Nie?n:kZ(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tU extends pn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Wt(e);let i=jl(e);return this.maxValue!=null&&(i=eo(i,0,this.maxValue)),i}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}tU.className="ReLU";Xe(tU);class nU extends pn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const i=Wt(e);return lS(i,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}nU.className="LeakyReLU";Xe(nU);class iU extends pn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=fi(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=mi(e.alphaRegularizer),this.alphaConstraint=yr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new he(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Rn(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)i[r]=e[r];this.inputSpec=[new ir({ndim:e.length,axes:i})],this.built=!0}call(e,t){return e=Wt(e),fS(e,this.alpha.read())}getConfig(){const e={alphaInitializer:wi(this.alphaInitializer),alphaRegularizer:Hn(this.alphaRegularizer),alphaConstraint:gr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}iU.className="PReLU";Xe(iU);let rU=class extends pn{constructor(n){if(super(n??{}),this.DEFAULT_ALPHA=1,n==null&&(n={}),n.alpha!=null&&n.alpha!==this.DEFAULT_ALPHA)throw new tn(`Non-default alpha value (${n.alpha}) is not supported by the ELU layer yet.`);this.alpha=n.alpha==null?this.DEFAULT_ALPHA:n.alpha}call(n,e){const t=Wt(n);return ib(t)}computeOutputShape(n){return n}getConfig(){const n={alpha:this.alpha},e=super.getConfig();return Object.assign(n,e),n}};rU.className="ELU";Xe(rU);let sU=class extends pn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const i=Wt(e);return ae(i,ot(Fs(i,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};sU.className="ThresholdedReLU";Xe(sU);let oU=class extends pn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new qV().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const i=Wt(e);return this.softmax(i,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};oU.className="Softmax";Xe(oU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uy(n,e,t){if(typeof n=="number")return Uf(n,e);if(n.length!==e)throw new he(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let i=0;i<e;++i){const r=n[i];if(!d$e(r))throw new he(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Ol(n,e,t,i,r=1){if(n==null)return n;const s=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-s+1,Math.floor((o+i-1)/i)}function yu(n,e,t,i){if(n==null)return null;if(i==="valid")n=n*e+wd([t-e,0]);else if(i==="same")n=n*e;else throw new he(`Unsupport padding mode: ${i}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aU(n,e){return me(()=>(Zi(e),e==="channelsFirst"?gn(n,[0,2,3,1]):n))}function Lie(n,e){return me(()=>(Zi(e),e==="channelsFirst"?gn(n,[0,2,3,4,1]):n))}function EWe(n,e,t,i=1,r="valid",s,o=1){return me(()=>{if(s==null&&(s=Wl()),Zi(s),n.shape.length!==3)throw new he(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new he(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new he(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(n=gn(n,[0,2,1])),r==="causal")throw new tn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=pI(n,e,i,r==="same"?"same":"valid","NWC",o);return t!=null&&(a=Yl(a,t)),a})}function RZ(n,e,t,i=[1,1],r="valid",s,o,a=null){return me(()=>{if(s==null&&(s=Wl()),Zi(s),n.rank!==3&&n.rank!==4)throw new he(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new he(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=aU(n,s);if(r==="causal")throw new tn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Bte({x:l,filter:e,strides:i,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),s==="channelsFirst"&&(l=gn(l,[0,3,1,2])),l})}function IWe(n,e,t,i=[1,1,1],r="valid",s,o){return me(()=>{if(s==null&&(s=Wl()),Zi(s),n.rank!==4&&n.rank!==5)throw new he(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new he(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Lie(n,s);if(r==="causal")throw new tn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=gG(a,e,i,r==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Yl(a,t)),s==="channelsFirst"&&(a=gn(a,[0,4,1,2,3])),a})}class hk extends pn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",hk.verifyArgs(t),this.rank=e,_r(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new tn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=uy(t.kernelSize,e,"kernelSize"),this.strides=uy(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,ba(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Zi(this.dataFormat),this.activation=Td(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=fi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=yr(t.biasConstraint),this.biasRegularizer=mi(t.biasRegularizer),this.activityRegularizer=mi(t.activityRegularizer),this.dilationRate=uy(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new he(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new he(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new he(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(gu("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!LV(e.kernelSize,"number",1,3))throw new he(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Sd(this.activation),useBias:this.useBias,biasInitializer:wi(this.biasInitializer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),biasConstraint:gr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class fb extends hk{constructor(e,t){super(e,t),this.kernel=null,fb.verifyArgs(t),this.filters=t.filters,_r(this.filters,"filters"),this.kernelInitializer=fi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=yr(t.kernelConstraint),this.kernelRegularizer=mi(t.kernelRegularizer)}build(e){e=Rn(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he(`The channel dimension of the input should be defined. Found ${e[t]}`);const i=e[t],r=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:i}}],this.built=!0}call(e,t){return me(()=>{e=Wt(e);let i;const r=this.bias==null?null:this.bias.read(),s=Hne(this.activation.getClassName());if(s!=null&&this.rank===2)i=RZ(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)i=EWe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)i=RZ(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)i=IWe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new tn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(i=this.activation.apply(i))}return i})}computeOutputShape(e){e=Rn(e);const t=[],i=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<i.length;++s){const o=Ol(i[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:wi(this.kernelInitializer),kernelRegularizer:Hn(this.kernelRegularizer),kernelConstraint:gr(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new he(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class mb extends fb{constructor(e){super(2,e),mb.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!LV(e.kernelSize,"number",1,2))throw new he(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}mb.className="Conv2D";Xe(mb);class gb extends fb{constructor(e){super(3,e),gb.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new he(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}gb.className="Conv3D";Xe(gb);let lU=class extends mb{constructor(e){if(super(e),this.inputSpec=[new ir({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Rn(e),e.length!==4)throw new he("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");const i=e[t],r=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ir({ndim:4,axes:{[t]:i}})],this.built=!0}call(e,t){return me(()=>{let i=Wt(e);if(i.shape.length!==4)throw new he(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const r=i.shape,s=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],u=r[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=yu(l,d,c,this.padding),g=yu(u,p,h,this.padding),y=[s,f,g,this.filters];this.dataFormat!=="channelsLast"&&(i=gn(i,[0,2,3,1]));let m=fI(i,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(m=gn(m,[0,3,1,2])),this.bias!=null&&(m=Yl(m,this.bias.read(),this.dataFormat)),this.activation!=null&&(m=this.activation.apply(m)),m})}computeOutputShape(e){e=Rn(e);const t=e.slice();let i,r,s;this.dataFormat==="channelsFirst"?(i=1,r=2,s=3):(i=3,r=1,s=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[i]=this.filters,t[r]=yu(t[r],l,o,this.padding),t[s]=yu(t[s],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};lU.className="Conv2DTranspose";Xe(lU);let uU=class extends gb{constructor(e){if(super(e),this.inputSpec=[new ir({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Rn(e),e.length!==5)throw new he("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");const i=e[t],r=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ir({ndim:5,axes:{[t]:i}})],this.built=!0}call(e,t){return me(()=>{let i=Wt(e);if(i.shape.length!==5)throw new he(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const r=i.shape,s=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const u=r[l],c=r[o],h=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[0],y=this.strides[1],m=this.strides[2],v=yu(u,g,d,this.padding),w=yu(c,y,p,this.padding),S=yu(h,m,f,this.padding),C=[s,v,w,S,this.filters];this.dataFormat!=="channelsLast"&&(i=gn(i,[0,2,3,4,1]));let _=yG(i,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=gn(_,[0,4,1,2,3])),this.bias!==null&&(_=Yl(_,this.bias.read(),this.dataFormat)),this.activation!==null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=Rn(e);const t=e.slice();let i,r,s,o;this.dataFormat==="channelsFirst"?(i=1,r=2,s=3,o=4):(i=4,r=1,s=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[i]=this.filters,t[r]=yu(t[r],c,a,this.padding),t[s]=yu(t[s],h,l,this.padding),t[o]=yu(t[o],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};uU.className="Conv3DTranspose";Xe(uU);let Pie=class extends fb{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new he("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new he("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new he(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=fi(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=mi(t.depthwiseRegularizer),this.depthwiseConstraint=yr(t.depthwiseConstraint),this.pointwiseInitializer=fi(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=mi(t.pointwiseRegularizer),this.pointwiseConstraint=yr(t.pointwiseConstraint)}build(e){if(e=Rn(e),e.length<this.rank+2)throw new he(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const i=e[t],r=this.kernelSize.concat([i,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(i*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new ir({ndim:this.rank+2,axes:{[t]:i}})],this.built=!0}call(e,t){return me(()=>{e=Wt(e);let i;if(this.rank===1)throw new tn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=gn(e,[0,2,3,1])),i=EI(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=Yl(i,this.bias.read(),this.dataFormat)),this.activation!=null&&(i=this.activation.apply(i)),this.dataFormat==="channelsFirst"&&(i=gn(i,[0,3,1,2])),i})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=wi(this.depthwiseInitializer),e.pointwiseInitializer=wi(this.pointwiseInitializer),e.depthwiseRegularizer=Hn(this.depthwiseRegularizer),e.pointwiseRegularizer=Hn(this.pointwiseRegularizer),e.depthwiseConstraint=gr(this.depthwiseConstraint),e.pointwiseConstraint=gr(this.pointwiseConstraint),e}};Pie.className="SeparableConv";let cU=class extends Pie{constructor(e){super(2,e)}};cU.className="SeparableConv2D";Xe(cU);class kS extends fb{constructor(e){super(1,e),kS.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!LV(e.kernelSize,"number",1,1))throw new he(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}kS.className="Conv1D";Xe(kS);let hU=class extends pn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return me(()=>{if(e=Wt(e),this.dataFormat==="channelsLast"){const i=n_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return n_(i,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const i=n_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return n_(i,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};hU.className="Cropping2D";Xe(hU);let dU=class extends pn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zi(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,u$e(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],i=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,i]}else{const t=e[1]==null?null:this.size[0]*e[1],i=e[2]==null?null:this.size[1]*e[2];return[e[0],t,i,e[3]]}}call(e,t){return me(()=>{let i=Wt(e);const r=i.shape;if(this.dataFormat==="channelsFirst"){i=gn(i,[0,2,3,1]);const s=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?wu.resizeNearestNeighbor(i,[s,o]):wu.resizeBilinear(i,[s,o]);return gn(a,[0,3,1,2])}else{const s=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?wu.resizeNearestNeighbor(i,[s,o]):wu.resizeBilinear(i,[s,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};dU.className="UpSampling2D";Xe(dU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kWe(n,e,t=[1,1],i="valid",r,s){return me(()=>{r==null&&(r=Wl()),Zi(r);let o=aU(n,r);if(n.rank!==4)throw new he(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new he(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=nb(o,e,t,i==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(o=gn(o,[0,3,1,2])),o})}let pU=class extends hk{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=fi(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=yr(e.depthwiseConstraint),this.depthwiseRegularizer=mi(e.depthwiseRegularizer)}build(e){if(e=Rn(e),e.length<4)throw new he(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const i=e[t],r=[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return me(()=>{e=Wt(e);let i=kWe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=Yl(i,this.bias.read(),this.dataFormat)),this.activation!=null&&(i=this.activation.apply(i)),i})}computeOutputShape(e){e=Rn(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],i=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Ol(t,this.kernelSize[0],this.padding,this.strides[0]),o=Ol(i,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,o]:[e[0],s,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=wi(this.depthwiseInitializer),e.depthwiseRegularizer=Hn(this.depthwiseRegularizer),e.depthwiseConstraint=gr(this.depthwiseRegularizer),e}};pU.className="DepthwiseConv2D";Xe(pU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Die(n,e,t,i){if(Array.isArray(n)){if(e!=null||t!=null)throw new he("When inputs is an array, neither initialState or constants should be provided");i!=null&&(t=n.slice(n.length-i,n.length),n=n.slice(0,n.length-i)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function Fie(n,e,t,i=!1,r,s,o=!1,a=!1){return me(()=>{const l=e.shape.length;if(l<3)throw new he(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat($l(2,l));if(e=gn(e,u),s!=null)throw new tn("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ot(ot(r,"bool"),"float32"),r.rank===l-1&&(r=as(r,-1)),r=gn(r,u)),i&&(e=da(e,0),r!=null&&(r=da(r,0)));const c=[];let h,d=t;const p=e.shape[0],f=pa(e);let g;r!=null&&(g=pa(r));for(let m=0;m<p;++m){const v=f[m],w=me(()=>n(v,d));if(r==null)h=w[0],d=w[1];else{const S=me(()=>{const C=g[m],_=xt(Lo(C),C),A=He(ae(w[0],C),ae(d[0],_)),I=d.map((E,k)=>He(ae(w[1][k],C),ae(E,_)));return{output:A,newStates:I}});h=S.output,d=S.newStates}a&&c.push(h)}let y;return a&&(y=Ls(c,1)),[h,y,d]})}class Jl extends pn{constructor(e){super(e);let t;if(e.cell==null)throw new he("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new fk({cells:e.cell}):t=e.cell,t.stateSize==null)throw new he("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ir({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return $l(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){bF(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const i=t[0];let r;if(this.returnSequences?r=[e[0],e[1],i]:r=[e[0],i],this.returnState){const s=[];for(const o of t)s.push([e[0],o]);return[r].concat(s)}else return r}computeMask(e,t){return me(()=>{Array.isArray(t)&&(t=t[0]);const i=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(s=>null);return[i].concat(r)}else return i})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let i=0;i<e;++i)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new tn("Constants support is not implemented in RNN yet.");bF(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new ir({shape:[t,null,...i]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!bn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),s))throw new he(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(o=>new ir({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){me(()=>{if(!this.stateful)throw new Rh("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(i==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>tr([i,r])):this.states_=[tr([i,this.cell.stateSize])];else if(e==null)jt(this.states_),this.keptStates!=null&&(jt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>tr([i,r])):this.states_[0]=tr([i,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):jt(this.states_);for(let r=0;r<this.states_.length;++r){const s=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[i,o];if(!bn(s.shape,a))throw new he(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Ri(r.clone()))})}apply(e,t){let i=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const s=Die(e,i,r,this.numConstants);e=s.inputs,i=s.initialState,r=s.constants;let o=[],a=[];if(i!=null){t.initialState=i,o=o.concat(i),this.stateSpec=[];for(const l of i)this.stateSpec.push(new ir({shape:l.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof El){const l=[e].concat(o),u=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=u;const h=super.apply(l,t);return this.inputSpec=c,h}else return super.apply(e,t)}call(e,t){return me(()=>{const i=t==null?null:t.mask,r=t==null?null:t.training;let s=t==null?null:t.initialState;e=Wt(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==o)throw new he(`RNN Layer has ${o} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},l=Fie((p,f)=>{const g=this.cell.call([p].concat(f),a);return[g[0],g.slice(1)]},e,s,this.goBackwards,i,null,this.unroll,this.returnSequences),u=l[0],c=l[1],h=l[2];this.stateful&&this.resetStates(h,r);const d=this.returnSequences?c:u;return this.returnState?[d].concat(h):d})}getInitialState(e){return me(()=>{let t=tr(e.shape);return t=wt(t,[1,2]),t=_S(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?gF(t,[1,i]):t):this.cell.stateSize>1?[gF(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===Jl.className&&(t.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),e),t)}static fromConfig(e,t,i={}){const r=t.cell,s=Fl(r,i);return new e(Object.assign(t,{cell:s}))}}Jl.className="RNN";Xe(Jl);class RS extends pn{}let dk=class extends RS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_r(this.units,"units"),this.activation=Td(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mi(e.kernelRegularizer),this.recurrentRegularizer=mi(e.recurrentRegularizer),this.biasRegularizer=mi(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=zy([1,wd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zy([1,wd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return me(()=>{if(e=e,e.length!==2)throw new he(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let i=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Cd({ones:()=>Lo(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Cd({ones:()=>Lo(i),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?s=Lu(ae(e,o),this.kernel.read()):s=Lu(e,this.kernel.read()),this.bias!=null&&(s=Yl(s,this.bias.read())),a!=null&&(i=ae(i,a));let l=He(s,Lu(i,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Sd(this.activation),useBias:this.useBias,kernelInitializer:wi(this.kernelInitializer),recurrentInitializer:wi(this.recurrentInitializer),biasInitializer:wi(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};dk.className="SimpleRNNCell";Xe(dk);let fU=class extends Jl{constructor(e){e.cell=new dk(e),super(e)}call(e,t){return me(()=>{this.cell.dropoutMask!=null&&(jt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(jt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:i,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};fU.className="SimpleRNN";Xe(fU);let pk=class extends RS{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new he("GRUCell does not support reset_after parameter set to true.");this.units=e.units,_r(this.units,"units"),this.activation=Td(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Td(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mi(e.kernelRegularizer),this.recurrentRegularizer=mi(e.recurrentRegularizer),this.biasRegularizer=mi(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=zy([1,wd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zy([1,wd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rn(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return me(()=>{if(e=e,e.length!==2)throw new he(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const i=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Cd({ones:()=>Lo(e),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Cd({ones:()=>Lo(r),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=ae(e,s[0]));let c=Lu(e,this.kernel.read());this.useBias&&(c=Yl(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,o[0]));const h=this.recurrentKernel.read(),[d,p]=Js(h,[2*this.units,this.units],h.rank-1),f=Lu(r,d),[g,y,m]=Js(c,3,c.rank-1),[v,w]=Js(f,2,f.rank-1);a=this.recurrentActivation.apply(He(g,v)),l=this.recurrentActivation.apply(He(y,w));const S=Lu(ae(l,r),p);u=this.activation.apply(He(m,S));const C=He(ae(a,r),ae(He(1,si(a)),u));return[C,C]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Sd(this.activation),recurrentActivation:Sd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wi(this.kernelInitializer),recurrentInitializer:wi(this.recurrentInitializer),biasInitializer:wi(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};pk.className="GRUCell";Xe(pk);let mU=class extends Jl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new pk(e),super(e)}call(e,t){return me(()=>{this.cell.dropoutMask!=null&&(jt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(jt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:i,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};mU.className="GRU";Xe(mU);class NS extends RS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_r(this.units,"units"),this.activation=Td(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Td(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=mi(e.kernelRegularizer),this.recurrentRegularizer=mi(e.recurrentRegularizer),this.biasRegularizer=mi(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=zy([1,wd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=zy([1,wd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Rn(e);const i=e[e.length-1];this.kernel=this.addWeight("kernel",[i,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,o=this.units;r=new(t=class extends sl{apply(a,l){const u=s.apply([o]),c=new qI().apply([o]),h=s.apply([o*2]);return fZ(fZ(u,c),h)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return me(()=>{const i=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new he(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Cd({ones:()=>Lo(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Cd({ones:()=>Lo(r),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=ae(e,o[0]));let d=Lu(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,a[0])),d=He(d,Lu(r,this.recurrentKernel.read())),this.useBias&&(d=Yl(d,this.bias.read()));const[p,f,g,y]=Js(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=He(ae(u,s),ae(l,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const m=ae(h,this.activation.apply(c));return[m,m,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Sd(this.activation),recurrentActivation:Sd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wi(this.kernelInitializer),recurrentInitializer:wi(this.recurrentInitializer),biasInitializer:wi(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}NS.className="LSTMCell";Xe(NS);let gU=class extends Jl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new NS(e),super(e)}call(e,t){return me(()=>{this.cell.dropoutMask!=null&&(jt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(jt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:i,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};gU.className="LSTM";Xe(gU);let fk=class extends RS{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return me(()=>{e=e;let i=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(i.splice(0,a.stateSize.length)):r.push(i.splice(0,1));r.reverse();const s=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];i=r[a],a===0?o=[e[0]].concat(i):o=[o[0]].concat(i),o=l.call(o,t),s.push(o.slice(1))}i=[];for(const a of s.slice().reverse())i.push(...a);return[o[0]].concat(i)})}build(e){bF(e)&&(e=e[0]),e=e;let t;this.cells.forEach((i,r)=>{cf(`RNNCell_${r}`,()=>{i.build(e),Array.isArray(i.stateSize)?t=i.stateSize[0]:t=i.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,i={}){const r=[];for(const s of t.cells)r.push(Fl(s,i));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const i of this.cells)t.push(...i.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return xF(e)}setWeights(e){const t=[];for(const i of this.cells){const r=i.weights.length,s=e.splice(r);for(let o=0;o<i.weights.length;++o)t.push([i.weights[o],s[o]])}UV(t)}};fk.className="StackedRNNCells";Xe(fk);function Cd(n){const{ones:e,rate:t,training:i=!1,count:r=1,dropoutFunc:s}=n,o=()=>s!=null?s(e(),t):Qne(e(),t),a=()=>AS(o,e,i);return!r||r<=1?Ri(a().clone()):Array(r).fill(void 0).map(a).map(l=>Ri(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var RWe=globalThis&&globalThis.__rest||function(n,e){var t={};for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&e.indexOf(i)<0&&(t[i]=n[i]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,i=Object.getOwnPropertySymbols(n);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(n,i[r])&&(t[i[r]]=n[i[r]]);return t};let Oie=class extends Jl{constructor(e){if(e.unroll)throw new tn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new tn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ir({ndim:5})]}call(e,t){return me(()=>{if(this.cell.dropoutMask!=null&&(jt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(jt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new he("ConvRNN2D cell does not support constants");const i=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:i,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return me(()=>{const{stateSize:t}=this.cell,i=e.shape,r=this.computeSingleOutputShape(i),s=[r[0],...r.slice(2)],o=tr(s);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){me(()=>{if(!this.stateful)throw new Rh("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,r=this.computeSingleOutputShape(i),s=[r[0],...r.slice(2)];if(i[0]==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>tr(s)):this.states_=[tr(s)];else if(e==null)jt(this.states_),this.keptStates!=null&&(jt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>tr(s)):this.states_[0]=tr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):jt(this.states_);for(let o=0;o<this.states_.length;++o){const a=e[o],l=s;if(!bn(a.shape,l))throw new he(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${a.shape}`);this.states_[o]=a}}this.states_=this.states_.map(o=>Ri(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:i,kernelSize:r,padding:s,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=Ol(u,r[0],s,o[0],a[0]),d=Ol(c,r[1],s,o[1],a[1]);return[...e.slice(0,2),...l?[i,h,d]:[h,d,i]]}};Oie.className="ConvRNN2D";let mk=class extends NS{constructor(e){const{filters:t,kernelSize:i,strides:r,padding:s,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,_r(this.filters,"filters"),this.kernelSize=uy(i,2,"kernelSize"),this.kernelSize.forEach(l=>_r(l,"kernelSize")),this.strides=uy(r||1,2,"strides"),this.strides.forEach(l=>_r(l,"strides")),this.padding=s||"valid",ba(this.padding),this.dataFormat=o||"channelsLast",Zi(this.dataFormat),this.dilationRate=uy(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>_r(l,"dilationRate"))}build(e){var t;e=Rn(e);const i=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[i]==null)throw new he(`The channel dimension of the input should be defined. Found ${e[i]}`);const r=e[i],s=4,o=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends sl{apply(h,d){const p=u.apply([c]),f=_o([c]),g=u.apply([c*2]);return PV([p,f,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return me(()=>{if(e.length!==3)throw new he(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const i=t.training||!1,r=e[0],s=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Cd({ones:()=>Lo(r),rate:this.dropout,training:i,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(j,z,Z)=>!z||!z[Z]?j:ae(z[Z],j);let c=u(r,l,0),h=u(r,l,1),d=u(r,l,2),p=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Cd({ones:()=>Lo(s),rate:this.recurrentDropout,training:i,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let g=u(s,f,0),y=u(s,f,1),m=u(s,f,2),v=u(s,f,3);const w=3,[S,C,_,A]=Js(this.kernel.read(),a,w),[I,E,k,P]=this.useBias?Js(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,S,I,this.padding),h=this.inputConv(h,C,E,this.padding),d=this.inputConv(d,_,k,this.padding),p=this.inputConv(p,A,P,this.padding);const[V,U,F,$]=Js(this.recurrentKernel.read(),a,w);g=this.recurrentConv(g,V),y=this.recurrentConv(y,U),m=this.recurrentConv(m,F),v=this.recurrentConv(v,$);const J=this.recurrentActivation.apply(He(c,g)),q=this.recurrentActivation.apply(He(h,y)),O=He(ae(q,o),ae(J,this.activation.apply(He(d,m)))),X=ae(this.recurrentActivation.apply(He(p,v)),this.activation.apply(O));return[X,X,O]})}getConfig(){const e=super.getConfig(),t=RWe(e,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),i)}inputConv(e,t,i,r){const s=Uc(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return i?Yl(s,i,this.dataFormat):s}recurrentConv(e,t){return Uc(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};mk.className="ConvLSTM2DCell";Xe(mk);let yU=class extends Oie{constructor(e){const t=new mk(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};yU.className="ConvLSTM2D";Xe(yU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let gk=class extends pn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,i=[];for(let r=0;r<this.noiseShape.length;++r)i.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return i}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,s=this.getNoiseShape(i);return AS(()=>Qne(i,this.rate,s,this.seed),()=>i,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};gk.className="Dropout";Xe(gk);let bU=class extends gk{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}};bU.className="SpatialDropout1D";Xe(bU);let xU=class extends pn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,_r(this.units,"units"),this.activation=Td(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=fi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=fi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=yr(e.kernelConstraint),this.biasConstraint=yr(e.biasConstraint),this.kernelRegularizer=mi(e.kernelRegularizer),this.biasRegularizer=mi(e.biasRegularizer),this.activityRegularizer=mi(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Rn(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Rn(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e),r=Hne(this.activation.getClassName());let s;return r!=null?s=Lu(i,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Lu(i,this.kernel.read()),this.bias!=null&&(s=Yl(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:Sd(this.activation),useBias:this.useBias,kernelInitializer:wi(this.kernelInitializer),biasInitializer:wi(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),biasConstraint:gr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};xU.className="Dense";Xe(xU);let vU=class extends pn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Rn(e);for(const t of e.slice(1))if(t==null)throw new he(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ld(e,1)]}call(e,t){return me(()=>{this.invokeCallHook(e,t);let i=Wt(e);if(this.dataFormat==="channelsFirst"&&i.rank>1){const r=[0];for(let s=2;s<i.rank;++s)r.push(s);r.push(1),i=gn(i,r)}return m$e(i)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}};vU.className="Flatten";Xe(vU);let wU=class extends pn{constructor(e){super(e),this.supportsMasking=!0,this.activation=Td(e.activation)}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e);return this.activation.apply(i)})}getConfig(){const e={activation:Sd(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};wU.className="Activation";Xe(wU);let SU=class extends pn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return me(()=>(e=Wt(e),p$e(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};SU.className="RepeatVector";Xe(SU);let TU=class extends pn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const i="Total size of new array must be unchanged.",r=t.slice();let s=1,o=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(o===null)o=l;else throw new he("Can only specifiy one unknown dimension.");else s*=u}const a=ld(e);if(o!==null){if(s===0||a%s!==0)throw new he(i);r[o]=a/s}else if(a!==s)throw new he(i);return r}computeOutputShape(e){let t=!1;for(let i=0;i<e.length;++i)if(this.isUnknown(e[i])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e),r=i.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ue(i,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};TU.className="Reshape";Xe(TU);let CU=class extends pn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=$l(1,e.dims.length+1);if(!bn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ir({ndim:this.dims.length+1})]}computeOutputShape(e){e=Rn(e);const t=e.slice();return this.dims.forEach((i,r)=>{t[r+1]=e[i]}),t}call(e,t){return gn(Wt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};CU.className="Permute";Xe(CU);let _U=class extends pn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const i=Wt(e),r=-1;return d1(zf(i,this.maskValue),r)}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e),r=-1,s=!0,o=d1(zf(i,this.maskValue),r,s);return ae(i,ot(o,i.dtype))})}};_U.className="Masking";Xe(_U);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let MU=class extends pn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(qn(e.inputLength))}this.inputDim=e.inputDim,_r(this.inputDim,"inputDim"),this.outputDim=e.outputDim,_r(this.outputDim,"outputDim"),this.embeddingsInitializer=fi(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=mi(e.embeddingsRegularizer),this.activityRegularizer=mi(e.activityRegularizer),this.embeddingsConstraint=yr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return me(()=>this.maskZero?(e=Wt(e),zf(e,wn(e))):null)}computeOutputShape(e){if(e=Rn(e),this.inputLength==null)return[...e,this.outputDim];const t=qn(this.inputLength);if(t.length!==e.length-1)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let i=0;for(let r=0;r<t.length;++r){const s=t[r],o=e[r+1];if(s!=null&&o!=null&&s!==o)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[i]=o),i++}}return[e[0],...t,this.outputDim]}call(e,t){return me(()=>{this.invokeCallHook(e,t);let i=Wt(e);i.dtype!=="int32"&&(i=Hc(i,"int32"));const r=Jne(this.embeddings.read(),ue(i,[i.size]));return ue(r,Rn(this.computeOutputShape(i.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:wi(this.embeddingsInitializer),embeddingsRegularizer:Hn(this.embeddingsRegularizer),activityRegularizer:Hn(this.activityRegularizer),embeddingsConstraint:gr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};MU.className="Embedding";Xe(MU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Mm extends pn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new tn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const i=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],o=t[r];if(s==null||o==null||s<0||o<0)i.push(null);else if(s===1)i.push(o);else if(o===1)i.push(s);else{if(s!==o)throw new he("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));i.push(s)}}return i}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Rn(e)]),e=e,e.length<2)throw new he(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=ad(t),t.length>1)throw new he(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let i=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){const o=e[s]==null?null:e[s].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}const r=e.map(s=>s.length);e.indexOf(null)===-1&&ad(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return me(()=>{if(e=e,this.reshapeRequired){const i=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){const s=wd(r);for(let o of e){const a=o.rank;for(let l=0;l<s-a;++l)o=_S(o,1);i.push(o)}return this.mergeFunction(i)}else{let s=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=ue(l,[h].concat(ld(c.slice(1))));p=gn(p,[1,0]),p=ue(p,d),i.push(p),s=!0}else if(u>1){const c=$l(1,u).concat([0]);i.push(gn(l,c)),s=!0}else i.push(l)}let o=this.mergeFunction(i);const a=o.rank;if(s){if(a==null){const l=o.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));o=ue(gn(ue(o,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat($l(0,a-1));o=gn(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let i=[];for(const r of e)r!=null&&r[0]!==null&&i.push(r[0]);return i=ad(i),i.length===1?t=i.concat(t):t=[null].concat(t),t}computeMask(e,t){return me(()=>{if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an Array");if(!Array.isArray(e))throw new he("`inputs` should be an Array");if(t.length!==e.length)throw new he(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:as(r,0));let i=t[0];for(let r=1;r<t.length-1;++r)i=tl(i,t[r]);return i})}}let AU=class extends Mm{constructor(e){super(e)}mergeFunction(e){return me(()=>{let t=e[0].clone();for(let i=1;i<e.length;++i)t=He(t,e[i]);return t})}};AU.className="Add";Xe(AU);let EU=class extends Mm{constructor(e){super(e)}mergeFunction(e){return me(()=>{let t=e[0].clone();for(let i=1;i<e.length;++i)t=ae(t,e[i]);return t})}};EU.className="Multiply";Xe(EU);let IU=class extends Mm{constructor(e){super(e)}mergeFunction(e){return me(()=>{let t=e[0].clone();for(let i=1;i<e.length;++i)t=He(t,e[i]);return ae(1/e.length,t)})}};IU.className="Average";Xe(IU);let kU=class extends Mm{constructor(e){super(e)}mergeFunction(e){return me(()=>{let t=e[0];for(let i=1;i<e.length;++i)t=Hu(t,e[i]);return t})}};kU.className="Maximum";Xe(kU);let RU=class extends Mm{constructor(e){super(e)}mergeFunction(e){return me(()=>{let t=e[0];for(let i=1;i<e.length;++i)t=ab(t,e[i]);return t})}};RU.className="Minimum";Xe(RU);let NU=class extends Mm{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new he("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const i=[];for(let r=0;r<e.length;++r){const s=e[r].slice();s.splice(this.axis,1);let o=!1;for(const a of i)if(bn(a,s)){o=!0;break}o||i.push(s)}if(i.length>1)throw new he("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return me(()=>PV(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new he("A `Concatenate` layer should be called on a list of inputs.");const t=e,i=t[0].slice(),r=this.axis<0?i.length+this.axis:this.axis;for(const s of t.slice(1)){if(i[r]==null||s[r]==null){i[r]=null;break}i[r]+=s[r]}return i}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new he("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new he(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return me(()=>{let i=!0;if(t.forEach(o=>{if(o!=null){i=!1;return}}),i)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(ot(Lo(e[o]),"bool")):t[o].rank<e[o].rank?r.push(as(t[o],-1)):r.push(t[o]);const s=Hi(r,this.axis);return dI(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};NU.className="Concatenate";Xe(NU);function Sx(n,e){for(;n<0;)n+=e;return n}function NWe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new tn("batchDot is not implemented for tensors of 4D or higher rank yet");if(B(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),B(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new tn("batchDot is not implemented for complex64-type Tensors yet.");const i=n.shape.length,r=e.shape.length;t==null&&(t=[i-1,r-2]);const s=t;return me(()=>{let o;if(i>r){o=i-r;const l=[];for(let u=0;u<o;++u)l.push(1);e=ue(e,e.shape.concat(l))}else if(r>i){o=r-i;const l=[];for(let u=0;u<o;++u)l.push(1);n=ue(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)s[0]===s[1]?a=wt(ae(n,e),s[0]):a=wt(ae(gn(n,[1,0]),e),s[1]);else{const l=s[0]!==n.shape.length-1,u=s[1]===e.shape.length-1;a=ln(n,e,l,u)}if(o>0){let l;i>r?l=i+r-3:l=i-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=Ud(a,u)}return a.shape.length===1&&(a=as(a,1)),a})}let LU=class extends Mm{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],i=e[1];if(t.length>3||i.length>3)throw new tn("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,i);if(t[r[0]]!==i[r[1]])throw new he(`Dimension incompatibility: ${t[r[0]]} !== ${i[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new he(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],i=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,o)=>Sx(s,e[o].shape.length)):r=[Sx(this.axes,t.shape.length),Sx(this.axes,i.shape.length)],this.normalize&&(t=lA(t,r[0]),i=lA(i,r[1])),NWe(t,i,r)}interpretAxes(e,t){let i;return Array.isArray(this.axes)?i=this.axes:i=[Sx(this.axes,e.length),Sx(this.axes,t.length)],i}computeOutputShape(e){B(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),i=e[1].slice();if(t.length>3||i.length>3)throw new tn("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,i);t.splice(r[0],1),i.splice(r[1],1),i.splice(0,1);const s=t.concat(i);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};LU.className="Dot";Xe(LU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let PU=class extends pn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e);return AS(()=>He(QI(i.shape,0,this.stddev),i),()=>i,t.training||!1)})}};PU.className="GaussianNoise";Xe(PU);let DU=class extends pn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return me(()=>{this.invokeCallHook(e,t);const i=Wt(e);return this.rate>0&&this.rate<1?AS(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return ae(i,QI(i.shape,1,r))},()=>i,t.training||!1):i})}};DU.className="GaussianDropout";Xe(DU);let FU=class extends pn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Wt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return me(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(e);return AS(()=>{const r=Wt(e),s=1.6732632423543772,o=1.0507009873554805,a=-s*o;let l=qc(ub(i),this.rate);l=Hc(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=He(ae(r,l),ae(He(l,-1),a));return He(ae(h,u),c)},()=>Wt(e),t.training||!1)}return e})}};FU.className="AlphaDropout";Xe(FU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function b1(n,e,t,i,r,s=.001){let o;if(n.rank===2)o=oG(n,e,t,i,r,s);else if(n.rank===3)o=aG(n,e,t,i,r,s);else if(n.rank===4)o=lG(n,e,t,i,r,s);else throw new tn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function LWe(n,e,t,i,r=.001){return me(()=>{const s=dS(n,i),o=s.mean,a=s.variance;return[b1(n,o,a,t,e,r),o,a]})}function PWe(n,e,t,i,r=.001){return me(()=>{const s=dS(n,i),o=s.mean,a=s.variance,l=[];for(const p of $l(0,n.rank))i.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const u=ue(o,l),c=ue(a,l),h=e==null?null:ue(e,l),d=t==null?null:ue(t,l);return[b1(n,u,c,d,h,r),o,a]})}function DWe(n,e,t,i,r=.001){return bn(i.slice().sort(),$l(0,n.rank-1))?LWe(n,e,t,i,r):PWe(n,e,t,i,r)}let OU=class extends pn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=fi(e.betaInitializer||"zeros"),this.gammaInitializer=fi(e.gammaInitializer||"ones"),this.movingMeanInitializer=fi(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=fi(e.movingVarianceInitializer||"ones"),this.betaConstraint=yr(e.betaConstraint),this.gammaConstraint=yr(e.gammaConstraint),this.betaRegularizer=mi(e.betaRegularizer),this.gammaRegularizer=mi(e.gammaRegularizer)}build(e){e=Rn(e);const t=this.axis>=0?this.axis:this.axis+e.length,i=e[t];if(i==null)throw new he(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ir({ndim:e.length,axes:{[t]:i}})];const r=[i];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return me(()=>{const i=t.training==null?!1:t.training,r=Wt(e),s=r.shape,o=s.length,a=$l(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=Uf(1,o);u[l]=s[l];const c=a.slice();c.sort();const h=!bn(c,$l(0,o).slice(0,o-1)),d=()=>{if(h){const m=ue(this.movingMean.read(),u),v=ue(this.movingVariance.read(),u),w=this.center?ue(this.beta.read(),u):null,S=this.scale?ue(this.gamma.read(),u):null;return b1(r,m,v,w,S,this.epsilon)}else return b1(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!i)return d();const[p,f,g]=DWe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),y=(m,v,w)=>{me(()=>{const S=1-w,C=m.read(),_=ae(xt(C,v),S);m.write(xt(C,_))})};return y(this.movingMean,f,this.momentum),y(this.movingVariance,g,this.momentum),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wi(this.betaInitializer),gammaInitializer:wi(this.gammaInitializer),movingMeanInitializer:wi(this.movingMeanInitializer),movingVarianceInitializer:wi(this.movingVarianceInitializer),betaRegularizer:Hn(this.betaRegularizer),gammaRegularizer:Hn(this.gammaRegularizer),betaConstraint:gr(this.betaConstraint),gammaConstraint:gr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};OU.className="BatchNormalization";Xe(OU);let BU=class extends pn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=fi(e.betaInitializer||"zeros"),this.gammaInitializer=fi(e.gammaInitializer||"ones"),this.betaRegularizer=mi(e.betaRegularizer),this.gammaRegularizer=mi(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Rn(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==ad(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const i=Wt(e),r=i.shape,s=r.length;return me(()=>{let{mean:o,variance:a}=dS(i,this.axis,!0);const l=Uf(1,s);for(const f of this.axis)l[f]=r[f];const u=f=>f!=null&&f.shape.length!==s?ue(f,l):f;let c=this.scale?u(this.gamma.read()):null,h=this.center?u(this.beta.read()):null;const d=[],p=[];for(let f=0;f<s;++f)this.axis.indexOf(f)!==-1?(d.push(r[f]),p.push(1)):(d.push(1),p.push(r[f]));return o=Qo(o,d),a=Qo(a,d),c!=null&&(c=Qo(c,p)),h!=null&&(h=Qo(h,p)),b1(i,o,a,h,c,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wi(this.betaInitializer),gammaInitializer:wi(this.gammaInitializer),betaRegularizer:Hn(this.betaRegularizer),gammaRegularizer:Hn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};BU.className="LayerNormalization";Xe(BU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FWe(n,e,t){return me(()=>{if(n.rank!==4)throw new he(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new he("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Wl()),t!=="channelsLast"&&t!=="channelsFirst")throw new he(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let i;return t==="channelsFirst"?i=[[0,0],[0,0],e[0],e[1]]:i=[[0,0],e[0],e[1],[0,0]],eh(n,i)})}let zU=class extends pn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Wl():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new he(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,i;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new he(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new he(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);i=e.padding[1]}this.padding=[t,i]}this.inputSpec=[new ir({ndim:4})]}computeOutputShape(e){e=Rn(e);let t,i;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?i=e[3]+this.padding[1][0]+this.padding[1][1]:i=null,[e[0],e[1],t,i]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?i=e[2]+this.padding[1][0]+this.padding[1][1]:i=null,[e[0],t,i,e[3]])}call(e,t){return me(()=>FWe(Wt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};zU.className="ZeroPadding2D";Xe(zU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yk(n,e,t,i,r,s){return me(()=>{Zi(r),Kne(s),ba(i),t==null&&(t=[1,1]),i==null&&(i="valid"),r==null&&(r=Wl()),s==null&&(s="max"),n=aU(n,r);let o;const a=i==="same"?"same":"valid";return s==="max"?o=hS(n,e,t,a):o=rS(n,e,t,a),r==="channelsFirst"&&(o=gn(o,[0,3,1,2])),o})}function Bie(n,e,t,i,r,s){return me(()=>{Zi(r),Kne(s),ba(i),t==null&&(t=[1,1,1]),i==null&&(i="valid"),r==null&&(r=Wl()),s==null&&(s="max"),n=Lie(n,r);let o;const a=i==="same"?"same":"valid";return s==="max"?o=NG(n,e,t,a):o=sG(n,e,t,a),r==="channelsFirst"&&(o=gn(o,[0,4,1,2,3])),o})}let zie=class extends pn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new he(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(_r(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new he(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ba(this.padding),this.inputSpec=[new ir({ndim:3})]}computeOutputShape(e){e=Rn(e);const t=Ol(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return me(()=>{this.invokeCallHook(e,t),e=_S(Wt(e),2);const i=this.poolingFunction(Wt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ud(i,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},GU=class extends zie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),yk(e,t,i,r,s,"max")}};GU.className="MaxPooling1D";Xe(GU);let VU=class extends zie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),yk(e,t,i,r,s,"avg")}};VU.className="AveragePooling1D";Xe(VU);let Gie=class extends pn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new he(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zi(this.dataFormat),ba(this.padding),this.inputSpec=[new ir({ndim:4})]}computeOutputShape(e){e=Rn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],i=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ol(t,this.poolSize[0],this.padding,this.strides[0]),i=Ol(i,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,i]:[e[0],t,i,e[3]]}call(e,t){return me(()=>(this.invokeCallHook(e,t),this.poolingFunction(Wt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},UU=class extends Gie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),yk(e,t,i,r,s,"max")}};UU.className="MaxPooling2D";Xe(UU);let $U=class extends Gie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),yk(e,t,i,r,s,"avg")}};$U.className="AveragePooling2D";Xe($U);let Vie=class extends pn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new he(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zi(this.dataFormat),ba(this.padding),this.inputSpec=[new ir({ndim:5})]}computeOutputShape(e){e=Rn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],i=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ol(t,this.poolSize[0],this.padding,this.strides[0]),i=Ol(i,this.poolSize[1],this.padding,this.strides[1]),r=Ol(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,i,r]:[e[0],t,i,r,e[4]]}call(e,t){return me(()=>(this.invokeCallHook(e,t),this.poolingFunction(Wt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},WU=class extends Vie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),Bie(e,t,i,r,s,"max")}};WU.className="MaxPooling3D";Xe(WU);let HU=class extends Vie{constructor(e){super(e)}poolingFunction(e,t,i,r,s){return Zi(s),ba(r),Bie(e,t,i,r,s,"avg")}};HU.className="AveragePooling3D";Xe(HU);let Uie=class extends pn{constructor(e){super(e),this.inputSpec=[new ir({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new tn}},XU=class extends Uie{constructor(e){super(e||{})}call(e,t){return me(()=>{const i=Wt(e);return vi(i,1)})}};XU.className="GlobalAveragePooling1D";Xe(XU);let KU=class extends Uie{constructor(e){super(e||{})}call(e,t){return me(()=>{const i=Wt(e);return la(i,1)})}};KU.className="GlobalMaxPooling1D";Xe(KU);let $ie=class extends pn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Zi(this.dataFormat),this.inputSpec=[new ir({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new tn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ZU=class extends $ie{call(e,t){return me(()=>{const i=Wt(e);return this.dataFormat==="channelsLast"?vi(i,[1,2]):vi(i,[2,3])})}};ZU.className="GlobalAveragePooling2D";Xe(ZU);class jU extends $ie{call(e,t){return me(()=>{const i=Wt(e);return this.dataFormat==="channelsLast"?la(i,[1,2]):la(i,[2,3])})}}jU.className="GlobalMaxPooling2D";Xe(jU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wie extends pn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,i={}){const r=t.layer,s=Fl(r,i);delete t.layer;const o={layer:s};return Object.assign(o,t),new e(o)}}class YU extends Wie{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Rn(e),e.length<3)throw new he(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Rn(e);const t=[e[0]].concat(e.slice(2)),i=this.layer.computeOutputShape(t),r=e[1];return[i[0],r].concat(i.slice(1))}call(e,t){return me(()=>(e=Wt(e),Fie((i,r)=>[Wt(this.layer.call(i,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}YU.className="TimeDistributed";Xe(YU);function OWe(n){Cm(l$e,"BidirectionalMergeMode",n)}const BWe="concat";class JU extends Wie{constructor(e){super(e);const t=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=t,this.forwardLayer=Fl(i),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Fl(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?BWe:e.mergeMode,OWe(this.mergeMode),e.weights)throw new tn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,i=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,i)),this.backwardLayer.setWeights(e.slice(i))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let i,r,s;return this.returnState&&(s=t.slice(1)),i=t[0],i=i,this.mergeMode==="concat"?(i[i.length-1]*=2,r=[i]):this.mergeMode==null?r=[i,i.slice()]:r=[i],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[i].concat(s).concat(s.slice()):Xs(r)}apply(e,t){let i=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const s=Die(e,i,r,this.numConstants);if(e=s.inputs,i=s.initialState,r=s.constants,Array.isArray(e)&&(i=e.slice(1),e=e[0]),(i==null||i.length===0)&&r==null)return super.apply(e,t);const o=[],a=[];if(i!=null){const u=i.length;if(u%2>0)throw new he("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=i,o.push(...i);const c=i.map(h=>new ir({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(r!=null)throw new tn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof El;for(const u of o)if(u instanceof El!==l)throw new he("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return me(()=>{const i=t.initialState;let r,s;if(i==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const l=i.slice(0,i.length/2),u=i.slice(i.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=da(s,1));let a;return this.mergeMode==="concat"?a=PV([r,s]):this.mergeMode==="sum"?a=He(r,s):this.mergeMode==="ave"?a=ae(.5,He(r,s)):this.mergeMode==="mul"?a=ae(r,s):this.mergeMode==null&&(a=[r,s]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){cf(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),cf(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let i;if(this.returnSequences?this.mergeMode==null?i=[t,t]:i=t:this.mergeMode==null?i=[null,null]:i=null,this.returnState){const r=this.forwardLayer.states.map(s=>null);return Array.isArray(i)?i.concat(r).concat(r):[i].concat(r).concat(r)}else return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const i=Fl(t.layer);if(delete t.layer,t.numConstants!=null)throw new tn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=i,new e(r)}}JU.className="Bidirectional";Xe(JU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QU extends pn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return me(()=>(e=Wt(e),e.dtype!=="float32"&&(e=Hc(e,"float32")),He(ae(e,this.scale),this.offset)))}}QU.className="Rescaling";Xe(QU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:zWe,cropAndResize:GWe}=wu;class qU extends pn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,i,r,s,o,a,l){return me(()=>{let u,c=!1;const h=t/o,d=i/a,p=(r+t)/o,f=(s+i)/a,g=[h,d,p,f],y=[];e.rank===3?(c=!0,u=Ls([e])):u=e;for(let S=0;S<u.shape[0];S++)y.push(g);const m=hi(y,[y.length,4]),v=Gf(0,y.length,1,"int32"),w=GWe(u,m,v,[r,s],"nearest");return Hc(c?Wt(pa(w)):w,l)})}upsize(e,t,i,r){return me(()=>{const s=zWe(e,[t,i]);return Hc(s,r)})}call(e,t){return me(()=>{const i=Wt(e),r=i.dtype,s=i.shape,o=s[s.length-3],a=s[s.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(i,l,u,this.height,this.width,o,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Rn(e);const t=e.length-3,i=e.length-2;return e[t]=this.height,e[i]=this.width,e}}qU.className="CenterCrop";Xe(qU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function VWe(n,e,t,i){let r=Wt(n);if(r.dtype!=="int32"&&(r=Hc(r,"int32")),e==="int")return r;const s=r.shape;if(r.rank===0&&(r=as(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=as(r,-1)),r.rank>2)throw new he(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof i<"u"&&e==="count"?l=iA(a,i,t,o):l=iA(a,[],t,o),e!=="tfIdf")return l;if(i)return ae(l,i);throw new he("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class e$ extends pn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Rn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return me(()=>{e=Wt(e),e.dtype!=="int32"&&(e=Hc(e,"int32"));let i;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new he(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);i=Wt(t.countWeights)}const r=la(e),s=Py(e),o=Fs(this.numTokens,r).bufferSync().get(0),a=qc(s,0).bufferSync().get(0);if(!(o&&a))throw new he(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return VWe(e,this.outputMode,this.numTokens,i)})}}e$.className="CategoryEncoding";Xe(e$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const UWe=["bilinear","nearest"],NZ=new Set(UWe);class t$ extends pn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(NZ.has(e.interpolation))this.interpolation=e.interpolation;else throw new he(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Rn(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return me(()=>{const i=[this.height,this.width];if(this.interpolation==="bilinear")return wu.resizeBilinear(e,i,!this.cropToAspectRatio);if(this.interpolation==="nearest")return wu.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...NZ]} are supported`)})}}t$.className="Resizing";Xe(t$);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $We=ve();$We.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Fa;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Fa||(Fa={}));var LZ;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(LZ||(LZ={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function WWe(n,e){return pA(n,e)}function pA(n,e,t=new Map,i=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(i.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Vy(n)){const s=Array.isArray(n)?[]:{};i.add(n);for(const o in n){const a=n[o],l=pA(a,e,t,i);s[o]=l}return i.delete(n),n.__proto__&&(s.__proto__=n.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function HWe(n,e=Xie){return Hie(n,e)}function Hie(n,e,t=new Set){const i=n[0];if(t.has(i))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Vy(i)){const s=Array.isArray(i)?[]:{};t.add(i);for(const o in i){const a=n.map(u=>u[o]),l=Hie(a,e,t);s[o]=l}return t.delete(i),s}else throw new Error(`Can't recurse into non-iterable type: ${i}`);else return r.value}function Xie(n){return n===null?null:Vy(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function Kie(n,e){const t=new Map;pA(n,e,t);for(const i of Array.from(t.keys())){const r=t.get(i);if(Bc(r)){const s=await r;t.set(i,s)}}return pA(n,e,t)}function Vy(n){let e=!1;if(ve().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof An)&&!(n instanceof Promise)&&!e)}function XWe(n){return n==null||KWe(n)||Array.isArray(n)||typeof n=="object"&&n instanceof An||Tr(n)}function KWe(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function ZWe(n){return WWe(n,jWe)}function jWe(n){return n instanceof An?{value:n.clone(),recurse:!1}:Vy(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Zie{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),i=this.get(t);return this.set(t,this.pop()),i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class bk extends Zie{constructor(){super(bk.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),i=this.length();for(let r=0;r<i;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=i}}bk.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function jie(n){return new QWe(n)}function n$(n){return new qWe(n)}function YWe(n,e){return new Yie(n,e)}function JWe(n,e=Uh.FAIL){return new lHe(n,e)}let Er=class{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let i=await e.next();for(;!i.done;)t.push(i.value),i=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),i=e(t.value);for(;!t.done&&i;)t=await this.next(),i=e(t.value)}handleErrors(e){return new oHe(this,e)}filter(e){return new rHe(this,e)}map(e){return new sHe(this,e)}mapAsync(e){return new PZ(this,e)}serialMapAsync(e){return new PZ(this,e).serial()}flatmap(e){return new aHe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new iHe(this,e,t)}columnMajorBatch(e,t=!0,i=Xie){return this.rowMajorBatch(e,t).map(r=>HWe(r,i))}concatenate(e,t){return new Yie(jie([this,e]),t)}take(e){return e<0||e==null?this:new nHe(this,e)}skip(e){return e<0||e==null?this:new tHe(this,e)}prefetch(e){return new Jie(this,e)}shuffle(e,t){return new uHe(this,e,t)}serial(){return new eHe(this)}};class QWe extends Er{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:ZWe(e),done:!1}}}class qWe extends Er{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class eHe extends Er{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class tHe extends Er{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;jt(e.value)}return this.upstream.next()}}class nHe extends Er{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class iHe extends Er{constructor(e,t,i=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=i,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class rHe extends Er{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;jt(e.value)}}}class sHe extends Er{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Gc(e.value),i=this.transform(e.value),r=Gc(i);for(const s of t)uI(s,r)||s.dispose();return{value:i,done:!1}}}class oHe extends Er{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class PZ extends Er{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Gc(e.value),i=await this.transform(e.value),r=Gc(i);for(const s of t)uI(s,r)||s.dispose();return{value:i,done:!1}}}class i$ extends Er{constructor(){super(),this.outputQueue=new bk,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class aHe extends i${constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Gc(e.value),i=this.transform(e.value),r=Gc(i);this.outputQueue.pushAll(i);for(const s of t)uI(s,r)||s.dispose();return!0}}class Yie extends Er{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const i=await this.moreIterators.next();if(i.done)return{value:null,done:!0};this.iterator=i.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Uh;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Uh||(Uh={}));class lHe extends Er{constructor(e,t=Uh.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,i=0;function r(o){return o instanceof Er?{value:o.next().then(a=>(t++,a.done&&i++,a.value)),recurse:!1}:{value:null,recurse:!0}}const s=await Kie(this.iterators,r);if(t===i)return{value:null,done:!0};if(i>0)switch(this.mismatchMode){case Uh.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Uh.SHORTEST:return{value:null,done:!0};case Uh.LONGEST:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class Jie extends Er{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Zie(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class uHe extends Jie{constructor(e,t,i){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=lb.alea(i||Ur().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let yb=class{constructor(){this.size=null}batch(e,t=!0){const i=this;B(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),fo(async()=>(await i.iterator()).columnMajorBatch(e,t,dHe),r)}concatenate(e){const t=this;let i;return this.size===1/0||e.size===1/0?i=1/0:this.size!=null&&e.size!=null?i=this.size+e.size:i=null,fo(async()=>(await t.iterator()).concatenate(await e.iterator()),i)}filter(e){const t=this;let i;return this.size===1/0?i=1/0:i=null,fo(async()=>(await t.iterator()).filter(r=>me(()=>e(r))),i)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return fo(async()=>(await t.iterator()).map(i=>me(()=>e(i))),this.size)}mapAsync(e){const t=this;return fo(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return fo(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let i;return this.size!=null&&e>0?i=this.size*e:e===0?i=0:this.size!=null&&(e===void 0||e<0)?i=1/0:i=null,fo(async()=>{const r=n$(async()=>({value:await t.iterator(),done:!1}));return YWe(r.take(e))},i)}skip(e){const t=this;let i;return this.size!=null&&e>=0&&this.size>=e?i=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?i=0:i=null,fo(async()=>(await t.iterator()).skip(e),i)}shuffle(e,t,i=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=lb.alea(t||Ur().toString());return fo(async()=>{let o=s.int32();return i&&(o+=s.int32()),(await r.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let i;return this.size!=null&&this.size>e?i=e:this.size!=null&&this.size<=e?i=this.size:i=null,fo(async()=>(await t.iterator()).take(e),i)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};yb.MAX_BUFFER_SIZE=1e4;function fo(n,e=null){return new class extends yb{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function cHe(n){return fo(async()=>jie(n),n.length)}function hHe(n){if(!Vy(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return fo(async()=>{const t=await Kie(n,i=>{if(i instanceof yb)return{value:i.iterator(),recurse:!1};if(Vy(i))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return JWe(t,Uh.SHORTEST)},e)}function dHe(n){if(n===null)return null;const e=n[0];return XWe(e)?{value:pHe(n),recurse:!1}:{value:null,recurse:!0}}function pHe(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof An?Ls(n):hi(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fHe=FI;class xk extends n2{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Rz(this,Wn())}nextDataId(){return xk.nextDataId++}write(e,t,i){this.firstUse&&(this.firstUse=!1,ve().get("IS_NODE")&&Yo(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:i,refCount:1}),r}makeTensorInfo(e,t,i){let r;if(t==="string"&&i!=null&&i.length>0&&vu(i[0])){const s=i.map(o=>ku(o));r=this.write(s,e,t)}else r=this.write(i,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,i,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:i}=this.data.get(e);if(t==="complex64"){const r=this.readSync(i.real.dataId),s=this.readSync(i.imag.dataId);return Wc(r,s)}return Yee(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const i=t.map(r=>zc(r));return nn(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return nn(e.shape,e.dtype,t)}makeOutput(e,t,i){return Wn().makeTensorFromTensorInfo(this.makeTensorInfo(t,i,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(e);i!=null&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Ur();return e(),{kernelMs:Ur()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Tt([e],"where");const t=this.readSync(e.dataId);return fHe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}xk.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const mHe=n=>{const{x:e}=n.inputs,t=n.backend;Tt(e,"abs");let i=new Float32Array(ke(e.shape));const r=t.data.get(e.dataId).values;return i=Qie(r),t.makeOutput(i,e.shape,e.dtype)},gHe={kernelName:ew,backendName:"cpu",kernelFunc:mHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sr(n){return(e,t,i,r,s)=>{const o=Yt(e,t),a=o.length,l=kt(o),u=ke(o),c=br(s,u),h=e.length,d=t.length,p=kt(e),f=kt(t),g=Bf(e,o),y=Bf(t,o);if(g.length+y.length===0)for(let m=0;m<c.length;++m)c[m]=n(i[m%i.length],r[m%r.length]);else for(let m=0;m<c.length;++m){const v=mm(m,a,l),w=v.slice(-h);g.forEach(A=>w[A]=0);const S=Pl(w,h,p),C=v.slice(-d);y.forEach(A=>C[A]=0);const _=Pl(C,d,f);c[m]=n(i[S],r[_])}return[c,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(n){const{inputs:e,backend:t}=n,{real:i,imag:r}=e,s=t.data.get(i.dataId).values,o=t.data.get(r.dataId).values,a=t.makeTensorInfo(i.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(i.shape,"float32",s),imag:t.makeTensorInfo(r.shape,"float32",o)},a}const yHe={kernelName:h2,backendName:"cpu",kernelFunc:wo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(n,e,t="float32"){if(t==="complex64"){const r=fA(n,e,"float32"),s=fA(n,e,"float32");return wo({inputs:{real:r,imag:s},backend:n})}const i=jr(ke(e),t);return n.makeTensorInfo(e,t,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(n){const{inputs:e,backend:t}=n,{x:i}=e;return t.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const bHe={kernelName:M0,backendName:"cpu",kernelFunc:Vu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.data.get(i.dataId).complexTensorInfos.real,s=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,s)}const xHe={kernelName:$2,backendName:"cpu",kernelFunc:$f};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qie(n,e,t,i){if(i==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(i==="bool"){const r=Od([0],t),[s,o]=sr((a,l)=>a!==l?1:0)(e,[],n,r,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${i}`)}function _d(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dtype:s}=i;if(s==="complex64"){if(r.dtype==="complex64")return Vu({inputs:{x:r},backend:t});const c=fA(t,r.shape,r.dtype),h=_d({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),d=wo({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=$f({inputs:{input:r},backend:t}),h=_d({inputs:{x:c},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(c),h}if(!Pz(r.dtype,s)){const c=Vu({inputs:{x:r},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:s}}const o=t.data.get(r.dataId).values,[a,l,u]=qie(o,r.shape,r.dtype,s);return t.makeTensorInfo(a,l,u)}const vHe={kernelName:p0,backendName:"cpu",kernelFunc:_d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(n,e,t,i){return t==null?({inputs:r,backend:s})=>{const{a:o,b:a}=r,l=s;Tt([o,a],n);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=o.dtype==="string"?Vf(u):u,d=o.dtype==="string"?Vf(c):c,p=i||o.dtype,[f,g]=e(o.shape,a.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:({inputs:r,backend:s})=>{const{a:o,b:a}=r,l=s;if(o.dtype==="complex64"||a.dtype==="complex64"){const u=_d({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,g=_d({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),m=y.complexTensorInfos.real,v=y.complexTensorInfos.imag,w=l.data.get(m.dataId).values,S=l.data.get(v.dataId).values,[C,_,A]=t(o.shape,a.shape,p,f,w,S),I=l.makeTensorInfo(A,"float32",C),E=l.makeTensorInfo(A,"float32",_),k=wo({inputs:{real:I,imag:E},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(E),k}else{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=i||o.dtype,[d,p]=e(o.shape,a.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function r$(n){return(e,t,i,r,s,o)=>{const a=Yt(e,t),l=ke(a),u=a.length,c=kt(a),h=br("float32",l),d=br("float32",l),p=Bf(e,a),f=Bf(t,a),g=Wc(i,r),y=Wc(s,o),m=e.length,v=kt(e),w=t.length,S=kt(t);if(p.length+f.length===0)for(let C=0;C<h.length;C++){const _=C%g.length,A=C%y.length,I=n(g[_*2],g[_*2+1],y[A*2],y[A*2+1]);h[C]=I.real,d[C]=I.imag}else for(let C=0;C<h.length;C++){const _=mm(C,u,c),A=_.slice(-m);p.forEach(V=>A[V]=0);const I=Pl(A,m,v),E=_.slice(-w);f.forEach(V=>E[V]=0);const k=Pl(E,w,S),P=n(g[I*2],g[I*2+1],y[k*2],y[k*2+1]);h[C]=P.real,d[C]=P.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ere=sr((n,e)=>n+e),wHe=r$((n,e,t,i)=>({real:n+t,imag:e+i})),Uy=Rr(gm,ere,wHe),SHe={kernelName:gm,backendName:"cpu",kernelFunc:Uy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e,t,i,r){const s=ke(i),o=jr(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(s>0?o[l]+=e[a]:o[l]+=1)}return o}function tre(n,e,t,i=!1){const r=n.shape[0],s=n.shape[1],o=nn([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<s;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(i?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(n){return(e,t,i)=>{const r=br(t,e.length);for(let s=0;s<e.length;++s)r[s]=n(e[s],i);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(n,e,t){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;if(Tt(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=s,l=a.data.get(o.dataId).values,u=ke(o.shape),c=t||o.dtype,h=Wi(c,u);for(let d=0;d<u;++d)h[d]=e(l[d],r);return a.makeTensorInfo(o.shape,c,h)}}function bb(n,e,t){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;if(Tt(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=s,l=a.data.get(o.dataId).values,u=t||o.dtype,c=e(l,u,r);return a.makeTensorInfo(o.shape,u,c)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre=$d(n=>Math.ceil(n)),THe=bb(f0,nre),CHe={kernelName:f0,backendName:"cpu",kernelFunc:THe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ire(n,e,t,i){const r=Wi(t,ke(e));if(i&&t!=="string"){let s=0;n.forEach(o=>{const a=ke(o.shape);r.set(o.vals,s),s+=a})}else{let s=0;n.forEach(o=>{const a=t==="string"?Vf(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+s;for(let h=0;h<o.shape[1];++h)r[c+h]=a[l++]}s+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rre=sr((n,e)=>n===e?1:0),sre=Rr(gw,rre,null,"bool"),_He={kernelName:gw,backendName:"cpu",kernelFunc:sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ore=$d(n=>Math.exp(n)),are=bb(w0,ore,"float32"),MHe={kernelName:w0,backendName:"cpu",kernelFunc:are};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lre=$d(n=>Math.expm1(n)),AHe=bb(S0,lre),EHe={kernelName:S0,backendName:"cpu",kernelFunc:AHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ure=$d(n=>Math.floor(n)),IHe=bb(T0,ure),kHe={kernelName:T0,backendName:"cpu",kernelFunc:IHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cre(n,e,t,i,r,s,o,a,l){const u=nn([i,s],t);for(let c=0;c<i;c++){const h=[];let d=0;for(let p=0;p<r;p++){const f=n[c*r+p];d+=f*o[p],h.push(f)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<s;p++)u.values[c*s+p]=e.get(...e.indexToLoc(d*s+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hre(n,e,t){const i=nn(t,n.dtype);for(let r=0;r<i.size;++r){const s=i.indexToLoc(r).slice(),o=s[0],a=s[2],l=e.locToIndex([o,a]);s[2]=e.values[l];const u=n.locToIndex(s);0<=u&&u<n.values.length&&(i.values[r]=n.values[u])}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dre=sr((n,e)=>n>e?1:0),RHe=Rr(vw,dre,null,"bool"),NHe={kernelName:vw,backendName:"cpu",kernelFunc:RHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pre=sr((n,e)=>n>=e?1:0),LHe=Rr(_0,pre,null,"bool"),PHe={kernelName:_0,backendName:"cpu",kernelFunc:LHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fre=sr((n,e)=>n<e?1:0),DHe=Rr(Sw,fre,null,"bool"),FHe={kernelName:Sw,backendName:"cpu",kernelFunc:DHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre=sr((n,e)=>n<=e?1:0),OHe=Rr(Tw,mre,null,"bool"),BHe={kernelName:Tw,backendName:"cpu",kernelFunc:OHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gre(n,e,t){const i=(e-n)/(t-1),r=jr(t,"float32");r[0]=n;for(let s=1;s<r.length;s++)r[s]=r[s-1]+i;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yre=$d(n=>Math.log(n)),zHe=bb(k0,yre),GHe={kernelName:k0,backendName:"cpu",kernelFunc:zHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bre(n,e,t,i){const r=br(i,ke(t));for(let s=0;s<r.length;++s){const o=s*e;let a=n[o];for(let l=0;l<e;++l){const u=n[o+l];(Number.isNaN(u)||u>a)&&(a=u)}r[s]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xre=sr((n,e)=>Math.max(n,e)),VHe=Rr(N0,xre),UHe={kernelName:N0,backendName:"cpu",kernelFunc:VHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vre=sr((n,e)=>Math.min(n,e)),$He=Rr(L0,vre),WHe={kernelName:L0,backendName:"cpu",kernelFunc:$He};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o$=sr((n,e)=>n*e),HHe=r$((n,e,t,i)=>({real:n*t-e*i,imag:n*i+e*t})),vk=Rr(D0,o$,HHe),XHe={kernelName:D0,backendName:"cpu",kernelFunc:vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wre(n,e,t){const i=Yc(-1,t);return o$([],e,i,n,t)}function KHe(n){const{inputs:e,backend:t}=n,{x:i}=e;Tt(i,"neg");const r=t.data.get(i.dataId).values,[s,o]=wre(r,i.shape,i.dtype);return t.makeTensorInfo(o,i.dtype,s)}const ZHe={kernelName:Pw,backendName:"cpu",kernelFunc:KHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sre=sr((n,e)=>n!==e?1:0),jHe=Rr(Dw,Sre,null,"bool"),YHe={kernelName:Dw,backendName:"cpu",kernelFunc:jHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n,e,t,i,r){const s=e.length,o=ke(e),a=kt(e),l=kt(r),u=br(t,ke(r));for(let c=0;c<o;++c){const h=mm(c,s,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[i[f]];const p=Pl(d,s,l);u[p]=n[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n){const{inputs:e,attrs:t,backend:i}=n,{x:r}=e,{perm:s}=t;Tt(r,"transpose");const o=r.shape.length,a=new Array(o);for(let c=0;c<a.length;c++)a[c]=r.shape[s[c]];const l=i.data.get(r.dataId).values,u=a$(l,r.shape,r.dtype,s,a);return{dataId:i.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const JHe={kernelName:lf,backendName:"cpu",kernelFunc:no};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tre(n,e,t,i){const[r,s]=kr(n,i),o=qs(e,"int32"),a=jr(ke(r),o),l=ke(s);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=t[c+d];a[u]=h}return{outVals:a,outShape:r,outDtype:o}}function QHe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;Tt(r,"prod");const a=r.shape.length,l=un(s,r.shape),u=Ti(l,a);let c=l,h=r;const d=[];u!=null&&(h=no({inputs:{x:r},backend:t,attrs:{perm:u}}),d.push(h),c=Ki(c.length,a));const p=t.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:y}=Tre(h.shape,h.dtype,p,c);let m=g;return o&&(m=Xi(g,l)),d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(m,y,f)}const qHe={kernelName:Vw,backendName:"cpu",kernelFunc:QHe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eXe(n,e,t){n.forEach((i,r)=>{if(i<0||i>=t){const s=mm(r,e.length,kt(e)).join(",");throw new Error(`indices[${s}] = ${i} is not in [0, ${t})`)}})}function tXe(n,e){for(let t=0;t<n.length;++t){const i=n[t],r=t===n.length-1?e:n[t+1].length;if(i.length===0)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<i.length;++s)if(i[s-1]>i[s])throw new Error("Ragged splits must be sorted in ascending order")}}function nXe(n,e,t,i){const r=[];let s=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);tXe(t,i);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const g=a[f],y=g[g.length-1]-p[c];for(let m=c;m<h;++m)a[f].push(p[m+1]+y)}c=p[c],h=p[h]}h!==c&&(r.push([c,h]),s+=h-c)}return{outSplits:a,valueSlices:r,numValues:s}}function iXe(n){const e=[];for(let t=0;t<n.length;++t){const i=n[t].length,r=Wi("int32",i);e.push(r),n[t].forEach((s,o)=>r[o]=s)}return e}function DZ(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let i=e;i<n.length;i++)t[e-1]*=n[i];return t}function rXe(n,e,t,i,r,s){const o=DZ(e,2)[1],a=DZ(s,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<i;++h)r[l*a+h]=n[c*o+h];++l}}function sXe(n,e,t,i,r){const s=e.slice();s[0]=r;const o=Wi(t,ke(s)),a=n.length,l=a===0?0:a/e[0];return rXe(n,e,i,l,o,s),[o,s]}function Cre(n,e,t,i,r,s,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(eXe(s,o,l),i.length===0)throw new Error("params.rank must be nonzero");const u=i[0],{outSplits:c,valueSlices:h,numValues:d}=nXe(s,o,n,u),p=iXe(c),f=sXe(t,i,r,h,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZ=2147483647;function _re(n,e,t,i,r,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(r[0]),u||c.push(o[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=Wi("int32",h+1);d[0]=0;for(let y=0;y<h;++y){const m=a?n[0]:n[y],v=l?i[0]:i[y],w=u?s[0]:s[y];if(w===0)throw new Error("Requires delta != 0");let S;if(w>0&&v<m||w<0&&v>m)S=0;else if(S=Math.ceil(Math.abs((v-m)/w)),S>FZ)throw new Error(`Requires ((limit - start) / delta) <= ${FZ}`);d[y+1]=d[y]+S}const p=d[h],f=Wi(t,p);let g=0;for(let y=0;y<h;++y){const m=d[y+1]-d[y];let v=a?n[0]:n[y];const w=u?s[0]:s[y];for(let S=0;S<m;++S)f[g++]=v,v+=w}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Da=_l;class mA{constructor(e,t,i,r,s,o,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=i,this.valuesShape=r,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=pne(c),this.raggedRank=fne(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Da.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Da.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Da.VALUE_ROWIDS:return mA.getMaxWidthValueRowID(t);case Da.ROW_SPLITS:return mA.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Da[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let i=0;for(let r=0;r<t-1;++r){const s=e[r+1]-e[r];s>i&&(i=s)}return i}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let i=0,r=e[0],s=0;for(let o=1;o<t;++o){const a=e[o];a!==r&&(r=a,s=Math.max(o-i,s),i=o)}return Math.max(t-i,s)}tensorShapeFromTensor(e,t,i=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return BZ(e,i)}calculateOutputSize(e){const t=this.valuesShape,i=this.defaultValueShape;mne(i,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=dne(this.raggedRank,r,t);s[0]<0&&(s[0]=e);for(let o=1;o<=this.raggedRank;++o)s[o]<0&&(s[o]=this.getMaxWidth(o));return s}calculateFirstParentOutputIndex(e,t,i){const r=Math.min(e,i),s=[];let o=0;for(let a=0;a<r;++a,o+=t)s.push(o);for(let a=r;a<e;++a)s.push(-1);return B(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,i,r){const s=e.length,o=[];for(let a=0;a<s-1;++a){const l=e[a+1]-e[a];let u=Math.min(r,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)o.push(c),c+=i;for(let h=0;h<l-u;++h)o.push(-1)}if(s>0&&o.length!==e[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,i,r){const s=e.length,o=[];if(s===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];o.push(u);for(let c=1;c<s;++c){const h=e[c];if(h===l)u>=0&&(++a,a<r?u+=i:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,i,r){const s=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Da.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,i,r);case Da.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,i,r);default:throw new Error(`Unsupported partition type: ${Da[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Da.FIRST_DIM_SIZE:return e[0];case Da.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Da.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Da[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let o=i.length-2;o>=0;--o)i[o]=i[o+1]*t[o+1];const r=BZ(t,!1),s=Wi(this.valuesDType,ke(r));if(i[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,i[0],t[0]);for(let a=1;a<=this.raggedRank;++a)o=this.calculateOutputIndex(a-1,o,i[a],t[a]);this.setOutput(this.raggedRank,o,s,r)}return[r,s]}setOutput(e,t,i,r){if(i.length===0)return;const s=this.values,o=i;let a=r.slice();a=a.slice(e+1);const l=ke(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;me(()=>{const g=ue(c,f);c=uf(g,a).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let g=f<u?t[f]:-1;if(g===p){++p;continue}if(d<p){const y=s.subarray(h*l),m=o.subarray(d*l),v=(p-d)*l;OZ(m,y,v)}if(f>=u){const y=i.length;g=Math.floor(y/l)}if(g>p)if(this.defaultValue.length===1)o.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;){const y=o.slice(p*l);OZ(y,c,l),++p}g<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function OZ(n,e,t){for(let i=0;i<t;i++)n[i]=e[i]}function BZ(n,e){const t=[];for(let i of n){if(i<0){if(!e)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}t.push(i)}return t}function Mre(n,e,t,i,r,s,o,a,l,u){return new mA(n,e,t,i,r,s,o,a,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Are(n,e,t,i){const r=n===e,s=n<e&&t<0,o=e<n&&t>1;if(r||s||o)return jr(0,i);const a=Math.abs(Math.ceil((e-n)/t)),l=jr(a,i);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ere=$d(n=>1/Math.sqrt(n)),oXe=bb(V0,Ere),aXe={kernelName:V0,backendName:"cpu",kernelFunc:oXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zg(n,e,t,i,r,s,o,a,l,u){const c=[i/r,r],h=n.values,d=e.values;if(i===0)return nn(t,e.dtype);const p=nn(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<s;f++){const g=[];let y=0;for(let m=0;m<o;m++){const v=h[f*o+m];g.push(v),y+=v*a[m]}if(y<0||y>=i/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let m=0;m<r;m++)u?p.values[y*r+m]+=d[f*r+m]:p.values[y*r+m]=e.rank===0?d[0]:d[f*r+m]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lXe=$d(n=>1/(1+Math.exp(-n))),Ire=Bn(X0,n=>1/(1+Math.exp(-n))),uXe={kernelName:X0,backendName:"cpu",kernelFunc:Ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kre(n,e,t,i,r){const s=cV(i,e,t),o=ke(t),a=kt(i);if(s){const h=hV(e,a);return r==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=r==="string"?Vf(n):n,u=nn(i,r,l),c=nn(t,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((f,g)=>f+e[g]);c.set(u.get(...p),...d)}return r==="string"?Dne(c.values):c.values}function Wf(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,size:o}=i;Tt(r,"slice");const[a,l]=KI(r,s,o);lV(r,a,l);const u=t.data.get(r.dataId).values,c=kre(u,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,c)}const cXe={kernelName:Kw,backendName:"cpu",kernelFunc:Wf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rre(n,e,t,i,r,s,o){const a=e[0],l=s[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(Sne(a));const y=Wi(t,0),m=Wi(r,0);return[y,[0,h],m,u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let y=0;y<a;++y){const m=n[y*h];if(m<0)throw new Error(Tne(y,m));if(m>=l)throw new Error(Cne(y,m,l));++f[m],d=d&&m>=p,p=m}let g=!0;for(let y=0;y<l;++y){const m=f[y]===0;u[y]=m,g=g&&!m,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&d){const y=n,m=i;for(let v=0;v<a;++v)c[v]=v;return[y,[a,h],m,u,c]}else{const y=f[l-1],m=Wi(t,y*h),v=Wi(r,y),w=new Array(l).fill(0);for(let S=0;S<a;++S){const C=n[S*h],_=w[C],A=(C===0?0:f[C-1])+_;w[C]++;for(let I=0;I<h;++I)m[A*h+I]=n[S*h+I];v[A]=i[S],c[S]=A}for(let S=0;S<l;++S)if(w[S]===0){const C=S===0?0:f[S-1];m[C*h+0]=S;for(let _=1;_<h;++_)m[C*h+_]=0;v[C]=o}return[m,[y,h],v,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nre(n,e,t,i,r){const s=ke(i),o=e[0],a=r.length,l=[];let u=1,c=-1;for(let g=0;g<a;++g){const y=r[g];if(y===-1){if(c!==-1)throw new Error(_ne(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(Mne(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(Ane());const g=Math.trunc(s/u);if(u*g!==s)throw new Error(Ene(i,l));l[c]=g}if(ke(l)!==s)throw new Error(Ine(i,l));const h=i.length,d=[];if(h>0){d[h-1]=1;for(let g=h-2;g>=0;--g)d[g]=d[g+1]*i[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const f=Wi(t,o*a);for(let g=0;g<o;++g){let y=0;for(let m=0;m<h;++m)y+=n[g*h+m]*d[m];for(let m=0;m<a;++m)f[g*a+m]=Math.trunc(y/p[m]),y%=p[m]}return[f,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n,e,t,i,r,s=!1,o=0){const a=i.length,l=[e[0],n.length/e[0]],u=l[1],c=a>0?r[a-1]+1:0;if(c<0)throw new Error(fF());const h=e.slice();h[0]=c;const d=h.reduce((v,w)=>v*w,1),p=Wi(t,d);if(a===0)return c>0&&p.fill(o),[p,h];if(c<=0)throw new Error(fF());let f=0,g=1,y=0,m=r[f];for(;;){let v=0;if(g<a){if(v=r[g],m===v){++g;continue}if(m>=v)throw new Error(kne())}if(m<0||m>=c)throw new Error(Rne(m,c));m>y&&p.fill(o,y*u,m*u);for(let w=f;w<g;++w){const S=i[w];if(S<0||S>=l[0])throw new Error(Nne(w,i[w],l[0]));for(let C=0;C<u;C++)p[m*u+C]+=n[S*u+C]}if(s)for(let w=0;w<u;w++)p[m*u+w]/=g-f;if(f=g,++g,y=m+1,m=v,g>a)break}return y<c&&p.fill(o,y*u,c*u),[p,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hXe=$d(n=>Math.sqrt(n)),dXe=Bn(Z0,n=>Math.sqrt(n)),pXe={kernelName:Z0,backendName:"cpu",kernelFunc:dXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lre=sr((n,e)=>{const t=n-e;return t*t}),fXe=Rr(j0,Lre),mXe={kernelName:j0,backendName:"cpu",kernelFunc:fXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pre(n,e,t,i){const r=nn(n,e.dtype);for(let s=0;s<r.size;s++){const o=r.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+i[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gXe{constructor(e,t,i,r,s,o){this.separator=ku(e),this.nGramWidths=t,this.leftPad=ku(i),this.rightPad=ku(r),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const i=this.getPadWidth(t);return Math.max(0,e+2*i-t+1)}createNGrams(e,t,i,r,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),h=o-(u+c),d=t+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let v=0;v<h;++v)p+=e[d+v].length;p+=c*this.rightPad.length;const f=u+c+h-1;p+=f*this.separator.length,i[r+a]=new Uint8Array(p);const g=i[r+a];let y=0;const m=v=>v.forEach(w=>g[y++]=w);for(let v=0;v<u;++v)m(this.leftPad),m(this.separator);for(let v=0;v<h-1;++v)m(e[d+v]),m(this.separator);if(h>0){m(e[d+h-1]);for(let v=0;v<c;++v)m(this.separator),m(this.rightPad)}else{for(let v=0;v<c-1;++v)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const i=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=t[u]>=l;if(c=c&&t[u]<=i,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${i}]`);l=t[u]}if(l!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${l}`)}const s=r-1,o=Wi("int32",r);if(i===0||r===0){const l=new Array(i);for(let u=0;u<=s;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[s]);for(let l=0;l<s;++l){const u=t[l];let c=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,a,c,p,h),c+=p}),this.preserveShort&&c===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth,p=1;this.createNGrams(e,u,a,c,p,d)}}return[a,o]}}function Dre(n,e,t,i,r,s,o,a){return new gXe(t,i,r,s,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yXe(n,e,t,i){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)i.push(n.subarray(s,s+1));return}if(e.length===1){const s=e[0];let o=n.indexOf(s);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&i.push(a),n=n.subarray(o+1),o=n.indexOf(s)}(!t||n.length!==0)&&i.push(n);return}let r=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){const o=n.subarray(r,s);(!t||o.length!==0)&&i.push(o),r=s+1}}function Fre(n,e,t){const i=n.length,r=[];let s=0,o=0;const a=new Array(i);for(let d=0;d<i;++d){const p=r.length;yXe(n[d],e,t,r);const f=r.length-p;a[d]=f,s+=f,o=Math.max(o,f)}const l=Wi("int32",s*2),u=new Array(s),c=[i,o];let h=0;for(let d=0;d<i;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=r[h],++h;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ore(n,e){const t=Wi("int32",n.length);for(let i=0;i<n.length;++i)t[i]=cte(n[i]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bre=sr((n,e)=>n-e),bXe=r$((n,e,t,i)=>({real:n-t,imag:e-i})),u$=Rr(Y0,Bre,bXe),xXe={kernelName:Y0,backendName:"cpu",kernelFunc:u$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zre(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const i=nn(t,n.dtype);for(let r=0;r<i.values.length;++r){const s=i.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%n.shape[l];const a=n.locToIndex(o);i.values[r]=n.values[a]}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zx=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Gre(n,e,t=0,i=n.length-1){for(;i>t;){if(i-t>600){const a=i-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*c/a+h)),p=Math.min(i,Math.floor(e+(a-l)*c/a+h));Gre(n,e,d,p)}const r=n[e];let s=t,o=i;for(fc(n,t,e),zx(n[i],r)>0&&fc(n,t,i);s<o;){for(fc(n,s,o),s++,o--;zx(n[s],r)<0;)s=s+1;for(;zx(n[o],r)>0;)o=o-1}zx(n[t],r)===0?fc(n,t,o):(o=o+1,fc(n,o,i)),o<=e&&(t=o+1),e<=o&&(i=o-1)}}function Vre(n,e,t,i,r){const s=e[e.length-1],[o,a]=[n.length/s,s],l=br(t,o*i),u=br("int32",o*i);for(let h=0;h<o;h++){const d=h*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((v,w)=>f[w]={value:v,index:w}),i<f.length&&(Gre(f,i),f=f.slice(0,i)),r&&f.sort(zx);const g=h*i,y=l.subarray(g,g+i),m=u.subarray(g,g+i);for(let v=0;v<i;v++)y[v]=f[v].value,m[v]=f[v].index}const c=e.slice();return c[c.length-1]=i,[nn(c,t,l),nn(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ure(n,e,t,i){const r=un(e,t)[0],s=[1,t[0],1];for(let f=0;f<r;f++)s[0]*=t[f];s[1]=t[r];for(let f=r+1;f<t.length;f++)s[2]*=t[f];const o={},a=new Int32Array(t[r]),l=new mr(s,i,n),u=[],c=s[0]===1&&s[2]===1;for(let f=0;f<t[r];f++){let g;if(c)g=n[f].toString();else{const y=[];for(let m=0;m<s[0];m++)for(let v=0;v<s[2];v++)y.push(l.get(m,f,v));g=y.join(",")}if(o[g]!==void 0)a[f]=o[g];else{const y=Object.keys(o).length;o[g]=y,a[f]=y,u.push(f)}}const h=s.slice();h[1]=Object.keys(o).length;const d=new mr(h,i);u.forEach((f,g)=>{for(let y=0;y<s[0];y++)for(let m=0;m<s[2];m++)d.set(l.get(y,f,m),y,g,m)});const p=t.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vXe=Object.freeze(Object.defineProperty({__proto__:null,addImpl:ere,bincountImpl:s$,bincountReduceImpl:tre,castImpl:qie,ceilImpl:nre,concatImpl:ire,equalImpl:rre,expImpl:ore,expm1Impl:lre,floorImpl:ure,gatherNdImpl:cre,gatherV2Impl:hre,greaterEqualImpl:pre,greaterImpl:dre,lessEqualImpl:mre,lessImpl:fre,linSpaceImpl:gre,logImpl:yre,maxImpl:bre,maximumImpl:xre,minimumImpl:vre,multiplyImpl:o$,negImpl:wre,notEqualImpl:Sre,prodImpl:Tre,raggedGatherImpl:Cre,raggedRangeImpl:_re,raggedTensorToTensorImpl:Mre,rangeImpl:Are,rsqrtImpl:Ere,scatterImpl:Zg,sigmoidImpl:lXe,simpleAbsImpl:Qie,sliceImpl:kre,sparseFillEmptyRowsImpl:Rre,sparseReshapeImpl:Nre,sparseSegmentReductionImpl:l$,sqrtImpl:hXe,squaredDifferenceImpl:Lre,stridedSliceImpl:Pre,stringNGramsImpl:Dre,stringSplitImpl:Fre,stringToHashBucketFastImpl:Ore,subImpl:Bre,tileImpl:zre,topKImpl:Vre,transposeImpl:a$,uniqueImpl:Ure},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jz("cpu",()=>new xk,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $re=Bn(x0,n=>n>=0?n:Math.exp(n)-1),wXe={kernelName:x0,backendName:"cpu",kernelFunc:$re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wre(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{alpha:s}=i;Tt([r],"leakyRelu");const o=ke(r.shape),a=t.data.get(r.dataId).values,l=br("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?s*a[u]:a[u];return t.makeTensorInfo(r.shape,"float32",l)}const SXe={kernelName:ww,backendName:"cpu",kernelFunc:Wre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TXe=sr((n,e)=>n<0?e*n:n);function Hre(n){const{inputs:e,backend:t}=n,{x:i,alpha:r}=e;Tt([i,r],"prelu");const s=t.data.get(i.dataId).values,o=t.data.get(r.dataId).values,[a,l]=TXe(i.shape,r.shape,s,o,"float32");return t.makeTensorInfo(l,"float32",a)}const CXe={kernelName:Gw,backendName:"cpu",kernelFunc:Hre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xre=Bn(B0,n=>Math.max(0,n)),_Xe={kernelName:B0,backendName:"cpu",kernelFunc:Xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kre=Bn(z0,n=>Math.min(Math.max(0,n),6)),MXe={kernelName:z0,backendName:"cpu",kernelFunc:Kre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(n,e,t,i,r){if(t==="linear")return Vu({inputs:{x:e},backend:n});if(t==="relu")return Xre({inputs:{x:e},backend:n});if(t==="elu")return $re({inputs:{x:e},backend:n});if(t==="relu6")return Kre({inputs:{x:e},backend:n});if(t==="prelu")return Hre({inputs:{x:e,alpha:i},backend:n});if(t==="leakyrelu")return Wre({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return Ire({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{shape:s}=i,o=ke(r.shape),a=Lz(s,o),l=ke(a);B(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const AXe={kernelName:Uw,backendName:"cpu",kernelFunc:jn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;Tt([r,s],"matMul");const l=r.shape.length,u=s.shape.length,c=o?r.shape[l-2]:r.shape[l-1],h=a?s.shape[u-1]:s.shape[u-2],d=o?r.shape[l-1]:r.shape[l-2],p=a?s.shape[u-2]:s.shape[u-1],f=r.shape.slice(0,-2),g=s.shape.slice(0,-2),y=ke(f),m=ke(g),v=Yt(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);B(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[y,c,d]:[y,d,c],S=a?[m,p,h]:[m,h,p],C=jn({inputs:{x:r},backend:t,attrs:{shape:w}}),_=jn({inputs:{x:s},backend:t,attrs:{shape:S}}),A=o?C.shape[1]:C.shape[2],I=o?C.shape[2]:C.shape[1],E=a?_.shape[1]:_.shape[2],k=Math.max(y,m),P=t.data.get(C.dataId).values,V=t.data.get(_.dataId).values,U=kt(C.shape),F=kt(_.shape),[$,J,q]=o?[U[0],1,U[1]]:[U[0],U[1],1],[O,X,j]=a?[1,F[1],F[0]]:[F[1],1,F[0]],z=I*E,Z=nn([k,I,E],C.dtype),ce=Z.values,fe=t.blockSize;for(let ge=0;ge<k;ge++){const Ne=ge%y,Fe=ge%m;for(let We=0;We<I;We+=fe){const Ue=Math.min(We+fe,I);for(let Ye=0;Ye<E;Ye+=fe){const $e=Math.min(Ye+fe,E);for(let ee=0;ee<A;ee+=fe){const De=Math.min(ee+fe,A);for(let _e=We;_e<Ue;_e++)for(let ze=Ye;ze<$e;ze++){let Re=0;for(let nt=ee;nt<De;nt++){const Ze=P[Ne*$+_e*J+nt*q],st=V[nt*O+ze*X+Fe*j];Re+=Ze*st}ce[ge*z+(_e*E+ze)]+=Re}}}}}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(v,Z.dtype,Z.values)}const EXe={kernelName:ow,backendName:"cpu",kernelFunc:Zre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IXe(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=i;let d,p,f;const g=[];d=Zre({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:t}),o&&(p=Uy({inputs:{a:d,b:o},backend:t}),g.push(d),d=p),c&&(f=gA(t,d,c,a,h),g.push(d),d=f);for(const y of g)t.disposeIntermediateTensorInfo(y);return d}const kXe={kernelName:s1,backendName:"cpu",kernelFunc:IXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RXe=Bn(o0,n=>Math.acos(n)),NXe={kernelName:o0,backendName:"cpu",kernelFunc:RXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LXe=Bn(a0,n=>Math.acosh(n)),PXe={kernelName:a0,backendName:"cpu",kernelFunc:LXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DXe(n){const{inputs:e,backend:t}=n,i=e;Tt(e,"addN");const r=i.map(a=>t.data.get(a.dataId).values),s=nn(i[0].shape,i[0].dtype),o=s.values;for(let a=0;a<i.length;a++){const l=r[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}const FXe={kernelName:tw,backendName:"cpu",kernelFunc:DXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OXe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;Tt(r,"all");const a=un(s,r.shape);let l=a;const u=Ti(l,r.shape.length);let c=r;u!=null&&(c=no({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Ki(l.length,r.shape.length)),ts("all",l,c.shape.length);const[h,d]=kr(c.shape,l),p=ke(d),f=jr(ke(h),c.dtype),g=t.data.get(c.dataId).values;for(let m=0;m<f.length;++m){const v=m*p;let w=g[v];for(let S=0;S<p;++S){const C=g[v+S];w=w&&C}f[m]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(o){const m=Xi(h,a),v=jn({inputs:{x:y},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(y),v}return y}const BXe={kernelName:s2,backendName:"cpu",kernelFunc:OXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zXe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;Tt(r,"any");const a=un(s,r.shape);let l=a;const u=Ti(l,r.shape.length);let c=r;u!=null&&(c=no({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Ki(l.length,r.shape.length)),ts("any",l,c.shape.length);const[h,d]=kr(c.shape,l),p=ke(d),f=jr(ke(h),c.dtype),g=t.data.get(c.dataId).values;for(let m=0;m<f.length;++m){const v=m*p;let w=g[v];for(let S=0;S<p;++S){const C=g[v+S];w=w||C}f[m]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(o){const m=Xi(h,a),v=jn({inputs:{x:y},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(y),v}return y}const GXe={kernelName:o2,backendName:"cpu",kernelFunc:zXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VXe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;Tt(r,"argMax");let o=un(s,r.shape);const a=Ti(o,r.shape.length);let l=r;const u=[];a!=null&&(l=no({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Ki(o.length,l.shape.length)),o=[o[0]],ts("argMax",o,l.shape.length);const[c,h]=kr(l.shape,o),d=ke(c),p=jr(d,"int32"),f=ke(h),g=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const m=y*f;let v=g[m],w=0;for(let S=0;S<f;++S){const C=g[m+S];C>v&&(v=C,w=S)}p[y]=w}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const UXe={kernelName:nw,backendName:"cpu",kernelFunc:VXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Xe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;Tt(r,"argMin");let o=un(s,r.shape);const a=Ti(o,r.shape.length);let l=r;const u=[];a!=null&&(l=no({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Ki(o.length,l.shape.length)),o=[o[0]],ts("argMin",o,l.shape.length);const[c,h]=kr(l.shape,o),d=ke(c),p=jr(d,"int32"),f=ke(h),g=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const m=y*f;let v=g[m],w=0;for(let S=0;S<f;++S){const C=g[m+S];C<v&&(v=C,w=S)}p[y]=w}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const WXe={kernelName:iw,backendName:"cpu",kernelFunc:$Xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HXe=Bn(l0,n=>Math.asin(n)),XXe={kernelName:l0,backendName:"cpu",kernelFunc:HXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KXe=Bn(u0,n=>Math.asinh(n)),ZXe={kernelName:u0,backendName:"cpu",kernelFunc:KXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jXe=Bn(c0,n=>Math.atan(n)),YXe={kernelName:c0,backendName:"cpu",kernelFunc:jXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JXe=sr((n,e)=>Math.atan2(n,e)),QXe=Rr(d0,JXe),qXe={kernelName:d0,backendName:"cpu",kernelFunc:QXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4e=Bn(h0,n=>Math.atanh(n)),t4e={kernelName:h0,backendName:"cpu",kernelFunc:e4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(n,e,t,i,r,s){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=nn(r.outShape,t),y=g.values,m=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],w=r.outShape[3];for(let S=0;S<r.batchSize;++S){const C=S*m,_=S*i[0];for(let A=0;A<r.inChannels;++A)for(let I=0;I<r.outHeight;++I){const E=I*o-d,k=Math.max(0,E),P=Math.min(r.inHeight,c+E),V=C+I*v;for(let U=0;U<r.outWidth;++U){const F=U*a-p,$=Math.max(0,F),J=Math.min(r.inWidth,h+F);let q=f,O=0,X=0;for(let z=k;z<P;z+=l){const Z=_+z*i[1];for(let ce=$;ce<J;ce+=u){const fe=Z+ce*i[2],ge=n[fe+A];s==="max"&&ge>q?q=ge:s==="avg"&&(O+=ge,X++)}if(isNaN(q))break}const j=V+U*w+A;y[j]=s==="avg"?O/X:q}}}return g}function jre(n,e,t,i,r=!1,s=!1){const o=nn(i.outShape,"int32"),a=i.strideHeight,l=i.strideWidth,u=i.dilationHeight,c=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,g=nn(e,t,n);for(let y=0;y<i.batchSize;++y)for(let m=0;m<i.inChannels;++m)for(let v=0;v<i.outHeight;++v){const w=v*a-p;let S=w;for(;S<0;)S+=u;const C=Math.min(i.inHeight,h+w);for(let _=0;_<i.outWidth;++_){const A=_*l-f;let I=A;for(;I<0;)I+=c;const E=Math.min(i.inWidth,d+A);let k=Number.NEGATIVE_INFINITY,P=-1;for(let V=S;V<C;V+=u){const U=V-w;for(let F=I;F<E;F+=c){const $=F-A,J=g.get(y,V,F,m);J>k&&(k=J,r?P=s?((y*i.inHeight+V)*i.inWidth+F)*i.inChannels+m:(V*i.inWidth+F)*i.inChannels+m:P=U*d+$)}}o.set(P,y,v,_,m)}}return o}function Yre(n,e,t,i,r,s){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,y=r.padInfo.top,m=r.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=nn(r.outShape,t),S=w.values,C=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],A=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let E=0;E<r.batchSize;++E){const k=E*C,P=E*i[0];for(let V=0;V<r.inChannels;++V)for(let U=0;U<r.outDepth;++U){const F=U*o-g;let $=F;for(;$<0;)$+=u;const J=Math.min(r.inDepth,d+F),q=k+U*_;for(let O=0;O<r.outHeight;++O){const X=O*a-y;let j=X;for(;j<0;)j+=c;const z=Math.min(r.inHeight,p+X),Z=q+O*A;for(let ce=0;ce<r.outWidth;++ce){const fe=ce*l-m;let ge=fe;for(;ge<0;)ge+=h;const Ne=Math.min(r.inWidth,f+fe),Fe=Z+ce*I;let We=v,Ue=0,Ye=0;for(let ee=$;ee<J;ee+=u){const De=P+ee*i[1];for(let _e=j;_e<z;_e+=c){const ze=De+_e*i[2];for(let Re=ge;Re<Ne;Re+=h){const nt=ze+Re*i[3],Ze=n[nt+V];if(s==="max"&&Ze>We?We=Ze:s==="avg"&&(Ue+=Ze,Ye++),isNaN(We))break}if(isNaN(We))break}if(isNaN(We))break}const $e=Fe+V;S[$e]=s==="avg"?Ue/Math.max(Ye,1):We}}}}return w}function n4e(n,e){const t=nn(e.outShape,"int32"),i=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let y=0;y<e.inChannels;++y)for(let m=0;m<e.outDepth;++m){const v=m*i-d;let w=v;for(;w<0;)w+=o;const S=Math.min(e.inDepth,u+v);for(let C=0;C<e.outHeight;++C){const _=C*r-p;let A=_;for(;A<0;)A+=a;const I=Math.min(e.inHeight,c+_);for(let E=0;E<e.outWidth;++E){const k=E*s-f;let P=k;for(;P<0;)P+=l;const V=Math.min(e.inWidth,h+k);let U=Number.NEGATIVE_INFINITY,F=-1;for(let $=w;$<S;$+=o){const J=$-v;for(let q=A;q<I;q+=a){const O=q-_;for(let X=P;X<V;X+=l){const j=X-k,z=n.get(g,$,q,X,y);z>=U&&(U=z,F=J*c*h+O*c+j)}}}t.set(F,g,m,C,E,y)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;Tt(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,u=1;B(es(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=rl(r.shape,s,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&bn(c.inShape,c.outShape))h=Vu({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=kt(r.shape),f=c$(d,r.shape,r.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const r4e={kernelName:rw,backendName:"cpu",kernelFunc:i4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=i;Tt(r,"avgPool3d");const c=Jc(r.shape,s,o,1,a,l,u),h=t.data.get(r.dataId).values,d=Yre(h,r.shape,r.dtype,kt(r.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const o4e={kernelName:sw,backendName:"cpu",kernelFunc:s4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=i;Tt([r,s],"avgPool3DGrad");const c=Jc(s.shape,o,a,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,y=c.filterWidth,m=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,S=c.effectiveFilterDepth,C=c.effectiveFilterHeight,_=c.effectiveFilterWidth,A=S-1-c.padInfo.front,I=_-1-c.padInfo.left,E=C-1-c.padInfo.top,k=nn(s.shape,"float32"),P=1/(f*g*y),V=t.bufferSync(r);for(let U=0;U<c.batchSize;++U)for(let F=0;F<c.inChannels;++F)for(let $=0;$<c.inDepth;++$)for(let J=0;J<c.inHeight;++J)for(let q=0;q<c.inWidth;++q){const O=$-A,X=J-E,j=q-I;let z=0;for(let Z=0;Z<S;Z+=m){const ce=(O+Z)/h;if(!(ce<0||ce>=c.outDepth||Math.floor(ce)!==ce))for(let fe=0;fe<C;fe+=v){const ge=(X+fe)/d;if(!(ge<0||ge>=c.outHeight||Math.floor(ge)!==ge))for(let Ne=0;Ne<_;Ne+=w){const Fe=(j+Ne)/p;if(Fe<0||Fe>=c.outWidth||Math.floor(Fe)!==Fe)continue;const We=V.get(U,ce,ge,Fe,F);z+=We}}}k.set(z*P,U,$,J,q,F)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const l4e={kernelName:l2,backendName:"cpu",kernelFunc:a4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s;Tt([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=i,c=rl(o.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,m=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=v-1-c.padInfo.left,S=m-1-c.padInfo.top,C=nn(o.shape,"float32"),_=1/(p*f),A=t.data.get(r.dataId).values,I=nn(r.shape,"float32",A);for(let E=0;E<c.batchSize;++E)for(let k=0;k<c.inChannels;++k)for(let P=0;P<c.inHeight;++P)for(let V=0;V<c.inWidth;++V){const U=P-S,F=V-w;let $=0;for(let J=0;J<m;J+=g){const q=(U+J)/h;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let O=0;O<v;O+=y){const X=(F+O)/d;if(X<0||X>=c.outWidth||Math.floor(X)!==X)continue;const j=I.get(E,q,X,k);$+=j}}C.set($*_,E,P,V,k)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const c4e={kernelName:a2,backendName:"cpu",kernelFunc:u4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,scale:s,offset:o,mean:a,variance:l}=e;B(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Tt([r,a,l,s,o],"batchNorm");let{varianceEpsilon:u}=i;u==null&&(u=.001);const c=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,p=s?t.data.get(s.dataId).values:new Float32Array([1]),f=o?t.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),y=f.length,m=p.length,v=d.length,w=h.length;let S=0,C=0,_=0,A=0;for(let I=0;I<c.length;++I)g[I]=f[S++]+(c[I]-h[C++])*p[_++]/Math.sqrt(d[A++]+u),S>=y&&(S=0),C>=w&&(C=0),_>=m&&(_=0),A>=v&&(A=0);return t.makeTensorInfo(r.shape,r.dtype,g)}const d4e={kernelName:bw,backendName:"cpu",kernelFunc:h4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,crops:o}=i;Tt([r],"batchToSpaceND");const a=s.reduce((m,v)=>m*v),l=wS(r.shape,s,a),u=SS(l.length,s.length),c=TS(r.shape,s,a),h=gV(o,s.length),d=yV(c,o,s.length),p=jn({inputs:{x:r},backend:t,attrs:{shape:l}}),f=no({inputs:{x:p},backend:t,attrs:{perm:u}}),g=jn({inputs:{x:f},backend:t,attrs:{shape:c}}),y=Wf({inputs:{x:g},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),y}const f4e={kernelName:aw,backendName:"cpu",kernelFunc:p4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o}=i,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=s$(a,l,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,u)}const g4e={kernelName:u2,backendName:"cpu",kernelFunc:m4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4e(n){const{inputs:e,backend:t}=n,{s0:i,s1:r}=e,s=t.data.get(i.dataId).values,o=t.data.get(r.dataId).values,a=Yt(Array.from(s),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const b4e={kernelName:c2,backendName:"cpu",kernelFunc:y4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x4e=Bn(m0,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),v4e={kernelName:m0,backendName:"cpu",kernelFunc:x4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w4e=n=>{const{x:e}=n.inputs,t=n.backend,i=new Float32Array(ke(e.shape)),r=t.data.get(e.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];i[u]=Math.hypot(c,h)}return t.makeOutput(i,e.shape,"float32")},S4e={kernelName:lw,backendName:"cpu",kernelFunc:w4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.data.get(i.dataId).complexTensorInfos.imag,s=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,s)}const T4e={kernelName:I2,backendName:"cpu",kernelFunc:$y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i,s=un(r,e[0].shape)[0],o=e.map(g=>g.shape);pV(o,s);let a=Nu(e.map(g=>g.shape),s);if(ke(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(g=>ke(g.shape)>0);if(l.length===1)return Vu({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const g=l.map(S=>$f({inputs:{input:S},backend:t})),y=l.map(S=>$y({inputs:{input:S},backend:t})),m=Wy({inputs:g,backend:t,attrs:{axis:s}}),v=Wy({inputs:y,backend:t,attrs:{axis:s}}),w=wo({inputs:{real:m,imag:v},backend:t});return g.forEach(S=>t.disposeIntermediateTensorInfo(S)),y.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(v),w}const u=l.map(g=>{const y=[-1,ke(g.shape.slice(s))];return jn({inputs:{x:g},backend:t,attrs:{shape:y}})}),c=u.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));a=Nu(u.map(g=>g.shape),1);const h=u[0].shape[0]===1,d=ire(c,a,e[0].dtype,h),p=Nu(l.map(g=>g.shape),s),f=t.makeTensorInfo(p,e[0].dtype,d);return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const C4e={kernelName:uw,backendName:"cpu",kernelFunc:Wy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=i;Tt([r,s],"conv2d");const h=Qc(l),d=Ir(r.shape,s.shape,o,u,a,c,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,y=d.dilationWidth,m=d.padInfo.left,v=d.padInfo.top,w=d.dataFormat==="channelsLast",S=new mr(d.outShape,r.dtype),C=kt(r.shape),_=kt(s.shape),A=C[0],I=w?C[1]:C[2],E=w?C[2]:1,k=w?1:C[1],P=S.strides[0],V=w?S.strides[1]:S.strides[2],U=w?S.strides[2]:1,F=w?1:S.strides[1],$=t.data.get(r.dataId).values,J=t.data.get(s.dataId).values,q=S.values;for(let O=0;O<d.batchSize;++O){const X=O*A,j=O*P;for(let z=0;z<d.outHeight;++z){const Z=j+z*V,ce=z*d.strideHeight-v;for(let fe=0;fe<p;++fe){const ge=ce+fe*g;if(ge<0||ge>=d.inHeight)continue;const Ne=fe*_[0],Fe=X+ge*I;for(let We=0;We<d.outWidth;++We){const Ue=Z+We*U,Ye=We*d.strideWidth-m;for(let $e=0;$e<f;++$e){const ee=Ye+$e*y;if(ee<0||ee>=d.inWidth)continue;const De=Ne+$e*_[1],_e=Fe+ee*E;let ze=De;for(let Re=0;Re<d.inChannels;++Re){const nt=$[_e+Re*k];for(let Ze=0;Ze<d.outChannels;++Ze)q[Ue+Ze*F]+=nt*J[ze+Ze];ze+=d.outChannels}}}}}}return t.makeTensorInfo(S.shape,S.dtype,q)}const _4e={kernelName:cw,backendName:"cpu",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=i;Tt([r,s],"conv2dBackpropFilter");const h=Qc(l),d=Ir(r.shape,c,o,1,a,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:y}=d,m=d.dataFormat==="channelsLast",v=new mr(d.filterShape,"float32"),w=d.padInfo.left,S=d.padInfo.top,C=t.data.get(r.dataId).values,_=t.data.get(s.dataId).values,A=new mr(r.shape,r.dtype,C),I=new mr(s.shape,s.dtype,_);for(let E=0;E<g;++E){const k=Math.max(0,Math.ceil((S-E)/p)),P=Math.min(d.outHeight,(d.inHeight+S-E)/p);for(let V=0;V<y;++V){const U=Math.max(0,Math.ceil((w-V)/f)),F=Math.min(d.outWidth,(d.inWidth+w-V)/f);for(let $=0;$<d.inChannels;++$)for(let J=0;J<d.outChannels;++J){let q=0;for(let O=0;O<d.batchSize;++O)for(let X=k;X<P;++X){const j=E+X*p-S;for(let z=U;z<F;++z){const Z=V+z*f-w;m?q+=A.get(O,j,Z,$)*I.get(O,X,z,J):q+=A.get(O,$,j,Z)*I.get(O,J,X,z)}}v.set(q,E,V,$,J)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const A4e={kernelName:d2,backendName:"cpu",kernelFunc:M4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=i;Tt([r,s],"conv2dBackpropInput");const h=kt(s.shape),d=kt(r.shape);let p=Qc(u);const f=Ir(o,s.shape,a,1,l,c,!1,p),g=new mr(f.inShape,"float32"),y=g.values,m=t.data.get(r.dataId).values,v=t.data.get(s.dataId).values,[w,S,C]=h,{batchSize:_,filterHeight:A,filterWidth:I,inChannels:E,inHeight:k,inWidth:P,outChannels:V,outHeight:U,outWidth:F,strideHeight:$,strideWidth:J}=f;p=f.dataFormat;const q=A-1-f.padInfo.top,O=I-1-f.padInfo.left,X=p==="channelsLast",j=g.strides[0],z=X?g.strides[1]:g.strides[2],Z=X?g.strides[2]:1,ce=X?1:g.strides[1],fe=d[0],ge=X?d[1]:d[2],Ne=X?d[2]:1,Fe=X?1:d[1];for(let We=0;We<_;++We)for(let Ue=0;Ue<E;++Ue)for(let Ye=0;Ye<k;++Ye){const $e=Ye-q,ee=Math.max(0,Math.ceil($e/$)),De=Math.min(U,(A+$e)/$);for(let _e=0;_e<P;++_e){const ze=_e-O,Re=Math.max(0,Math.ceil(ze/J)),nt=Math.min(F,(I+ze)/J);let Ze=0;for(let yt=ee;yt<De;++yt){const Lt=yt*$-$e;for(let ye=Re;ye<nt;++ye){const H=ye*J-ze,D=fe*We+ge*yt+Ne*ye,oe=w*(A-1-Lt)+S*(I-1-H)+C*Ue;for(let Ie=0;Ie<V;++Ie){const Me=m[D+Fe*Ie],Ve=v[oe+Ie];Ze+=Me*Ve}}}const st=j*We+z*Ye+Z*_e+ce*Ue;y[st]=Ze}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const I4e={kernelName:hw,backendName:"cpu",kernelFunc:E4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i;Tt([r,s],"conv3d");const u=zd(r.shape,s.shape,o,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:y}=u,m=y.front,v=y.left,w=y.top,S=new mr(u.outShape,r.dtype),C=t.data.get(r.dataId).values,_=t.data.get(s.dataId).values,A=S.values,I=kt(r.shape),E=kt(s.shape);for(let k=0;k<u.batchSize;++k){const P=k*I[0],V=k*S.strides[0];for(let U=0;U<u.outDepth;++U){const F=V+U*S.strides[1],$=U*u.strideDepth-m;for(let J=0;J<c;++J){const q=$+J*p;if(q<0||q>=u.inDepth)continue;const O=J*E[0],X=P+q*I[1];for(let j=0;j<u.outHeight;++j){const z=F+j*S.strides[2],Z=j*u.strideHeight-w;for(let ce=0;ce<h;++ce){const fe=Z+ce*f;if(fe<0||fe>=u.inHeight)continue;const ge=O+ce*E[1],Ne=X+fe*I[2];for(let Fe=0;Fe<u.outWidth;++Fe){const We=z+Fe*u.outChannels,Ue=Fe*u.strideWidth-v;for(let Ye=0;Ye<d;++Ye){const $e=Ue+Ye*g;if($e<0||$e>=u.inWidth)continue;const ee=ge+Ye*E[2],De=Ne+$e*u.inChannels;let _e=ee;for(let ze=0;ze<u.inChannels;++ze){const Re=C[De+ze];for(let nt=0;nt<u.outChannels;++nt)A[We+nt]+=Re*_[_e+nt];_e+=u.outChannels}}}}}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const R4e={kernelName:dw,backendName:"cpu",kernelFunc:k4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i;Tt([r,s],"conv3dBackpropFilterV2");const u=kt(r.shape),c=kt(s.shape),h=zd(r.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,y=h.filterHeight,m=h.filterWidth,v=new mr(h.filterShape,"float32"),w=v.values,[S,C,_,A]=v.strides,I=t.data.get(s.dataId).values,[E,k,P,V]=c,U=t.data.get(r.dataId).values,[F,$,J,q]=u,O=h.padInfo.front,X=h.padInfo.left,j=h.padInfo.top;for(let z=0;z<g;++z){const Z=Math.max(0,Math.ceil((O-z)/d)),ce=Math.min(h.outDepth,(h.inDepth+O-z)/d),fe=z*S;for(let ge=0;ge<y;++ge){const Ne=Math.max(0,Math.ceil((j-ge)/p)),Fe=Math.min(h.outHeight,(h.inHeight+j-ge)/p),We=ge*C+fe;for(let Ue=0;Ue<m;++Ue){const Ye=Math.max(0,Math.ceil((X-Ue)/f)),$e=Math.min(h.outWidth,(h.inWidth+X-Ue)/f),ee=Ue*_+We;for(let De=0;De<h.inChannels;++De){const _e=De*A+ee;for(let ze=0;ze<h.outChannels;++ze){let Re=0;for(let nt=0;nt<h.batchSize;++nt){const Ze=nt*F,st=nt*E;for(let yt=Z;yt<ce;++yt){const Lt=(z+yt*d-O)*$+Ze,ye=yt*k+st;for(let H=Ne;H<Fe;++H){const D=(ge+H*p-j)*J+Lt,oe=H*P+ye;for(let Ie=Ye;Ie<$e;++Ie){const Me=(Ue+Ie*f-X)*q+D,Ve=Ie*V+oe;Re+=U[Me+De]*I[Ve+ze]}}}}w[_e+ze]=Re}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const L4e={kernelName:p2,backendName:"cpu",kernelFunc:N4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i;Tt([r],"conv3dBackpropInputV2");const u=kt(r.shape),c=kt(s.shape),h=zd(l,s.shape,a,1,o),d=new mr(h.inShape,"float32"),p=d.values,[f,g,y,m]=d.strides,v=t.data.get(r.dataId).values,[w,S,C,_]=u,A=t.data.get(s.dataId).values,[I,E,k,P]=c,{batchSize:V,filterDepth:U,filterHeight:F,filterWidth:$,inChannels:J,inDepth:q,inHeight:O,inWidth:X,outChannels:j,outDepth:z,outHeight:Z,outWidth:ce,strideDepth:fe,strideHeight:ge,strideWidth:Ne}=h,Fe=U-1-h.padInfo.front,We=F-1-h.padInfo.top,Ue=$-1-h.padInfo.left;for(let Ye=0;Ye<V;++Ye)for(let $e=0;$e<J;++$e)for(let ee=0;ee<q;++ee){const De=ee-Fe,_e=Math.max(0,Math.ceil(De/fe)),ze=Math.min(z,(U+De)/fe);for(let Re=0;Re<O;++Re){const nt=Re-We,Ze=Math.max(0,Math.ceil(nt/ge)),st=Math.min(Z,(F+nt)/ge);for(let yt=0;yt<X;++yt){const Lt=yt-Ue,ye=Math.max(0,Math.ceil(Lt/Ne)),H=Math.min(ce,($+Lt)/Ne);let D=0;for(let oe=_e;oe<ze;++oe){const Ie=oe*fe-De;for(let Me=Ze;Me<st;++Me){const Ve=Me*ge-nt;for(let ct=ye;ct<H;++ct){const qe=ct*Ne-Lt,at=w*Ye+S*oe+C*Me+_*ct,Ot=I*(U-1-Ie)+E*(F-1-Ve)+k*($-1-qe)+P*$e;for(let Xt=0;Xt<j;++Xt){const Qe=v[at+Xt],sn=A[Ot+Xt];D+=Qe*sn}}}}p[f*Ye+g*ee+y*Re+m*yt+$e]=D}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const D4e={kernelName:f2,backendName:"cpu",kernelFunc:P4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F4e=Bn(g0,n=>Math.cos(n)),O4e={kernelName:g0,backendName:"cpu",kernelFunc:F4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B4e=Bn(y0,n=>Math.cosh(n)),z4e={kernelName:y0,backendName:"cpu",kernelFunc:B4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4e(n){const{inputs:e,backend:t,attrs:i}=n,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=i,[c,h,d,p]=r.shape,f=s.shape[0],[g,y]=a,m=nn([f,g,y,p],"float32"),v=t.data.get(s.dataId).values,w=t.data.get(o.dataId).values,S=t.data.get(r.dataId).values,C=kt(r.shape),_=kt(m.shape);for(let A=0;A<f;A++){const I=A*4,E=v[I],k=v[I+1],P=v[I+2],V=v[I+3],U=w[A];if(U>=c)continue;const F=g>1?(P-E)*(h-1)/(g-1):0,$=y>1?(V-k)*(d-1)/(y-1):0;for(let J=0;J<g;J++){const q=g>1?E*(h-1)+J*F:.5*(E+P)*(h-1);if(q<0||q>h-1){for(let O=0;O<y;O++)for(let X=0;X<p;X++){const j=X+O*_[2]+J*_[1]+A*_[0];m.values[j]=u}continue}if(l==="bilinear"){const O=Math.floor(q),X=Math.ceil(q),j=q-O;for(let z=0;z<y;z++){const Z=y>1?k*(d-1)+z*$:.5*(k+V)*(d-1);if(Z<0||Z>d-1){for(let Ne=0;Ne<p;Ne++){const Fe=Ne+z*_[2]+J*_[1]+A*_[0];m.values[Fe]=u}continue}const ce=Math.floor(Z),fe=Math.ceil(Z),ge=Z-ce;for(let Ne=0;Ne<p;Ne++){let Fe=Ne+ce*C[2]+O*C[1]+U*C[0];const We=S[Fe];Fe=Ne+fe*C[2]+O*C[1]+U*C[0];const Ue=S[Fe];Fe=Ne+ce*C[2]+X*C[1]+U*C[0];const Ye=S[Fe];Fe=Ne+fe*C[2]+X*C[1]+U*C[0];const $e=S[Fe],ee=We+(Ue-We)*ge,De=Ye+($e-Ye)*ge;Fe=Ne+z*_[2]+J*_[1]+A*_[0],m.values[Fe]=ee+(De-ee)*j}}}else for(let O=0;O<y;++O){const X=y>1?k*(d-1)+O*$:.5*(k+V)*(d-1);if(X<0||X>d-1){for(let Z=0;Z<p;Z++){const ce=Z+O*_[2]+J*_[1]+A*_[0];m.values[ce]=u}continue}const j=Math.round(X),z=Math.round(q);for(let Z=0;Z<p;Z++){const ce=Z+j*C[2]+z*C[1]+U*C[0],fe=Z+O*_[2]+J*_[1]+A*_[0];m.values[fe]=S[ce]}}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const V4e={kernelName:g2,backendName:"cpu",kernelFunc:G4e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;Tt(r,"cumprod");const l=Ti([s],r.shape.length);let u=r;l!=null&&(u=no({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=Ki(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=qs(u.dtype,"int32"),d=r2(ke(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(m,v)=>m+f-v-1:(m,v)=>m+v;for(let m=0;m<p.length;m+=f)for(let v=0;v<f;v++){const w=g(m,v);if(v===0)d[w]=o?1:p[w];else{const S=g(m,v-1);d[w]=o?p[S]*d[S]:p[w]*d[S]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const m=Gd(l),v=no({inputs:{x:y},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),v}return y}const $4e={kernelName:m2,backendName:"cpu",kernelFunc:U4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;Tt(r,"cumsum");const l=Ti([s],r.shape.length);let u=r;l!=null&&(u=no({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=Ki(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=qs(u.dtype,"int32"),d=jr(ke(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(m,v)=>m+f-v-1:(m,v)=>m+v;for(let m=0;m<p.length;m+=f)for(let v=0;v<f;v++){const w=g(m,v);if(v===0)d[w]=o?0:p[w];else{const S=g(m,v-1);d[w]=o?p[S]+d[S]:p[w]+d[S]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const m=Gd(l),v=no({inputs:{x:y},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),v}return y}const H4e={kernelName:pw,backendName:"cpu",kernelFunc:W4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(r.shape.length===1){const l=t.data.get(r.dataId).values,u=t.data.get(s.dataId).values,c=s$(l,u,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(s),c=tre(l,u,o,a);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const K4e={kernelName:y2,backendName:"cpu",kernelFunc:X4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockSize:s,dataFormat:o}=i;B(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*s,d=u*s,p=c/(s*s),f=t.data.get(r.dataId).values,g=new Float32Array(a*h*d*p);let y=0;for(let m=0;m<a;++m)for(let v=0;v<h;++v){const w=Math.floor(v/s),S=v%s;for(let C=0;C<d;++C){const _=Math.floor(C/s),A=C%s,I=(S*s+A)*p;for(let E=0;E<p;++E){const k=E+I+c*(_+u*(w+l*m));g[y++]=f[k]}}}return t.makeTensorInfo([a,h,d,p],r.dtype,g)}const j4e={kernelName:b2,backendName:"cpu",kernelFunc:Z4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qre(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=i;Tt([r,s],"depthwiseConv2DNative");const c=kt(r.shape),h=kt(s.shape);let d=l;d==null&&(d=[1,1]),B(es(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Ir(r.shape,s.shape,o,d,a,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:y,dilationWidth:m,padInfo:v}=p,w=v.left,S=v.top,C=p.outChannels/p.inChannels,_=new mr(p.outShape,r.dtype),A=t.data.get(r.dataId).values,I=t.data.get(s.dataId).values,E=_.values;for(let k=0;k<p.batchSize;++k){const P=k*c[0],V=k*_.strides[0];for(let U=0;U<p.outHeight;++U){const F=V+U*_.strides[1],$=U*p.strideHeight-S;for(let J=0;J<f;++J){const q=$+J*y;if(q<0||q>=p.inHeight)continue;const O=J*h[0],X=P+q*c[1];for(let j=0;j<p.outWidth;++j){const z=F+j*_.strides[2],Z=j*p.strideWidth-w;for(let ce=0;ce<g;++ce){const fe=Z+ce*m;if(fe<0||fe>=p.inWidth)continue;const ge=O+ce*h[1],Ne=X+fe*p.inChannels;let Fe=z,We=ge;for(let Ue=0;Ue<p.inChannels;++Ue){const Ye=A[Ne+Ue];for(let $e=0;$e<C;++$e)E[Fe+$e]+=Ye*I[We+$e];Fe+=C,We+=C}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const Y4e={kernelName:fw,backendName:"cpu",kernelFunc:Qre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=i;Tt([r,s],"depthwiseConv2dNativeBackpropFilter");const h=Ir(r.shape,c,o,a,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,y=new mr(h.filterShape,"float32"),m=h.padInfo.left,v=h.padInfo.top,w=h.outChannels/h.inChannels,S=t.data.get(r.dataId).values,C=new mr(r.shape,r.dtype,S),_=t.data.get(s.dataId).values,A=new mr(s.shape,s.dtype,_);for(let I=0;I<f;++I){const E=Math.max(0,Math.ceil((v-I)/d)),k=Math.min(h.outHeight,(h.inHeight+v-I)/d);for(let P=0;P<g;++P){const V=Math.max(0,Math.ceil((m-P)/p)),U=Math.min(h.outWidth,(h.inWidth+m-P)/p);for(let F=0;F<h.outChannels;++F){const $=Math.trunc(F/w),J=F%w;let q=0;for(let O=0;O<h.batchSize;++O)for(let X=E;X<k;++X){const j=I+X*d-v;for(let z=V;z<U;++z){const Z=P+z*p-m;q+=C.get(O,j,Z,$)*A.get(O,X,z,F)}}y.set(q,I,P,$,J)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Q4e={kernelName:x2,backendName:"cpu",kernelFunc:J4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=i;Tt([r,s],"depthwiseConv2DNativeBackpropInput");const h=kt(r.shape),d=kt(s.shape),p=Ir(c,s.shape,o,a,l,u,!0),f=new mr(p.inShape,"float32"),g=f.values,[y,m,v]=f.strides,w=t.data.get(r.dataId).values,[S,C,_]=h,A=t.data.get(s.dataId).values,[I,E,k]=d,{batchSize:P,filterHeight:V,filterWidth:U,inChannels:F,inHeight:$,inWidth:J,outChannels:q,outHeight:O,outWidth:X,strideHeight:j,strideWidth:z}=p,Z=V-1-p.padInfo.top,ce=U-1-p.padInfo.left,fe=q/F;for(let ge=0;ge<P;++ge)for(let Ne=0;Ne<F;++Ne)for(let Fe=0;Fe<$;++Fe){const We=Fe-Z,Ue=Math.max(0,Math.ceil(We/j)),Ye=Math.min(O,(V+We)/j);for(let $e=0;$e<J;++$e){const ee=$e-ce,De=Math.max(0,Math.ceil(ee/z)),_e=Math.min(X,(U+ee)/z);let ze=0;for(let Re=Ue;Re<Ye;++Re){const nt=Re*j-We;for(let Ze=De;Ze<_e;++Ze){const st=Ze*z-ee,yt=S*ge+C*Re+_*Ze,Lt=I*(V-1-nt)+E*(U-1-st)+k*Ne;for(let ye=0;ye<fe;++ye){const H=Ne*fe+ye,D=w[yt+H],oe=A[Lt+ye];ze+=D*oe}}}g[y*ge+m*Fe+v*$e+Ne]=ze}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const e9e={kernelName:v2,backendName:"cpu",kernelFunc:q4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9e(n){const{inputs:e,backend:t}=n,{x:i}=e,r=ke(i.shape),s=t.data.get(i.dataId).values,o=nn([r,r],i.dtype),a=o.values;for(let u=0;u<s.length;u++)a[u*r+u]=s[u];const l=[...i.shape,...i.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const n9e={kernelName:w2,backendName:"cpu",kernelFunc:t9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i9e={kernelName:mw,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:i,filter:r}=n,{strides:s,pad:o,dilations:a}=t,l=e,u=l.data.get(i.dataId).values,c=i.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:y,outHeight:m,outWidth:v,padInfo:w,strideHeight:S,strideWidth:C,filterHeight:_,filterWidth:A,dilationHeight:I,dilationWidth:E,outShape:k}=iS(i.shape,r.shape,s,o,"NHWC",a),P=ke(k),V=k.length,U=Wi(i.dtype,P);for(let F=0;F<p;++F)for(let $=0;$<m;++$){const J=$*S-w.top;for(let q=0;q<v;++q){const O=q*C-w.left;for(let X=0;X<y;++X){let j=Number.MIN_SAFE_INTEGER;for(let Z=0;Z<_;++Z){const ce=J+Z*I;if(ce>=0&&ce<f)for(let fe=0;fe<A;++fe){const ge=O+fe*E;if(ge>=0&&ge<g){const Ne=Pl([F,ce,ge,X],c,kt(i.shape)),Fe=Pl([Z,fe,X],d,kt(r.shape)),We=u[Ne]+h[Fe];We>j&&(j=We)}}}const z=Pl([F,$,q,X],V,kt(k));U[z]=j}}}return{dataId:l.write(Od(U,i.dtype),k,i.dtype),shape:k,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r9e={kernelName:JM,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:i,filter:r,dy:s}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=aa(i.shape,u.data.get(i.dataId).values),h=aa(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:m,padInfo:v,strideHeight:w,strideWidth:S,filterHeight:C,filterWidth:_,dilationHeight:A,dilationWidth:I,outShape:E}=iS(i.shape,r.shape,o,a,"NHWC",l);B(s.rank===E.length,()=>`Error in ${JM}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);const k=aa(E,u.data.get(s.dataId).values),P=Dz(r.shape,r.dtype);for(let V=0;V<d;++V)for(let U=0;U<y;++U){const F=U*w-v.top;for(let $=0;$<m;++$){const J=$*S-v.left;for(let q=0;q<g;++q){let O=Number.MIN_SAFE_INTEGER,X=0,j=0;for(let z=0;z<C;++z){const Z=F+z*A;if(Z>=0&&Z<p)for(let ce=0;ce<_;++ce){const fe=J+ce*I;if(fe>=0&&fe<f){const ge=c[V][Z][fe][q]+h[z][ce][q];ge>O&&(O=ge,X=z,j=ce)}}}P[X][j][q]+=k[V][U][$][q]}}}return{dataId:u.write(Od(P,i.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s9e={kernelName:YM,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:i,filter:r,dy:s}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=aa(i.shape,u.data.get(i.dataId).values),h=aa(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:m,padInfo:v,strideHeight:w,strideWidth:S,filterHeight:C,filterWidth:_,dilationHeight:A,dilationWidth:I,outShape:E}=iS(i.shape,r.shape,o,a,"NHWC",l);B(s.rank===E.length,()=>`Error in ${YM}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);const k=aa(E,u.data.get(s.dataId).values),P=Dz(i.shape,i.dtype);for(let V=0;V<d;++V)for(let U=0;U<y;++U){const F=U*w-v.top;for(let $=0;$<m;++$){const J=$*S-v.left;for(let q=0;q<g;++q){let O=Number.MIN_SAFE_INTEGER,X=F<0?0:F,j=J<0?0:J;for(let z=0;z<C;++z){const Z=F+z*A;if(Z>=0&&Z<p)for(let ce=0;ce<_;++ce){const fe=J+ce*I;if(fe>=0&&fe<f){const ge=c[V][Z][fe][q]+h[z][ce][q];ge>O&&(O=ge,X=Z,j=fe)}}}P[V][X][j][q]+=k[V][U][$][q]}}}return{dataId:u.write(Od(P,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;Tt(r,"sum");let a;r.dtype==="bool"?a=_d({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=Vu({inputs:{x:r},backend:t});const l=a.shape.length,u=un(s,a.shape),c=Ti(u,l);let h=u,d=a;c!=null&&(d=no({inputs:{x:a},backend:t,attrs:{perm:c}}),h=Ki(h.length,l)),ts("sum",h,d.shape.length);const[p,f]=kr(d.shape,h),g=qs(d.dtype,"int32");let y=fA(t,p,g);const m=ke(f),v=t.data.get(y.dataId).values,w=t.data.get(d.dataId).values;for(let S=0;S<v.length;++S){const C=S*m;let _=0;for(let A=0;A<m;++A)_+=w[C+A];v[S]=_}if(o){const S=Xi(y.shape,u),C=y;y=jn({inputs:{x:y},backend:t,attrs:{shape:S}}),t.disposeIntermediateTensorInfo(C)}return t.disposeIntermediateTensorInfo(a),c!=null&&t.disposeIntermediateTensorInfo(d),y}const o9e={kernelName:Zw,backendName:"cpu",kernelFunc:LS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a9e(n){const{inputs:e,backend:t,attrs:i}=n,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=_V(r,s.length);AV(o.length,l,s);const{path:u,steps:c}=EV(a,l),h=c.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const y of c[g]){const{permutationIndices:m,expandDims:v}=MV(p,l[y]);let w;IV(m)?w=s[y]:(w=no({inputs:{x:s[y]},backend:t,attrs:{perm:m}}),f.push(w));const S=w.shape.slice();for(let C=0;C<v.length;++C)S.splice(v[C],0,1);bn(w.shape,S)||(w=jn({inputs:{x:w},backend:t,attrs:{shape:S}}),f.push(w)),d===null?d=w:(d=vk({inputs:{a:w,b:d},backend:t}),f.push(d))}g<h-1&&(u[g]>=0&&(d=LS({inputs:{x:d},backend:t,attrs:{axis:u[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const l9e={kernelName:S2,backendName:"cpu",kernelFunc:a9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9e(n){const{inputs:e,backend:t}=n,{dy:i,y:r}=e;Tt([i,r],"eluGrad");const s=new Float32Array(ke(r.shape)),o=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];u>=1?s[l]=a[l]:s[l]=a[l]*(u+1)}return t.makeTensorInfo(r.shape,"float32",s)}const c9e={kernelName:T2,backendName:"cpu",kernelFunc:u9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h9e=bV,d9e=xV,p9e=vV,f9e=wV,m9e=SV,g9e=TV,y9e=Bn(v0,n=>{const e=Math.sign(n),t=Math.abs(n),i=1/(1+h9e*t);return e*(1-((((g9e*i+m9e)*i+f9e)*i+p9e)*i+d9e)*i*Math.exp(-t*t))}),b9e={kernelName:v0,backendName:"cpu",kernelFunc:y9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n){const{inputs:e,backend:t,attrs:i}=n,{input:r}=e,{dim:s}=i,o=r.shape.length,a=r.shape.slice();let l=s;return s<0&&(B(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),jn({inputs:{x:r},backend:t,attrs:{shape:a}})}const x9e={kernelName:yw,backendName:"cpu",kernelFunc:yA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v9e=sr((n,e)=>n/e),h$=Rr(b0,v9e),_F={kernelName:b0,backendName:"cpu",kernelFunc:h$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qre(n,e,t){const i=n.shape,r=i[0],s=i[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,s],c=ke(u),h=br("float32",c),d=br("float32",c);for(let y=0;y<r;y++){const m=Wf({inputs:{x:a},backend:t,attrs:{begin:[y,0],size:[1,s]}}),v=Wf({inputs:{x:l},backend:t,attrs:{begin:[y,0],size:[1,s]}}),w=wo({inputs:{real:m,imag:v},backend:t}),{real:S,imag:C}=w9e(w,e,t),_=Wc(S,C);for(let A=0;A<s;A++){const I=CV(_,A);h[y*s+A]=I.real,d[y*s+A]=I.imag}t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w)}const p=t.makeTensorInfo(u,"float32",h),f=t.makeTensorInfo(u,"float32",d),g=wo({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),g}function w9e(n,e,t){const i=ke(n.shape),r=t.data.get(n.dataId),s=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(S9e(i)){const a=MF(s,o,i,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Yc(i,"float32")),d=Vu({inputs:{x:h},backend:t}),p=_F.kernelFunc({inputs:{a:u,b:h},backend:t}),f=_F.kernelFunc({inputs:{a:c,b:d},backend:t}),g=t.data.get(p.dataId).values,y=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:g,imag:y}}return a}else{const a=Wc(s,o),l=T9e(a,i,e);return gne(l)}}function S9e(n){return(n&n-1)===0}function MF(n,e,t,i,r){if(t===1)return{real:n,imag:e};const s=Wc(n,e),o=t/2,a=yne(s),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=wo({inputs:{real:h,imag:d},backend:r}),f=bne(s),g=f.real,y=f.imag,m=[g.length],v=r.makeTensorInfo(m,"float32",g),w=r.makeTensorInfo(m,"float32",y),S=wo({inputs:{real:v,imag:w},backend:r}),C=MF(l,u,o,i,r),_=C.real,A=C.imag,I=[_.length],E=r.makeTensorInfo(I,"float32",_),k=r.makeTensorInfo(I,"float32",A),P=wo({inputs:{real:E,imag:k},backend:r}),V=MF(g,y,o,i,r),U=V.real,F=V.imag,$=[U.length],J=r.makeTensorInfo($,"float32",U),q=r.makeTensorInfo($,"float32",F),O=wo({inputs:{real:J,imag:q},backend:r}),X=vne(t,i),j=[X.real.length],z=r.makeTensorInfo(j,"float32",X.real),Z=r.makeTensorInfo(j,"float32",X.imag),ce=wo({inputs:{real:z,imag:Z},backend:r}),fe=vk({inputs:{a:ce,b:O},backend:r}),ge=Uy({inputs:{a:P,b:fe},backend:r}),Ne=u$({inputs:{a:P,b:fe},backend:r}),Fe=$f({inputs:{input:ge},backend:r}),We=$f({inputs:{input:Ne},backend:r}),Ue=$y({inputs:{input:ge},backend:r}),Ye=$y({inputs:{input:Ne},backend:r}),$e=Wy({inputs:[Fe,We],backend:r,attrs:{axis:0}}),ee=Wy({inputs:[Ue,Ye],backend:r,attrs:{axis:0}}),De=r.data.get($e.dataId).values,_e=r.data.get(ee.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(ge),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(Fe),r.disposeIntermediateTensorInfo(Ue),r.disposeIntermediateTensorInfo(We),r.disposeIntermediateTensorInfo(Ye),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(ee),{real:De,imag:_e}}function T9e(n,e,t){const i=new Float32Array(e*2);for(let r=0;r<e;r++){let s=0,o=0;for(let a=0;a<e;a++){const l=wne(r*a,e,t),u=CV(n,a);s+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}t&&(s/=e,o/=e),xne(i,s,o,r)}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9e(n){const{inputs:e,backend:t}=n,{input:i}=e,r=ke(i.shape),s=i.shape[i.shape.length-1],o=r/s,a=jn({inputs:{x:i},backend:t,attrs:{shape:[o,s]}}),l=qre(a,!1,t),u=jn({inputs:{x:l},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const _9e={kernelName:C2,backendName:"cpu",kernelFunc:C9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n){const{backend:e,attrs:t}=n,{shape:i,value:r,dtype:s}=t,o=s||s0(r),a=Wi(o,ke(i));return A9e(a,r),e.makeTensorInfo(i,o,a)}const M9e={kernelName:_2,backendName:"cpu",kernelFunc:d$};function A9e(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E9e={kernelName:M2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:i}=n,r=t,s=br(i.dtype,ke(i.shape)),[o,a,l,u]=i.shape,c=r.data.get(i.dataId).values;for(let h=0;h<o;h++){const d=h*l*a*u;for(let p=0;p<a;p++){const f=p*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let m=0;m<u;m++){const v=Math.round(l-g-1),w=d+f+y+m;let S=c[w];if(v>=0&&v<l){const C=v*u,_=d+f+C+m;S=c[_]}s[w]=S}}}}return{dataId:r.write(s,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I9e=sr((n,e)=>Math.floor(n/e)),k9e=Rr(C0,I9e,null,"int32"),R9e={kernelName:C0,backendName:"cpu",kernelFunc:k9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let g=Jre({inputs:{x:r,filter:s},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const y=g;if(c==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const m=jn({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});g=Uy({inputs:{a:g,b:m},backend:t}),t.disposeIntermediateTensorInfo(m)}else g=Uy({inputs:{a:g,b:o},backend:t});t.disposeIntermediateTensorInfo(y)}if(p){const y=g;if(c==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const m=jn({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=gA(t,g,p,m,f),t.disposeIntermediateTensorInfo(m)}else g=gA(t,g,p,a,f);t.disposeIntermediateTensorInfo(y)}return g}const L9e={kernelName:o1,backendName:"cpu",kernelFunc:N9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let g=Qre({inputs:{x:r,filter:s},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const y=g;g=Uy({inputs:{a:g,b:o},backend:t}),t.disposeIntermediateTensorInfo(y)}if(p){const y=g;g=gA(t,g,p,a,f),t.disposeIntermediateTensorInfo(y)}return g}const D9e={kernelName:a1,backendName:"cpu",kernelFunc:P9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F9e(n){const{inputs:e,backend:t}=n,{params:i,indices:r}=e,s=ke(i.shape),o=r.shape,a=o[o.length-1],[l,u,c,h]=XI(i,r);if(u===0)return t.makeTensorInfo(l,i.dtype,[]);const d=t.data.get(r.dataId).values,p=t.bufferSync(i),f=cre(d,p,i.dtype,u,a,c,h,i.shape,s);return t.makeTensorInfo(l,i.dtype,f.values)}const O9e={kernelName:A2,backendName:"cpu",kernelFunc:F9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B9e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,indices:s}=e,{axis:o,batchDims:a}=i;Tt([r,s],"gatherV2");const l=un(o,r.shape)[0],u=t.data.get(s.dataId).values,c=r.shape[l];for(let S=0;S<u.length;++S){const C=u[S];B(C<=c-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=ke(s.shape),p=RV(r,s,l,h),f=jn({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=jn({inputs:{x:s},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),y=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],m=t.bufferSync(g),v=t.bufferSync(f),w=hre(v,m,y);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(p.outputShape,w.dtype,w.values)}const z9e={kernelName:xw,backendName:"cpu",kernelFunc:B9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G9e(n){const{inputs:e,backend:t}=n,{input:i}=e,r=ke(i.shape),s=i.shape[i.shape.length-1],o=r/s,a=jn({inputs:{x:i},backend:t,attrs:{shape:[o,s]}}),l=qre(a,!0,t),u=jn({inputs:{x:l},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const V9e={kernelName:E2,backendName:"cpu",kernelFunc:G9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9e=Bn(A0,n=>Number.isFinite(n)?1:0,"bool"),$9e={kernelName:A0,backendName:"cpu",kernelFunc:U9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W9e=Bn(E0,n=>Math.abs(n)===1/0?1:0,"bool"),H9e={kernelName:E0,backendName:"cpu",kernelFunc:W9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X9e=Bn(I0,n=>Number.isNaN(n)?1:0,"bool"),K9e={kernelName:I0,backendName:"cpu",kernelFunc:X9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9e(n){const{backend:e,attrs:t}=n,{start:i,stop:r,num:s}=t,o=gre(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}const j9e={kernelName:k2,backendName:"cpu",kernelFunc:Z9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y9e=Bn(R0,n=>Math.log1p(n)),J9e={kernelName:R0,backendName:"cpu",kernelFunc:Y9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q9e=sr((n,e)=>n&&e),q9e=Rr(Cw,Q9e,null,"bool"),e5e={kernelName:Cw,backendName:"cpu",kernelFunc:q9e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5e=Bn(_w,n=>n?0:1,"bool"),n5e={kernelName:_w,backendName:"cpu",kernelFunc:t5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i5e=sr((n,e)=>n||e),r5e=Rr(Mw,i5e,null,"bool"),s5e={kernelName:Mw,backendName:"cpu",kernelFunc:r5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i;Tt(r,"LRN");const u=r.shape[3],c=u-1,h=t.data.get(r.dataId).values,d=ke(r.shape),p=new Float32Array(d);function f(g){const y=g%u;let m=g-y+Math.max(0,y-s);const v=g-y+Math.min(y+s,c);let w=0;for(;m<=v;m++){const S=h[m];w+=S*S}return w}for(let g=0;g<d;g++){const y=f(g),m=h[g]*Math.pow(o+a*y,-l);p[g]=m}return t.makeTensorInfo(r.shape,r.dtype,p)}const a5e={kernelName:Aw,backendName:"cpu",kernelFunc:o5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=i;Tt(o,"LRNGrad");const h=ke(o.shape),d=o.shape[3],p=t.data.get(o.dataId).values,f=t.data.get(r.dataId).values,g=t.data.get(s.dataId).values,y=new Float32Array(h),m=h;for(let v=0;v<m;v++){const w=v%d,S=v-w+Math.max(0,w-a),C=v-w+Math.min(d,w+a+1);let _=0;for(let A=S;A<C;A++)_+=Math.pow(f[A],2);_=u*_+l;for(let A=S;A<C;A++){let I=-2*u*c*f[A]*g[v]/_;v===A&&(I+=Math.pow(_,-c)),I*=p[v],y[A]+=I}}return t.makeTensorInfo(o.shape,r.dtype,y)}const u5e={kernelName:R2,backendName:"cpu",kernelFunc:l5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reductionIndices:s,keepDims:o}=i,a=t;let l=r.shape;const u=l.length,c=un(s,l);let h=c;const d=Ti(h,u);let p=a.data.get(r.dataId).values;if(d!=null){const S=new Array(u);for(let C=0;C<S.length;C++)S[C]=l[d[C]];p=a$(p,l,r.dtype,d,S),h=Ki(h.length,u),l=S}Tt(r,"max"),ts("max",h,u);const[f,g]=kr(l,h),y=ke(g),m=bre(p,y,f,r.dtype),v=a.write(m,f,r.dtype);let w=f;return o&&(w=Xi(f,c)),{dataId:v,shape:w,dtype:r.dtype}}const c5e={kernelName:Ew,backendName:"cpu",kernelFunc:ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;Tt(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,u=1;B(es(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=rl(r.shape,s,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&bn(c.inShape,c.outShape))h=Vu({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=kt(r.shape),f=c$(d,r.shape,r.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const d5e={kernelName:Iw,backendName:"cpu",kernelFunc:h5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=i;Tt(r,"maxPool3d");const c=Jc(r.shape,s,o,1,a,l,u),h=t.data.get(r.dataId).values,d=Yre(h,r.shape,r.dtype,kt(r.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const f5e={kernelName:kw,backendName:"cpu",kernelFunc:p5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=i;Tt([r,s],"maxPool3DGrad");const c=Jc(s.shape,o,a,1,l,u),h=t.bufferSync(s),d=n4e(h,c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,y=c.dilationDepth,m=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,S=c.effectiveFilterHeight,C=c.effectiveFilterWidth,_=w-1-c.padInfo.front,A=C-1-c.padInfo.left,I=S-1-c.padInfo.top,E=nn(s.shape,"float32"),k=t.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let V=0;V<c.inChannels;++V)for(let U=0;U<c.inDepth;++U)for(let F=0;F<c.inHeight;++F)for(let $=0;$<c.inWidth;++$){const J=U-_,q=F-I,O=$-A;let X=0;for(let j=0;j<w;j+=y){const z=(J+j)/p;if(!(z<0||z>=c.outDepth||Math.floor(z)!==z))for(let Z=0;Z<S;Z+=m){const ce=(q+Z)/f;if(!(ce<0||ce>=c.outHeight||Math.floor(ce)!==ce))for(let fe=0;fe<C;fe+=v){const ge=(O+fe)/g;if(ge<0||ge>=c.outWidth||Math.floor(ge)!==ge)continue;const Ne=w*S*C-1-d.get(P,z,ce,ge,V),Fe=j*S*C+Z*C+fe,We=Ne===Fe?1:0;if(We===0)continue;const Ue=k.get(P,z,ce,ge,V);X+=Ue*We}}}E.set(X,P,U,F,$,V)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const g5e={kernelName:L2,backendName:"cpu",kernelFunc:m5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s,output:o}=e,a=s;Tt([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=i,d=rl(a.shape,l,u,1,c,h),p=t.data.get(a.dataId).values,f=nn(d.outShape,a.dtype,jre(p,a.shape,a.dtype,d).values),g=d.strideHeight,y=d.strideWidth,m=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,S=d.effectiveFilterWidth,C=S-1-d.padInfo.left,_=w-1-d.padInfo.top,A=nn(a.shape,"float32"),I=t.data.get(r.dataId).values,E=nn(r.shape,"float32",I);for(let k=0;k<d.batchSize;++k)for(let P=0;P<d.inChannels;++P)for(let V=0;V<d.inHeight;++V)for(let U=0;U<d.inWidth;++U){const F=V-_,$=U-C;let J=0;for(let q=0;q<w;q+=m){const O=(F+q)/g;if(!(O<0||O>=d.outHeight||Math.floor(O)!==O))for(let X=0;X<S;X+=v){const j=($+X)/y;if(j<0||j>=d.outWidth||Math.floor(j)!==j)continue;const z=w*S-1-f.get(k,O,j,P),Z=q*S+X,ce=z===Z?1:0;if(ce===0)continue;const fe=E.get(k,O,j,P);J+=fe*ce}}A.set(J,k,V,U,P)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const b5e={kernelName:N2,backendName:"cpu",kernelFunc:y5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5e(n,e,t,i,r){const s=kt(e),o=c$(n,e,t,s,r,"max"),a=jre(n,e,t,r,!0,i);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v5e={kernelName:P2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:i}=n,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=e,l=t;Tt(i,"MaxPoolWithArgmax");const u=l.data.get(i.dataId).values,c=rl(i.shape,r,s,[1,1],o),[h,d]=x5e(u,i.shape,i.dtype,a,c),p=l.write(h,c.outShape,i.dtype),f=l.write(d,c.outShape,i.dtype);return[{dataId:p,shape:c.outShape,dtype:i.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=un(s,r.shape),l=kr(r.shape,a)[1],u=ke(l),c=[],h=t.makeTensorInfo([],"float32",new Float32Array([u]));c.push(h);const d=_d({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});c.push(d);const p=h$({inputs:{a:d,b:h},backend:t});c.push(p);const f=LS({inputs:{x:p},backend:t,attrs:{axis:s,keepDims:o}});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const S5e={kernelName:Rw,backendName:"cpu",kernelFunc:w5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;Tt(r,"min");const a=un(s,r.shape);let l=a;const u=Ti(l,r.shape.length);let c=r;u!=null&&(c=no({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Ki(l.length,r.shape.length)),ts("min",l,c.shape.length);const[h,d]=kr(c.shape,l),p=ke(d),f=jr(ke(h),c.dtype),g=t.data.get(c.dataId).values;for(let m=0;m<f.length;++m){const v=m*p;let w=g[v];for(let S=0;S<p;++S){const C=g[v+S];(Number.isNaN(C)||C<w)&&(w=C)}f[m]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,f);if(o){const m=Xi(h,a),v=jn({inputs:{x:y},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(y),v}return y}const C5e={kernelName:Nw,backendName:"cpu",kernelFunc:T5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{paddings:s,mode:o}=i;Tt(r,"mirrorPad");const a=s.map((v,w)=>v[0]+r.shape[w]+v[1]),l=s.map(v=>v[0]),u=s.map((v,w)=>v[0]+r.shape[w]),c=o==="reflect"?0:1,h=t.data.get(r.dataId).values,d=r.shape.length,p=kt(r.shape),f=ke(a),g=a.length,y=kt(a),m=br(r.dtype,f);for(let v=0;v<f;v++){let w=mm(v,g,y);for(let C=0;C<g;C++)w[C]<l[C]?w[C]=l[C]*2-w[C]-c:w[C]>=u[C]&&(w[C]=(u[C]-1)*2-w[C]+c);w=w.map((C,_)=>C-l[_]);const S=Pl(w,d,p);m[v]=h[S]}return{dataId:t.write(m,a,r.dtype),shape:a,dtype:r.dtype}}const M5e={kernelName:Lw,backendName:"cpu",kernelFunc:_5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A5e=sr((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),E5e=Rr(P0,A5e),I5e={kernelName:P0,backendName:"cpu",kernelFunc:E5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tse(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{dim:s}=i,o=r.shape.length;let a=s;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=un([a],r.shape),u=ese({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=Xi(u.shape,l),h=jn({inputs:{x:u},backend:t,attrs:{shape:c}}),d=u$({inputs:{a:r,b:h},backend:t}),p=are({inputs:{x:d},backend:t}),f=LS({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),g=jn({inputs:{x:f},backend:t,attrs:{shape:c}}),y=h$({inputs:{a:p,b:g},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),y}const k5e={kernelName:Jw,backendName:"cpu",kernelFunc:tse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5e(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i;Tt(r,"multinomial");const l=a?r:tse({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,d=[u,s],p=jr(ke(d),"int32");for(let f=0;f<u;++f){const g=f*c,y=new Float32Array(c-1);y[0]=h[g];for(let w=1;w<y.length;++w)y[w]=y[w-1]+h[g+w];const m=lb.alea(o.toString()),v=f*s;for(let w=0;w<s;++w){const S=m();p[v+w]=y.length;for(let C=0;C<y.length;C++)if(S<y[C]){p[v+w]=C;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const N5e={kernelName:D2,backendName:"cpu",kernelFunc:R5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L5e=UI;function P5e(n){const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i;Tt(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,c=t.data.get(s.dataId).values,{selectedIndices:h}=L5e(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const D5e={kernelName:F2,backendName:"cpu",kernelFunc:P5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F5e=$I;function O5e(n){const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=i;Tt(r,"NonMaxSuppressionPadded");const c=t.data.get(r.dataId).values,h=t.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=F5e(c,h,o,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const B5e={kernelName:O2,backendName:"cpu",kernelFunc:O5e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z5e=WI;function G5e(n){const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=i;Tt(r,"NonMaxSuppressionWithScore");const c=t.data.get(r.dataId).values,h=t.data.get(s.dataId).values,d=o,p=a,f=l,g=u,{selectedIndices:y,selectedScores:m}=z5e(c,h,d,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}const V5e={kernelName:B2,backendName:"cpu",kernelFunc:G5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5e(n){const{inputs:e,backend:t,attrs:i}=n,{indices:r}=e,{dtype:s,depth:o,onValue:a,offValue:l}=i;Tt(r,"oneHot");const u=ke(r.shape),c=new Float32Array(u*o);c.fill(l);const h=t.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<o&&(c[d*o+h[d]]=a);return t.makeTensorInfo([...r.shape,o],s,c)}const $5e={kernelName:Ow,backendName:"cpu",kernelFunc:U5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(i.dtype==="complex64"){const r=$f({inputs:{input:i},backend:t}),s=bA({inputs:{x:r},backend:t}),o=$y({inputs:{input:i},backend:t}),a=bA({inputs:{x:o},backend:t}),l=wo({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return d$({backend:t,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const W5e={kernelName:eS,backendName:"cpu",kernelFunc:bA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nse(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(i.dtype==="complex64"){const r=$f({inputs:{input:i},backend:t}),s=nse({inputs:{x:r},backend:t}),o=$y({inputs:{input:i},backend:t}),a=bA({inputs:{x:o},backend:t}),l=wo({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return d$({backend:t,attrs:{shape:i.shape,value:1,dtype:i.dtype}})}const H5e={kernelName:Fw,backendName:"cpu",kernelFunc:nse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i;if(e.length===1)return yA({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach(c=>{qr(s,c.shape,"All tensors passed to stack must have matching shapes"),B(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=yA({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=Wy({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const X5e={kernelName:Bw,backendName:"cpu",kernelFunc:ise};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{paddings:s,constantValue:o}=i;Tt(r,"pad");const a=s.map((m,v)=>m[0]+r.shape[v]+m[1]),l=s.map(m=>m[0]),u=t.data.get(r.dataId).values,c=ke(r.shape),h=r.shape.length,d=kt(r.shape),p=ke(a),f=a.length,g=kt(a),y=br(r.dtype,p);o!==0&&y.fill(o);for(let m=0;m<c;m++){const v=mm(m,h,d).map((S,C)=>S+l[C]),w=Pl(v,f,g);y[w]=u[m]}return{dataId:t.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const rse={kernelName:zw,backendName:"cpu",kernelFunc:K5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z5e=sr((n,e)=>Math.pow(n,e)),j5e=Rr(F0,Z5e),Y5e={kernelName:F0,backendName:"cpu",kernelFunc:j5e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5e(n){const{inputs:e,backend:t,attrs:i}=n,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=e,a=r.map(y=>t.data.get(y.dataId).values),l=r.map(y=>y.shape),u=t.data.get(s.dataId).values,c=t.data.get(o.dataId).values,[h,d,p]=Cre(a,l,u,s.shape,s.dtype,c,o.shape),f=h.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,s.dtype,d);return f.concat([g])}const Q5e={kernelName:z2,backendName:"cpu",kernelFunc:J5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5e(n){const{inputs:e,backend:t}=n,{starts:i,limits:r,deltas:s}=e,o=t.data.get(i.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,[u,c]=_re(o,i.shape,i.dtype,a,r.shape,l,s.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],i.dtype,c);return[h,d]}const eKe={kernelName:G2,backendName:"cpu",kernelFunc:q5e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tKe(n){const{inputs:e,backend:t,attrs:i}=n,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=i,u=t.data.get(r.dataId).values,c=t.data.get(s.dataId).values,h=t.data.get(o.dataId).values,d=a.map(y=>t.data.get(y.dataId).values),p=a.map(y=>y.shape),[f,g]=Mre(u,r.shape,c,s.shape,s.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(f,s.dtype,g)}const nKe={kernelName:V2,backendName:"cpu",kernelFunc:tKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iKe(n){const{backend:e,attrs:t}=n,{start:i,stop:r,dtype:s,step:o}=t,a=Are(i,r,o,s);return e.makeTensorInfo([a.length],s,a)}const rKe={kernelName:U2,backendName:"cpu",kernelFunc:iKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sKe=Bn(O0,n=>1/n),oKe={kernelName:O0,backendName:"cpu",kernelFunc:sKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aKe(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i;Tt(r,"resizeBilinear");const l=kt(r.shape),[u,c]=a,[h,d,p,f]=r.shape,g=t.data.get(r.dataId).values,y=new Float32Array(ke([h,u,c,f])),m=[s&&u>1?d-1:d,s&&c>1?p-1:p],v=[s&&u>1?u-1:u,s&&c>1?c-1:c];let w=0;const S=m[0]/v[0],C=m[1]/v[1];for(let _=0;_<h;_++)for(let A=0;A<u;A++){let I;o?I=S*(A+.5)-.5:I=S*A;const E=Math.max(0,Math.floor(I)),k=I-E,P=Math.min(d-1,Math.ceil(I)),V=_*l[0]+E*l[1],U=_*l[0]+P*l[1];for(let F=0;F<c;F++){let $;o?$=C*(F+.5)-.5:$=C*F;const J=Math.max(0,Math.floor($)),q=$-J,O=Math.min(p-1,Math.ceil($)),X=V+J*l[2],j=U+J*l[2],z=V+O*l[2],Z=U+O*l[2];for(let ce=0;ce<f;ce++){const fe=g[X+ce],ge=g[j+ce],Ne=g[z+ce],Fe=g[Z+ce],We=fe+(Ne-fe)*q,Ue=ge+(Fe-ge)*q,Ye=We+(Ue-We)*k;y[w++]=Ye}}}return t.makeTensorInfo([h,u,c,f],"float32",y)}const lKe={kernelName:Ww,backendName:"cpu",kernelFunc:aKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uKe(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i;Tt([s,r],"resizeBilinearGrad");const a=kt(r.shape),[l,u,c,h]=r.shape,[,d,p]=s.shape,f=new Float32Array(l*u*c*h),g=[o&&d>1?u-1:u,o&&p>1?c-1:c],y=[o&&d>1?d-1:d,o&&p>1?p-1:p],m=g[0]/y[0],v=g[1]/y[1],w=t.data.get(s.dataId).values;let S=0;for(let C=0;C<l;C++){const _=C*a[0];for(let A=0;A<d;A++){const I=A*m,E=Math.floor(I),k=Math.min(Math.ceil(I),u-1),P=_+E*a[1],V=_+k*a[1],U=I-E,F=1-U;for(let $=0;$<p;$++){const J=$*v,q=Math.floor(J),O=Math.min(Math.ceil(J),c-1),X=J-q,j=1-X,z=P+q*a[2],Z=P+O*a[2],ce=V+q*a[2],fe=V+O*a[2],ge=F*j,Ne=F*X,Fe=U*j,We=U*X;for(let Ue=0;Ue<h;Ue++){const Ye=w[S++];f[z+Ue]+=Ye*ge,f[Z+Ue]+=Ye*Ne,f[ce+Ue]+=Ye*Fe,f[fe+Ue]+=Ye*We}}}}return t.makeTensorInfo([l,c,u,h],"float32",f)}const cKe={kernelName:H2,backendName:"cpu",kernelFunc:uKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hKe(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i;Tt(r,"resizeNearestNeighbor");const l=kt(r.shape),[u,c]=a,[h,d,p,f]=r.shape,g=t.data.get(r.dataId).values,y=new Float32Array(h*u*c*f),m=[s&&u>1?d-1:d,s&&c>1?p-1:p],v=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=m[0]/v[0],S=m[1]/v[1];let C=0;for(let _=0;_<h;_++){const A=_*l[0];for(let I=0;I<u;I++){const E=o?w*(I+.5):w*I;let k=Math.min(d-1,s?Math.round(E):Math.floor(E));o&&(k=Math.max(0,k));const P=A+k*l[1];for(let V=0;V<c;V++){const U=o?S*(V+.5):S*V;let F=Math.min(p-1,s?Math.round(U):Math.floor(U));o&&(F=Math.max(0,F));const $=P+F*l[2];for(let J=0;J<f;J++){const q=g[$+J];y[C++]=q}}}}return t.makeTensorInfo([h,u,c,f],r.dtype,y)}const dKe={kernelName:$w,backendName:"cpu",kernelFunc:hKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pKe(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i;Tt([s,r],"resizeNearestNeighborGrad");const a=kt(r.shape),l=kt(s.shape),[u,c,h,d]=r.shape,[,p,f]=s.shape,g=new Float32Array(u*c*h*d),y=t.data.get(s.dataId).values,m=[o&&p>1?c-1:c,o&&f>1?h-1:h],v=[o&&p>1?p-1:p,o&&f>1?f-1:f],w=m[0]/v[0],S=m[1]/v[1],C=1/w,_=1/S,A=Math.ceil(C)*2+2,I=Math.ceil(_)*2+2;for(let E=0;E<u;E++){const k=E*a[0];for(let P=0;P<c;P++){const V=k+P*a[1],U=Math.floor(P*C),F=Math.floor(U-A/2);for(let $=0;$<h;$++){const J=V+$*a[2],q=Math.floor($*_),O=Math.floor(q-I/2);for(let X=0;X<d;X++){let j=0;for(let z=0;z<A;z++){const Z=z+F;if(Z<0||Z>=p)continue;const ce=k+Z*l[1],fe=Z*w,ge=Math.min(c-1,o?Math.round(fe):Math.floor(fe));if(P===ge)for(let Ne=0;Ne<I;Ne++){const Fe=Ne+O;if(Fe<0||Fe>=f)continue;const We=ce+Fe*l[2],Ue=Fe*S,Ye=Math.min(h-1,o?Math.round(Ue):Math.floor(Ue));$===Ye&&(j+=y[We+X])}}g[J+X]=j}}}}return t.makeTensorInfo(r.shape,r.dtype,g)}const fKe={kernelName:W2,backendName:"cpu",kernelFunc:pKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mKe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dims:s}=i;Tt(r,"reverse");const o=r.shape.length,a=un(s,r.shape);if(o===0)return Vu({inputs:{x:r},backend:t});const l=new mr(r.shape,r.dtype),u=t.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const gKe={kernelName:Hw,backendName:"cpu",kernelFunc:mKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yKe={kernelName:aI,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:i}=n,{radians:r,fillValue:s,center:o}=e,a=t,l=br(i.dtype,ke(i.shape)),[u,c,h,d]=i.shape,[p,f]=mV(o,c,h),g=255,y=Math.sin(r),m=Math.cos(r),v=a.data.get(i.dataId).values;for(let w=0;w<u;w++){const S=w*h*c*d;for(let C=0;C<c;C++){const _=C*(h*d);for(let A=0;A<h;A++){const I=A*d;for(let E=0;E<d;E++){const k=[u,C,A,E],P=k[2],V=k[1];let U=(P-p)*m-(V-f)*y,F=(P-p)*y+(V-f)*m;U=Math.round(U+p),F=Math.round(F+f);let $=s;if(typeof s!="number"&&(E===3?$=g:$=s[E]),U>=0&&U<h&&F>=0&&F<c){const q=F*(h*d),O=U*d,X=S+q+O+E;$=v[X]}const J=S+_+I+E;l[J]=$}}}}return{dataId:a.write(l,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bKe=Bn(G0,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),xKe={kernelName:G0,backendName:"cpu",kernelFunc:bKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vKe(n){const{inputs:e,backend:t,attrs:i}=n,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=cb(s,r,o),d=!0,p=t.bufferSync(r),f=t.bufferSync(s),g=Zg(p,f,o,h,u,l,a,c,0,d);return t.makeTensorInfo(o,g.dtype,g.values)}const wKe={kernelName:X2,backendName:"cpu",kernelFunc:vKe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SKe(n,e){let t=0,i=n.length,r=0;for(;t<i;)r=Math.floor((t+i)/2),n[r]<e?t=r+1:i=r;return i}function TKe(n,e){let t=0,i=n.length,r=0;for(;t<i;)r=Math.floor((t+i)/2),n[r]<=e?t=r+1:i=r;return i}function CKe(n,e,t,i,r,s){const o=Wi("int32",t*r);for(let a=0;a<t;++a){const l=n.slice(a*i,(a+1)*i),u=a*r;for(let c=0;c<r;++c)o[u+c]=s==="left"?SKe(l,e[c+u]):TKe(l,e[c+u])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ke(n){const{inputs:e,backend:t,attrs:i}=n,{sortedSequence:r,values:s}=e,{side:o}=i,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=CKe(a,l,r.shape[0],r.shape[1],s.shape[1],o);return t.makeTensorInfo(s.shape,"int32",u)}const MKe={kernelName:K2,backendName:"cpu",kernelFunc:_Ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AKe(n){const{inputs:e,backend:t}=n,{condition:i,t:r,e:s}=e;Tt([i,r,s],"select");const o=i.shape.length,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(s.dataId).values,c=qs(r.dtype,s.dtype),h=jr(ke(r.shape),c);let d=0;const p=o===0||o>1||r.shape.length===1?1:ke(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)a[f]===1?h[d++]=l[f]:h[d++]=u[f];return t.makeTensorInfo(r.shape,c,h)}const EKe={kernelName:Xw,backendName:"cpu",kernelFunc:AKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IKe=jI,kKe=YI,RKe=Bn(U0,n=>n>=0?kKe*n:IKe*(Math.exp(n)-1)),NKe={kernelName:U0,backendName:"cpu",kernelFunc:RKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LKe=Bn(H0,n=>n<0?-1:n>0?1:0),PKe={kernelName:H0,backendName:"cpu",kernelFunc:LKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DKe=Bn($0,n=>Math.sin(n)),FKe={kernelName:$0,backendName:"cpu",kernelFunc:DKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OKe=Bn(W0,n=>Math.sinh(n)),BKe={kernelName:W0,backendName:"cpu",kernelFunc:OKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zKe=11920928955078125e-23,zZ=Math.log(zKe)+2,GKe=Bn(K0,n=>{const e=n>-zZ,t=n<zZ,i=Math.exp(n);let r;return t?r=i:e?r=n:r=Math.log(1+i),r}),VKe={kernelName:K0,backendName:"cpu",kernelFunc:GKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UKe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,paddings:o}=i;Tt([r],"spaceToBatchND");const a=ke(s),l=[[0,0]];l.push(...o);for(let y=1+s.length;y<r.shape.length;++y)l.push([0,0]);const u=rse.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),c=wS(u.shape,s,a,!1),h=SS(c.length,s.length,!1),d=TS(u.shape,s,a,!1),p=jn({inputs:{x:u},backend:t,attrs:{shape:c}}),f=no({inputs:{x:p},backend:t,attrs:{perm:h}}),g=jn({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),g}const $Ke={kernelName:jw,backendName:"cpu",kernelFunc:UKe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WKe(n){const{inputs:e,backend:t}=n,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(s.dataId).values,c=t.data.get(o.dataId).values[0],[h,d,p,f,g]=Rre(a,i.shape,i.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,i.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],i.dtype,new Int32Array(g))]}const HKe={kernelName:Z2,backendName:"cpu",kernelFunc:WKe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XKe(n){const{inputs:e,backend:t}=n,{inputIndices:i,inputShape:r,newShape:s}=e;if(i.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(t.data.get(r.dataId).values),a=t.data.get(i.dataId).values,l=Array.from(t.data.get(s.dataId).values),[u,c,h]=Nre(a,i.shape,i.dtype,o,l);return[t.makeTensorInfo(c,i.dtype,u),t.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const KKe={kernelName:j2,backendName:"cpu",kernelFunc:XKe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZKe(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(i.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,[u,c]=l$(o,i.shape,i.dtype,a,l,!0);return t.makeTensorInfo(c,i.dtype,u)}const jKe={kernelName:Y2,backendName:"cpu",kernelFunc:ZKe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YKe(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(i.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,[u,c]=l$(o,i.shape,i.dtype,a,l);return t.makeTensorInfo(c,i.dtype,u)}const JKe={kernelName:J2,backendName:"cpu",kernelFunc:YKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QKe(n){const{inputs:e,backend:t,attrs:i}=n,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=cb(s,r,a),p=!1,f=t.bufferSync(r);let g;switch(s.dtype){case"bool":{const y=t.bufferSync(s),m=!!t.data.get(o.dataId).values[0];g=Zg(f,y,a,d,c,u,l,h,m,p);break}case"float32":{const y=t.bufferSync(s),m=t.data.get(o.dataId).values[0];g=Zg(f,y,a,d,c,u,l,h,m,p);break}case"int32":{const y=t.bufferSync(s),m=t.data.get(o.dataId).values[0];g=Zg(f,y,a,d,c,u,l,h,m,p);break}case"string":{const y=t.bufferSync(s),m=zc(t.data.get(o.dataId).values[0]);g=Zg(f,y,a,d,c,u,l,h,m,p);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(a,g.dtype,g.values)}const qKe={kernelName:Q2,backendName:"cpu",kernelFunc:QKe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=un(o,r.shape)[0],l=kV(r,s,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const d=[...c];d[a]=h;const p=Wf({inputs:{x:r},backend:t,attrs:{begin:u,size:d}});return u[a]+=h,p})}const tZe={kernelName:Yw,backendName:"cpu",kernelFunc:eZe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nZe={kernelName:q2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,i=e;Tt(t,"square");const r=i.data.get(t.dataId).values,s=new Float32Array(r.length);for(let o=0;o<r.length;++o){const a=r[o];s[o]=a*a}return{dataId:i.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZe=Bn(eb,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),rZe={kernelName:eb,backendName:"cpu",kernelFunc:iZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=i;Tt(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:m,begin:v,end:w,strides:S}=dV(r.shape,s,o,a,l,u,c,h,d);let C;if(g)C=jn({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||m){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=uV(v,w,S),A=Wf({inputs:{x:r},backend:t,attrs:{begin:v,size:_}});C=jn({inputs:{x:A},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(A)}else{const _=t.bufferSync(r),A=Pre(p,_,S,v);C=t.makeTensorInfo(f,A.dtype,A.values)}return C}const oZe={kernelName:eI,backendName:"cpu",kernelFunc:sZe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZe(n){const{inputs:e,backend:t,attrs:i}=n,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=i,{data:c,dataSplits:h}=e,d=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[f,g]=Dre(d,p,r,s,o,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const lZe={kernelName:tI,backendName:"cpu",kernelFunc:aZe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZe(n){const{inputs:e,backend:t,attrs:i}=n,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values[0],[u,c,h]=Fre(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const cZe={kernelName:nI,backendName:"cpu",kernelFunc:uZe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZe(n){const{inputs:e,backend:t,attrs:i}=n,{numBuckets:r}=i,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(s.dataId).values,a=Ore(o,r);return t.makeTensorInfo(s.shape,"int32",a)}const dZe={kernelName:iI,backendName:"cpu",kernelFunc:hZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZe=Bn(J0,n=>Math.tan(n)),fZe={kernelName:J0,backendName:"cpu",kernelFunc:pZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZe=Bn(Q0,n=>Math.tanh(n)),gZe={kernelName:Q0,backendName:"cpu",kernelFunc:mZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reps:s}=i;Tt(r,"tile");const o=zre(t.bufferSync(r),s);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const bZe={kernelName:q0,backendName:"cpu",kernelFunc:yZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{k:s,sorted:o}=i;Tt(r,"topk");const a=t.data.get(r.dataId).values,[l,u]=Vre(a,r.shape,r.dtype,s,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const vZe={kernelName:rI,backendName:"cpu",kernelFunc:xZe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZe(n){const{inputs:e,attrs:t,backend:i}=n,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=t,[c,h,d,p]=r.shape,[f,g]=u??[h,d],y=[c,f,g,p],m=kt(r.shape),v=m[0],w=m[1],S=m[2],C=kt(y),_=C[0],A=C[1],I=C[2],E=br(r.dtype,ke(y));E.fill(l);const k=i.data.get(r.dataId).values,P=i.data.get(s.dataId).values;for(let V=0;V<c;++V){const U=s.shape[0]===1?P:P.subarray(V*8,V*8+8);for(let F=0;F<f;++F)for(let $=0;$<g;++$)for(let J=0;J<p;++J){let q;const O=U[6]*$+U[7]*F+1;if(O===0)continue;const X=(U[0]*$+U[1]*F+U[2])/O,j=(U[3]*$+U[4]*F+U[5])/O,z=GZ(X,d,a),Z=GZ(j,h,a);switch(o){case"nearest":q=AZe(k,h,d,v,w,S,V,Z,z,J,l);break;case"bilinear":q=EZe(k,h,d,v,w,S,V,Z,z,J,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ce=V*_+F*A+$*I+J;E[ce]=q}return i.makeTensorInfo(y,r.dtype,E)}return{dataId:i.write(E,y,r.dtype),shape:r.shape,dtype:r.dtype}}const SZe={kernelName:sI,backendName:"cpu",kernelFunc:wZe};function GZ(n,e,t){switch(t){case"reflect":return TZe(n,e);case"wrap":return CZe(n,e);case"nearest":return MZe(n,e);case"constant":default:return _Ze(n)}}function TZe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const i=2*e;t<i&&(t=i*Math.trunc(-t/i)+t),t=t<-e?t+i:-t-1}else if(t>e-1)if(e<=1)t=0;else{const i=2*e;t-=i*Math.trunc(t/i),t>=e&&(t=i-t-1)}return bd(0,t,e-1)}function CZe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const i=e-1;t+=e*(Math.trunc(-t/i)+1)}else if(t>e-1)if(e<=1)t=0;else{const i=e-1;t-=e*Math.trunc(t/i)}return bd(0,t,e-1)}function _Ze(n,e){return n}function MZe(n,e){return bd(0,n,e-1)}function Gx(n,e,t,i,r,s,o,a,l,u,c){const h=o*i+a*r+l*s+u;return 0<=a&&a<e&&0<=l&&l<t?n[h]:c}function AZe(n,e,t,i,r,s,o,a,l,u,c){const h=Math.round(a),d=Math.round(l);return Gx(n,e,t,i,r,s,o,h,d,u,c)}function EZe(n,e,t,i,r,s,o,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1,g=(f-l)*Gx(n,e,t,i,r,s,o,h,d,u,c)+(l-d)*Gx(n,e,t,i,r,s,o,h,f,u,c),y=(f-l)*Gx(n,e,t,i,r,s,o,p,d,u,c)+(l-d)*Gx(n,e,t,i,r,s,o,p,f,u,c);return(p-a)*g+(a-h)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZe(n){const{inputs:e,attrs:t,backend:i}=n,{axis:r}=t,{x:s}=e;Tt(s,"unique");const o=i.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:u}=Ure(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([u.length],"int32",u)]}const kZe={kernelName:oI,backendName:"cpu",kernelFunc:IZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZe(n){const{inputs:e,backend:t,attrs:i}=n,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r.shape.length,a=r.shape[s],l=new Array(o-1);let u=0;for(let p=0;p<o;p++)p!==s&&(l[u++]=r.shape[p]);const c=new Array(o).fill(0),h=r.shape.slice();h[s]=1;const d=new Array(a);for(let p=0;p<d.length;p++){c[s]=p;const f=Wf({inputs:{x:r},backend:t,attrs:{begin:c,size:h}});d[p]=jn({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const NZe={kernelName:Qw,backendName:"cpu",kernelFunc:RZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,segmentIds:s}=e,{numSegments:o}=i;Tt(r,"unsortedSegmentSum");const a=r.shape.length,l=s.shape.length,u=[],c=[],h=a-l;let d=s;for(let f=0;f<h;++f){const g=yA({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=g,c.push(g)}for(let f=0;f<o;++f){const g=Yc(f,"int32"),y=t.makeTensorInfo([],"int32",g),m=sre({inputs:{a:y,b:d},backend:t}),v=_d({inputs:{x:m},backend:t,attrs:{dtype:"float32"}}),w=vk({inputs:{a:v,b:r},backend:t}),S=LS({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});u.push(S),c.push(y),c.push(m),c.push(v),c.push(w),c.push(S)}const p=ise({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const PZe={kernelName:qw,backendName:"cpu",kernelFunc:LZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZe=[kXe,gHe,NXe,PXe,SHe,FXe,BXe,GXe,UXe,WXe,XXe,ZXe,YXe,qXe,t4e,r4e,o4e,l4e,c4e,EXe,d4e,f4e,g4e,b4e,vHe,CHe,v4e,yHe,S4e,C4e,_4e,A4e,I4e,R4e,L4e,D4e,O4e,z4e,V4e,$4e,H4e,K4e,j4e,Y4e,Q4e,e9e,n9e,i9e,r9e,s9e,l9e,wXe,c9e,_He,b9e,MHe,x9e,EHe,_9e,M9e,E9e,kHe,R9e,L9e,D9e,O9e,z9e,NHe,PHe,bHe,V9e,T4e,$9e,H9e,K9e,SXe,FHe,BHe,j9e,GHe,J9e,e5e,n5e,s5e,a5e,u5e,c5e,UHe,d5e,f5e,g5e,b5e,v5e,S5e,C5e,WHe,M5e,I5e,N5e,XHe,ZHe,D5e,B5e,V5e,YHe,$5e,H5e,X5e,rse,Y5e,CXe,qHe,Q5e,eKe,nKe,rKe,xHe,_F,oKe,_Xe,MXe,AXe,lKe,cKe,dKe,fKe,gKe,yKe,xKe,aXe,wKe,MKe,EKe,NKe,uXe,PKe,FKe,BKe,cXe,k5e,VKe,$Ke,HKe,KKe,jKe,JKe,qKe,tZe,pXe,nZe,mXe,rZe,oZe,lZe,cZe,dZe,xXe,o9e,fZe,gZe,bZe,vZe,SZe,JHe,kZe,NZe,PZe,W5e];for(const n of DZe)so(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pp={},r_={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function FZe(n,e){Pp[n]=e}function Hl(n,e){if(!(n in Pp)||e!=null){const i=BZe(n,e);if(i!==null)Pp[n]=i;else return console.log("Could not get context for WebGL version",n),null}const t=Pp[n];return t==null||t.isContextLost()?(delete Pp[n],Hl(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Pp[n])}function OZe(n){if(typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function BZe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??OZe(n);return t.addEventListener("webglcontextlost",i=>{i.preventDefault(),delete Pp[n]},!1),ve().getBool("SOFTWARE_WEBGL_ENABLED")&&(r_.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",r_)||t.getContext("experimental-webgl",r_):t.getContext("webgl2",r_)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var x1;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(x1||(x1={}));var qo;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(qo||(qo={}));var Wr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Wr||(Wr={}));function PS(n,e){return[e,n]}function zZe(n,e){return n*e}function s_(n){const e=ke(n),t=Math.ceil(e/4);return KM(t)}function xb(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function GZe(n,e){const[t,i]=xb(n,e);return t*i*4}function p$(n,e){const t=n;let i,r,s,o,a,l,u,c,h,d;return ve().getNumber("WEBGL_VERSION")===2?(i=t.R32F,r=t.R16F,s=t.RGBA16F,o=t.RGBA32F,a=t.RED,u=4,c=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(i=n.RGBA,r=n.RGBA,s=n.RGBA,o=t.RGBA,a=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:i,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gt(n,e){const t=e();return ve().getBool("DEBUG")&&VZe(n),t}function VZe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+HZe(n,e))}const UZe=596e-10,$Ze=65504;function WZe(n){return!!(ve().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||UZe<Math.abs(n)&&Math.abs(n)<$Ze)}function HZe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function o_(n,e){return ih(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function XZe(n,e){const t=ih(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(gt(n,()=>n.shaderSource(t,e)),gt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function KZe(n,e){const t=ih(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(gt(n,()=>n.shaderSource(t,e)),gt(n,()=>n.compileShader(t)),ve().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw sse(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const ZZe=/ERROR: [0-9]+:([0-9]+):/g;function sse(n,e){const t=ZZe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const i=+t[1],r=n.split(`
`),s=r.length.toString().length+2,o=r.map((h,d)=>af((d+1).toString(),s)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,i-1),u=o.slice(i-1,i),c=o.slice(i);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${af(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function jZe(n){return ih(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function YZe(n,e){if(gt(n,()=>n.linkProgram(e)),!ve().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function ZL(n,e){if(gt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function JZe(n,e){const t=ih(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return gt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),gt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function QZe(n,e){const t=ih(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return gt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),gt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function qZe(n){return ih(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function eje(n,e){const t=ve().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const i=`[${n}x${e}]`;throw new Error("Requested texture size "+i+" is invalid.")}if(n>t||e>t){const i=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+i+" greater than WebGL maximum on this browser / GPU "+r+".")}}function tje(n){return ih(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function VZ(n,e,t,i,r,s,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(gt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,i)),gt(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,s,o)),gt(n,()=>n.enableVertexAttribArray(a)),!0)}function nje(n,e,t){aje(n,t),gt(n,()=>n.activeTexture(n.TEXTURE0+t)),gt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function ije(n,e,t){return ih(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function rje(n,e,t){return n.getUniformLocation(e,t)}function sje(n,e,t,i){gt(n,()=>nje(n,e,i)),gt(n,()=>n.uniform1i(t,i))}function jL(n,e,t){gt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),gt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function UZ(n,e){gt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),gt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function a_(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+oje(n,e))}function oje(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ih(n,e,t){const i=gt(n,()=>e());if(i==null)throw new Error(t);return i}function aje(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,i=e+n.TEXTURE0;if(i<n.TEXTURE0||i>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Hy(n,e=2){return ke(n.slice(0,n.length-e))}function Xy(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function l_(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Hy(n),...Xy(n)]),e}function lje(n,e=!1){let t=ve().getNumber("WEBGL_MAX_TEXTURE_SIZE"),i=ve().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");i===1/0&&ve().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(i=t/2),e&&(t=t*2,i=i*2,n=n.map((a,l)=>l>=n.length-2?i2(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=jc(n).newShape);let r=ke(n),s=null;n.length<=1&&r<=t?s=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?s=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(s=[n[0],n[1]*n[2]*n[3]]);const o=s!=null&&Math.max(...s)>i&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||o)if(e){const a=Hy(n);let l=2,u=2;n.length&&([l,u]=Xy(n)),r=a*(l/2)*(u/2),s=KM(r).map(c=>c*2)}else s=KM(r);return s}function u_(n){return n%2===0}function xA(n,e){if(n=n.slice(-2),e=e.slice(-2),bn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],i=e.slice(-1)[0];if(t===i||u_(t)&&u_(i)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&u_(n[0])&&u_(e[0])}let YL,JL;function uje(n){if(YL==null){const e=Hl(n);YL=e.getParameter(e.MAX_TEXTURE_SIZE)}return YL}function cje(n){if(JL==null){const e=Hl(n);JL=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,JL)}function hje(n){if(n===0)return 0;let e;const t=Hl(n);return Za(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Za(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Za(n,e){return n.getExtension(e)!=null}function $Z(n){try{if(Hl(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function dje(n){if(n===0)return!1;const e=Hl(n);if(n===1){if(!Za(e,"OES_texture_float"))return!1}else if(!Za(e,"EXT_color_buffer_float"))return!1;return AF(e)}function pje(n){if(n===0)return!1;const e=Hl(n);if(n===1){if(!Za(e,"OES_texture_float")||!Za(e,"WEBGL_color_buffer_float"))return!1}else{if(Za(e,"EXT_color_buffer_float"))return AF(e);const t="EXT_color_buffer_half_float";if(Za(e,t)){const i=e.getExtension(t);return fje(e,i)}return!1}return AF(e)}function AF(n){const e=p$(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const i=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,i,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),o}function fje(n,e){const t=p$(n,e),i=n.createTexture();n.bindTexture(n.TEXTURE_2D,i);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(i),n.deleteFramebuffer(o),a}function mje(n){return n!==2?!1:Hl(n).fenceSync!=null}function DS(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&B(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Et=ve();Et.registerFlag("HAS_WEBGL",()=>Et.getNumber("WEBGL_VERSION")>0);Et.registerFlag("WEBGL_VERSION",()=>$Z(2)?2:$Z(1)?1:0);Et.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Et.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Et.get("WEBGL_VERSION")===2);Et.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Et.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Et.registerFlag("WEBGL_PACK",()=>Et.getBool("HAS_WEBGL"));Et.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_CLIP",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_PACK_REDUCE",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_LAZILY_UNPACK",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_CONV_IM2COL",()=>Et.getBool("WEBGL_PACK"));Et.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>uje(Et.getNumber("WEBGL_VERSION")));Et.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>cje(Et.getNumber("WEBGL_VERSION")));Et.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Et.getNumber("WEBGL_VERSION");return n===0?0:hje(n)});Et.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Et.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Gz());Et.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>dje(Et.getNumber("WEBGL_VERSION")));Et.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Et.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Et.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Et.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>pje(Et.getNumber("WEBGL_VERSION")));Et.registerFlag("WEBGL_FENCE_API_ENABLED",()=>mje(Et.getNumber("WEBGL_VERSION")));Et.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Et.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Et.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Et.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Gz()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Et.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Et.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Et.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Et.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Et.registerFlag("WEBGL_EXP_CONV",()=>!1);Et.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Et.getBool("IS_TEST"));Et.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Et.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Et.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Et.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(){let n,e,t,i,r,s,o,a,l,u;return ve().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",i="in",r="texture",s="outputColor",o="out vec4 outputColor;",a=ve().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",i="varying",r="texture2D",s="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:i,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Am(n,e,t="index"){const i=kt(e);return i.map((r,s)=>{const o=`int ${n[s]} = ${t} / ${r}`,a=s===i.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${r}`:`index -= ${n[s]} * ${r}`;return`${o}; ${a};`}).join("")}function wk(n,e,t="index"){const i=kt(e);return i.map((r,s)=>{const o=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,a=s===i.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${o}; ${a};`}).join("")}function gje(n,e){const t=n.length,i=n.map(s=>`${e}[${s}]`),r=new Array(t-1);r[t-2]=i[t-1];for(let s=t-3;s>=0;--s)r[s]=`(${r[s+1]} * ${i[s+1]})`;return r}function yje(n,e,t="index"){const i=n.map((s,o)=>o),r=gje(i,e);return r.map((s,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function f$(n){const e=kt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function m$(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const ose=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:ase}=Fne;function bje(n,e,t){const i=[];if(n.forEach(d=>{const p=ke(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?i.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(i.push(`uniform sampler2D ${d.name};`),i.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:f}=g$(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:i.push(`uniform int ${d.name}Shape;`);break;case 2:i.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:i.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:i.push(`uniform ivec4 ${d.name}Shape;`);break}i.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:i.push("uniform int outShape;");break;case 2:i.push("uniform ivec2 outShape;"),i.push("uniform int outShapeStrides;");break;case 3:i.push("uniform ivec3 outShape;"),i.push("uniform ivec2 outShapeStrides;");break;case 4:i.push("uniform ivec4 outShape;"),i.push("uniform ivec3 outShapeStrides;");break}i.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{i.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const r=i.join(`
`),s=n.map(d=>xje(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Os(),l=Sje(a);let u,c,h=_je(a);return e.isPacked?(u=vje(e.logicalShape,o,t.enableShapeUniforms),c=Cje(a)):(u=wje(e.logicalShape,o,t.enableShapeUniforms),c=Tje(a)),t.packedInputs&&(h+=Ije),[h,l,c,r,u,s,t.userCode].join(`
`)}function vb(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Vje(n,e);case 1:return $je(n,e);case 2:return Hje(n,e);case 3:return Kje(n,e);case 4:return jje(n,e);case 5:return Yje(n);case 6:return Jje(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function lse(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Gje(n);case 1:return Uje(n,e);case 2:return Wje(n,e);case 3:return Xje(n,e);default:return Zje(n,e)}}function xje(n,e,t=!1,i){let r="";t?r+=lse(n,i):r+=vb(n,i);const s=n.shapeInfo.logicalShape,o=e.logicalShape;return s.length<=o.length&&(t?r+=Qje(n,e):r+=qje(n,e)),r}function vje(n,e,t){switch(n.length){case 0:return use();case 1:return kje(n,e,t);case 2:return Bje(n,e,t);case 3:return Nje(n,e,t);default:return Pje(n,e,t)}}function wje(n,e,t){switch(n.length){case 0:return use();case 1:return Rje(n,e,t);case 2:return zje(n,e,t);case 3:return Lje(n,e,t);case 4:return Dje(n,e,t);case 5:return Fje(n,e);case 6:return Oje(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Sje(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Tje(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Cje(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function _je(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Mje}
    ${Aje}
    ${Eje}
  `}const Mje=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Aje=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Eje=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ije=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function use(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function kje(n,e,t){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return i[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${i[1]}.0);
      }
    `:i[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${i[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);
    }
  `}function Rje(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Nje(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),s=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Lje(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${wk(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const i=Am(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec3(r, c, d);
    }
  `}function Pje(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),s=r*Math.ceil(n[n.length-2]/2);let o=s,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)o*=n[n.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function Dje(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${wk(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const i=Am(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec4(r, c, d, d2);
    }
  `}function Fje(n,e){const t=Am(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Oje(n,e){const t=Am(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Bje(n,e,t){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(bn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));

      int index = resTexRC.x * ${i[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function zje(n,e,t){return bn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Em(n){return`offset${n}`}function Gje(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),i=Os();return`
    vec4 ${t}() {
      return ${i.texture2D}(${e}, halfCR);
    }
  `}function Vje(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${i}() {return ${t};}`;const[r,s]=n.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${i}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Em(t);if(e)return`
    float ${i}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${i}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function Uje(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,s=Os();if(e)return`
    vec4 ${i}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${i}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function $je(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${i}(int index) {
        ${wb(n)}
      }
    `;const r=n.shapeInfo.texShape,s=r[0],o=r[1];if(o===1&&s===1)return`
      float ${i}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Em(t);return o===1?e?`
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Wje(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=s[0],a=s[1],l=Os();if(s!=null&&bn(t,s))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);

        return ${l.texture2D}(${i}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${i}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${i}, uv);
    }
  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${i}, uv);
    }
  `}function Hje(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape;if(s!=null&&bn(t,s)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `;const d=s[0],p=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${i}, uv);
    }
  `}const{newShape:o,keptDims:a}=jc(t),l=o;if(l.length<t.length){const d=Sb(n,l),p=["row","col"];return`
      ${vb(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${Tb(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${wb(n)}
      }
    `;const u=s[0],c=s[1],h=Em(i);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${i}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${i}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
        return sampleTexture(${i}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${i}, uv);
  }
`}function Xje(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Sb(n,d),g=["b","row","col"];return`
        ${lse(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Tb(g,p)});
        }
      `}const a=Os();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${i}, uv);
    }
  `;const l=o[0],u=o[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${i}, uv);
    }
  `}function Kje(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=jc(t),u=a;if(u.length<t.length){const g=Sb(n,u),y=["row","col","depth"];return`
        ${vb(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Tb(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${wb(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],d=c[1],p=n.shapeInfo.flatOffset;if(d===s&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${i}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${i}, uv);
        }
      `;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${i}, uv);
    }
  `;const f=Em(i);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${i}Shape[1] * ${i}Shape[2];
      int stride1 = ${i}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
      return sampleTexture(${i}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${i}, uv);
      }
  `}function Zje(n,e){const t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Os();if(e)return`
    vec4 ${i}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const s=n.shapeInfo.logicalShape,o=s.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<o-1;g++)p=`int b${g}, `+p,d*=s[o-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${i}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function jje(n,e){const t=n.shapeInfo.logicalShape,i=n.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t[3],o=t[2]*s,a=t[1]*o,{newShape:l,keptDims:u}=jc(t);if(l.length<t.length){const v=Sb(n,l),w=["row","col","depth","depth2"];return`
      ${vb(v,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Tb(w,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${s}, 1)));
        ${wb(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${i}Shape[3];`,g=`int stride1 = ${i}Shape[2] * stride2;`,y=`int stride0 = ${i}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(p===s&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${i}, uv);
      }
    `;const m=Em(i);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${m});
      return sampleTexture(${i}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${m});
      return sampleTexture(${i}, uv);
    }
  `}function Yje(n){const e=n.shapeInfo.logicalShape,t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],s=e[3]*r,o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:u}=jc(e);if(l.length<e.length){const g=Sb(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${vb(g)}
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        return ${i}(${Tb(y,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${s}, ${r})) +
          depth3;
        ${wb(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&c==null)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Em(t);return`
    float ${i}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${s} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Jje(n){const e=n.shapeInfo.logicalShape,t=n.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:s}=jc(e);if(r.length<e.length){const y=Sb(n,r),m=["row","col","depth","depth2","depth3","depth4"];return`
      ${vb(y)}
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${i}(${Tb(m,s)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${wb(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&h==null)return`
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&h==null)return`
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Em(t);return`
    float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function wb(n){const e=n.name,t=ke(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Qje(n,e){const t=n.name,i=t.charAt(0).toUpperCase()+t.slice(1),r="get"+i+"AtOutCoords",s=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=ase(n.shapeInfo.logicalShape,e.logicalShape),l=Yn(o),u=o-s;let c;const h=["x","y","z","w","u","v"];s===0?c="":o<2&&a.length>=1?c="coords = 0;":c=a.map(y=>`coords.${h[y+u]} = 0;`).join(`
`);let d="";o<2&&s>0?d="coords":d=n.shapeInfo.logicalShape.map((y,m)=>`coords.${h[m+u]}`).join(", ");let p="return outputValue;";const f=ke(n.shapeInfo.logicalShape)===1,g=ke(e.logicalShape)===1;if(s===1&&!f&&!g)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!g)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const y=s-2,m=s-1;a.indexOf(y)>-1&&a.indexOf(m)>-1?p="return vec4(outputValue.x);":a.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(m)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${i}(${d});
      ${p}
    }
  `}function qje(n,e){const t=n.name,i=t.charAt(0).toUpperCase()+t.slice(1),r="get"+i+"AtOutCoords",s=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&bn(o,s))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=Yn(l),c=ase(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(g=>`coords.${p[g+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${i}(${f});
    }
  `}function Yn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function g$(n,e,t){const{newShape:i,keptDims:r}=jc(e),s=e.length,o=n&&s===3&&e[0]===1,a=o?e.slice(1):i,l=!n&&s>1&&!bn(e,t)&&i.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function Sb(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Tb(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8e(n,e,t,i){const r=t.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),s=r.map(c=>c.shapeInfo),o={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},a=bje(r,o,e),l=KZe(n.gl,a),u=n.createProgram(l);return ve().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:o},cse(n,e,u))}function cse(n,e,t){const i={},r={},s={},o=[];let a,l,u,c=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ve().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(let p=0;p<e.variableNames.length;p++){const f=e.variableNames[p];i[f]=n.getUniformLocation(t,f,d),i[`offset${f}`]=n.getUniformLocation(t,`offset${f}`,d),e.enableShapeUniforms&&(r[`${f}Shape`]=n.getUniformLocation(t,`${f}Shape`,d),s[`${f}TexShape`]=n.getUniformLocation(t,`${f}TexShape`,d))}return e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",d),u=n.getUniformLocation(t,"outShapeStrides",d),l=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach((p,f)=>{o[f]=n.getUniformLocation(t,p.name,d)}),{uniformLocations:i,customUniformLocations:o,infLoc:c,nanLoc:h,inShapesLocations:r,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}}function WZ(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,i)=>{const r=t.logicalShape,s=e[i],o=s.shape;if(!bn(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!bn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function t8e(n,e,t,i,r){e.program.enableShapeUniforms||(WZ(e.inShapeInfos,t),WZ([e.outShapeInfo],[i]));const s=i.texData.texture,o=i.texData.texShape;i.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):n.setOutputMatrixTexture(s.texture,o[0],o[1]),n.setProgram(e.webGLProgram),ve().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((l,u)=>{const c=e.program.variableNames[u],h=e.uniformLocations[c],d=e.uniformLocations[`offset${c}`],p=e.inShapesLocations[`${c}Shape`],f=e.inTexShapesLocations[`${c}TexShape`];if(p){const{uniformShape:g}=g$(e.program.packedInputs,l.shape,l.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(p,new Int32Array(g));break;case 2:n.gl.uniform2iv(p,new Int32Array(g));break;case 3:n.gl.uniform3iv(p,new Int32Array(g));break;case 4:n.gl.uniform4iv(p,new Int32Array(g));break}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(ke(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let g=l.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(h,g)}return}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,u)}});const a=e.outShapeLocation;if(a)switch(i.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(i.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(i.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(i.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(i.shape));break}if(e.outShapeStridesLocation){const l=kt(i.shape);switch(i.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,i.texData.texShape[0],i.texData.texShape[1]),e.program.customUniforms&&r&&e.program.customUniforms.forEach((l,u)=>{const c=e.customUniformLocations[u],h=r[u];if(l.type==="float")n.gl.uniform1fv(c,h);else if(l.type==="vec2")n.gl.uniform2fv(c,h);else if(l.type==="vec3")n.gl.uniform3fv(c,h);else if(l.type==="vec4")n.gl.uniform4fv(c,h);else if(l.type==="int")n.gl.uniform1iv(c,h);else if(l.type==="ivec2")n.gl.uniform2iv(c,h);else if(l.type==="ivec3")n.gl.uniform3iv(c,h);else if(l.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),n.executeProgram()}function n8e(n,e,t){let i="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=g$(n.packedInputs,o.shape,l);let d="",p="",f="";if(c.length===1&&n.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${C[0]>1}_${C[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const C=kt(c);f=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}const g=o.shape.length,y=c.length===2&&bn(o.shape,l),m=ke(o.shape)===1,v=Bf(o.shape,t.shape),w=!n.packedInputs&&g===t.shape.length&&bn(l,t.texData.texShape),S=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;i+=`${g}_${w}_${u?h:""}_${c.length}_${m}_${v}_${y}_${d}_${p}_${f}_${S}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;i+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let s=n.constructor.name;return s+="_"+i+"_"+r+`${ve().getNumber("WEBGL_VERSION")}`,s}function Bs(n){return ve().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i8e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=x1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Os();this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wk(["r","c","d"],e):Am(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r8e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=x1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Os();this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wk(["r","c","d"],e):Am(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s8e{constructor(e){this.variableNames=["A"],this.outTexUsage=qo.DOWNLOAD;const t=Os();this.outputShape=e,this.userCode=`
      ${ose}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o8e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qo.DOWNLOAD;const t=Os();this.outputShape=e,this.userCode=`
      ${ose}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a8e={R:0,G:1,B:2,A:3};let HZ=class{constructor(e,t=!1,i="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Os();this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let o="";for(let a=0;a<i.length;a++){const l=i[a];o+=`
          if(offset == ${a}) {
            result = values[${a8e[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?m$():f$(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${i.length});

        flatIndex = idiv(flatIndex, ${i.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l8e{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Os();this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${i.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?m$():f$(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${i.output} = ${s};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u8e(n){const e=Os(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return XZe(n,t)}function c8e(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return JZe(n,e)}function h8e(n){const e=new Uint16Array([0,1,2,2,1,3]);return QZe(n,e)}function FS(n,e,t,i,r,s){eje(e,t);const o=qZe(n),a=n.TEXTURE_2D;return gt(n,()=>n.bindTexture(a,o)),gt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),gt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),gt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),gt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ve().getNumber("WEBGL_VERSION")===1?gt(n,()=>n.texImage2D(a,0,i,e,t,0,r,s,null)):gt(n,()=>n.texStorage2D(a,1,i,e,t)),gt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function hse(n){return n.internalFormatFloat}function d8e(n,e,t,i){const[r,s]=PS(e,t);return FS(n,r,s,hse(i),i.textureFormatFloat,n.FLOAT)}function dse(n){return n.internalFormatHalfFloat}function p8e(n,e,t,i){const[r,s]=PS(e,t);return FS(n,r,s,dse(i),i.textureFormatFloat,i.textureTypeHalfFloat)}function pse(n){return n.downloadTextureFormat}function f8e(n,e,t,i){const[r,s]=PS(e,t);return FS(n,r,s,pse(i),n.RGBA,n.UNSIGNED_BYTE)}function fse(n){return n.internalFormatPackedFloat}function m8e(n,e,t,i){const[r,s]=xb(e,t);return FS(n,r,s,fse(i),n.RGBA,n.FLOAT)}function mse(n){return n.internalFormatPackedHalfFloat}function g8e(n,e,t,i){const[r,s]=xb(e,t);return FS(n,r,s,mse(i),n.RGBA,i.textureTypeHalfFloat)}function y8e(n,e,t){return gt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),VZ(n,e,"clipSpacePos",t,3,20,0)&&VZ(n,e,"uv",t,2,20,12)}function b8e(n,e,t,i,r,s){gt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(t*i*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*i*4),a=n.FLOAT,l=s.internalFormatPackedFloat),o.set(r),ve().getNumber("WEBGL_VERSION")===2?gt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,i,n.RGBA,a,o)):gt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,i,0,n.RGBA,a,o)),gt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function x8e(n,e,t){gt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ve().getNumber("WEBGL_VERSION")===2?gt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):gt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ve().getNumber("WEBGL_VERSION")===2?gt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):gt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),gt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function v8e(n,e,t,i){const r=n.createBuffer();gt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const s=4*4*e*t;return gt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,s,n.STREAM_READ)),gt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),gt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function w8e(n,e,t){const i=n,r=new Float32Array(t);return i.bindBuffer(i.PIXEL_PACK_BUFFER,e),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,r),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),r}function S8e(n,e,t,i){const[r,s]=PS(e,t),o=4,a=new Uint8Array(zZe(e*t,o));return gt(n,()=>n.readPixels(0,0,r,s,i.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function T8e(n,e,t,i,r,s,o,a){const l=n,u=new Float32Array(GZe(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function C8e(n,e,t){const i=new Float32Array(e*t*4);return gt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,i)),i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QL{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ve().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,FZe(t,e)):this.gl=Hl(t),e=this.gl,ve().getNumber("WEBGL_VERSION")===2){const s=e;this.createVertexArray=()=>gt(s,()=>s.createVertexArray()),this.bindVertexArray=o=>gt(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>gt(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>gt(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){const s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>gt(e,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>gt(e,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>gt(e,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>gt(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let i="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ve().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=o_(this.gl,s),Za(this.gl,o))this.textureHalfFloatExtension=o_(this.gl,o);else if(ve().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(i),Za(this.gl,r))this.colorBufferHalfFloatExtension=o_(this.gl,r);else if(ve().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(i="EXT_color_buffer_float",Za(this.gl,i))this.colorBufferFloatExtension=this.gl.getExtension(i);else if(Za(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=c8e(this.gl),this.indexBuffer=h8e(this.gl),this.framebuffer=tje(this.gl),this.textureConfig=p$(this.gl,this.textureHalfFloatExtension)}get debug(){return ve().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;gt(e,()=>e.finish()),gt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),gt(e,()=>e.deleteFramebuffer(this.framebuffer)),gt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),gt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),gt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),d8e(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),p8e(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),f8e(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),x8e(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,i,r){this.throwIfDisposed(),b8e(this.gl,e,t,i,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),g8e(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),m8e(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(UZ(this.gl,this.framebuffer),this.outputTexture=null),gt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,i){return this.downloadMatrixDriver(e,()=>S8e(this.gl,t,i,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,i,r,s,o){return T8e(this.gl,e,t,i,r,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return w8e(this.gl,e,t)}createBufferFromTexture(e,t,i){this.bindTextureToFrameBuffer(e);const r=v8e(this.gl,t,i,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,i;if(ve().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),i=()=>{const o=r.clientWaitSync(s,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=s}else ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),i=()=>this.isQueryAvailable(t,ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):i=()=>!0;return{query:t,isFencePassed:i}}downloadMatrixFromPackedTexture(e,t,i){return this.downloadMatrixDriver(e,()=>C8e(this.gl,t,i))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=u8e(t));const i=jZe(t);gt(t,()=>t.attachShader(i,this.vertexShader)),gt(t,()=>t.attachShader(i,e)),YZe(t,i);let r;return r=Object.assign(i,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),gt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(y8e(t,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&ZL(t,r),this.setProgram(r),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(gt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&ZL(this.gl,this.program)),gt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,i=!0){return this.throwIfDisposed(),i?ije(this.gl,e,t):rje(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),gt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,i){this.throwIfDisposed(),this.throwIfNoProgram(),sje(this.gl,e,t,i)}setOutputMatrixTexture(e,t,i){this.setOutputMatrixTextureDriver(e,i,t)}setOutputPackedMatrixTexture(e,t,i){this.throwIfDisposed();const[r,s]=xb(t,i);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,i,r){this.setOutputMatrixWriteRegionDriver(i,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,i,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&ZL(this.gl,this.program),a_(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}gt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),gt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=o_(this.gl,ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.createQuery();return i.beginQuery(r.TIME_ELAPSED_EXT,s),s}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,i=this.getQueryTimerExtensionWebGL2();t.endQuery(i.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await j3(()=>this.disposed||this.isQueryAvailable(e,ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const i=this.gl;return i.getQueryParameter(e,i.QUERY_RESULT)/1e6}else{const i=this.getQueryTimerExtensionWebGL1();return i.getQueryObjectEXT(e,i.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const i=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=i.getQueryParameter(e,i.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const i=this.getQueryTimerExtensionWebGL1(),r=i.getQueryObjectEXT(e,i.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=_8e(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:i}=this.itemsToPoll[t];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let i;"setTimeoutCustom"in ve().platform&&(i=ve().platform.setTimeoutCustom.bind(ve().platform)),j3(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,i)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),jL(this.gl,e,this.framebuffer),this.debug&&a_(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(jL(this.gl,this.outputTexture,this.framebuffer),this.debug&&a_(this.gl)):UZ(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const i=t();return this.unbindTextureToFrameBuffer(),i}setOutputMatrixTextureDriver(e,t,i){this.throwIfDisposed();const r=this.gl;jL(r,e,this.framebuffer),this.debug&&a_(r),this.outputTexture=e,gt(r,()=>r.viewport(0,0,t,i)),gt(r,()=>r.scissor(0,0,t,i))}setOutputMatrixWriteRegionDriver(e,t,i,r){this.throwIfDisposed(),gt(this.gl,()=>this.gl.scissor(e,t,i,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function _8e(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:M8e,bincountImpl:gse,bincountReduceImpl:A8e,castImpl:E8e,ceilImpl:I8e,concatImpl:k8e,equalImpl:R8e,expImpl:N8e,expm1Impl:L8e,floorImpl:P8e,gatherNdImpl:D8e,gatherV2Impl:F8e,greaterImpl:O8e,greaterEqualImpl:B8e,lessImpl:z8e,lessEqualImpl:G8e,linSpaceImpl:V8e,logImpl:U8e,maxImpl:$8e,maximumImpl:W8e,minimumImpl:H8e,multiplyImpl:X8e,negImpl:K8e,notEqualImpl:Z8e,prodImpl:j8e,raggedGatherImpl:Y8e,raggedRangeImpl:J8e,raggedTensorToTensorImpl:Q8e,rangeImpl:q8e,rsqrtImpl:e6e,scatterImpl:t6e,sigmoidImpl:n6e,simpleAbsImpl:yse,sliceImpl:i6e,sparseFillEmptyRowsImpl:r6e,sparseReshapeImpl:s6e,sparseSegmentReductionImpl:bse,sqrtImpl:o6e,stridedSliceImpl:a6e,stringNGramsImpl:l6e,stringSplitImpl:u6e,stringToHashBucketFastImpl:c6e,subImpl:h6e,tileImpl:d6e,topKImpl:p6e,transposeImpl:y$,uniqueImpl:f6e}=vXe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xse(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function As(n,e){return e===1?[n]:xse(n,e)}function m6e(n,e){if(n===1)return"rc";let t="";for(let i=0;i<n;i++)t+=e[i],i<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g6e{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Bs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=As("rc",this.rank),i=Yn(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let i=0;i<=1;i++)for(let r=0;r<=1;r++){let s=`${i===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${e[e.length-1-o]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let i=this.rank-2;i<this.rank;i++)t+=`${e[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),i=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${i};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vse{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length);let i="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),i+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${y6e(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?m$():f$(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${i}

        setOutput(result);
      }
    `}}function y6e(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?yje(["r","c","d"],"inputShape"):Am(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b6e{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,i){const r=KZ(t,i),s=ZZ(e,r,i);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=XZ(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return r===Wr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Wr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Wr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Wr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Wr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,i,r){if(this.freeTextures==null)return;const s=KZ(i,r),o=ZZ(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=XZ(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ve().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function x6e(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F||e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function XZ(n,e,t,i,r){const s=v6e(e,i);let o;if(r){const[l,u]=xb(n[0],n[1]);o=l*u}else{const[l,u]=PS(n[0],n[1]);o=l*u}const a=x6e(t,s);return o*a}function v6e(n,e){switch(n){case Wr.PACKED_2X2_FLOAT32:return fse(e);case Wr.PACKED_2X2_FLOAT16:return mse(e);case Wr.UNPACKED_FLOAT32:return hse(e);case Wr.UNPACKED_FLOAT16:return dse(e);case Wr.PACKED_4X1_UNSIGNED_BYTE:return pse(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function w6e(n){return ve().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Wr.PACKED_2X2_FLOAT32:Wr.UNPACKED_FLOAT32:n?Wr.PACKED_2X2_FLOAT16:Wr.UNPACKED_FLOAT16}function KZ(n,e){if(n===qo.UPLOAD)return Wr.PACKED_2X2_FLOAT32;if(n===qo.RENDER||n==null)return w6e(e);if(n===qo.DOWNLOAD||n===qo.PIXELS)return Wr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function ZZ(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tu=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const ol="if (isnan(x)) return x;",S6e="return x;",jZ="return abs(x);",T6e="return (x >= 0.0) ? x : (exp(x) - 1.0);",C6e=ol+`
  return (x < 0.0) ? 0.0 : x;
`,_6e=ol+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Nh="return x;",M6e="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A6e="return x;",E6e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,I6e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,k6e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,R6e="return 1.0 / (1.0 + exp(-1.0 * x));";class $h{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N6e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length);const t=e.length,i=As("rc",t),r=Yn(t),s=m6e(t,i),o=i.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L6e=FI,P6e=1e-7,D6e=1e-4,qL={};function F6e(n){return n in qL||(qL[n]={}),qL[n]}const O6e=ve().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),B6e=600;function z6e(){return ve().global.screen==null?1024:ve().global.screen.height*ve().global.screen.width*window.devicePixelRatio*B6e/1024/1024}class Sk extends n2{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ve().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof QL)t=e;else{const i=Hl(ve().getNumber("WEBGL_VERSION"),e);t=new QL(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=Hl(ve().getNumber("WEBGL_VERSION"));t=new QL(i),this.binaryCache=F6e(ve().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new b6e(this.gpgpu),this.numMBBeforeWarning=z6e(),this.texData=new Rz(this,Wn())}nextDataId(){return Sk.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,i,r,s,o){const a=this.makeTensorInfo(t,i),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,s]},l.texShape=[r,s];const u=l_(t),c=new HZ(u,!1,o),h=this.runWebGLProgram(c,[a],i,[[r,s]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,i){if((ve().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ve().getBool("DEBUG"))&&this.checkNumericalProblems(e),i==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:i,values:e,usage:qo.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,i,r,s){if(ve().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:r,values:t,usage:qo.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:i,dtype:r,complexTensorInfos:s,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new $h(a,Nh):d=new Tu(a,Nh);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(i!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return i;const u=this.activeTimers!=null;let c;u&&(c=Ur());let h;if(r==="complex64"){const d=this.readSync(s.real.dataId),p=this.readSync(s.imag.dataId);h=Wc(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Ur()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:i,shape:r,slice:s,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(s!=null){let f;l?f=new $h(r,Nh):f=new Tu(r,Nh);const g=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(i!=null)return this.convertAndCacheOnCPU(e);if(ve().getBool("DEBUG")&&!ve().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ve().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(o!=="complex64"&&ve().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...s_(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],y=f[1];h=Wc(g,y)}else if(u==null)h=this.getValuesFromTexture(e);else{const f=ke(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;gt(f,()=>f.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Wn().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const i=this.texData.get(e),{values:r,shape:s,slice:o,dtype:a,isPacked:l,texture:u}=i;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new $h(s,Nh):p=new Tu(s,Nh);const f=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Wn().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const i=t.map(r=>zc(r));return nn(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return nn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const i=e[t];if(!WZe(i))throw ve().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:i,isPacked:r}=this.texData.get(e),s=ke(t);if(ve().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...s_(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),f}const o=ve().getBool("WEBGL_PACK")&&r===!0,a=o?l_(t):t,l=o?new o8e(a):new s8e(a),u=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,i=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=i,r=!0):this.activeTimers.push(i),this.activeTimers=i,e();const s=Bu(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Bu(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(s);a.kernelMs=Wee(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ur(),endMs:null}}endTimer(e){return ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ur(),e)}async getQueryTime(e){if(ve().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return i!=null&&(this.disposeData(i.real.dataId,t),this.disposeData(i.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:i,texShape:r,usage:s,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,i),this.textureManager.releaseTexture(t,r,s,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=O6e){return ve().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>this.texData.get(i.dataId).texture==null&&ke(i.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Yo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return L6e(e.shape,t)}packedUnaryOp(e,t,i){const r=new $h(e.shape,t),s=this.compileAndRun(r,[e],i);return Wn().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=yse(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ve().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,jZ,e.dtype);const t=new Tu(e.shape,jZ),i=this.compileAndRun(t,[e]);return Wn().makeTensorFromTensorInfo(i)}makeTensorInfo(e,t,i){let r;if(t==="string"&&i!=null&&i.length>0&&vu(i[0])){const s=i.map(o=>ku(o));r=this.write(s,e,t)}else r=this.write(i,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,i){return Wn().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,i),this)}unpackTensor(e){const t=new N6e(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new g6e(e.shape),i=!0;return this.runWebGLProgram(t,[e],e.dtype,null,i)}packedReshape(e,t){const i=[Hy(e.shape),...Xy(e.shape)],r={dtype:e.dtype,shape:i,dataId:e.dataId},s=[Hy(t),...Xy(t)],o=new vse(s,i),a=!0,l=[i],u=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const i=this.texData.get(e),{isPacked:r,shape:s,dtype:o}=i;if(t!=null){const d=ke(s),p=t[0]*t[1]*4;B(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=l_(s);let l;r?l=new r8e(a):l=new i8e(a);const u=!0,c=[t??s_(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,c,u,t);return{dtype:o,shape:s,dataId:h.dataId}}runWebGLProgram(e,t,i,r,s=!1,o){const a=this.makeTensorInfo(e.outputShape,i),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===x1.DENSE){const m=o??s_(e.outputShape);l.texShape=m.map(v=>v*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),ke(a.shape)===0)return l.values=br(a.dtype,0),a;const u=[],c=t.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(m.dataId);if(v.texture==null){if(!e.packedInputs&&ke(m.shape)<=ve().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=m.shape)}if(this.uploadToGPU(m.dataId),!!v.isPacked!=!!e.packedInputs)m=v.isPacked?this.unpackTensor(m):this.packTensor(m),u.push(m),v=this.texData.get(m.dataId);else if(v.isPacked&&!xA(v.shape,m.shape)){const w=m,S=m.shape;m.shape=v.shape,m=this.packedReshape(m,S),u.push(m),v=this.texData.get(m.dataId),w.shape=S}return{shape:m.shape,texData:v,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=n8e(e,c,h),p=this.getAndSaveBinary(d,()=>e8e(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),ve().get("ENGINE_COMPILE_ONLY")||t8e(this.gpgpu,p,c,h,r),u.forEach(m=>this.disposeIntermediateTensorInfo(m)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=ve().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const m=Ur();m-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!ve().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){const m=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),m}return a}compileAndRun(e,t,i,r,s=!1){return i=i||t[0].dtype,this.runWebGLProgram(e,t,i,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ve().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=me(()=>{if(!ve().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ve().getBool("DEBUG");ve().set("DEBUG",!1);const t=this.abs(Nt(1e-8)).dataSync()[0];if(ve().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?P6e:D6e}uploadToGPU(e){const t=this.texData.get(e),{shape:i,dtype:r,values:s,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Ur());let h=t.texShape;if(h==null&&(h=lje(i,l),t.texShape=h),s!=null){const d=l_(i);let p,f=h[1],g=h[0];const y=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!y)&&([f,g]=xb(h[0],h[1])),l?p=new l8e(d,y):p=new HZ(d,y);const m=y?[g,f]:h,v=this.makeTensorInfo(m,r),w=this.texData.get(v.dataId);y?w.usage=qo.PIXELS:w.usage=qo.UPLOAD,w.texShape=m,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),f,g,s);const S=[[g,f]],C=!0,_=this.runWebGLProgram(p,[v],r,S,C),A=this.texData.get(_.dataId);t.texShape=A.texShape,t.isPacked=A.isPacked,t.usage=A.usage,ve().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=A.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(v),u&&(this.uploadWaitMs+=Ur()-c)}else{const d=this.acquireTexture(h,a,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const i=this.texData.get(e),{dtype:r}=i;return t!=null&&(i.values=G6e(t,r)),i.values}acquireTexture(e,t,i,r){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*r1(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const i=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(s){throw s}});e.push(i)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await vS(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(sse(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:i,infLoc:r,nanLoc:s,inShapesLocations:o,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:u,outTexShapeLocation:c}=cse(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=i,e.infLoc=r,e.nanLoc=s,e.inShapesLocations=o,e.inTexShapesLocations=a,e.outShapeLocation=l,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromGPUData(e,t,i){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:o,channels:a}=e,l=Wn().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,i,s,o,a);return Wn().makeTensorFromDataId(u,t,i,l)}}Sk.nextDataId=0;function G6e(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let i=0;i<t.length;++i)t[i]=Math.round(n[i]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Vz()&&jz("webgl",()=>new Sk,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b$=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Ky{constructor(e,t,i){this.variableNames=["A","B"],this.outputShape=Yt(t,i),this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OS=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class BS{constructor(e,t,i,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Yt(t,i);const s=this.outputShape.length;this.enableShapeUniforms=Bs(s);let o="";if(r)if(s===0||ke(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Yn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const a=As("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${a[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${a[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${a[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${a[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Po(n){const{inputs:e,backend:t}=n,{x:i}=e;return t.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const V6e={kernelName:M0,backendName:"webgl",kernelFunc:Po};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wd(n){const{inputs:e,backend:t}=n,{real:i,imag:r}=e,s=t.makeTensorInfo(i.shape,"complex64"),o=t.texData.get(s.dataId),a=Po({inputs:{x:i},backend:t}),l=Po({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:l},s}const U6e={kernelName:h2,backendName:"webgl",kernelFunc:Wd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wse="return (a < 0.) ? b * a : a;",Sse=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $6e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{alpha:s}=i,o=t.makeTensorInfo([],"float32",Yc(s,"float32")),a=ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BS(Sse,r.shape,o.shape):new Ky(wse,r.shape,o.shape),l=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const W6e={kernelName:ww,backendName:"webgl",kernelFunc:$6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tse="return (a < 0.) ? b * a : a;",Cse=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function H6e(n){const{inputs:e,backend:t}=n,{x:i,alpha:r}=e,s=ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BS(Cse,i.shape,r.shape):new Ky(Tse,i.shape,r.shape);return t.runWebGLProgram(s,[i,r],"float32")}const X6e={kernelName:Gw,backendName:"webgl",kernelFunc:H6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cb="if (isnan(x)) return x;";function In({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:i}){return({inputs:r,backend:s})=>{const{x:o}=r,a=s,l=i||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const u=ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new $h(o.shape,e):c=new Tu(o.shape,n),a.runWebGLProgram(c,[o],l)}}function ns({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:i=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(i&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[y,m]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{const[S,C]=w,_={dataId:S.dataId,dtype:S.dtype,shape:l.shape},A={dataId:C.dataId,dtype:C.dtype,shape:u.shape},I=new Ky(n,l.shape,u.shape);return c.runWebGLProgram(I,[_,A],qs(S.dtype,C.dtype))}),v=Wd({inputs:{real:y,imag:m},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(m),v}const h=s||qs(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,y=l.dtype==="string"?Vf(f):f,m=l.dtype==="string"?Vf(g):g,[v,w]=r(l.shape,u.shape,y,m,h),S=c.makeTensorInfo(w,h),C=c.texData.get(S.dataId);return C.values=v,S}const d=ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new BS(e,l.shape,u.shape,t):p=new Ky(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function v1(n,e=!1){if(n==="linear")return e?A6e:S6e;if(n==="relu")return e?I6e:C6e;if(n==="elu")return e?E6e:T6e;if(n==="relu6")return e?k6e:_6e;if(n==="prelu")return e?Cse:Tse;if(n==="leakyrelu")return e?Sse:wse;if(n==="sigmoid")return e?R6e:M6e;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _se{constructor(e,t,i,r=!1,s=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i,this.enableShapeUniforms=Bs(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",m="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,m="result = activation(result);");const v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",S="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(S=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${S};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${m}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let JZ=class{constructor(e,t,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Yt(t,i),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZ="return a * b;";function x$(n){const{inputs:e,backend:t}=n,{a:i,b:r}=e,s=qs(i.dtype,r.dtype);if(i.dtype==="complex64"){const a=t.texData.get(i.dataId),l=t.texData.get(r.dataId),u=new JZ(YZ.REAL,i.shape,r.shape),c=new JZ(YZ.IMAG,i.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Wd({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([i,r])){const a=t.texData.get(i.dataId),l=t.texData.get(r.dataId),[u,c]=X8e(i.shape,r.shape,a.values,l.values,s),h=t.makeTensorInfo(c,s),d=t.texData.get(h.dataId);return d.values=u,h}let o;return ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new BS(QZ,i.shape,r.shape):o=new Ky(QZ,i.shape,r.shape),t.runWebGLProgram(o,[i,r],s)}const K6e={kernelName:D0,backendName:"webgl",kernelFunc:x$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6e(n,e,t){const i=[Hy(n.shape),...Xy(n.shape)],r={dtype:n.dtype,shape:i,dataId:n.dataId},s=[Hy(e),...Xy(e)],o=new vse(s,i),a=!0,l=[i],u=t.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{shape:s}=i,o=t,a=ke(r.shape),l=Lz(s,a),u=ke(l);B(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return c.isPacked&&!xA(r.shape,l)&&!(c.texture!==null&&xA(c.shape,l))?Z6e(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const j6e={kernelName:Uw,backendName:"webgl",kernelFunc:ft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qZ=class{constructor(e,t){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(i/4)*4,l=i%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Nf(h)?h.toPrecision(2):h}, ones);`}let c="";s%i>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y6e{constructor(e,t){this.variableNames=["x"];const{windowSize:i,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(i/4)*4,h=i%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";s%i>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6e(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],i=ZI(t);e.push({inSize:t,windowSize:i,outSize:Math.ceil(t/i)})}return e}function Im(n,e,t,i){const r=J6e(n.shape);let s=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:u}=r[o];let c,h;t==="mean"?c=o===0?new qZ({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new qZ({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new Y6e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},t),h=s,s=i.runWebGLProgram(c,[s],e),h.dataId!==n.dataId&&i.disposeIntermediateTensorInfo(h)}return s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q6e{constructor(e,t){this.variableNames=["A"];const i=new Array(e.length);for(let o=0;o<i.length;o++)i[o]=e[t[o]];this.outputShape=i,this.rank=i.length;const r=Yn(this.rank),s=q6e(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function q6e(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],i=new Array(e);for(let r=0;r<n.length;r++)i[n[r]]=t[r];return i.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eYe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const i=new Array(e.length);for(let c=0;c<i.length;c++)i[c]=e[t[c]];if(this.outputShape=i,this.rank=i.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Yn(this.rank),s=xse("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=s[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${i[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${i[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tk(n,e,t){const i=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eYe(n.shape,e):new Q6e(n.shape,e);return t.runWebGLProgram(i,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tYe(n,e,t,i){const r=e,s=n.shape.length,o=un(r,n.shape);let a=o;const l=Ti(a,s),u=l!=null;let c=n;u&&(c=Tk(n,l,i),a=Ki(a.length,s)),ts("sum",a,s);const[h,d]=kr(c.shape,a);let p=h;t&&(p=Xi(h,o));const f=ke(d),g=ke(n.shape)/f,y=ft({inputs:{x:c},attrs:{shape:[g,f]},backend:i}),m=lI(n.dtype),v=Im(y,m,"sum",i),w=ft({inputs:{x:v},attrs:{shape:p},backend:i});return i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(v),u&&i.disposeIntermediateTensorInfo(c),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i;return tYe(r,s,o,t)}const nYe={kernelName:Zw,backendName:"webgl",kernelFunc:Ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ps(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{perm:s}=i,o=t,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[s[c]];let u;if(o.shouldExecuteOnCPU([r])){const c=o.texData.get(r.dataId).values,h=y$(c,r.shape,r.dtype,s,l);u=o.makeTensorInfo(l,r.dtype);const d=o.texData.get(u.dataId);d.values=h}else u=Tk(r,s,o);return u}const iYe={kernelName:lf,backendName:"webgl",kernelFunc:Ps};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mse=1e3;function vA({a:n,b:e,transposeA:t,transposeB:i,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],d=i?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],f=i?e.shape[c-2]:e.shape[c-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),m=ke(g),v=ke(y),w=Yt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);B(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${i} must match.`);const S=t?[m,h,p]:[m,p,h],C=i?[v,f,d]:[v,d,f],_=ft({inputs:{x:n},backend:r,attrs:{shape:S}}),A=ft({inputs:{x:e},backend:r,attrs:{shape:C}}),I=[_,A],E=Math.max(m,v),k=t?_.shape[1]:_.shape[2],P=s!=null,V=o!=null,U=l==="leakyrelu",F=l!=null?v1(l,!0):null,$=P||V||U||F!=null;let J;if((p===1||f===1)&&k>Mse&&$===!1){let O=_,X=A;t&&(O=Ps({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),I.push(O)),i&&(X=Ps({inputs:{x:A},backend:r,attrs:{perm:[0,2,1]}}),I.push(X));const j=f!==1,z=f===1;let Z=O;j&&(Z=ft({inputs:{x:O},backend:r,attrs:{shape:[E,k,1]}}),I.push(Z));const ce=f===1?2:1;let fe=X;z&&(fe=ft({inputs:{x:X},backend:r,attrs:{shape:[E,1,k]}}),I.push(fe));const ge=x$({inputs:{a:Z,b:fe},backend:r});J=Ck({inputs:{x:ge},backend:r,attrs:{axis:ce,keepDims:!0}}),I.push(ge)}else{const O=qs(n.dtype,e.dtype),X=new _se(S,C,[E,p,f],t,i,P,F,V,U),j=[_,A];if(s!=null&&j.push(s),V&&j.push(o),U){const z=r.makeTensorInfo([],"float32",Yc(a,"float32"));j.push(z),I.push(z)}J=r.runWebGLProgram(X,j,O)}const q=ft({inputs:{x:J},backend:r,attrs:{shape:w}});I.push(J);for(const O of I)r.disposeIntermediateTensorInfo(O);return q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rYe(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=i;return vA({a:r,b:s,transposeA:l,transposeB:u,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const sYe={kernelName:s1,backendName:"webgl",kernelFunc:rYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ej="return abs(x);";function oYe(n){const{inputs:e,backend:t}=n,{x:i}=e;if(t.shouldExecuteOnCPU([i])&&i.dtype!=="complex64"){const s=t.texData.get(i.dataId),o=yse(s.values);return t.makeTensorInfo(i.shape,i.dtype,o)}let r;return ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new $h(i.shape,ej):r=new Tu(i.shape,ej),t.runWebGLProgram(r,[i],i.dtype)}const aYe={kernelName:ew,backendName:"webgl",kernelFunc:oYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lYe=ol+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,uYe=In({opSnippet:lYe}),cYe={kernelName:o0,backendName:"webgl",kernelFunc:uYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hYe=ol+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,dYe=In({opSnippet:hYe}),pYe={kernelName:a0,backendName:"webgl",kernelFunc:dYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tj="return a + b;",fYe=ns({opSnippet:tj,packedOpSnippet:tj,supportsComplex:!0,cpuKernelImpl:M8e}),mYe={kernelName:gm,backendName:"webgl",kernelFunc:fYe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gYe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`float v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${i.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yYe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const i=[];this.variableNames.forEach(s=>{i.push(`vec4 v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${i.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(n){const{inputs:e,backend:t}=n,i=e;if(i.length===1)return Po({inputs:{x:i[0]},backend:t});if(i.length>ve().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const a=Math.floor(i.length/2),l=Z_({inputs:i.slice(0,a),backend:t}),u=Z_({inputs:i.slice(a),backend:t});return Z_({inputs:[l,u],backend:t})}const r=i.map(a=>a.dtype).reduce((a,l)=>qs(a,l)),s=i.map(a=>a.shape),o=ve().getBool("WEBGL_PACK")?new yYe(i[0].shape,s):new gYe(i[0].shape,s);return t.runWebGLProgram(o,i,r)}const bYe={kernelName:tw,backendName:"webgl",kernelFunc:Z_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xYe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=un(s,r.shape);let u=l;const c=Ti(u,a);let h=r;c!=null&&(h=Ps({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Ki(u.length,a)),ts("all",u,a);const[d,p]=kr(h.shape,u),f=ke(p),g=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Im(g,g.dtype,"all",t);let m;if(o){const v=Xi(d,l);m=ft({inputs:{x:y},backend:t,attrs:{shape:v}})}else m=ft({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),m}const vYe={kernelName:s2,backendName:"webgl",kernelFunc:xYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wYe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=un(s,r.shape);let u=l;const c=Ti(u,a);let h=r;c!=null&&(h=Ps({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Ki(u.length,a)),ts("any",u,a);const[d,p]=kr(h.shape,u),f=ke(p),g=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Im(g,g.dtype,"any",t);let m;if(o){const v=Xi(d,l);m=ft({inputs:{x:y},backend:t,attrs:{shape:v}})}else m=ft({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),m}const SYe={kernelName:o2,backendName:"webgl",kernelFunc:wYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TYe{constructor(e,t,i){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=e;i||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const a=t==="max"?">":"<",l=i?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CYe{constructor(e,t,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,B(e.length>2,()=>`Packed arg${i.charAt(0).toUpperCase()+i.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],o=Math.ceil(s/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Yn(l),c=As("coords",l);let h,d;if(o===1){d=l+1;const I=Yn(d);h=`
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l-1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l-2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l-1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],g=p.map(I=>"int "+I),y=As("sourceLocR",d-1).concat("inIdx.r"),m=As("sourceLocG",d-1).concat("inIdx.g"),v=As("sourceLocB",d-1).concat("inIdx.b"),w=As("sourceLocA",d-1).concat("inIdx.a"),S=i==="max"?"greaterThan":"lessThan",C=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,_=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,A=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(n,e,t,i=null){let r=e.shape[0],s=e.shape[1];i!=null&&(r=i.shape[0],s=i.shape[1]);const o=ZI(s),a={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new TYe(a,t,i==null),u=[e];i!=null&&u.push(i);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=Ase(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function Ese(n,e,t,i=null){const r=i!=null?i.shape:e.shape,s=r[r.length-1],o=ZI(s),a=new CYe(r,o,t,i==null),l=i==null?[e]:[e,i],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=Ese(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function Ise(n,e,t,i){const r=[t];if(ts("arg"+i.charAt(0).toUpperCase()+i.slice(1),r,e.shape.length),!ve().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const s=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),s.push(l));const[u,c]=kr(l.shape,r),h=ke(c),d=ft({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});s.push(d);const p=Ase(n,d,i);s.push(p);const f=ft({inputs:{x:p},backend:n,attrs:{shape:u}});return s.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return Ese(n,e,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ye(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;let o=un(s,r.shape);const a=Ti(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Ps({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Ki(o.length,l.shape.length)),ts("argMax",[o[0]],l.shape.length);const c=Ise(t,l,o[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const MYe={kernelName:nw,backendName:"webgl",kernelFunc:_Ye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AYe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s}=i;let o=un(s,r.shape);const a=Ti(o,r.shape.length);let l=r;const u=[];a!=null&&(l=Ps({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Ki(o.length,l.shape.length)),ts("argMin",[o[0]],l.shape.length);const c=Ise(t,l,o[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const EYe={kernelName:iw,backendName:"webgl",kernelFunc:AYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IYe=ol+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,kYe=In({opSnippet:IYe}),RYe={kernelName:l0,backendName:"webgl",kernelFunc:kYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NYe=ol+"return log(x + sqrt(x * x + 1.0));",LYe=In({opSnippet:NYe}),PYe={kernelName:u0,backendName:"webgl",kernelFunc:LYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DYe=ol+`
  return atan(x);
`,FYe=In({opSnippet:DYe}),OYe={kernelName:c0,backendName:"webgl",kernelFunc:FYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BYe=b$+`
  return atan(a, b);
`,zYe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+OS+`
  return result;
`,GYe=ns({opSnippet:BYe,packedOpSnippet:zYe}),VYe={kernelName:d0,backendName:"webgl",kernelFunc:GYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UYe=ol+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,$Ye=In({opSnippet:UYe}),WYe={kernelName:h0,backendName:"webgl",kernelFunc:$Ye};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w1{constructor(e,t,i,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&i)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let v="0.0";if(g||(v="-1.0 / 1e-20"),i){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?y:m:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,_=o%4,A=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${C};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${S});
      }
    `}}let v$=class{constructor(e,t,i,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&i)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,m=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg";let S="0.0";if(w||(S="-1.0 / 1e-20"),i){const k=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${y}, ${m}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${k} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const A=Math.floor(o/4)*4,I=o%4,E=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${y}, ${m}, ${v});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${A};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${_});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HYe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;DS(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,u=1;B(es(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=rl(r.shape,s,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&bn(c.inShape,c.outShape))return Po({inputs:{x:r},backend:t});const h=new w1(c,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const XYe={kernelName:rw,backendName:"webgl",kernelFunc:HYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KYe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=i,c=[1,1,1],h=Jc(r.shape,s,o,c,a,l,u),d=new v$(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const ZYe={kernelName:sw,backendName:"webgl",kernelFunc:KYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jYe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(t*i);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class YYe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,i=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,g=d-1-e.padInfo.top,y=p-1-e.padInfo.left,m=1/(t*i*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float avgMultiplier = float(${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JYe(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=i,h=[1,1,1],d=Jc(o.shape,a,l,h,u,c),p=new YYe(d);return t.runWebGLProgram(p,[r],o.dtype)}const QYe={kernelName:l2,backendName:"webgl",kernelFunc:JYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qYe(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s;DS([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=i,c=rl(o.shape,a,l,1,u),h=new jYe(c);return t.runWebGLProgram(h,[r],o.dtype)}const eJe={kernelName:a2,backendName:"webgl",kernelFunc:qYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJe(n){const{inputs:e,backend:t,attrs:i}=n,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;return vA({a:r,b:s,transposeA:o,transposeB:a,backend:t})}const nJe={kernelName:ow,backendName:"webgl",kernelFunc:tJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iJe{constructor(e,t,i,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Yt(e,t),Yt(e,i);let a="0.0";r!=null&&(Yt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(Yt(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rJe{constructor(e,t,i,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Yt(e,t),Yt(e,i);let a="vec4(0.0)";r!=null&&(Yt(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(Yt(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJe=({inputs:n,backend:e,attrs:t})=>{const{x:i,mean:r,variance:s,offset:o,scale:a}=n;B(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),B(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),B(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[i,r,s];let c=null;o!=null&&(c=o.shape,u.push(o));let h=null;a!=null&&(h=a.shape,u.push(a));const d=ve().getBool("WEBGL_PACK_NORMALIZATION")?new rJe(i.shape,r.shape,s.shape,c,h,l):new iJe(i.shape,r.shape,s.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},oJe={kernelName:bw,backendName:"webgl",kernelFunc:sJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aJe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Yn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const i=lJe(this.rank);let r;const s=e.map((o,a)=>`sourceLoc.${EF[a]} = start[${a}] + coords.${EF[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${i}));
      }
    `}}const EF=["x","y","z","w","u","v"];function lJe(n){if(n===1)return"sourceLoc";if(n<=6)return EF.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uJe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Yn(this.rank),i=As("coords",this.rank),r=As("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,a=`
      result.x = ${o};
      if (++${i[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${i[this.rank-1]};
      if (++${i[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${i[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${i[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJe(n,e,t,i){const r=i.texData.get(n.dataId),s=i.makeTensorInfo(t,n.dtype),o=i.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=hV(e,kt(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=i.dataRefCount.get(o.slice.origDataId)||1;return i.dataRefCount.set(o.slice.origDataId,l+1),s}function _b(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,size:o}=i,[a,l]=KI(r,s,o);if(lV(r,a,l),ke(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=i6e(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:u}=t.texData.get(r.dataId),c=cV(r.shape,a,l);if(u||!c){const h=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uJe(l):new aJe(l),d=[a];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),cJe(r,a,l,t)}const hJe={kernelName:Kw,backendName:"webgl",kernelFunc:_b};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJe=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,crops:o}=i;B(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((v,w)=>v*w),l=wS(r.shape,s,a),u=SS(l.length,s.length),c=TS(r.shape,s,a),h=gV(o,s.length),d=yV(c,o,s.length),p=[],f=ft({inputs:{x:r},backend:t,attrs:{shape:l}}),g=Ps({inputs:{x:f},backend:t,attrs:{perm:u}}),y=ft({inputs:{x:g},backend:t,attrs:{shape:c}}),m=_b({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(y),p.forEach(v=>t.disposeIntermediateTensorInfo(v)),m},pJe={kernelName:aw,backendName:"webgl",kernelFunc:dJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o}=i,a=t.readSync(r.dataId),l=t.readSync(s.dataId),u=gse(a,l,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,u)}const mJe={kernelName:u2,backendName:"webgl",kernelFunc:fJe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJe(n){const{inputs:e,backend:t}=n,{s0:i,s1:r}=e,s=t.readSync(i.dataId),o=t.readSync(r.dataId),a=Yt(Array.from(s),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const yJe={kernelName:c2,backendName:"webgl",kernelFunc:gJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJe="return float(a != b);",kse=ns({opSnippet:bJe,cpuKernelImpl:Z8e,dtype:"bool"}),xJe={kernelName:Dw,backendName:"webgl",kernelFunc:kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.texData.get(i.dataId);return Po({inputs:{x:r.complexTensorInfos.real},backend:t})}const vJe={kernelName:$2,backendName:"webgl",kernelFunc:zS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wJe="return float(int(x));";function SJe(n,e){const t=new Tu(n.shape,wJe),i=e.runWebGLProgram(t,[n],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dtype:s}=i;if(s==="complex64"){if(r.dtype==="complex64")return Po({inputs:{x:r},backend:t});const o=tr(r.shape),a=IF({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Wd({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=zS({inputs:{input:r},backend:t}),a=IF({inputs:{x:o},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(o),a}if(!Pz(r.dtype,s)){const o=Po({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[a,l,u]=E8e(o,r.shape,r.dtype,s);return t.makeTensorInfo(a,l,u)}if(s==="int32")return SJe(r,t);if(s==="bool"){const o=t.makeTensorInfo([],"bool",br("bool",1)),a=kse({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),a}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}const TJe={kernelName:p0,backendName:"webgl",kernelFunc:IF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nj="return ceil(x);",CJe=In({opSnippet:nj,packedOpSnippet:nj,cpuKernelImpl:I8e}),_Je={kernelName:f0,backendName:"webgl",kernelFunc:CJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MJe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AJe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{clipValueMin:s,clipValueMax:o}=i;let a;ve().getBool("WEBGL_PACK_CLIP")?a=new AJe(r.shape):a=new MJe(r.shape);const l=[[s],[o]];return t.runWebGLProgram(a,[r],r.dtype,l)}const IJe={kernelName:m0,backendName:"webgl",kernelFunc:EJe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kJe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ij(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function RJe(n){const{inputs:e,backend:t}=n,{x:i}=e,r=t.texData.get(i.dataId),s=new kJe(i.shape),o=[ij(i,r.complexTensorInfos.real),ij(i,r.complexTensorInfos.imag)];return t.runWebGLProgram(s,o,o[0].dtype)}const NJe={kernelName:lw,backendName:"webgl",kernelFunc:RJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LJe{constructor(e){this.outputShape=[],this.outputShape=Nu(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const i=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];i.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,s=t[t.length-1];i.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${i.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PJe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Nu(e,t);const i=this.outputShape,r=i.length,s=Yn(r),o=As("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let g=1;g<l.length;g++)l[g]=l[g-1]+e[g][t];const u=a[t],c=a.slice(-2),h=a.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){const y=l[g-1];d+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${c_(a,u,y)}),
            vec2(${c_(c,u,y)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${c_(a,u,f)}),
          vec2(${c_(c,u,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${i[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${i[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${i[r-2]} &&
            ${o[r-1]} < ${i[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function c_(n,e,t){const i=n.indexOf(e);return n.map((r,s)=>s===i?`${r} - ${t}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _k(n){const{inputs:e,backend:t}=n,{input:i}=e,r=t.texData.get(i.dataId);return Po({inputs:{x:r.complexTensorInfos.imag},backend:t})}const DJe={kernelName:I2,backendName:"webgl",kernelFunc:_k};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(n,e,t){const i=n[0].dtype;if(i==="complex64"){const p=n.map(v=>zS({inputs:{input:v},backend:t})),f=n.map(v=>_k({inputs:{input:v},backend:t})),g=Vx(p,e,t),y=Vx(f,e,t),m=Wd({inputs:{real:g,imag:y},backend:t});return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),m}let r=t.shouldExecuteOnCPU(n);if(i==="string"&&(r=!0),r){const p=n.map(S=>{const C=[-1,ke(S.shape.slice(e))];return ft({inputs:{x:S},backend:t,attrs:{shape:C}})}),f=p.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=Nu(p.map(S=>S.shape),1),y=p[0].shape[0]===1,m=k8e(f,g,i,y),v=Nu(n.map(S=>S.shape),e),w=t.makeTensorInfo(v,i,m);return p.forEach(S=>t.disposeIntermediateTensorInfo(S)),w}const s=n.filter(p=>ke(p.shape)>0),o=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){const p=o?new Tu(n[0].shape,Nh):new $h(n[0].shape,Nh);return t.runWebGLProgram(p,n,i)}const a=ve().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const p=[];for(let g=0;g<s.length;g+=a){const y=s.slice(g,g+a);p.push(Vx(y,e,t))}const f=Vx(p,e,t);for(const g of p)t.disposeIntermediateTensorInfo(g);return f}if(o){const p=new PJe(s.map(f=>f.shape),e);return t.runWebGLProgram(p,s,i)}const{tensors2D:l,outShape:u}=FJe(s,e,t),c=new LJe(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,i);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=ft({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),d}function FJe(n,e,t){const i=Nu(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>ft({inputs:{x:r},attrs:{shape:[-1,ke(r.shape.slice(e))]},backend:t})),outShape:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rse(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i,s=un(r,e[0].shape)[0],o=e.map(u=>u.shape);pV(o,s);const a=Nu(e.map(u=>u.shape),s);if(ke(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>ke(u.shape)>0);return l.length===1?Po({inputs:{x:l[0]},backend:t}):Vx(l,s,t)}const OJe={kernelName:uw,backendName:"webgl",kernelFunc:Rse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nse{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",m=y?1:2,v=y?2:3,w=y?3:1;let S="",C="";i&&(r?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:S=`
          float activation(float x) {
            ${i}
          }
        `,C="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${m}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${C}
        setOutput(result);
      }
    `}}class BJe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,i=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${i}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lse{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)d+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)d+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const m=y*2;if(d+=`
           xC = xCCorner + ${m*l};
           `,a===1){if(m<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }
               `,l===1&&m>0?d+=`
                 xC${m} = vec4(xTexelC${m-2}.zw, xTexelC${m}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                   } else {
                     xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xC${m} = xTexelC${m};
                 `,m+1<c)){const v=o%2===0?i2(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                     xTexelC${m+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${m+1}.zw = vec2(0.0);
                     }
                     xTexelC${m+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${m+1} = vec4(previous.zw, xTexelC${m+1}.xy);
                     } else {
                      xC${m+1} = vec4(0.0, 0.0, xTexelC${m+1}.xy);
                     }
                     `:d+=`
                     xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.xy);
                     `):v===1?d+=`
                     xC${m+1} = xTexelC${m};
                     `:d+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                       xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${m+1}.zw = vec2(0.0);
                       }
                       xTexelC${m+1}Ready = 1;
                     }

                     xC${m+1} = xTexelC${m+1};
                     `}}else m<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.0);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
               `,m+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${m+1} = vec4(xTexelC${m+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(
                   xTexelC${m}.xy, xTexelC${m+1}.xy);
               `,m+1<c&&(d+=`
                   xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
                 `)));m<c&&(d+=`
             wTexel = getW(r, ${m}, d1, d2);
             dotProd += xC${m}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${m}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,m+1<c&&(d+=`
               wTexel = getW(r, ${m+1}, d1, d2);
               dotProd += xC${m+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${m+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";i&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${i}
         }`:s?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${i}
         }`:p=`vec4 activation(vec4 x) {
           ${i}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zJe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Bs(this.outputShape.length);const{dataFormat:i}=t,r=Os(),s=i==="channelsLast",o=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Pse({x:n,filter:e,convInfo:t,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,u=i.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,g=!1;let y;const m=[];if(s!=null){const v=wA(s.shape,p);v!=null&&(s=ft({inputs:{x:s},backend:i,attrs:{shape:v}}),m.push(s))}if(r!=null){const v=wA(r.shape,p);v!=null&&(r=ft({inputs:{x:r},backend:i,attrs:{shape:v}}),m.push(r))}if(!((h===1||d===1)&&c>Mse)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&bn(u.shape.slice(-3),l.slice(-3))){const v=l[0]*l[1]*(l[2]+1),w={dataId:n.dataId,shape:[1,v,t.inChannels],dtype:n.dtype},S=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,B(xA(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const C=ft({inputs:{x:e},backend:i,attrs:{shape:[1,t.inChannels,t.outChannels]}});m.push(C);const _=vA({a:w,b:C,backend:i,transposeA:f,transposeB:g,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),A=i.texData.get(_.dataId);B(A.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=S,A.shape=t.outShape,y=Po({inputs:{x:_},backend:i}),y.shape=t.outShape,m.push(_)}else{const v=t.outHeight*t.outWidth,w=ft({inputs:{x:n},backend:i,attrs:{shape:p?[t.batchSize,v,t.inChannels]:[t.batchSize,t.inChannels,v]}}),S=ft({inputs:{x:e},backend:i,attrs:{shape:[1,t.inChannels,t.outChannels]}}),C=vA({a:p?w:S,b:p?S:w,transposeA:!p,transposeB:g,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o});y=ft({inputs:{x:C},backend:i,attrs:{shape:t.outShape}}),m.push(w),m.push(S),m.push(C)}for(const v of m)i.disposeIntermediateTensorInfo(v);return y}function Dse({x:n,filter:e,convInfo:t,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",g=l*u*c,y=d*h,m=[t.batchSize,g,y],v=!0,w=!1,S=[];if(s!=null){const O=wA(s.shape,f);O!=null&&(s=ft({inputs:{x:s},backend:i,attrs:{shape:O}}),S.push(s))}if(r!=null){const O=wA(r.shape,f);O!=null&&(r=ft({inputs:{x:r},backend:i,attrs:{shape:O}}),S.push(r))}const C=ft({inputs:{x:e},backend:i,attrs:{shape:[1,g,ke(e.shape)/g]}});S.push(C);const _=new zJe(m,t),A=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],I=i.runWebGLProgram(_,[n],"float32",A),E=ft({inputs:{x:I},backend:i,attrs:{shape:m}});S.push(I),S.push(E);const k=r!=null,P=s!=null,V=a==="leakyrelu",U=a?v1(a,!0):null,F=new _se(f?E.shape:C.shape,f?C.shape:E.shape,f?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],v,w,k,U,P,V),$=f?[E,C]:[C,E];if(r&&$.push(r),P&&$.push(s),V){const O=i.makeTensorInfo([],"float32",Yc(o,"float32"));$.push(O),S.push(O)}const J=i.runWebGLProgram(F,$,"float32"),q=ft({inputs:{x:J},backend:i,attrs:{shape:t.outShape}});S.push(J);for(const O of S)i.disposeIntermediateTensorInfo(O);return q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=i,h=Qc(l),d=Ir(r.shape,s.shape,o,u,a,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=Pse({x:r,filter:s,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&ve().getBool("WEBGL_EXP_CONV")){const g=new Lse(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(g,[r,s],"float32",y)}else if(ve().getBool("WEBGL_CONV_IM2COL"))p=Dse({x:r,filter:s,convInfo:d,backend:t});else{const g=new Nse(d);p=t.runWebGLProgram(g,[r,s],"float32")}const f=ft({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const VJe={kernelName:cw,backendName:"webgl",kernelFunc:GJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UJe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,i=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${i} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $Je{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=i-1-e.padInfo.left,u=o?1:2,c=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${i} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WJe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${i} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class HJe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,i=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,u=i-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${i}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${i} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=i,h=Qc(l),d=Ir(r.shape,c,o,1,a,u,!1,h),p=new UJe(d);return t.runWebGLProgram(p,[r,s],"float32")}const KJe={kernelName:d2,backendName:"webgl",kernelFunc:XJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJe(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=i,h=Qc(u),d=Ir(o,s.shape,a,1,l,c,!1,h),p=new $Je(d);return t.runWebGLProgram(p,[r,s],"float32")}const jJe={kernelName:hw,backendName:"webgl",kernelFunc:ZJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,u=zd(r.shape,s.shape,o,l,a),c=new BJe(u);return t.runWebGLProgram(c,[r,s],"float32")}const JJe={kernelName:dw,backendName:"webgl",kernelFunc:YJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i,u=zd(r.shape,l,o,1,a),c=new WJe(u);return t.runWebGLProgram(c,[r,s],"float32")}const qJe={kernelName:p2,backendName:"webgl",kernelFunc:QJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i,u=zd(l,s.shape,a,1,o),c=new HJe(u);return t.runWebGLProgram(c,[r,s],"float32")}const t7e={kernelName:f2,backendName:"webgl",kernelFunc:e7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n7e=Cb+`
  return cos(x);
`,i7e=In({opSnippet:n7e}),r7e={kernelName:g0,backendName:"webgl",kernelFunc:i7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s7e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,o7e=In({opSnippet:s7e}),a7e={kernelName:y0,backendName:"webgl",kernelFunc:o7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l7e{constructor(e,t,i,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=e,[c]=t,[h,d]=i;this.outputShape=[c,h,d,u];const p=r==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${l-1}.0`],[y,m,v]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[w,S,C]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${S};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u7e=n=>{const{inputs:e,backend:t,attrs:i}=n,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=i,c=new l7e(r.shape,s.shape,a,l,u);return t.runWebGLProgram(c,[r,s,o],"float32")},c7e={kernelName:g2,backendName:"webgl",kernelFunc:u7e};var S1;(function(n){n.Prod="*",n.Sum="+"})(S1||(S1={}));let rj=class{constructor(e,t,i,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=this.op===S1.Prod?"1.0":"0.0",a=i?o:`getX(${sj(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";i?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Yn(s)} coords = getOutputCoords();
        int end = ${oj(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${oj(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${sj(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function sj(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function oj(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fse(n,e,t,i,r,s){const o=e.shape.length,a=Ti([i],o);let l=e;a!=null&&(l=Ps({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=Ki(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${i}`);const c=l.shape[u];let h=Po({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new rj(n,l.shape,!1,s),f=[[d]],g=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(g)}if(r){const d=new rj(n,l.shape,r,s),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Gd(a),p=Ps({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return Fse(S1.Prod,r,t,s,o,a)}const d7e={kernelName:m2,backendName:"webgl",kernelFunc:h7e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return Fse(S1.Sum,r,t,s,o,a)}const f7e={kernelName:pw,backendName:"webgl",kernelFunc:p7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(r.shape.length===1){const l=t.readSync(r.dataId),u=t.readSync(s.dataId),c=gse(l,u,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(s),c=A8e(l,u,o,a);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const g7e={kernelName:y2,backendName:"webgl",kernelFunc:m7e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y7e{constructor(e,t,i){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=i,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockSize:s,dataFormat:o}=i,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],u=o==="NHWC"?r.shape[2]:r.shape[3],c=o==="NHWC"?r.shape[3]:r.shape[1],h=l*s,d=u*s,p=c/(s*s),f=o==="NHWC"?[a,h,d,p]:[a,p,h,d],g=new y7e(f,s,o);return t.runWebGLProgram(g,[r],r.dtype)}const x7e={kernelName:b2,backendName:"webgl",kernelFunc:b7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ose{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";i&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:u=`
          float activation(float x) {
            ${i}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bse{constructor(e,t=!1,i=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<h;m++)p+=`
          vec4 xTexelC${m*2};
          int xTexelC${m*2}Ready;
          vec4 xTexelC${m*2+1};
          int xTexelC${m*2+1}Ready;
          vec4 xC${m};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let m=0;m<h;m++)p+=`
          xTexelC${m*2} = vec4(0.0);
          xTexelC${m*2}Ready = 0;
          xTexelC${m*2+1} = vec4(0.0);
          xTexelC${m*2+1}Ready = 0;
          xC${m} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let m=0;m<(d+1)/2;m++){const v=m*2;if(p+=`
          xC = xCCorner + ${v*u};
          `,l===1){if(v<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,u===1&&v>0?p+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<h)){const w=a%2===0?i2(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:p+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):w===1?p+=`
                    xC${v+1} = xTexelC${v};
                    `:p+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<h&&(p+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<h&&(p+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<h&&(p+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";i&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:f=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=i;let c=l;c==null&&(c=[1,1]),B(es(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=Ir(r.shape,s.shape,o,c,a,u,!0);let d;ve().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new Bse(h):d=new Ose(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,s],"float32",p)}const w7e={kernelName:fw,backendName:"webgl",kernelFunc:v7e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S7e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,i=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${i} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class T7e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,i=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,a=i-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${i} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=i,h=Ir(r.shape,c,o,a,l,u,!0),d=new S7e(h);return t.runWebGLProgram(d,[r,s],"float32")}const _7e={kernelName:x2,backendName:"webgl",kernelFunc:C7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7e(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=i,h=Ir(c,s.shape,o,a,l,u,!0),d=new T7e(h);return t.runWebGLProgram(d,[r,s],"float32")}const A7e={kernelName:v2,backendName:"webgl",kernelFunc:M7e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E7e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7e(n){const{inputs:e,backend:t}=n,{x:i}=e,r=[...i.shape,...i.shape],s=ke(i.shape),o=ft({inputs:{x:i},backend:t,attrs:{shape:[s]}}),a=new E7e(s),l=t.runWebGLProgram(a,[o],o.dtype),u=ft({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}const k7e={kernelName:w2,backendName:"webgl",kernelFunc:I7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R7e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:i,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${i}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7e(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,u=iS(r.shape,s.shape,o,a,"NHWC",l);let c;const h=new R7e(u);c=t.runWebGLProgram(h,[r,s],"float32");const d=ft({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const L7e={kernelName:mw,backendName:"webgl",kernelFunc:N7e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7e(n){const{inputs:e,backend:t,attrs:i}=n,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=_V(r,s.length);AV(o.length,l,s);const{path:u,steps:c}=EV(a,l),h=c.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const y of c[g]){const{permutationIndices:m,expandDims:v}=MV(p,l[y]);let w;IV(m)?w=s[y]:(w=Ps({inputs:{x:s[y]},backend:t,attrs:{perm:m}}),f.push(w));const S=w.shape.slice();for(let C=0;C<v.length;++C)S.splice(v[C],0,1);bn(w.shape,S)||(w=ft({inputs:{x:w},backend:t,attrs:{shape:S}}),f.push(w)),d===null?d=w:(d=x$({inputs:{a:w,b:d},backend:t}),f.push(d))}g<h-1&&(u[g]>=0&&(d=Ck({inputs:{x:d},backend:t,attrs:{axis:u[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const D7e={kernelName:S2,backendName:"webgl",kernelFunc:P7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F7e="return (x >= 0.0) ? x : (exp(x) - 1.0);",O7e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,B7e=In({opSnippet:F7e,packedOpSnippet:O7e}),z7e={kernelName:x0,backendName:"webgl",kernelFunc:B7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G7e="return (b >= 1.0) ? a : a * (b + 1.0);",V7e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,U7e=n=>{const{inputs:e,backend:t}=n,{dy:i,y:r}=e,s=ve().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BS(V7e,i.shape,r.shape):new Ky(G7e,i.shape,r.shape);return t.runWebGLProgram(s,[i,r],i.dtype)},$7e={kernelName:T2,backendName:"webgl",kernelFunc:U7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W7e=`
  return vec4(equal(a, b));
`,H7e="return float(a == b);",X7e=ns({opSnippet:H7e,packedOpSnippet:W7e,dtype:"bool",cpuKernelImpl:R8e}),K7e={kernelName:gw,backendName:"webgl",kernelFunc:X7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z7e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${bV};
  float a1 = ${xV};
  float a2 = ${vV};
  float a3 = ${wV};
  float a4 = ${SV};
  float a5 = ${TV};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,j7e=In({opSnippet:Z7e}),Y7e={kernelName:v0,backendName:"webgl",kernelFunc:j7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J7e=Cb+`
  return exp(x);
`,Q7e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zse=In({opSnippet:J7e,packedOpSnippet:Q7e,cpuKernelImpl:N8e,dtype:"float32"}),q7e={kernelName:w0,backendName:"webgl",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(n){const{inputs:e,attrs:t,backend:i}=n,{dim:r}=t,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=r;return r<0&&(B(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),ft({inputs:{x:s},backend:i,attrs:{shape:a}})}const eQe={kernelName:yw,backendName:"webgl",kernelFunc:kF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aj="return exp(x) - 1.0;",tQe=In({opSnippet:aj,packedOpSnippet:aj,cpuKernelImpl:L8e}),nQe={kernelName:S0,backendName:"webgl",kernelFunc:tQe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lj=class{constructor(e,t,i){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=i?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=i?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gse(n,e,t){const i=t.texData.get(n.dataId),r=ke(n.shape),s=n.shape[n.shape.length-1],o=r/s,a=ft({inputs:{x:n},backend:t,attrs:{shape:[o,s]}}),l=a.shape,u=new lj("real",l,e),c=new lj("imag",l,e),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=Wd({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const g=ft({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQe(n){const{inputs:e,backend:t}=n,{input:i}=e;return Gse(i,!1,t)}const rQe={kernelName:C2,backendName:"webgl",kernelFunc:iQe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sQe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GS(n){const{backend:e,attrs:t}=n,{shape:i,value:r}=t;let{dtype:s}=t;if(s=s||s0(r),s==="string"){const o=Wi(s,ke(i));return o.fill(r),e.makeTensorInfo(i,s,o)}else{const o=new sQe(i,r),a=[[r]];return e.runWebGLProgram(o,[],s,a)}}const oQe={kernelName:_2,backendName:"webgl",kernelFunc:GS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aQe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lQe={kernelName:M2,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,i=e,r=new aQe(t.shape);return i.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uj="return floor(x);",uQe=In({opSnippet:uj,packedOpSnippet:uj,cpuKernelImpl:P8e}),cQe={kernelName:T0,backendName:"webgl",kernelFunc:uQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hQe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,dQe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,pQe=ns({opSnippet:hQe,packedOpSnippet:dQe,dtype:"int32"}),fQe={kernelName:C0,backendName:"webgl",kernelFunc:pQe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mQe{constructor(e){this.variableNames=["A"];const t=Os(),[i,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${i}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gQe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Os(),[i,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${i}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yQe={kernelName:QM,backendName:"webgl",kernelFunc:bQe};let gg,eP=ve().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function bQe(n){const{inputs:e,backend:t,attrs:i}=n;let{pixels:r}=e;const{numChannels:s}=i,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,s];if(a||o){const g=ve().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(gg==null||g!==eP)&&(eP=g,gg=document.createElement("canvas").getContext("2d",{willReadFrequently:eP})),gg.canvas.width=l,gg.canvas.height=u,gg.drawImage(r,0,0,l,u),r=gg.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=qo.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=ve().getBool("WEBGL_PACK")?new gQe(h):new mQe(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i,g=Qc(c),y=Ir(r.shape,s.shape,l,h,u,d,!1,g);let m;const v=[],w=o!=null,S=a!=null,C=p==="leakyrelu",_=()=>{const I=[r,s],E=(k,P)=>{if(P==="NCHW"&&k.shape.length===1&&k.shape[0]!==1){const V=ft({inputs:{x:k},backend:t,attrs:{shape:[k.shape[0],1,1]}});return v.push(V),V}return k};if(w&&I.push(E(o,c)),S&&I.push(E(a,c)),C){const k=t.makeTensorInfo([],"float32",Yc(f,"float32"));I.push(k),v.push(k)}return I};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))m=Pse({x:r,filter:s,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(y.strideWidth<=2&&g==="channelsLast"&&ve().getBool("WEBGL_EXP_CONV")){const I=p?v1(p,!0):null,E=new Lse(y,w,I,S,C),k=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],P=_();m=t.runWebGLProgram(E,P,"float32",k)}else if(ve().getBool("WEBGL_CONV_IM2COL"))m=Dse({x:r,filter:s,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const I=p?v1(p,!1):null,E=new Nse(y,w,I,S,C),k=_();m=t.runWebGLProgram(E,k,"float32")}const A=ft({inputs:{x:m},backend:t,attrs:{shape:y.outShape}});return v.push(m),v.forEach(I=>t.disposeIntermediateTensorInfo(I)),A}const vQe={kernelName:o1,backendName:"webgl",kernelFunc:xQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wQe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=i,f=[];let g=c;g==null&&(g=[1,1]),B(es(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const y=Ir(r.shape,s.shape,l,g,u,h,!0),m=ve().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=d?v1(d,m):null,w=[r,s],S=o!=null,C=a!=null,_=d==="leakyrelu";if(S&&w.push(o),C&&w.push(a),_){const k=t.makeTensorInfo([],"float32",Yc(p,"float32"));w.push(k),f.push(k)}let A;m?A=new Bse(y,S,v,C,_):A=new Ose(y,S,v,C,_);const I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],E=t.runWebGLProgram(A,w,"float32",I);return f.forEach(k=>t.disposeIntermediateTensorInfo(k)),E}const SQe={kernelName:a1,backendName:"webgl",kernelFunc:wQe};class TQe{constructor(e,t,i,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=i;const s=Yn(i.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQe(n){const{inputs:e,backend:t}=n,{params:i,indices:r}=e,s=r.shape,o=s[s.length-1],a=ke(i.shape),[l,u,c,h]=XI(i,r),d=ft({inputs:{x:r},backend:t,attrs:{shape:[u,o]}}),p=ft({inputs:{x:i},backend:t,attrs:{shape:[ke(i.shape)/c,c]}});if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const m=t.readSync(r.dataId),v=t.bufferSync(i),w=D8e(m,v,i.dtype,u,o,c,h,i.shape,a);return t.makeTensorInfo(l,i.dtype,w.values)}const f=new TQe(o,h,[u,c],i.shape),g=t.runWebGLProgram(f,[p,d],p.dtype),y=ft({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),y}const _Qe={kernelName:A2,backendName:"webgl",kernelFunc:CQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MQe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const i=Yn(this.rank),r=AQe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function AQe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let r=0;r<n.length;r++)r===2?i.push("index"):i.push(`${t[r]}`);return i.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,indices:s}=e,{axis:o,batchDims:a}=i,l=un(o,r.shape)[0];if(ve().get("DEBUG")){const v=t.readSync(s.dataId),w=r.shape[l];for(let S=0;S<v.length;++S){const C=v[S];B(C<=w-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${w-1}]`)}}const u=RV(r,s,l,a),c=ke(s.shape),h=[],d=ft({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ft({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const v=t.bufferSync(p),w=t.bufferSync(d),S=F8e(w,v,f);return h.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(u.outputShape,S.dtype,S.values)}const g=new MQe(d.shape,f),y=t.runWebGLProgram(g,[d,p],d.dtype);h.push(y);const m=ft({inputs:{x:y},backend:t,attrs:{shape:u.outputShape}});return h.forEach(v=>t.disposeIntermediateTensorInfo(v)),m}const EQe={kernelName:xw,backendName:"webgl",kernelFunc:Vse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IQe="return float(a > b);",kQe=`
  return vec4(greaterThan(a, b));
`,RQe=ns({opSnippet:IQe,packedOpSnippet:kQe,cpuKernelImpl:O8e,dtype:"bool"}),NQe={kernelName:vw,backendName:"webgl",kernelFunc:RQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LQe="return float(a >= b);",PQe=`
  return vec4(greaterThanEqual(a, b));
`,DQe=ns({opSnippet:LQe,packedOpSnippet:PQe,dtype:"bool",cpuKernelImpl:B8e}),FQe={kernelName:_0,backendName:"webgl",kernelFunc:DQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQe(n){const{inputs:e,backend:t}=n,{input:i}=e;return Gse(i,!0,t)}const BQe={kernelName:E2,backendName:"webgl",kernelFunc:OQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zQe="return float(!isnan(x) && !isinf(x));",GQe=In({opSnippet:zQe,dtype:"bool"}),VQe={kernelName:A0,backendName:"webgl",kernelFunc:GQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UQe="return float(isinf(x));",$Qe=In({opSnippet:UQe,dtype:"bool"}),WQe={kernelName:E0,backendName:"webgl",kernelFunc:$Qe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HQe="return float(isnan(x));",XQe=In({opSnippet:HQe,dtype:"bool"}),KQe={kernelName:I0,backendName:"webgl",kernelFunc:XQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZQe="return float(a < b);",jQe=`
  return vec4(lessThan(a, b));
`,YQe=ns({opSnippet:ZQe,packedOpSnippet:jQe,cpuKernelImpl:z8e,dtype:"bool"}),JQe={kernelName:Sw,backendName:"webgl",kernelFunc:YQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QQe="return float(a <= b);",qQe=`
  return vec4(lessThanEqual(a, b));
`,eqe=ns({opSnippet:QQe,packedOpSnippet:qQe,cpuKernelImpl:G8e,dtype:"bool"}),tqe={kernelName:Tw,backendName:"webgl",kernelFunc:eqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nqe(n){const{backend:e,attrs:t}=n,{start:i,stop:r,num:s}=t,o=V8e(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}const iqe={kernelName:k2,backendName:"webgl",kernelFunc:nqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rqe=Cb+`
  return x < 0.0 ? 0./0. : log(x);
`,sqe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,oqe=In({opSnippet:rqe,packedOpSnippet:sqe,cpuKernelImpl:U8e}),aqe={kernelName:k0,backendName:"webgl",kernelFunc:oqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lqe=Cb+`
  return log(1.0 + x);
`,uqe=In({opSnippet:lqe}),cqe={kernelName:R0,backendName:"webgl",kernelFunc:uqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hqe="return float(a >= 1.0 && b >= 1.0);",dqe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,pqe=ns({opSnippet:hqe,packedOpSnippet:dqe,dtype:"bool"}),fqe={kernelName:Cw,backendName:"webgl",kernelFunc:pqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mqe="return float(!(x >= 1.0));",gqe=In({opSnippet:mqe}),yqe={kernelName:_w,backendName:"webgl",kernelFunc:gqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bqe="return float(a >= 1.0 || b >= 1.0);",xqe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,vqe=ns({opSnippet:bqe,packedOpSnippet:xqe,dtype:"bool"}),wqe={kernelName:Mw,backendName:"webgl",kernelFunc:vqe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sqe{constructor(e,t,i,r,s){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${i}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tqe{constructor(e,t,i,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${i}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cqe=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i,u=ve().getBool("WEBGL_PACK_NORMALIZATION")?new Tqe(r.shape,s,o,a,l):new Sqe(r.shape,s,o,a,l);return t.runWebGLProgram(u,[r],r.dtype)},_qe={kernelName:Aw,backendName:"webgl",kernelFunc:Cqe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mqe{constructor(e,t,i,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=i,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${i});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aqe=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=i,h=new Mqe(r.shape,a,l,u,c);return t.runWebGLProgram(h,[r,s,o],r.dtype)},Eqe={kernelName:R2,backendName:"webgl",kernelFunc:Aqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iqe(n,e,t,i){const r=ke(e),s=ke(n.shape)/r,o=ft({inputs:{x:n},attrs:{shape:[s,r]},backend:i}),a=Im(o,n.dtype,"max",i),l=ft({inputs:{x:a},attrs:{shape:t},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(a),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Use(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reductionIndices:s,keepDims:o}=i,a=r.shape.length,l=un(s,r.shape);let u=l;const c=Ti(u,a),h=c!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const v=t.texData.get(p.dataId).values,w=new Array(a);for(let _=0;_<w.length;_++)w[_]=r.shape[c[_]];const S=y$(v,r.shape,r.dtype,c,w);p=t.makeTensorInfo(w,r.dtype);const C=t.texData.get(p.dataId);C.values=S}else p=Tk(r,c,t);u=Ki(u.length,a)}ts("max",u,a);const[f,g]=kr(p.shape,u);let y=f;o&&(y=Xi(f,l));let m;if(d){const v=t.texData.get(p.dataId).values,w=$8e(v,ke(g),y,r.dtype);m=t.makeTensorInfo(y,r.dtype);const S=t.texData.get(m.dataId);S.values=w}else m=Iqe(p,g,y,t);return h&&t.disposeIntermediateTensorInfo(p),m}const kqe={kernelName:Ew,backendName:"webgl",kernelFunc:Use};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rqe=b$+`
  return max(a, b);
`,Nqe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+OS+`
  return result;
`,Lqe=ns({opSnippet:Rqe,packedOpSnippet:Nqe,cpuKernelImpl:W8e}),Pqe={kernelName:N0,backendName:"webgl",kernelFunc:Lqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dqe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e;DS(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i,u=1;B(es(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=rl(r.shape,s,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&bn(c.inShape,c.outShape))return Po({inputs:{x:r},backend:t});const h=new w1(c,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const Fqe={kernelName:Iw,backendName:"webgl",kernelFunc:Dqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oqe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=i,c=[1,1,1],h=Jc(r.shape,s,o,c,a,u,l),d=new v$(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const Bqe={kernelName:kw,backendName:"webgl",kernelFunc:Oqe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zqe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,i=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,l=o-1-e.padInfo.left,u=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Gqe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,i=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vqe(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=i,h=[1,1,1],d=Jc(o.shape,a,l,h,u,c),p=new v$(d,"max",!0),f=t.runWebGLProgram(p,[o],o.dtype),g=new Gqe(d),y=t.runWebGLProgram(g,[r,f],o.dtype);return t.disposeIntermediateTensorInfo(f),y}const Uqe={kernelName:L2,backendName:"webgl",kernelFunc:Vqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $qe(n){const{inputs:e,backend:t,attrs:i}=n,{dy:r,input:s,output:o}=e,a=s;DS([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=i,d=rl(a.shape,l,u,1,c,h),p=!0,f=new w1(d,"max",p),g=t.runWebGLProgram(f,[a],a.dtype),y=new zqe(d),m=t.runWebGLProgram(y,[r,g],a.dtype);return t.disposeIntermediateTensorInfo(g),m}const Wqe={kernelName:N2,backendName:"webgl",kernelFunc:$qe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hqe(n,e,t,i){let r=new w1(t,"max",!1);const s=i.runWebGLProgram(r,[n],"float32");r=new w1(t,"max",!0,!0,e);const o=i.runWebGLProgram(r,[n],"float32");return[s,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xqe={kernelName:P2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:i}=n,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=e,l=t;B(i.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const u=[1,1];B(es(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);const c=rl(i.shape,r,s,u,o),[h,d]=Hqe(i,a,c,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kqe(n,e,t,i){const r=ke(e),s=ke(n.shape)/r,o=ft({inputs:{x:n},attrs:{shape:[s,r]},backend:i}),a=Im(o,"float32","mean",i),l=ft({inputs:{x:a},attrs:{shape:t},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(a),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zqe={kernelName:Rw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:i}=n,{keepDims:r,axis:s}=e,o=t,a=i.shape.length,l=un(s,i.shape);let u=l;const c=Ti(u,a),h=c!=null,d=o.shouldExecuteOnCPU([i]),p=[];let f=i;if(h){if(d){const w=o.texData.get(f.dataId).values,S=new Array(a);for(let A=0;A<S.length;A++)S[A]=i.shape[c[A]];const C=y$(w,i.shape,i.dtype,c,S);f=o.makeTensorInfo(S,i.dtype);const _=o.texData.get(f.dataId);_.values=C}else f=Tk(i,c,o);p.push(f),u=Ki(u.length,a)}ts("sum",u,a);const[g,y]=kr(f.shape,u);let m=g;r&&(m=Xi(g,l));const v=Kqe(f,y,m,o);for(const w of p)o.disposeIntermediateTensorInfo(w);return v}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jqe(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=un(s,r.shape);let u=l;const c=Ti(u,a);let h=r;c!=null&&(h=Ps({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Ki(u.length,r.shape.length)),ts("min",u,a);const[d,p]=kr(h.shape,u),f=ke(p),g=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Im(g,g.dtype,"min",t);let m;if(o){const v=Xi(d,l);m=ft({inputs:{x:y},backend:t,attrs:{shape:v}})}else m=ft({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),m}const Yqe={kernelName:Nw,backendName:"webgl",kernelFunc:jqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jqe=b$+`
  return min(a, b);
`,Qqe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+OS+`
  return result;
`,qqe=ns({opSnippet:Jqe,packedOpSnippet:Qqe,cpuKernelImpl:H8e}),eet={kernelName:L0,backendName:"webgl",kernelFunc:qqe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tet{constructor(e,t,i){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,s=Yn(r),o=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=i==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class net{constructor(e,t,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const r=e.length,s=Yn(r),o=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),l=As("rc",r),u=As("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=i==="reflect"?0:1;let p="";if(r===1){const f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet=({inputs:n,backend:e,attrs:t})=>{const{x:i}=n,{paddings:r,mode:s}=t,o=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new net(i.shape,r,s):new tet(i.shape,r,s);return e.runWebGLProgram(o,[i],i.dtype)},ret={kernelName:Lw,backendName:"webgl",kernelFunc:iet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const set=`if (b == 0.0) return NAN;
  return mod(a, b);`,oet=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+OS+`
  return result;
`,aet=ns({opSnippet:set,packedOpSnippet:oet}),uet={kernelName:P0,backendName:"webgl",kernelFunc:aet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cet{constructor(e,t,i){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,i],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het=`
if (a == b) {
  return 1.0;
};
return a / b;`,det=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,$se=ns({opSnippet:het,packedOpSnippet:det,checkOutOfBounds:!0}),pet={kernelName:b0,backendName:"webgl",kernelFunc:$se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cj="return a - b;",Wse=ns({opSnippet:cj,packedOpSnippet:cj,supportsComplex:!0,cpuKernelImpl:h6e}),fet={kernelName:Y0,backendName:"webgl",kernelFunc:Wse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hse(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{dim:s}=i,o=un([s],r.shape),a=Use({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Xi(a.shape,o),u=ft({inputs:{x:a},backend:t,attrs:{shape:l}}),c=Wse({inputs:{a:r,b:u},backend:t}),h=zse({inputs:{x:c},backend:t}),d=Ck({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=ft({inputs:{x:d},backend:t,attrs:{shape:l}}),f=$se({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const met={kernelName:Jw,backendName:"webgl",kernelFunc:Hse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function get(n){const{inputs:e,backend:t,attrs:i}=n,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i,l=a?r:Hse({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new cet(u,c,s),d=[[o]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const yet={kernelName:D2,backendName:"webgl",kernelFunc:get};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bet=ol+`
  return -x;
`,xet=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function vet(n){const{inputs:e,backend:t}=n,{x:i}=e;if(t.shouldExecuteOnCPU([i])){const s=t.texData.get(i.dataId),[o,a]=K8e(s.values,i.shape,i.dtype);return t.makeTensorInfo(a,i.dtype,o)}let r;return ve().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new $h(i.shape,xet):r=new Tu(i.shape,bet),t.runWebGLProgram(r,[i],i.dtype)}const wet={kernelName:Pw,backendName:"webgl",kernelFunc:vet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tet=UI;function Cet(n){Yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,u=t.readSync(r.dataId),c=t.readSync(s.dataId),{selectedIndices:h}=Tet(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const _et={kernelName:F2,backendName:"webgl",kernelFunc:Cet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Met=$I;function Aet(n){Yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=i,c=t.readSync(r.dataId),h=t.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=Met(c,h,o,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const Eet={kernelName:O2,backendName:"webgl",kernelFunc:Aet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet=WI;function ket(n){Yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:i}=n,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=i,c=t.readSync(r.dataId),h=t.readSync(s.dataId),d=o,p=a,f=l,g=u,{selectedIndices:y,selectedScores:m}=Iet(c,h,d,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}const Ret={kernelName:B2,backendName:"webgl",kernelFunc:ket};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Net{constructor(e,t,i,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${i}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Let=n=>{const{inputs:e,backend:t,attrs:i}=n,{indices:r}=e,{dtype:s,depth:o,onValue:a,offValue:l}=i,u=ke(r.shape),c=new Net(u,o,a,l),h=ft({inputs:{x:r},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[h],s);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,o],f=ft({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},Pet={kernelName:Ow,backendName:"webgl",kernelFunc:Let};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SA(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="complex64"){const r=zS({inputs:{input:i},backend:t}),s=SA({inputs:{x:r},backend:t}),o=_k({inputs:{input:i},backend:t}),a=SA({inputs:{x:o},backend:t}),l=Wd({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return GS({attrs:{shape:i.shape,dtype:i.dtype,value:i.dtype==="string"?"":0},backend:t})}const Det={kernelName:eS,backendName:"webgl",kernelFunc:SA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const{inputs:e,backend:t}=n,{x:i}=e;if(i.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(i.dtype==="complex64"){const r=zS({inputs:{input:i},backend:t}),s=Xse({inputs:{x:r},backend:t}),o=_k({inputs:{input:i},backend:t}),a=SA({inputs:{x:o},backend:t}),l=Wd({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return GS({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:t})}const Fet={kernelName:Fw,backendName:"webgl",kernelFunc:Xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oet(n){const{inputs:e,backend:t,attrs:i}=n,{axis:r}=i;if(e.length===1)return kF({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach(c=>{qr(s,c.shape,"All tensors passed to stack must have matching shapes"),B(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=kF({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=Rse({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const Bet={kernelName:Bw,backendName:"webgl",kernelFunc:Oet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zet{constructor(e,t,i){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,s=Yn(r),o=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Get{constructor(e,t,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const r=e.length,s=Yn(r),o=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),l=As("rc",r),u=As("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,y=r===1?2:4;g<y;g++)f+=`
        ${d[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{paddings:s,constantValue:o}=i;if(ke(r.shape)===0){const u=s.map((c,h)=>c[0]+r.shape[h]+c[1]);return GS({backend:t,attrs:{shape:u,value:o,dtype:r.dtype}})}const a=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Get(r.shape,s,o):new zet(r.shape,s,o),l=[[o]];return t.runWebGLProgram(a,[r],r.dtype,l)},Vet={kernelName:zw,backendName:"webgl",kernelFunc:Kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,$et=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+OS+`
  return result;
`,Wet=ns({opSnippet:Uet,packedOpSnippet:$et}),Het={kernelName:F0,backendName:"webgl",kernelFunc:Wet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xet(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=[],u=un(s,r.shape);let c=u;const h=Ti(c,a);let d=r;h!=null&&(d=Ps({inputs:{x:r},backend:t,attrs:{perm:h}}),c=Ki(c.length,a),l.push(d)),ts("prod",c,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:g,outShape:y,outDtype:m}=j8e(d.shape,d.dtype,f,c);p=t.makeTensorInfo(y,m,g)}else{const[f,g]=kr(d.shape,c),y=ke(g),m=ft({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),v=lI(r.dtype),w=Im(m,v,"prod",t);p=ft({inputs:{x:w},backend:t,attrs:{shape:f}}),l.push(m),l.push(w)}if(o){l.push(p);const f=Xi(p.shape,u);p=ft({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const Ket={kernelName:Vw,backendName:"webgl",kernelFunc:Xet};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zet(n){const{inputs:e,backend:t,attrs:i}=n,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:a}=i,l=r.map(m=>t.readSync(m.dataId)),u=r.map(m=>m.shape),c=t.readSync(s.dataId),h=t.readSync(o.dataId),[d,p,f]=Y8e(l,u,c,s.shape,s.dtype,h,o.shape,a),g=d.map(m=>t.makeTensorInfo([m.length],"int32",m)),y=t.makeTensorInfo(f,s.dtype,p);return g.concat([y])}const jet={kernelName:z2,backendName:"webgl",kernelFunc:Zet};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yet(n){const{inputs:e,backend:t}=n,{starts:i,limits:r,deltas:s}=e,o=t.readSync(i.dataId),a=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,c]=J8e(o,i.shape,i.dtype,a,r.shape,l,s.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],i.dtype,c);return[h,d]}const Jet={kernelName:G2,backendName:"webgl",kernelFunc:Yet};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qet(n){const{inputs:e,backend:t,attrs:i}=n,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=i,u=t.readSync(r.dataId),c=t.readSync(s.dataId),h=t.readSync(o.dataId),d=a.map(y=>t.readSync(y.dataId)),p=a.map(y=>y.shape),[f,g]=Q8e(u,r.shape,c,s.shape,s.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(f,s.dtype,g)}const qet={kernelName:V2,backendName:"webgl",kernelFunc:Qet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zse=n=>{const{backend:e,attrs:t}=n,{start:i,stop:r,step:s,dtype:o}=t,a=q8e(i,r,s,o);return e.makeTensorInfo([a.length],o,a)},ett={kernelName:U2,backendName:"webgl",kernelFunc:Zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt="return 1.0 / x;",ntt=In({opSnippet:ttt}),itt={kernelName:O0,backendName:"webgl",kernelFunc:ntt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rtt=ol+`
  return (x < 0.0) ? 0.0 : x;
`,stt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ott=In({opSnippet:rtt,packedOpSnippet:stt}),att={kernelName:B0,backendName:"webgl",kernelFunc:ott};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ltt=ol+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,utt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ctt=In({opSnippet:ltt,packedOpSnippet:utt}),htt={kernelName:z0,backendName:"webgl",kernelFunc:ctt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dtt{constructor(e,t,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,i,u];const c=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i];let d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ptt{constructor(e,t,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,i,u];const c=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i];let d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${i-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ftt(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,u]=a,c=ve().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ptt(r.shape,l,u,s,o):new dtt(r.shape,l,u,s,o);return t.runWebGLProgram(c,[r],"float32")}const mtt={kernelName:Ww,backendName:"webgl",kernelFunc:ftt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gtt{constructor(e,t,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,a]=e,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],u=[i&&o>1?o-1:o,i&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ytt(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i,a=new gtt(s.shape,r.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const btt={kernelName:H2,backendName:"webgl",kernelFunc:ytt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xtt{constructor(e,t,i,r,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,i,u];const c=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i],d=r?"0.5":"0.0";let p;s?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vtt{constructor(e,t,i,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,i,u];const c=[r&&t>1?a-1:a,r&&i>1?l-1:l],h=[r&&t>1?t-1:t,r&&i>1?i-1:i],d=r?"0.5":"0.0";let p;s?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${i-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wtt(n){const{inputs:e,backend:t,attrs:i}=n,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,u]=a,c=ve().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new vtt(r.shape,l,u,s,o):new xtt(r.shape,l,u,s,o);return t.runWebGLProgram(c,[r],r.dtype)}const Stt={kernelName:$w,backendName:"webgl",kernelFunc:wtt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ttt{constructor(e,t,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,a]=e,l=[i&&o>1?r-1:r,i&&a>1?s-1:s],u=[i&&o>1?o-1:o,i&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${i} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${i} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ctt(n){const{inputs:e,backend:t,attrs:i}=n,{images:r,dy:s}=e,{alignCorners:o}=i,a=new Ttt(s.shape,r.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const _tt={kernelName:W2,backendName:"webgl",kernelFunc:Ctt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mtt{constructor(e,t){this.variableNames=["x"];const i=e.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);if(this.outputShape=e,i===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,l)=>r(l)).join(","),o=Yn(i);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Att{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const i=e.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);this.outputShape=e;const r=As("rc",i),s=`${r[i-1]} + 1 < ${this.outputShape[i-1]}`,o=`${r[i-2]} + 1 < ${this.outputShape[i-2]}`,a=Yn(i);i===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${s}){
            result.g = ${u(r.slice())};
          }
          if(${o}) {
            result.b = ${c(r.slice())};
            if(${s}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function u(f){return f[i-1]="("+f[i-1]+" + 1)",d(f)}function c(f){return f[i-2]="("+f[i-2]+" + 1)",d(f)}function h(f){return f[i-1]="("+f[i-1]+" + 1)",f[i-2]="("+f[i-2]+" + 1)",d(f)}function d(f){const g=e.map((v,w)=>p(w,f)),y=g.join(","),m=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${m}))`}function p(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ett(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{dims:s}=i,o=r.shape.length,a=un(s,r.shape);if(o===0)return Po({inputs:{x:r},backend:t});const l=ve().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Att(r.shape,a):new Mtt(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const Itt={kernelName:Hw,backendName:"webgl",kernelFunc:Ett};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ktt{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const i=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${i}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt={kernelName:aI,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:i}=n,{radians:r,fillValue:s,center:o}=e,a=t,l=new ktt(i.shape,s),[u,c]=mV(o,i.shape[1],i.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[i],i.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ntt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Ltt=In({opSnippet:Ntt}),Ptt={kernelName:G0,backendName:"webgl",kernelFunc:Ltt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dtt="return inversesqrt(x);",Ftt=In({opSnippet:Dtt,cpuKernelImpl:e6e}),Ott={kernelName:V0,backendName:"webgl",kernelFunc:Ftt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jse{constructor(e,t,i,r,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=Yn(s.length),u=Yn(o.length);let c="";i===1?c="i":i===2&&(c="i, j");const h=`getIndices(${c})`;let d="";r===1?d="i":r===2&&(d="i, coords[1]");const p=`getUpdates(${d})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Btt(n){const{inputs:e,backend:t,attrs:i}=n,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=cb(s,r,o),d=[h/u,u];if(h===0)return t.makeTensorInfo(o,r.dtype);const p=ft({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),f=ft({inputs:{x:s},backend:t,attrs:{shape:[l,u]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new jse(l,a,p.shape.length,f.shape.length,c,d),m=t.runWebGLProgram(y,[f,p,g],f.dtype),v=ft({inputs:{x:m},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),v}const ztt={kernelName:X2,backendName:"webgl",kernelFunc:Btt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gtt{constructor(e,t,i,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,i];const s="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ve().getNumber("WEBGL_VERSION")===2?s:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vtt(n){const{inputs:e,backend:t,attrs:i}=n,{sortedSequence:r,values:s}=e,{side:o}=i,a=new Gtt(r.shape[0],r.shape[1],s.shape[1],o),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,s],"int32",l)}const Utt={kernelName:K2,backendName:"webgl",kernelFunc:Vtt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $tt{constructor(e,t,i){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(i>4)throw Error(`Where for rank ${i} is not yet supported`);if(i===1)s="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);r=l.join(),s=u.join()}const o=Yn(i);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wtt(n){const{inputs:e,backend:t}=n,{condition:i,t:r,e:s}=e,o=new $tt(i.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[i,r,s],qs(r.dtype,s.dtype))}const Htt={kernelName:Xw,backendName:"webgl",kernelFunc:Wtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xtt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${jI};
  float scale = ${YI};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Ktt=In({opSnippet:Xtt}),Ztt={kernelName:U0,backendName:"webgl",kernelFunc:Ktt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jtt=Cb+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Ytt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Jtt=In({opSnippet:jtt,packedOpSnippet:Ytt,cpuKernelImpl:n6e}),Qtt={kernelName:X0,backendName:"webgl",kernelFunc:Jtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qtt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,ent=In({opSnippet:qtt}),tnt={kernelName:H0,backendName:"webgl",kernelFunc:ent};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nnt=Cb+`
  return sin(x);
`,int=In({opSnippet:nnt}),rnt={kernelName:$0,backendName:"webgl",kernelFunc:int};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const snt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,ont=In({opSnippet:snt}),ant={kernelName:W0,backendName:"webgl",kernelFunc:ont};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lnt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,unt=In({opSnippet:lnt}),cnt={kernelName:K0,backendName:"webgl",kernelFunc:unt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hnt=n=>{const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{blockShape:s,paddings:o}=i;B(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((m,v)=>m*v),l=[[0,0]];l.push(...o);for(let m=1+s.length;m<r.shape.length;++m)l.push([0,0]);const u=[],c=Kse({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=wS(c.shape,s,a,!1),d=SS(h.length,s.length,!1),p=TS(c.shape,s,a,!1),f=ft({inputs:{x:c},backend:t,attrs:{shape:h}}),g=Ps({inputs:{x:f},backend:t,attrs:{perm:d}}),y=ft({inputs:{x:g},backend:t,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(m=>t.disposeIntermediateTensorInfo(m)),y},dnt={kernelName:jw,backendName:"webgl",kernelFunc:hnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pnt(n){const{inputs:e,backend:t}=n,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(r.dataId),u=t.readSync(s.dataId),c=t.readSync(o.dataId)[0],[h,d,p,f,g]=r6e(a,i.shape,i.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,i.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],i.dtype,new Int32Array(g))]}const fnt={kernelName:Z2,backendName:"webgl",kernelFunc:pnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mnt(n){const{inputs:e,backend:t}=n,{inputIndices:i,inputShape:r,newShape:s}=e;if(i.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(i.dataId),l=Array.from(t.readSync(s.dataId)),[u,c,h]=s6e(a,i.shape,i.dtype,o,l);return[t.makeTensorInfo(c,i.dtype,u),t.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const gnt={kernelName:j2,backendName:"webgl",kernelFunc:mnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ynt(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const o=t.readSync(i.dataId),a=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,c]=bse(o,i.shape,i.dtype,a,l,!0);return t.makeTensorInfo(c,i.dtype,u)}const bnt={kernelName:Y2,backendName:"webgl",kernelFunc:ynt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xnt(n){const{inputs:e,backend:t}=n,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const o=t.readSync(i.dataId),a=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,c]=bse(o,i.shape,i.dtype,a,l);return t.makeTensorInfo(c,i.dtype,u)}const vnt={kernelName:J2,backendName:"webgl",kernelFunc:xnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wnt(n){const{inputs:e,backend:t,attrs:i}=n,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=cb(s,r,a),p=!1;if(s.dtype==="string"){const m=t.bufferSync(r),v=t.bufferSync(s),w=zc(t.readSync(o.dataId)[0]),S=t6e(m,v,a,d,c,u,l,h,w,p);return t.makeTensorInfo(a,S.dtype,S.values)}const f=new jse(u,l,r.shape.length,s.shape.length,h,[d,1],p),g=t.runWebGLProgram(f,[s,r,o],s.dtype),y=ft({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),y}const Snt={kernelName:Q2,backendName:"webgl",kernelFunc:wnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tnt(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=un(o,r.shape)[0],l=kV(r,s,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=_b({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=d,f})}const Cnt={kernelName:Yw,backendName:"webgl",kernelFunc:Tnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hj="return sqrt(x);",_nt=In({opSnippet:hj,packedOpSnippet:hj,cpuKernelImpl:o6e}),Mnt={kernelName:Z0,backendName:"webgl",kernelFunc:_nt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ant="return x * x;",Ent=In({opSnippet:Ant}),Int={kernelName:q2,backendName:"webgl",kernelFunc:Ent};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dj="return (a - b) * (a - b);",knt=ns({opSnippet:dj,packedOpSnippet:dj}),Rnt={kernelName:j0,backendName:"webgl",kernelFunc:knt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nnt({inputs:n,attrs:e,backend:t}){const{x:i}=n,r=ol+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Tu(i.shape,r);return t.runWebGLProgram(s,[i],i.dtype)}const Lnt={kernelName:eb,backendName:"webgl",kernelFunc:Nnt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pnt{constructor(e,t,i){this.variableNames=["x"],this.outputShape=i;const r=i.length,s=Yn(i.length),o=Yn(i.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=i.map((u,c)=>(l++,i.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dnt(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=i,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:m,begin:v,end:w,strides:S}=dV(r.shape,s,o,a,l,u,c,h,d);let C;if(g)C=ft({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||m){B(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const A=uV(v,w,S),I=_b({inputs:{x:r},backend:t,attrs:{begin:v,size:A}});C=ft({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(I)}else if(t.shouldExecuteOnCPU([r])){const A=t.readSync(r.dataId),I=nn(r.shape,r.dtype,A),E=a6e(p,I,S,v);C=t.makeTensorInfo(f,r.dtype,E.values)}else{const A=new Pnt(v,S,p);C=t.runWebGLProgram(A,[r],r.dtype)}const _=ft({inputs:{x:C},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(C),_}const Fnt={kernelName:eI,backendName:"webgl",kernelFunc:Dnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ont(n){const{inputs:e,backend:t,attrs:i}=n,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=i,{data:c,dataSplits:h}=e,d=t.readSync(c.dataId),p=t.readSync(h.dataId),[f,g]=l6e(d,p,r,s,o,a,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const Bnt={kernelName:tI,backendName:"webgl",kernelFunc:Ont};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function znt(n){const{inputs:e,backend:t,attrs:i}=n,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(o.dataId)[0],[u,c,h]=u6e(a,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Gnt={kernelName:nI,backendName:"webgl",kernelFunc:znt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vnt(n){const{inputs:e,backend:t,attrs:i}=n,{numBuckets:r}=i,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(s.dataId),a=c6e(o,r);return t.makeTensorInfo(s.shape,"int32",a)}const Unt={kernelName:iI,backendName:"webgl",kernelFunc:Vnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $nt="return tan(x);",Wnt=In({opSnippet:$nt}),Hnt={kernelName:J0,backendName:"webgl",kernelFunc:Wnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xnt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Knt=In({opSnippet:Xnt}),Znt={kernelName:Q0,backendName:"webgl",kernelFunc:Knt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jnt{constructor(e,t){this.variableNames=["A"];const i=new Array(e.length);for(let o=0;o<i.length;o++)i[o]=e[o]*t[o];this.outputShape=i,this.rank=i.length;const r=Yn(this.rank),s=Ynt(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function Ynt(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],i=[];for(let r=0;r<n.length;r++)i.push(`imod(${t[r]}, ${n[r]})`);return i.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{reps:s}=i;if(r.dtype==="string"||r.shape.length>5){const a=t.readSync(r.dataId),l=r.dtype==="string"?a.map(h=>zc(h)):a,u=nn(r.shape,r.dtype,l),c=d6e(u,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const o=new jnt(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}const Jnt={kernelName:q0,backendName:"webgl",kernelFunc:Yse};class Qnt{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class qnt{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function pj(n){let e=1;for(;e<n;)e*=2;return e}function eit(n){const{inputs:e,backend:t,attrs:i}=n,{x:r}=e,{k:s,sorted:o}=i,a=ve().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ve().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([r])||c<a||s>l){const E=t.readSync(r.dataId),[k,P]=p6e(E,u,r.dtype,s,o);return[t.makeTensorInfo(k.shape,k.dtype,k.values),t.makeTensorInfo(P.shape,P.dtype,P.values)]}if(s===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[r,GS({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(r):r,f=ke(u)/c,g=ft({inputs:{x:p},attrs:{shape:[f,c]},backend:t});d&&mp(t,p);const y=pj(s),m=pj(c);let v=null;const w=()=>v===null?[g,g]:[g,v],S=(E,k,P)=>{const V=w(),U=new Qnt(P),F=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[E],[k]],$=v;v=t.runWebGLProgram(U,V,"int32",F),mp(t,$)};for(let E=1;E<y;E*=2){const k=E*2;for(let P=E;P>=1;P/=2)S(k,P,[f,m])}for(let E=m;E>y;E/=2){const k=w(),P=new qnt([f,E/2]),V=[[c],[v===null?1:0],[y]],U=v;v=t.runWebGLProgram(P,k,"int32",V),mp(t,U);const F=y/2,$=F*2;for(let J=F;J>=1;J/=2)S($,J,v.shape)}let C=v;v=_b({inputs:{x:v},backend:t,attrs:{begin:0,size:[f,s]}}),mp(t,C);let _=Vse({inputs:{x:g,indices:v},backend:t,attrs:{axis:1,batchDims:1}});mp(t,g);const A=u.slice(0,-1);A.push(s),C=v,v=ft({inputs:{x:v},attrs:{shape:A},backend:t}),mp(t,C);const I=_;return _=ft({inputs:{x:_},attrs:{shape:A},backend:t}),mp(t,I),[_,v]}const tit={kernelName:rI,backendName:"webgl",kernelFunc:eit};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nit{constructor(e,t,i,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=i==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iit(n){const{inputs:e,backend:t,attrs:i}=n,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=i,[c,h,d,p]=r.shape,[f,g]=u??[h,d],y=[c,f,g,p],m=new nit(h,d,o,a,l,y);return t.runWebGLProgram(m,[r,s],"float32")}const rit={kernelName:sI,backendName:"webgl",kernelFunc:iit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sit(n){const{inputs:e,attrs:t,backend:i}=n,{axis:r}=t,{x:s}=e;DS(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=i.readSync(s.dataId),{outputValues:a,outputShape:l,indices:u}=f6e(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([u.length],"int32",u)]}const oit={kernelName:oI,backendName:"webgl",kernelFunc:sit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ait(n){const{inputs:e,backend:t,attrs:i}=n,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==s&&(u[c++]=o.shape[g]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[s]=g;const y=_b({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),m=ft({inputs:{x:y},backend:t,attrs:{shape:u}});f[g]=m,h.push(y)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const lit={kernelName:Qw,backendName:"webgl",kernelFunc:ait};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uit{constructor(e,t){this.variableNames=["x","segmentIds"];const i=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/i);this.outputShape=[r,a];const l="0.0",u="sumValue",c=Math.floor(i/4)*4,h=i%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";s%i>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%i>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${i}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cit(n){const{inputs:e,backend:t,attrs:i}=n,{x:r,segmentIds:s}=e,{numSegments:o}=i,a=r.shape.length,l=[];let u=0;const c=Ti([u],a);let h=r;c!=null&&(h=Ps({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),u=Ki(1,a)[0]);const d=Pne(h.shape,u,o),p=ke([h.shape[u]]),f=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const g=lI(r.dtype),y=(S,C,_,A,I)=>{const E=S.shape[0],k=S.shape[1],P=Lne(k,I),V={windowSize:P,inSize:k,batchSize:E,numSegments:I},U=new uit(V,C),F=t.compileAndRun(U,[S,_],A);if(l.push(F),F.shape[1]===I)return F;const $=Zse({backend:t,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),J=Yse({inputs:{x:$},backend:t,attrs:{reps:[k/P]}});return l.push($),l.push(J),y(F,C,J,A,I)},m=y(f,"unsortedSegmentSum",s,g,o),v=ft({inputs:{x:m},backend:t,attrs:{shape:d}});let w=v;if(c!=null){l.push(v);const S=Gd(c);w=Ps({inputs:{x:w},backend:t,attrs:{perm:S}})}return l.forEach(S=>t.disposeIntermediateTensorInfo(S)),w}const hit={kernelName:qw,backendName:"webgl",kernelFunc:cit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dit=[sYe,aYe,cYe,pYe,mYe,bYe,vYe,SYe,MYe,EYe,RYe,PYe,OYe,VYe,WYe,XYe,ZYe,QYe,eJe,nJe,oJe,pJe,mJe,yJe,TJe,_Je,IJe,U6e,NJe,OJe,VJe,KJe,jJe,JJe,qJe,t7e,r7e,a7e,c7e,d7e,f7e,g7e,x7e,w7e,_7e,A7e,k7e,L7e,D7e,z7e,$7e,K7e,Y7e,q7e,eQe,nQe,rQe,oQe,lQe,cQe,fQe,yQe,vQe,SQe,_Qe,EQe,NQe,FQe,V6e,BQe,DJe,VQe,WQe,KQe,W6e,JQe,tqe,iqe,aqe,cqe,fqe,yqe,wqe,_qe,Eqe,kqe,Pqe,Fqe,Bqe,Uqe,Wqe,Xqe,Zqe,Yqe,eet,ret,uet,yet,K6e,wet,_et,Eet,Ret,xJe,Pet,Fet,Bet,Vet,Het,X6e,Ket,jet,Jet,qet,ett,vJe,pet,itt,att,htt,j6e,mtt,btt,Stt,_tt,Itt,Rtt,Ptt,Ott,ztt,Utt,Htt,Ztt,Qtt,tnt,rnt,ant,hJe,met,cnt,dnt,fnt,gnt,bnt,vnt,Snt,Cnt,Mnt,Int,Rnt,Lnt,Fnt,Bnt,Gnt,Unt,fet,nYe,Hnt,Znt,Jnt,tit,rit,iYe,oit,lit,hit,Det];for(const n of dit)so(n);const Jse="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIFd0e2NvbnN0cnVjdG9yKG49W10sZT1RdCl7aWYodGhpcy5kYXRhPW4sdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9ZSx0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKG4pe3RoaXMuZGF0YS5wdXNoKG4pLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBuPXRoaXMuZGF0YVswXSxlPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPWUsdGhpcy5fZG93bigwKSksbn1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAobil7Y29uc3R7ZGF0YTplLGNvbXBhcmU6dH09dGhpcyxzPWVbbl07Zm9yKDtuPjA7KXtjb25zdCByPW4tMT4+MSxpPWVbcl07aWYodChzLGkpPj0wKWJyZWFrO2Vbbl09aSxuPXJ9ZVtuXT1zfV9kb3duKG4pe2NvbnN0e2RhdGE6ZSxjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPWVbbl07Zm9yKDtuPHM7KXtsZXQgaT0objw8MSkrMSxoPWVbaV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChlW2xdLGgpPDAmJihpPWwsaD1lW2xdKSx0KGgscik+PTApYnJlYWs7ZVtuXT1oLG49aX1lW25dPXJ9fWZ1bmN0aW9uIFF0KG8sbil7cmV0dXJuIG88bj8tMTpvPm4/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTpuLHYyOmV9PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9KG5bc11eZVtzXSk+Pj4wO3QrPVp0KHIpfXJldHVybiB0fSxadD1vPT57dmFyIG49by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gbj0obj4+MiY4NTg5OTM0NTkpKyhuJjg1ODk5MzQ1OSksbj0obj4+NCkrbiYyNTI2NDUxMzUsbj0obj4+OCkrbiYxNjcxMTkzNSxuPShuPj4xNikrbiY2NTUzNSxufSxjdD0xLHZ0PW89Pntjb25zdHtrZXl3aWR0aDpuLGtleWhlaWdodDplLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgobixlKSxNPU1hdGguZmxvb3Iobi8yKSxUPU1hdGguZmxvb3IoZS8yKSxFPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludC5zY2FsZSxLPXJbTl0ua2V5cG9pbnQuc2NhbGU7Sz09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3Qgdj0kL0s7RS5wdXNoKHYqbSl9RS5zb3J0KChOLCQpPT5OLSQpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLEk9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLHo9cSpJLEI9eipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludCxLPXJbTl0ua2V5cG9pbnQse3g6dix5OlYsc2NhbGU6TCxhbmdsZTpDfT14dCh7cXVlcnlwb2ludDokLGtleXBvaW50Okssa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6VCxzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZih2PGh8fHY+PWl8fFY8dXx8Vj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8TDxhfHxMPj1qKXtjW05dPSExO2NvbnRpbnVlfWxldCBYPXEqKHYtaCkvKGktaCksd3Q9SSooVi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKEwtYSkvKGotYSk7cFtOXT17YmluWDpYLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBpdD1NYXRoLmZsb29yKFgtLjUpLGx0PU1hdGguZmxvb3Iod3QtLjUpLGh0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKGl0PDB8fGl0KzE+PXF8fGx0PDB8fGx0KzE+PUl8fGh0PDB8fGh0KzE+PWcpe2NbTl09ITE7Y29udGludWV9Zm9yKGxldCB1dD0wO3V0PDI7dXQrKyl7bGV0IGt0PWl0K3V0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCB1bj1sdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgY249KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBmbj1odCtSdDtjb25zdCBOdD1rdCt1bipxK2NuKnorZm4qQjtTW050XT09PXZvaWQgMCYmKFNbTnRdPTApLFNbTnRdKz0xfX19fWNbTl09ITB9bGV0IGQ9MCxEPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2goTj0+e1NbTl0+ZCYmKGQ9U1tOXSxEPU4pfSksZDwzKXJldHVybltdO2NvbnN0IFU9TWF0aC5mbG9vcihEJUIleiVxKSxGPU1hdGguZmxvb3IoKEQtVSklQiV6L3EpLFA9TWF0aC5mbG9vcigoRC1VLUYqcSklQi96KSxZPU1hdGguZmxvb3IoKEQtVS1GKnEtUCp6KS9CKSxHPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtpZighY1tOXSljb250aW51ZTtjb25zdCAkPXBbTl07aWYoTWF0aC5hYnMoJC5iaW5YLShVKy41KSk+PWN0fHxNYXRoLmFicygkLmJpblktKEYrLjUpKT49Y3R8fE1hdGguYWJzKCQuYmluU2NhbGUtKFkrLjUpKT49Y3QpY29udGludWU7Y29uc3QgTD1NYXRoLmFicygkLmJpbkFuZ2xlLShQKy41KSk7TWF0aC5taW4oTCxmLUwpPj1jdHx8Ry5wdXNoKHJbTl0pfXJldHVybiBHfSx4dD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDpuLGtleWNlbnRlclg6ZSxrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLW4uYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL24uc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSpuLngrdVsxXSpuLnksdVsyXSpuLngrdVszXSpuLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKmUrdVsxXSp0K2cseTp1WzJdKmUrdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0sQXQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBXKG8pe3JldHVybiBBdC5jYWxsKG8pLmVuZHNXaXRoKCJBcnJheV0iKX1mdW5jdGlvbiB0ZShvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIVcobykpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBiZSBhbiBhcnJheSIpO2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eSIpO3ZhciBlPW4uZnJvbUluZGV4LHQ9ZT09PXZvaWQgMD8wOmUscz1uLnRvSW5kZXgscj1zPT09dm9pZCAwP28ubGVuZ3RoOnM7aWYodDwwfHx0Pj1vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKCJmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCIpO2lmKHI8PXR8fHI+by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBFcnJvcigidG9JbmRleCBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIGZyb21JbmRleCBhbmQgYXQgbW9zdCBlcXVhbCB0byBsZW5ndGgiKTtmb3IodmFyIGk9b1t0XSxoPXQrMTtoPHI7aCsrKW9baF0+aSYmKGk9b1toXSk7cmV0dXJuIGl9ZnVuY3Rpb24gZWUobyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFXKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgZT1uLmZyb21JbmRleCx0PWU9PT12b2lkIDA/MDplLHM9bi50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihXKG8pKXtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTt2YXIgZTtpZihuLm91dHB1dCE9PXZvaWQgMCl7aWYoIVcobi5vdXRwdXQpKXRocm93IG5ldyBUeXBlRXJyb3IoIm91dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQiKTtlPW4ub3V0cHV0fWVsc2UgZT1uZXcgQXJyYXkoby5sZW5ndGgpO3ZhciB0PWVlKG8pLHM9dGUobyk7aWYodD09PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheSIpO3ZhciByPW4ubWluLGk9cj09PXZvaWQgMD9uLmF1dG9NaW5NYXg/dDowOnIsaD1uLm1heCxsPWg9PT12b2lkIDA/bi5hdXRvTWluTWF4P3M6MTpoO2lmKGk+PWwpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbiIpO2Zvcih2YXIgdT0obC1pKS8ocy10KSxmPTA7ZjxvLmxlbmd0aDtmKyspZVtmXT0ob1tmXS10KSp1K2k7cmV0dXJuIGV9Y29uc3QgZnQ9IiAiLnJlcGVhdCgyKSxfdD0iICIucmVwZWF0KDQpO2Z1bmN0aW9uIG5lKCl7cmV0dXJuIFR0KHRoaXMpfWZ1bmN0aW9uIFR0KG8sbj17fSl7Y29uc3R7bWF4Um93czplPTE1LG1heENvbHVtbnM6dD0xMCxtYXhOdW1TaXplOnM9OCxwYWRNaW51czpyPSJhdXRvIn09bjtyZXR1cm5gJHtvLmNvbnN0cnVjdG9yLm5hbWV9IHsKJHtmdH1bCiR7X3R9JHtzZShvLGUsdCxzLHIpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gc2UobyxuLGUsdCxzKXtjb25zdHtyb3dzOnIsY29sdW1uczppfT1vLGg9TWF0aC5taW4ocixuKSxsPU1hdGgubWluKGksZSksdT1bXTtpZihzPT09ImF1dG8iKXtzPSExO3Q6Zm9yKGxldCBmPTA7ZjxoO2YrKylmb3IobGV0IGc9MDtnPGw7ZysrKWlmKG8uZ2V0KGYsZyk8MCl7cz0hMDticmVhayB0fX1mb3IobGV0IGY9MDtmPGg7ZisrKXtsZXQgZz1bXTtmb3IobGV0IGE9MDthPGw7YSsrKWcucHVzaChvZShvLmdldChmLGEpLHQscykpO3UucHVzaChgJHtnLmpvaW4oIiAiKX1gKX1yZXR1cm4gbCE9PWkmJih1W3UubGVuZ3RoLTFdKz1gIC4uLiAke2ktZX0gbW9yZSBjb2x1bW5zYCksaCE9PXImJnUucHVzaChgLi4uICR7ci1ufSBtb3JlIHJvd3NgKSx1LmpvaW4oYAoke190fWApfWZ1bmN0aW9uIG9lKG8sbixlKXtyZXR1cm4obz49MCYmZT9gICR7enQobyxuLTEpfWA6enQobyxuKSkucGFkRW5kKG4pfWZ1bmN0aW9uIHp0KG8sbil7bGV0IGU9by50b1N0cmluZygpO2lmKGUubGVuZ3RoPD1uKXJldHVybiBlO2xldCB0PW8udG9GaXhlZChuKTtpZih0Lmxlbmd0aD5uJiYodD1vLnRvRml4ZWQoTWF0aC5tYXgoMCxuLSh0Lmxlbmd0aC1uKSkpKSx0Lmxlbmd0aDw9biYmIXQuc3RhcnRzV2l0aCgiMC4wMDAiKSYmIXQuc3RhcnRzV2l0aCgiLTAuMDAwIikpcmV0dXJuIHQ7bGV0IHM9by50b0V4cG9uZW50aWFsKG4pO3JldHVybiBzLmxlbmd0aD5uJiYocz1vLnRvRXhwb25lbnRpYWwoTWF0aC5tYXgoMCxuLShzLmxlbmd0aC1uKSkpKSxzLnNsaWNlKDApfWZ1bmN0aW9uIHJlKG8sbil7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1uLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxuLGUpe2xldCB0PWU/by5yb3dzOm8ucm93cy0xO2lmKG48MHx8bj50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gWihvLG4sZSl7bGV0IHQ9ZT9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYobjwwfHxuPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB0dChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8uY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMiKTtyZXR1cm4gbn1mdW5jdGlvbiBldChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MiKTtyZXR1cm4gbn1mdW5jdGlvbiBpZShvLG4pe2lmKCFXKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoInJvdyBpbmRpY2VzIG11c3QgYmUgYW4gYXJyYXkiKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihuW2VdPDB8fG5bZV0+PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigicm93IGluZGljZXMgYXJlIG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIGxlKG8sbil7aWYoIVcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiY29sdW1uIGluZGljZXMgbXVzdCBiZSBhbiBhcnJheSIpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKG5bZV08MHx8bltlXT49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gRnQobyxuLGUsdCxzKXtpZihhcmd1bWVudHMubGVuZ3RoIT09NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiZXhwZWN0ZWQgNCBhcmd1bWVudHMiKTtpZihhdCgic3RhcnRSb3ciLG4pLGF0KCJlbmRSb3ciLGUpLGF0KCJzdGFydENvbHVtbiIsdCksYXQoImVuZENvbHVtbiIscyksbj5lfHx0PnN8fG48MHx8bj49by5yb3dzfHxlPDB8fGU+PW8ucm93c3x8dDwwfHx0Pj1vLmNvbHVtbnN8fHM8MHx8cz49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gZ3QobyxuPTApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8bzt0KyspZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGF0KG8sbil7aWYodHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gbXVzdCBiZSBhIG51bWJlcmApfWZ1bmN0aW9uIG50KG8pe2lmKG8uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgbWF0cml4IGhhcyBubyBlbGVtZW50cyB0byBpbmRleCIpfWZ1bmN0aW9uIGhlKG8pe2xldCBuPWd0KG8ucm93cyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW2VdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIHVlKG8pe2xldCBuPWd0KG8uY29sdW1ucyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW3RdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGNlKG8pe2xldCBuPTA7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyluKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGZlKG8pe2xldCBuPWd0KG8ucm93cywxKTtmb3IobGV0IGU9MDtlPG8ucm93czsrK2UpZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KW5bZV0qPW8uZ2V0KGUsdCk7cmV0dXJuIG59ZnVuY3Rpb24gZ2Uobyl7bGV0IG49Z3Qoby5jb2x1bW5zLDEpO2ZvcihsZXQgZT0wO2U8by5yb3dzOysrZSlmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3Qpblt0XSo9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBhZShvKXtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspbio9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBtZShvLG4sZSl7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHQ7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7ZjxzO2YrKyl1PW8uZ2V0KGksZiktZVtpXSxoKz11LGwrPXUqdTtuP3IucHVzaCgobC1oKmgvcykvKHMtMSkpOnIucHVzaCgobC1oKmgvcykvcyl9cmV0dXJuIHJ9ZnVuY3Rpb24gd2UobyxuLGUpe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9W107Zm9yKGxldCBpPTA7aTxzO2krKyl7bGV0IGg9MCxsPTAsdT0wO2ZvcihsZXQgZj0wO2Y8dDtmKyspdT1vLmdldChmLGkpLWVbaV0saCs9dSxsKz11KnU7bj9yLnB1c2goKGwtaCpoL3QpLyh0LTEpKTpyLnB1c2goKGwtaCpoL3QpL3QpfXJldHVybiByfWZ1bmN0aW9uIHBlKG8sbixlKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPXQqcztsZXQgaT0wLGg9MCxsPTA7Zm9yKGxldCB1PTA7dTx0O3UrKylmb3IobGV0IGY9MDtmPHM7ZisrKWw9by5nZXQodSxmKS1lLGkrPWwsaCs9bCpsO3JldHVybiBuPyhoLWkqaS9yKS8oci0xKTooaC1pKmkvcikvcn1mdW5jdGlvbiBkZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCktbltlXSl9ZnVuY3Rpb24geWUobyxuKXtmb3IobGV0IGU9MDtlPG8ucm93cztlKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KGUsdCxvLmdldChlLHQpLW5bdF0pfWZ1bmN0aW9uIE1lKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS1uKX1mdW5jdGlvbiBFZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8uY29sdW1ucztzKyspdCs9TWF0aC5wb3coby5nZXQoZSxzKSwyKS8oby5jb2x1bW5zLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIFNlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW2VdKX1mdW5jdGlvbiBqZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5jb2x1bW5zO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8ucm93cztzKyspdCs9TWF0aC5wb3coby5nZXQocyxlKSwyKS8oby5yb3dzLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIGtlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW3RdKX1mdW5jdGlvbiBiZShvKXtjb25zdCBuPW8uc2l6ZS0xO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyllKz1NYXRoLnBvdyhvLmdldChzLHQpLDIpL247cmV0dXJuIE1hdGguc3FydChlKX1mdW5jdGlvbiBJZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCkvbil9Y2xhc3MgX3tzdGF0aWMgZnJvbTFEQXJyYXkobixlLHQpe2lmKG4qZSE9PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zIik7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHRbaSplK2hdKTtyZXR1cm4gcn1zdGF0aWMgcm93VmVjdG9yKG4pe2xldCBlPW5ldyBiKDEsbi5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KDAsdCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgY29sdW1uVmVjdG9yKG4pe2xldCBlPW5ldyBiKG4ubGVuZ3RoLDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KHQsMCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgemVyb3MobixlKXtyZXR1cm4gbmV3IGIobixlKX1zdGF0aWMgb25lcyhuLGUpe3JldHVybiBuZXcgYihuLGUpLmZpbGwoMSl9c3RhdGljIHJhbmQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cmFuZG9tOnM9TWF0aC5yYW5kb219PXQ7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHMoKSk7cmV0dXJuIHJ9c3RhdGljIHJhbmRJbnQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7bWluOnM9MCxtYXg6cj0xZTMscmFuZG9tOmk9TWF0aC5yYW5kb219PXQ7aWYoIU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWluIG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1heCBtdXN0IGJlIGFuIGludGVnZXIiKTtpZihzPj1yKXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IGg9ci1zLGw9bmV3IGIobixlKTtmb3IobGV0IHU9MDt1PG47dSsrKWZvcihsZXQgZj0wO2Y8ZTtmKyspe2xldCBnPXMrTWF0aC5yb3VuZChpKCkqaCk7bC5zZXQodSxmLGcpfXJldHVybiBsfXN0YXRpYyBleWUobixlLHQpe2U9PT12b2lkIDAmJihlPW4pLHQ9PT12b2lkIDAmJih0PTEpO2xldCBzPU1hdGgubWluKG4sZSkscj10aGlzLnplcm9zKG4sZSk7Zm9yKGxldCBpPTA7aTxzO2krKylyLnNldChpLGksdCk7cmV0dXJuIHJ9c3RhdGljIGRpYWcobixlLHQpe2xldCBzPW4ubGVuZ3RoO2U9PT12b2lkIDAmJihlPXMpLHQ9PT12b2lkIDAmJih0PWUpO2xldCByPU1hdGgubWluKHMsZSx0KSxpPXRoaXMuemVyb3MoZSx0KTtmb3IobGV0IGg9MDtoPHI7aCsrKWkuc2V0KGgsaCxuW2hdKTtyZXR1cm4gaX1zdGF0aWMgbWluKG4sZSl7bj10aGlzLmNoZWNrTWF0cml4KG4pLGU9dGhpcy5jaGVja01hdHJpeChlKTtsZXQgdD1uLnJvd3Mscz1uLmNvbHVtbnMscj1uZXcgYih0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5taW4obi5nZXQoaSxoKSxlLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIG1heChuLGUpe249dGhpcy5jaGVja01hdHJpeChuKSxlPXRoaXMuY2hlY2tNYXRyaXgoZSk7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IHRoaXModCxzKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgaD0wO2g8cztoKyspci5zZXQoaSxoLE1hdGgubWF4KG4uZ2V0KGksaCksZS5nZXQoaSxoKSkpO3JldHVybiByfXN0YXRpYyBjaGVja01hdHJpeChuKXtyZXR1cm4gXy5pc01hdHJpeChuKT9uOm5ldyBiKG4pfXN0YXRpYyBpc01hdHJpeChuKXtyZXR1cm4gbiE9bnVsbCYmbi5rbGFzcz09PSJNYXRyaXgifWdldCBzaXplKCl7cmV0dXJuIHRoaXMucm93cyp0aGlzLmNvbHVtbnN9YXBwbHkobil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluLmNhbGwodGhpcyxlLHQpO3JldHVybiB0aGlzfXRvMURBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXRvMkRBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKyl7bi5wdXNoKFtdKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspbltlXS5wdXNoKHRoaXMuZ2V0KGUsdCkpfXJldHVybiBufXRvSlNPTigpe3JldHVybiB0aGlzLnRvMkRBcnJheSgpfWlzUm93VmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF9aXNDb2x1bW5WZWN0b3IoKXtyZXR1cm4gdGhpcy5jb2x1bW5zPT09MX1pc1ZlY3Rvcigpe3JldHVybiB0aGlzLnJvd3M9PT0xfHx0aGlzLmNvbHVtbnM9PT0xfWlzU3F1YXJlKCl7cmV0dXJuIHRoaXMucm93cz09PXRoaXMuY29sdW1uc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMucm93cz09PTB8fHRoaXMuY29sdW1ucz09PTB9aXNTeW1tZXRyaWMoKXtpZih0aGlzLmlzU3F1YXJlKCkpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IGU9MDtlPD1uO2UrKylpZih0aGlzLmdldChuLGUpIT09dGhpcy5nZXQoZSxuKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1pc0VjaGVsb25Gb3JtKCl7bGV0IG49MCxlPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtuPHRoaXMucm93cyYmczspe2ZvcihlPTAscj0hMTtlPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChuLGUpPT09MD9lKys6dGhpcy5nZXQobixlKT09PTEmJmU+dD8ocj0hMCx0PWUpOihzPSExLHI9ITApO24rK31yZXR1cm4gc31pc1JlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBuPTAsZT0wLHQ9LTEscz0hMCxyPSExO2Zvcig7bjx0aGlzLnJvd3MmJnM7KXtmb3IoZT0wLHI9ITE7ZTx0aGlzLmNvbHVtbnMmJnI9PT0hMTspdGhpcy5nZXQobixlKT09PTA/ZSsrOnRoaXMuZ2V0KG4sZSk9PT0xJiZlPnQ/KHI9ITAsdD1lKToocz0hMSxyPSEwKTtmb3IobGV0IGk9ZSsxO2k8dGhpcy5yb3dzO2krKyl0aGlzLmdldChuLGkpIT09MCYmKHM9ITEpO24rK31yZXR1cm4gc31lY2hlbG9uRm9ybSgpe2xldCBuPXRoaXMuY2xvbmUoKSxlPTAsdD0wO2Zvcig7ZTxuLnJvd3MmJnQ8bi5jb2x1bW5zOyl7bGV0IHM9ZTtmb3IobGV0IHI9ZTtyPG4ucm93cztyKyspbi5nZXQocix0KT5uLmdldChzLHQpJiYocz1yKTtpZihuLmdldChzLHQpPT09MCl0Kys7ZWxzZXtuLnN3YXBSb3dzKGUscyk7bGV0IHI9bi5nZXQoZSx0KTtmb3IobGV0IGk9dDtpPG4uY29sdW1ucztpKyspbi5zZXQoZSxpLG4uZ2V0KGUsaSkvcik7Zm9yKGxldCBpPWUrMTtpPG4ucm93cztpKyspe2xldCBoPW4uZ2V0KGksdCkvbi5nZXQoZSx0KTtuLnNldChpLHQsMCk7Zm9yKGxldCBsPXQrMTtsPG4uY29sdW1ucztsKyspbi5zZXQoaSxsLG4uZ2V0KGksbCktbi5nZXQoZSxsKSpoKX1lKyssdCsrfX1yZXR1cm4gbn1yZWR1Y2VkRWNoZWxvbkZvcm0oKXtsZXQgbj10aGlzLmVjaGVsb25Gb3JtKCksZT1uLmNvbHVtbnMsdD1uLnJvd3Mscz10LTE7Zm9yKDtzPj0wOylpZihuLm1heFJvdyhzKT09PTApcy0tO2Vsc2V7bGV0IHI9MCxpPSExO2Zvcig7cjx0JiZpPT09ITE7KW4uZ2V0KHMscik9PT0xP2k9ITA6cisrO2ZvcihsZXQgaD0wO2g8cztoKyspe2xldCBsPW4uZ2V0KGgscik7Zm9yKGxldCB1PXI7dTxlO3UrKyl7bGV0IGY9bi5nZXQoaCx1KS1sKm4uZ2V0KHMsdSk7bi5zZXQoaCx1LGYpfX1zLS19cmV0dXJuIG59c2V0KCl7dGhyb3cgbmV3IEVycm9yKCJzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQiKX1nZXQoKXt0aHJvdyBuZXcgRXJyb3IoImdldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfXJlcGVhdChuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e3Jvd3M6ZT0xLGNvbHVtbnM6dD0xfT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoInJvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJjb2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIik7bGV0IHM9bmV3IGIodGhpcy5yb3dzKmUsdGhpcy5jb2x1bW5zKnQpO2ZvcihsZXQgcj0wO3I8ZTtyKyspZm9yKGxldCBpPTA7aTx0O2krKylzLnNldFN1Yk1hdHJpeCh0aGlzLHRoaXMucm93cypyLHRoaXMuY29sdW1ucyppKTtyZXR1cm4gc31maWxsKG4pe2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG4pO3JldHVybiB0aGlzfW5lZygpe3JldHVybiB0aGlzLm11bFMoLTEpfWdldFJvdyhuKXtRKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUucHVzaCh0aGlzLmdldChuLHQpKTtyZXR1cm4gZX1nZXRSb3dWZWN0b3Iobil7cmV0dXJuIGIucm93VmVjdG9yKHRoaXMuZ2V0Um93KG4pKX1zZXRSb3cobixlKXtRKHRoaXMsbiksZT10dCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZVt0XSk7cmV0dXJuIHRoaXN9c3dhcFJvd3MobixlKXtRKHRoaXMsbiksUSh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl7bGV0IHM9dGhpcy5nZXQobix0KTt0aGlzLnNldChuLHQsdGhpcy5nZXQoZSx0KSksdGhpcy5zZXQoZSx0LHMpfXJldHVybiB0aGlzfWdldENvbHVtbihuKXtaKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWUucHVzaCh0aGlzLmdldCh0LG4pKTtyZXR1cm4gZX1nZXRDb2x1bW5WZWN0b3Iobil7cmV0dXJuIGIuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKG4pKX1zZXRDb2x1bW4obixlKXtaKHRoaXMsbiksZT1ldCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLnNldCh0LG4sZVt0XSk7cmV0dXJuIHRoaXN9c3dhcENvbHVtbnMobixlKXtaKHRoaXMsbiksWih0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxuKTt0aGlzLnNldCh0LG4sdGhpcy5nZXQodCxlKSksdGhpcy5zZXQodCxlLHMpfXJldHVybiB0aGlzfWFkZFJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KStuW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3Iobil7bj10dCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCktblt0XSk7cmV0dXJuIHRoaXN9bXVsUm93VmVjdG9yKG4pe249dHQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpKm5bdF0pO3JldHVybiB0aGlzfWRpdlJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KS9uW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkrbltlXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKG4pe249ZXQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpLW5bZV0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihuKXtuPWV0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuW2VdKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkvbltlXSk7cmV0dXJuIHRoaXN9bXVsUm93KG4sZSl7USh0aGlzLG4pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4obixlKXtaKHRoaXMsbik7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsbix0aGlzLmdldCh0LG4pKmUpO3JldHVybiB0aGlzfW1heChuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk+ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1heEluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5uJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1pbihuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1pbkluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxuJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1heFJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPmUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1heFJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk+ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1pblJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPGUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1pblJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk8ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1heENvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPmUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1heENvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik+ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fW1pbkNvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPGUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1pbkNvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik8ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fWRpYWcoKXtsZXQgbj1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxlPVtdO2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHRoaXMuZ2V0KHQsdCkpO3JldHVybiBlfW5vcm0obj0iZnJvYmVuaXVzIil7bGV0IGU9MDtpZihuPT09Im1heCIpcmV0dXJuIHRoaXMubWF4KCk7aWYobj09PSJmcm9iZW5pdXMiKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKWU9ZSt0aGlzLmdldCh0LHMpKnRoaXMuZ2V0KHQscyk7cmV0dXJuIE1hdGguc3FydChlKX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHtufWApfWN1bXVsYXRpdmVTdW0oKXtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbis9dGhpcy5nZXQoZSx0KSx0aGlzLnNldChlLHQsbik7cmV0dXJuIHRoaXN9ZG90KG4pe18uaXNNYXRyaXgobikmJihuPW4udG8xREFycmF5KCkpO2xldCBlPXRoaXMudG8xREFycmF5KCk7aWYoZS5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBzaXplIik7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1lW3NdKm5bc107cmV0dXJuIHR9bW11bChuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9bi5jb2x1bW5zLHI9bmV3IGIoZSxzKSxpPW5ldyBGbG9hdDY0QXJyYXkodCk7Zm9yKGxldCBoPTA7aDxzO2grKyl7Zm9yKGxldCBsPTA7bDx0O2wrKylpW2xdPW4uZ2V0KGwsaCk7Zm9yKGxldCBsPTA7bDxlO2wrKyl7bGV0IHU9MDtmb3IobGV0IGY9MDtmPHQ7ZisrKXUrPXRoaXMuZ2V0KGwsZikqaVtmXTtyLnNldChsLGgsdSl9fXJldHVybiByfXN0cmFzc2VuMngyKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigyLDIpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPW4uZ2V0KDAsMCkscj10aGlzLmdldCgwLDEpLGk9bi5nZXQoMCwxKSxoPXRoaXMuZ2V0KDEsMCksbD1uLmdldCgxLDApLHU9dGhpcy5nZXQoMSwxKSxmPW4uZ2V0KDEsMSksZz0odCt1KSoocytmKSxhPShoK3UpKnMsaj10KihpLWYpLHc9dSoobC1zKSx5PSh0K3IpKmYsbT0oaC10KSoocytpKSxNPShyLXUpKihsK2YpLFQ9Zyt3LXkrTSxFPWoreSxrPWErdyxSPWctYStqK207cmV0dXJuIGUuc2V0KDAsMCxUKSxlLnNldCgwLDEsRSksZS5zZXQoMSwwLGspLGUuc2V0KDEsMSxSKSxlfXN0cmFzc2VuM3gzKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigzLDMpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPXRoaXMuZ2V0KDAsMSkscj10aGlzLmdldCgwLDIpLGk9dGhpcy5nZXQoMSwwKSxoPXRoaXMuZ2V0KDEsMSksbD10aGlzLmdldCgxLDIpLHU9dGhpcy5nZXQoMiwwKSxmPXRoaXMuZ2V0KDIsMSksZz10aGlzLmdldCgyLDIpLGE9bi5nZXQoMCwwKSxqPW4uZ2V0KDAsMSksdz1uLmdldCgwLDIpLHk9bi5nZXQoMSwwKSxtPW4uZ2V0KDEsMSksTT1uLmdldCgxLDIpLFQ9bi5nZXQoMiwwKSxFPW4uZ2V0KDIsMSksaz1uLmdldCgyLDIpLFI9KHQrcytyLWktaC1mLWcpKm0scT0odC1pKSooLWorbSksST1oKigtYStqK3ktbS1NLVQrayksej0oLXQraStoKSooYS1qK20pLEI9KGkraCkqKC1hK2opLGM9dCphLHA9KC10K3UrZikqKGEtdytNKSxTPSgtdCt1KSoody1NKSxkPSh1K2YpKigtYSt3KSxEPSh0K3Mrci1oLWwtdS1mKSpNLFU9ZiooLWErdyt5LW0tTS1UK0UpLEY9KC1yK2YrZykqKG0rVC1FKSxQPShyLWcpKihtLUUpLFk9cipULEc9KGYrZykqKC1UK0UpLE49KC1yK2grbCkqKE0rVC1rKSwkPShyLWwpKihNLWspLEs9KGgrbCkqKC1UK2spLHY9cyp5LFY9bCpFLEw9aSp3LEM9dSpqLFg9ZyprLHd0PWMrWSt2LHB0PVIreitCK2MrRitZK0csZHQ9YytwK2QrRCtZK04rSyxpdD1xK0kreitjK1krTiskLGx0PXEreitCK2MrVixodD1ZK04rJCtLK0wsanQ9YytwK1MrVStGK1ArWSx1dD1GK1ArWStHK0Msa3Q9YytwK1MrZCtYO3JldHVybiBlLnNldCgwLDAsd3QpLGUuc2V0KDAsMSxwdCksZS5zZXQoMCwyLGR0KSxlLnNldCgxLDAsaXQpLGUuc2V0KDEsMSxsdCksZS5zZXQoMSwyLGh0KSxlLnNldCgyLDAsanQpLGUuc2V0KDIsMSx1dCksZS5zZXQoMiwyLGt0KSxlfW1tdWxTdHJhc3NlbihuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5jbG9uZSgpLHQ9ZS5yb3dzLHM9ZS5jb2x1bW5zLHI9bi5yb3dzLGk9bi5jb2x1bW5zO3MhPT1yJiZjb25zb2xlLndhcm4oYE11bHRpcGx5aW5nICR7dH0geCAke3N9IGFuZCAke3J9IHggJHtpfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO2Z1bmN0aW9uIGgoZyxhLGope2xldCB3PWcucm93cyx5PWcuY29sdW1ucztpZih3PT09YSYmeT09PWopcmV0dXJuIGc7e2xldCBtPV8uemVyb3MoYSxqKTtyZXR1cm4gbT1tLnNldFN1Yk1hdHJpeChnLDAsMCksbX19bGV0IGw9TWF0aC5tYXgodCxyKSx1PU1hdGgubWF4KHMsaSk7ZT1oKGUsbCx1KSxuPWgobixsLHUpO2Z1bmN0aW9uIGYoZyxhLGosdyl7aWYoajw9NTEyfHx3PD01MTIpcmV0dXJuIGcubW11bChhKTtqJTI9PT0xJiZ3JTI9PT0xPyhnPWgoZyxqKzEsdysxKSxhPWgoYSxqKzEsdysxKSk6aiUyPT09MT8oZz1oKGcsaisxLHcpLGE9aChhLGorMSx3KSk6dyUyPT09MSYmKGc9aChnLGosdysxKSxhPWgoYSxqLHcrMSkpO2xldCB5PXBhcnNlSW50KGcucm93cy8yLDEwKSxtPXBhcnNlSW50KGcuY29sdW1ucy8yLDEwKSxNPWcuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxUPWEuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxFPWcuc3ViTWF0cml4KDAseS0xLG0sZy5jb2x1bW5zLTEpLGs9YS5zdWJNYXRyaXgoMCx5LTEsbSxhLmNvbHVtbnMtMSksUj1nLnN1Yk1hdHJpeCh5LGcucm93cy0xLDAsbS0xKSxxPWEuc3ViTWF0cml4KHksYS5yb3dzLTEsMCxtLTEpLEk9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSxtLGcuY29sdW1ucy0xKSx6PWEuc3ViTWF0cml4KHksYS5yb3dzLTEsbSxhLmNvbHVtbnMtMSksQj1mKF8uYWRkKE0sSSksXy5hZGQoVCx6KSx5LG0pLGM9ZihfLmFkZChSLEkpLFQseSxtKSxwPWYoTSxfLnN1YihrLHopLHksbSksUz1mKEksXy5zdWIocSxUKSx5LG0pLGQ9ZihfLmFkZChNLEUpLHoseSxtKSxEPWYoXy5zdWIoUixNKSxfLmFkZChULGspLHksbSksVT1mKF8uc3ViKEUsSSksXy5hZGQocSx6KSx5LG0pLEY9Xy5hZGQoQixTKTtGLnN1YihkKSxGLmFkZChVKTtsZXQgUD1fLmFkZChwLGQpLFk9Xy5hZGQoYyxTKSxHPV8uc3ViKEIsYyk7Ry5hZGQocCksRy5hZGQoRCk7bGV0IE49Xy56ZXJvcygyKkYucm93cywyKkYuY29sdW1ucyk7cmV0dXJuIE49Ti5zZXRTdWJNYXRyaXgoRiwwLDApLE49Ti5zZXRTdWJNYXRyaXgoUCxGLnJvd3MsMCksTj1OLnNldFN1Yk1hdHJpeChZLDAsRi5jb2x1bW5zKSxOPU4uc2V0U3ViTWF0cml4KEcsRi5yb3dzLEYuY29sdW1ucyksTi5zdWJNYXRyaXgoMCxqLTEsMCx3LTEpfXJldHVybiBmKGUsbixsLHUpfXNjYWxlUm93cyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMucm93cztyKyspe2NvbnN0IGk9dGhpcy5nZXRSb3cocik7aS5sZW5ndGg+MCYmcXQoaSx7bWluOmUsbWF4OnQsb3V0cHV0Oml9KSxzLnNldFJvdyhyLGkpfXJldHVybiBzfXNjYWxlQ29sdW1ucyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspe2NvbnN0IGk9dGhpcy5nZXRDb2x1bW4ocik7aS5sZW5ndGgmJnF0KGkse21pbjplLG1heDp0LG91dHB1dDppfSkscy5zZXRDb2x1bW4ocixpKX1yZXR1cm4gc31mbGlwUm93cygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMuY29sdW1ucy8yKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQoZSx0KSxyPXRoaXMuZ2V0KGUsdGhpcy5jb2x1bW5zLTEtdCk7dGhpcy5zZXQoZSx0LHIpLHRoaXMuc2V0KGUsdGhpcy5jb2x1bW5zLTEtdCxzKX1yZXR1cm4gdGhpc31mbGlwQ29sdW1ucygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMucm93cy8yKTtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxlKSxyPXRoaXMuZ2V0KHRoaXMucm93cy0xLXQsZSk7dGhpcy5zZXQodCxlLHIpLHRoaXMuc2V0KHRoaXMucm93cy0xLXQsZSxzKX1yZXR1cm4gdGhpc31rcm9uZWNrZXJQcm9kdWN0KG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT10aGlzLnJvd3MsdD10aGlzLmNvbHVtbnMscz1uLnJvd3Mscj1uLmNvbHVtbnMsaT1uZXcgYihlKnMsdCpyKTtmb3IobGV0IGg9MDtoPGU7aCsrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCB1PTA7dTxzO3UrKylmb3IobGV0IGY9MDtmPHI7ZisrKWkuc2V0KHMqaCt1LHIqbCtmLHRoaXMuZ2V0KGgsbCkqbi5nZXQodSxmKSk7cmV0dXJuIGl9a3JvbmVja2VyU3VtKG4pe2lmKG49Yi5jaGVja01hdHJpeChuKSwhdGhpcy5pc1NxdWFyZSgpfHwhbi5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiS3JvbmVja2VyIFN1bSBuZWVkcyB0d28gU3F1YXJlIE1hdHJpY2VzIik7bGV0IGU9dGhpcy5yb3dzLHQ9bi5yb3dzLHM9dGhpcy5rcm9uZWNrZXJQcm9kdWN0KGIuZXllKHQsdCkpLHI9Yi5leWUoZSxlKS5rcm9uZWNrZXJQcm9kdWN0KG4pO3JldHVybiBzLmFkZChyKX10cmFuc3Bvc2UoKXtsZXQgbj1uZXcgYih0aGlzLmNvbHVtbnMsdGhpcy5yb3dzKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKW4uc2V0KHQsZSx0aGlzLmdldChlLHQpKTtyZXR1cm4gbn1zb3J0Um93cyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspdGhpcy5zZXRSb3coZSx0aGlzLmdldFJvdyhlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zb3J0Q29sdW1ucyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspdGhpcy5zZXRDb2x1bW4oZSx0aGlzLmdldENvbHVtbihlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zdWJNYXRyaXgobixlLHQscyl7RnQodGhpcyxuLGUsdCxzKTtsZXQgcj1uZXcgYihlLW4rMSxzLXQrMSk7Zm9yKGxldCBpPW47aTw9ZTtpKyspZm9yKGxldCBoPXQ7aDw9cztoKyspci5zZXQoaS1uLGgtdCx0aGlzLmdldChpLGgpKTtyZXR1cm4gcn1zdWJNYXRyaXhSb3cobixlLHQpe2lmKGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PXRoaXMuY29sdW1ucy0xKSxlPnR8fGU8MHx8ZT49dGhpcy5jb2x1bW5zfHx0PDB8fHQ+PXRoaXMuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXJndW1lbnQgb3V0IG9mIHJhbmdlIik7bGV0IHM9bmV3IGIobi5sZW5ndGgsdC1lKzEpO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWZvcihsZXQgaT1lO2k8PXQ7aSsrKXtpZihuW3JdPDB8fG5bcl0+PXRoaXMucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm93IGluZGV4IG91dCBvZiByYW5nZTogJHtuW3JdfWApO3Muc2V0KHIsaS1lLHRoaXMuZ2V0KG5bcl0saSkpfXJldHVybiBzfXN1Yk1hdHJpeENvbHVtbihuLGUsdCl7aWYoZT09PXZvaWQgMCYmKGU9MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5yb3dzLTEpLGU+dHx8ZTwwfHxlPj10aGlzLnJvd3N8fHQ8MHx8dD49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgYih0LWUrMSxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspZm9yKGxldCBpPWU7aTw9dDtpKyspe2lmKG5bcl08MHx8bltyXT49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKGBDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlOiAke25bcl19YCk7cy5zZXQoaS1lLHIsdGhpcy5nZXQoaSxuW3JdKSl9cmV0dXJuIHN9c2V0U3ViTWF0cml4KG4sZSx0KXtpZihuPWIuY2hlY2tNYXRyaXgobiksbi5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7bGV0IHM9ZStuLnJvd3MtMSxyPXQrbi5jb2x1bW5zLTE7RnQodGhpcyxlLHMsdCxyKTtmb3IobGV0IGk9MDtpPG4ucm93cztpKyspZm9yKGxldCBoPTA7aDxuLmNvbHVtbnM7aCsrKXRoaXMuc2V0KGUraSx0K2gsbi5nZXQoaSxoKSk7cmV0dXJuIHRoaXN9c2VsZWN0aW9uKG4sZSl7aWUodGhpcyxuKSxsZSh0aGlzLGUpO2xldCB0PW5ldyBiKG4ubGVuZ3RoLGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9bltzXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl7bGV0IGg9ZVtpXTt0LnNldChzLGksdGhpcy5nZXQocixoKSl9fXJldHVybiB0fXRyYWNlKCl7bGV0IG49TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksZT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspZSs9dGhpcy5nZXQodCx0KTtyZXR1cm4gZX1jbG9uZSgpe2xldCBuPW5ldyBiKHRoaXMucm93cyx0aGlzLmNvbHVtbnMpO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXN1bShuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBoZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIHVlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBjZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19cHJvZHVjdChuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBmZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIGdlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBhZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19bWVhbihuKXtjb25zdCBlPXRoaXMuc3VtKG4pO3N3aXRjaChuKXtjYXNlInJvdyI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyllW3RdLz10aGlzLmNvbHVtbnM7cmV0dXJuIGV9Y2FzZSJjb2x1bW4iOntmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZVt0XS89dGhpcy5yb3dzO3JldHVybiBlfWNhc2Ugdm9pZCAwOnJldHVybiBlL3RoaXMuc2l6ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19dmFyaWFuY2UobixlPXt9KXtpZih0eXBlb2Ygbj09Im9iamVjdCImJihlPW4sbj12b2lkIDApLHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7dW5iaWFzZWQ6dD0hMCxtZWFuOnM9dGhpcy5tZWFuKG4pfT1lO2lmKHR5cGVvZiB0IT0iYm9vbGVhbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5iaWFzZWQgbXVzdCBiZSBhIGJvb2xlYW4iKTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gbWUodGhpcyx0LHMpfWNhc2UiY29sdW1uIjp7aWYoIVcocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHdlKHRoaXMsdCxzKX1jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHMhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBwZSh0aGlzLHQscyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXN0YW5kYXJkRGV2aWF0aW9uKG4sZSl7dHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKTtjb25zdCB0PXRoaXMudmFyaWFuY2UobixlKTtpZihuPT09dm9pZCAwKXJldHVybiBNYXRoLnNxcnQodCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXT1NYXRoLnNxcnQodFtzXSk7cmV0dXJuIHR9Y2VudGVyKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e2NlbnRlcjp0PXRoaXMubWVhbihuKX09ZTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBkZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiB5ZSh0aGlzLHQpLHRoaXN9Y2FzZSB2b2lkIDA6e2lmKHR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBNZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXNjYWxlKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2xldCB0PWUuc2NhbGU7c3dpdGNoKG4pe2Nhc2Uicm93Ijp7aWYodD09PXZvaWQgMCl0PUVlKHRoaXMpO2Vsc2UgaWYoIVcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBTZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZih0PT09dm9pZCAwKXQ9amUodGhpcyk7ZWxzZSBpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGtlKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodD09PXZvaWQgMCl0PWJlKHRoaXMpO2Vsc2UgaWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYSBudW1iZXIiKTtyZXR1cm4gSWUodGhpcyx0KSx0aGlzfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtufWApfX10b1N0cmluZyhuKXtyZXR1cm4gVHQodGhpcyxuKX19Xy5wcm90b3R5cGUua2xhc3M9Ik1hdHJpeCIsdHlwZW9mIFN5bWJvbDwidSImJihfLnByb3RvdHlwZVtTeW1ib2wuZm9yKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpXT1uZSk7ZnVuY3Rpb24gUHQobyxuKXtyZXR1cm4gby1ufWZ1bmN0aW9uIFJlKG8pe3JldHVybiBvLmV2ZXJ5KG49PnR5cGVvZiBuPT0ibnVtYmVyIil9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgYiBleHRlbmRzIF97Y29uc3RydWN0b3IobixlKXtpZihzdXBlcigpLGIuaXNNYXRyaXgobikpcmV0dXJuIG4uY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWZvcihsZXQgdD0wO3Q8bjt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShlKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoVyhuKSl7Y29uc3QgdD1uO2lmKG49dC5sZW5ndGgsZT1uP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIGUhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxuO3MrKyl7aWYodFtzXS5sZW5ndGghPT1lKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO2lmKCFSZSh0W3NdKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnB1dCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPW4sdGhpcy5jb2x1bW5zPWV9c2V0KG4sZSx0KXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdPXQsdGhpc31nZXQobixlKXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdfXJlbW92ZVJvdyhuKXtyZXR1cm4gUSh0aGlzLG4pLHRoaXMuZGF0YS5zcGxpY2UobiwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3cobixlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9bixuPXRoaXMucm93cyksUSh0aGlzLG4sITApLGU9RmxvYXQ2NEFycmF5LmZyb20odHQodGhpcyxlKSksdGhpcy5kYXRhLnNwbGljZShuLDAsZSksdGhpcy5yb3dzKz0xLHRoaXN9cmVtb3ZlQ29sdW1uKG4pe1oodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl0W3NdPXRoaXMuZGF0YVtlXVtzXTtmb3IobGV0IHM9bisxO3M8dGhpcy5jb2x1bW5zO3MrKyl0W3MtMV09dGhpcy5kYXRhW2VdW3NdO3RoaXMuZGF0YVtlXT10fXJldHVybiB0aGlzLmNvbHVtbnMtPTEsdGhpc31hZGRDb2x1bW4obixlKXt0eXBlb2YgZT4idSImJihlPW4sbj10aGlzLmNvbHVtbnMpLFoodGhpcyxuLCEwKSxlPWV0KHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXtjb25zdCBzPW5ldyBGbG9hdDY0QXJyYXkodGhpcy5jb2x1bW5zKzEpO2xldCByPTA7Zm9yKDtyPG47cisrKXNbcl09dGhpcy5kYXRhW3RdW3JdO2ZvcihzW3IrK109ZVt0XTtyPHRoaXMuY29sdW1ucysxO3IrKylzW3JdPXRoaXMuZGF0YVt0XVtyLTFdO3RoaXMuZGF0YVt0XT1zfXJldHVybiB0aGlzLmNvbHVtbnMrPTEsdGhpc319cmUoXyxiKTtjbGFzcyBzdCBleHRlbmRzIF97Y29uc3RydWN0b3Iobil7c3VwZXIoKSx0aGlzLmRhdGE9bix0aGlzLnJvd3M9bi5sZW5ndGgsdGhpcy5jb2x1bW5zPW5bMF0ubGVuZ3RofXNldChuLGUsdCl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXT10LHRoaXN9Z2V0KG4sZSl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXX19Y2xhc3MgTmV7Y29uc3RydWN0b3Iobil7bj1zdC5jaGVja01hdHJpeChuKTtsZXQgZT1uLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHQpLGk9MSxoLGwsdSxmLGcsYSxqLHcseTtmb3IoaD0wO2g8dDtoKyspcltoXT1oO2Zvcih3PW5ldyBGbG9hdDY0QXJyYXkodCksbD0wO2w8cztsKyspe2ZvcihoPTA7aDx0O2grKyl3W2hdPWUuZ2V0KGgsbCk7Zm9yKGg9MDtoPHQ7aCsrKXtmb3IoeT1NYXRoLm1pbihoLGwpLGc9MCx1PTA7dTx5O3UrKylnKz1lLmdldChoLHUpKndbdV07d1toXS09ZyxlLnNldChoLGwsd1toXSl9Zm9yKGY9bCxoPWwrMTtoPHQ7aCsrKU1hdGguYWJzKHdbaF0pPk1hdGguYWJzKHdbZl0pJiYoZj1oKTtpZihmIT09bCl7Zm9yKHU9MDt1PHM7dSsrKWE9ZS5nZXQoZix1KSxlLnNldChmLHUsZS5nZXQobCx1KSksZS5zZXQobCx1LGEpO2o9cltmXSxyW2ZdPXJbbF0scltsXT1qLGk9LWl9aWYobDx0JiZlLmdldChsLGwpIT09MClmb3IoaD1sKzE7aDx0O2grKyllLnNldChoLGwsZS5nZXQoaCxsKS9lLmdldChsLGwpKX10aGlzLkxVPWUsdGhpcy5waXZvdFZlY3Rvcj1yLHRoaXMucGl2b3RTaWduPWl9aXNTaW5ndWxhcigpe2xldCBuPXRoaXMuTFUsZT1uLmNvbHVtbnM7Zm9yKGxldCB0PTA7dDxlO3QrKylpZihuLmdldCh0LHQpPT09MClyZXR1cm4hMDtyZXR1cm4hMX1zb2x2ZShuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5MVTtpZihlLnJvd3MhPT1uLnJvd3MpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zIik7aWYodGhpcy5pc1Npbmd1bGFyKCkpdGhyb3cgbmV3IEVycm9yKCJMVSBtYXRyaXggaXMgc2luZ3VsYXIiKTtsZXQgcz1uLmNvbHVtbnMscj1uLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLDAscy0xKSxpPWUuY29sdW1ucyxoLGwsdTtmb3IodT0wO3U8aTt1KyspZm9yKGg9dSsxO2g8aTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqZS5nZXQoaCx1KSk7Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvZS5nZXQodSx1KSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKmUuZ2V0KGgsdSkpfXJldHVybiByfWdldCBkZXRlcm1pbmFudCgpe2xldCBuPXRoaXMuTFU7aWYoIW4uaXNTcXVhcmUoKSl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCBtdXN0IGJlIHNxdWFyZSIpO2xldCBlPXRoaXMucGl2b3RTaWduLHQ9bi5jb2x1bW5zO2ZvcihsZXQgcz0wO3M8dDtzKyspZSo9bi5nZXQocyxzKTtyZXR1cm4gZX1nZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI+aT9zLnNldChyLGksbi5nZXQocixpKSk6cj09PWk/cy5zZXQocixpLDEpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI8PWk/cy5zZXQocixpLG4uZ2V0KHIsaSkpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgcGl2b3RQZXJtdXRhdGlvblZlY3Rvcigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucGl2b3RWZWN0b3IpfX1mdW5jdGlvbiB4KG8sbil7bGV0IGU9MDtyZXR1cm4gTWF0aC5hYnMobyk+TWF0aC5hYnMobik/KGU9bi9vLE1hdGguYWJzKG8pKk1hdGguc3FydCgxK2UqZSkpOm4hPT0wPyhlPW8vbixNYXRoLmFicyhuKSpNYXRoLnNxcnQoMStlKmUpKTowfWNsYXNzIHZle2NvbnN0cnVjdG9yKG4pe249c3QuY2hlY2tNYXRyaXgobik7bGV0IGU9bi5jbG9uZSgpLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IEZsb2F0NjRBcnJheShzKSxpLGgsbCx1O2ZvcihsPTA7bDxzO2wrKyl7bGV0IGY9MDtmb3IoaT1sO2k8dDtpKyspZj14KGYsZS5nZXQoaSxsKSk7aWYoZiE9PTApe2ZvcihlLmdldChsLGwpPDAmJihmPS1mKSxpPWw7aTx0O2krKyllLnNldChpLGwsZS5nZXQoaSxsKS9mKTtmb3IoZS5zZXQobCxsLGUuZ2V0KGwsbCkrMSksaD1sKzE7aDxzO2grKyl7Zm9yKHU9MCxpPWw7aTx0O2krKyl1Kz1lLmdldChpLGwpKmUuZ2V0KGksaCk7Zm9yKHU9LXUvZS5nZXQobCxsKSxpPWw7aTx0O2krKyllLnNldChpLGgsZS5nZXQoaSxoKSt1KmUuZ2V0KGksbCkpfX1yW2xdPS1mfXRoaXMuUVI9ZSx0aGlzLlJkaWFnPXJ9c29sdmUobil7bj1iLmNoZWNrTWF0cml4KG4pO2xldCBlPXRoaXMuUVIsdD1lLnJvd3M7aWYobi5yb3dzIT09dCl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlIik7aWYoIXRoaXMuaXNGdWxsUmFuaygpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Iik7bGV0IHM9bi5jb2x1bW5zLHI9bi5jbG9uZSgpLGk9ZS5jb2x1bW5zLGgsbCx1LGY7Zm9yKHU9MDt1PGk7dSsrKWZvcihsPTA7bDxzO2wrKyl7Zm9yKGY9MCxoPXU7aDx0O2grKylmKz1lLmdldChoLHUpKnIuZ2V0KGgsbCk7Zm9yKGY9LWYvZS5nZXQodSx1KSxoPXU7aDx0O2grKylyLnNldChoLGwsci5nZXQoaCxsKStmKmUuZ2V0KGgsdSkpfWZvcih1PWktMTt1Pj0wO3UtLSl7Zm9yKGw9MDtsPHM7bCsrKXIuc2V0KHUsbCxyLmdldCh1LGwpL3RoaXMuUmRpYWdbdV0pO2ZvcihoPTA7aDx1O2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSplLmdldChoLHUpKX1yZXR1cm4gci5zdWJNYXRyaXgoMCxpLTEsMCxzLTEpfWlzRnVsbFJhbmsoKXtsZXQgbj10aGlzLlFSLmNvbHVtbnM7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZih0aGlzLlJkaWFnW2VdPT09MClyZXR1cm4hMTtyZXR1cm4hMH1nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4uY29sdW1ucyx0PW5ldyBiKGUsZSkscyxyO2ZvcihzPTA7czxlO3MrKylmb3Iocj0wO3I8ZTtyKyspczxyP3Quc2V0KHMscixuLmdldChzLHIpKTpzPT09cj90LnNldChzLHIsdGhpcy5SZGlhZ1tzXSk6dC5zZXQocyxyLDApO3JldHVybiB0fWdldCBvcnRob2dvbmFsTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCkscixpLGgsbDtmb3IoaD10LTE7aD49MDtoLS0pe2ZvcihyPTA7cjxlO3IrKylzLnNldChyLGgsMCk7Zm9yKHMuc2V0KGgsaCwxKSxpPWg7aTx0O2krKylpZihuLmdldChoLGgpIT09MCl7Zm9yKGw9MCxyPWg7cjxlO3IrKylsKz1uLmdldChyLGgpKnMuZ2V0KHIsaSk7Zm9yKGw9LWwvbi5nZXQoaCxoKSxyPWg7cjxlO3IrKylzLnNldChyLGkscy5nZXQocixpKStsKm4uZ2V0KHIsaCkpfX1yZXR1cm4gc319Y2xhc3MgRHR7Y29uc3RydWN0b3IobixlPXt9KXtpZihuPXN0LmNoZWNrTWF0cml4KG4pLG4uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgbm9uLWVtcHR5Iik7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zO2NvbnN0e2NvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzOnI9ITAsY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzOmk9ITAsYXV0b1RyYW5zcG9zZTpoPSExfT1lO2xldCBsPSEhcix1PSEhaSxmPSExLGc7aWYodDxzKWlmKCFoKWc9bi5jbG9uZSgpLGNvbnNvbGUud2FybigiQ29tcHV0aW5nIFNWRCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgY29sdW1ucyB0aGFuIHJvd3MuIENvbnNpZGVyIGVuYWJsaW5nIGF1dG9UcmFuc3Bvc2UiKTtlbHNle2c9bi50cmFuc3Bvc2UoKSx0PWcucm93cyxzPWcuY29sdW1ucyxmPSEwO2xldCBjPWw7bD11LHU9Y31lbHNlIGc9bi5jbG9uZSgpO2xldCBhPU1hdGgubWluKHQscyksaj1NYXRoLm1pbih0KzEscyksdz1uZXcgRmxvYXQ2NEFycmF5KGopLHk9bmV3IGIodCxhKSxtPW5ldyBiKHMscyksTT1uZXcgRmxvYXQ2NEFycmF5KHMpLFQ9bmV3IEZsb2F0NjRBcnJheSh0KSxFPW5ldyBGbG9hdDY0QXJyYXkoaik7Zm9yKGxldCBjPTA7YzxqO2MrKylFW2NdPWM7bGV0IGs9TWF0aC5taW4odC0xLHMpLFI9TWF0aC5tYXgoMCxNYXRoLm1pbihzLTIsdCkpLHE9TWF0aC5tYXgoayxSKTtmb3IobGV0IGM9MDtjPHE7YysrKXtpZihjPGspe3dbY109MDtmb3IobGV0IHA9YztwPHQ7cCsrKXdbY109eCh3W2NdLGcuZ2V0KHAsYykpO2lmKHdbY10hPT0wKXtnLmdldChjLGMpPDAmJih3W2NdPS13W2NdKTtmb3IobGV0IHA9YztwPHQ7cCsrKWcuc2V0KHAsYyxnLmdldChwLGMpL3dbY10pO2cuc2V0KGMsYyxnLmdldChjLGMpKzEpfXdbY109LXdbY119Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtpZihjPGsmJndbY10hPT0wKXtsZXQgUz0wO2ZvcihsZXQgZD1jO2Q8dDtkKyspUys9Zy5nZXQoZCxjKSpnLmdldChkLHApO1M9LVMvZy5nZXQoYyxjKTtmb3IobGV0IGQ9YztkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqZy5nZXQoZCxjKSl9TVtwXT1nLmdldChjLHApfWlmKGwmJmM8aylmb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYyxnLmdldChwLGMpKTtpZihjPFIpe01bY109MDtmb3IobGV0IHA9YysxO3A8cztwKyspTVtjXT14KE1bY10sTVtwXSk7aWYoTVtjXSE9PTApe01bYysxXTwwJiYoTVtjXT0wLU1bY10pO2ZvcihsZXQgcD1jKzE7cDxzO3ArKylNW3BdLz1NW2NdO01bYysxXSs9MX1pZihNW2NdPS1NW2NdLGMrMTx0JiZNW2NdIT09MCl7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKVRbcF09MDtmb3IobGV0IHA9YysxO3A8dDtwKyspZm9yKGxldCBTPWMrMTtTPHM7UysrKVRbcF0rPU1bU10qZy5nZXQocCxTKTtmb3IobGV0IHA9YysxO3A8cztwKyspe2xldCBTPS1NW3BdL01bYysxXTtmb3IobGV0IGQ9YysxO2Q8dDtkKyspZy5zZXQoZCxwLGcuZ2V0KGQscCkrUypUW2RdKX19aWYodSlmb3IobGV0IHA9YysxO3A8cztwKyspbS5zZXQocCxjLE1bcF0pfX1sZXQgST1NYXRoLm1pbihzLHQrMSk7aWYoazxzJiYod1trXT1nLmdldChrLGspKSx0PEkmJih3W0ktMV09MCksUisxPEkmJihNW1JdPWcuZ2V0KFIsSS0xKSksTVtJLTFdPTAsbCl7Zm9yKGxldCBjPWs7YzxhO2MrKyl7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfWZvcihsZXQgYz1rLTE7Yz49MDtjLS0paWYod1tjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDxhO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPXkuZ2V0KGQsYykqeS5nZXQoZCxwKTtTPS1TL3kuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKyl5LnNldChkLHAseS5nZXQoZCxwKStTKnkuZ2V0KGQsYykpfWZvcihsZXQgcD1jO3A8dDtwKyspeS5zZXQocCxjLC15LmdldChwLGMpKTt5LnNldChjLGMsMSt5LmdldChjLGMpKTtmb3IobGV0IHA9MDtwPGMtMTtwKyspeS5zZXQocCxjLDApfWVsc2V7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfX1pZih1KWZvcihsZXQgYz1zLTE7Yz49MDtjLS0pe2lmKGM8UiYmTVtjXSE9PTApZm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0wO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKylTKz1tLmdldChkLGMpKm0uZ2V0KGQscCk7Uz0tUy9tLmdldChjKzEsYyk7Zm9yKGxldCBkPWMrMTtkPHM7ZCsrKW0uc2V0KGQscCxtLmdldChkLHApK1MqbS5nZXQoZCxjKSl9Zm9yKGxldCBwPTA7cDxzO3ArKyltLnNldChwLGMsMCk7bS5zZXQoYyxjLDEpfWxldCB6PUktMSxCPU51bWJlci5FUFNJTE9OO2Zvcig7ST4wOyl7bGV0IGMscDtmb3IoYz1JLTI7Yz49LTEmJmMhPT0tMTtjLS0pe2NvbnN0IFM9TnVtYmVyLk1JTl9WQUxVRStCKk1hdGguYWJzKHdbY10rTWF0aC5hYnMod1tjKzFdKSk7aWYoTWF0aC5hYnMoTVtjXSk8PVN8fE51bWJlci5pc05hTihNW2NdKSl7TVtjXT0wO2JyZWFrfX1pZihjPT09SS0yKXA9NDtlbHNle2xldCBTO2ZvcihTPUktMTtTPj1jJiZTIT09YztTLS0pe2xldCBkPShTIT09ST9NYXRoLmFicyhNW1NdKTowKSsoUyE9PWMrMT9NYXRoLmFicyhNW1MtMV0pOjApO2lmKE1hdGguYWJzKHdbU10pPD1CKmQpe3dbU109MDticmVha319Uz09PWM/cD0zOlM9PT1JLTE/cD0xOihwPTIsYz1TKX1zd2l0Y2goYysrLHApe2Nhc2UgMTp7bGV0IFM9TVtJLTJdO01bSS0yXT0wO2ZvcihsZXQgZD1JLTI7ZD49YztkLS0pe2xldCBEPXgod1tkXSxTKSxVPXdbZF0vRCxGPVMvRDtpZih3W2RdPUQsZCE9PWMmJihTPS1GKk1bZC0xXSxNW2QtMV09VSpNW2QtMV0pLHUpZm9yKGxldCBQPTA7UDxzO1ArKylEPVUqbS5nZXQoUCxkKStGKm0uZ2V0KFAsSS0xKSxtLnNldChQLEktMSwtRiptLmdldChQLGQpK1UqbS5nZXQoUCxJLTEpKSxtLnNldChQLGQsRCl9YnJlYWt9Y2FzZSAyOntsZXQgUz1NW2MtMV07TVtjLTFdPTA7Zm9yKGxldCBkPWM7ZDxJO2QrKyl7bGV0IEQ9eCh3W2RdLFMpLFU9d1tkXS9ELEY9Uy9EO2lmKHdbZF09RCxTPS1GKk1bZF0sTVtkXT1VKk1bZF0sbClmb3IobGV0IFA9MDtQPHQ7UCsrKUQ9VSp5LmdldChQLGQpK0YqeS5nZXQoUCxjLTEpLHkuc2V0KFAsYy0xLC1GKnkuZ2V0KFAsZCkrVSp5LmdldChQLGMtMSkpLHkuc2V0KFAsZCxEKX1icmVha31jYXNlIDM6e2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5hYnMod1tJLTFdKSxNYXRoLmFicyh3W0ktMl0pLE1hdGguYWJzKE1bSS0yXSksTWF0aC5hYnMod1tjXSksTWF0aC5hYnMoTVtjXSkpLGQ9d1tJLTFdL1MsRD13W0ktMl0vUyxVPU1bSS0yXS9TLEY9d1tjXS9TLFA9TVtjXS9TLFk9KChEK2QpKihELWQpK1UqVSkvMixHPWQqVSooZCpVKTtsZXQgTj0wOyhZIT09MHx8RyE9PTApJiYoWTwwP049MC1NYXRoLnNxcnQoWSpZK0cpOk49TWF0aC5zcXJ0KFkqWStHKSxOPUcvKFkrTikpO2xldCAkPShGK2QpKihGLWQpK04sSz1GKlA7Zm9yKGxldCB2PWM7djxJLTE7disrKXtsZXQgVj14KCQsSyk7Vj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpO2xldCBMPSQvVixDPUsvVjtpZih2IT09YyYmKE1bdi0xXT1WKSwkPUwqd1t2XStDKk1bdl0sTVt2XT1MKk1bdl0tQyp3W3ZdLEs9Qyp3W3YrMV0sd1t2KzFdPUwqd1t2KzFdLHUpZm9yKGxldCBYPTA7WDxzO1grKylWPUwqbS5nZXQoWCx2KStDKm0uZ2V0KFgsdisxKSxtLnNldChYLHYrMSwtQyptLmdldChYLHYpK0wqbS5nZXQoWCx2KzEpKSxtLnNldChYLHYsVik7aWYoVj14KCQsSyksVj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpLEw9JC9WLEM9Sy9WLHdbdl09ViwkPUwqTVt2XStDKndbdisxXSx3W3YrMV09LUMqTVt2XStMKndbdisxXSxLPUMqTVt2KzFdLE1bdisxXT1MKk1bdisxXSxsJiZ2PHQtMSlmb3IobGV0IFg9MDtYPHQ7WCsrKVY9TCp5LmdldChYLHYpK0MqeS5nZXQoWCx2KzEpLHkuc2V0KFgsdisxLC1DKnkuZ2V0KFgsdikrTCp5LmdldChYLHYrMSkpLHkuc2V0KFgsdixWKX1NW0ktMl09JDticmVha31jYXNlIDQ6e2lmKHdbY108PTAmJih3W2NdPXdbY108MD8td1tjXTowLHUpKWZvcihsZXQgUz0wO1M8PXo7UysrKW0uc2V0KFMsYywtbS5nZXQoUyxjKSk7Zm9yKDtjPHomJiEod1tjXT49d1tjKzFdKTspe2xldCBTPXdbY107aWYod1tjXT13W2MrMV0sd1tjKzFdPVMsdSYmYzxzLTEpZm9yKGxldCBkPTA7ZDxzO2QrKylTPW0uZ2V0KGQsYysxKSxtLnNldChkLGMrMSxtLmdldChkLGMpKSxtLnNldChkLGMsUyk7aWYobCYmYzx0LTEpZm9yKGxldCBkPTA7ZDx0O2QrKylTPXkuZ2V0KGQsYysxKSx5LnNldChkLGMrMSx5LmdldChkLGMpKSx5LnNldChkLGMsUyk7YysrfUktLTticmVha319fWlmKGYpe2xldCBjPW07bT15LHk9Y310aGlzLm09dCx0aGlzLm49cyx0aGlzLnM9dyx0aGlzLlU9eSx0aGlzLlY9bX1zb2x2ZShuKXtsZXQgZT1uLHQ9dGhpcy50aHJlc2hvbGQscz10aGlzLnMubGVuZ3RoLHI9Yi56ZXJvcyhzLHMpO2ZvcihsZXQgYT0wO2E8czthKyspTWF0aC5hYnModGhpcy5zW2FdKTw9dD9yLnNldChhLGEsMCk6ci5zZXQoYSxhLDEvdGhpcy5zW2FdKTtsZXQgaT10aGlzLlUsaD10aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzLGw9aC5tbXVsKHIpLHU9aC5yb3dzLGY9aS5yb3dzLGc9Yi56ZXJvcyh1LGYpO2ZvcihsZXQgYT0wO2E8dTthKyspZm9yKGxldCBqPTA7ajxmO2orKyl7bGV0IHc9MDtmb3IobGV0IHk9MDt5PHM7eSsrKXcrPWwuZ2V0KGEseSkqaS5nZXQoaix5KTtnLnNldChhLGosdyl9cmV0dXJuIGcubW11bChlKX1zb2x2ZUZvckRpYWdvbmFsKG4pe3JldHVybiB0aGlzLnNvbHZlKGIuZGlhZyhuKSl9aW52ZXJzZSgpe2xldCBuPXRoaXMuVixlPXRoaXMudGhyZXNob2xkLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IGIodCx0aGlzLnMubGVuZ3RoKTtmb3IobGV0IGY9MDtmPHQ7ZisrKWZvcihsZXQgZz0wO2c8cztnKyspTWF0aC5hYnModGhpcy5zW2ddKT5lJiZyLnNldChmLGcsbi5nZXQoZixnKS90aGlzLnNbZ10pO2xldCBpPXRoaXMuVSxoPWkucm93cyxsPWkuY29sdW1ucyx1PW5ldyBiKHQsaCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPGg7ZysrKXtsZXQgYT0wO2ZvcihsZXQgaj0wO2o8bDtqKyspYSs9ci5nZXQoZixqKSppLmdldChnLGopO3Uuc2V0KGYsZyxhKX1yZXR1cm4gdX1nZXQgY29uZGl0aW9uKCl7cmV0dXJuIHRoaXMuc1swXS90aGlzLnNbTWF0aC5taW4odGhpcy5tLHRoaXMubiktMV19Z2V0IG5vcm0yKCl7cmV0dXJuIHRoaXMuc1swXX1nZXQgcmFuaygpe2xldCBuPU1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXSpOdW1iZXIuRVBTSUxPTixlPTAsdD10aGlzLnM7Zm9yKGxldCBzPTAscj10Lmxlbmd0aDtzPHI7cysrKXRbc10+biYmZSsrO3JldHVybiBlfWdldCBkaWFnb25hbCgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucyl9Z2V0IHRocmVzaG9sZCgpe3JldHVybiBOdW1iZXIuRVBTSUxPTi8yKk1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXX1nZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlV9Z2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCl7cmV0dXJuIHRoaXMuVn1nZXQgZGlhZ29uYWxNYXRyaXgoKXtyZXR1cm4gYi5kaWFnKHRoaXMucyl9fWZ1bmN0aW9uIE10KG8sbj0hMSl7cmV0dXJuIG89c3QuY2hlY2tNYXRyaXgobyksbj9uZXcgRHQobykuaW52ZXJzZSgpOnFlKG8sYi5leWUoby5yb3dzKSl9ZnVuY3Rpb24gcWUobyxuLGU9ITEpe3JldHVybiBvPXN0LmNoZWNrTWF0cml4KG8pLG49c3QuY2hlY2tNYXRyaXgobiksZT9uZXcgRHQobykuc29sdmUobik6by5pc1NxdWFyZSgpP25ldyBOZShvKS5zb2x2ZShuKTpuZXcgdmUobykuc29sdmUobil9Y29uc3QgX2U9MTIzNCxUZT0oKT0+KHtzZWVkOl9lLGFycmF5U2h1ZmZsZShuKXtjb25zdHthcnI6ZSxzYW1wbGVTaXplOnR9PW47Zm9yKGxldCBzPTA7czx0O3MrKyl7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCByPXRoaXMuc2VlZD4+MTYmMzI3Njc7cj1yJWUubGVuZ3RoO2xldCBpPWVbc107ZVtzXT1lW3JdLGVbcl09aX19LG5leHRJbnQobil7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCBlPXRoaXMuc2VlZD4+MTYmMzI3Njc7cmV0dXJuIGU9ZSVuLGV9fSksSj0obyxuLGUpPT4oblswXS1vWzBdKSooZVsxXS1vWzFdKS0oblsxXS1vWzFdKSooZVswXS1vWzBdKSx6ZT0obyxuLGUsdCxzLHIsaSxoKT0+IShKKG8sbixlKT4wIT1KKHMscixpKT4wfHxKKG4sZSx0KT4wIT1KKHIsaSxoKT4wfHxKKGUsdCxvKT4wIT1KKGksaCxzKT4wfHxKKHQsbyxuKT4wIT1KKGgscyxyKT4wKSxGZT0obyxuLGUsdCxzLHIpPT5KKG8sbixlKT4wPT1KKHQscyxyKT4wLFBlPW89Pntjb25zdCBuPW9bNF0qb1s4XS1vWzVdKm9bN10sZT1vWzNdKm9bOF0tb1s1XSpvWzZdLHQ9b1szXSpvWzddLW9bNF0qb1s2XTtyZXR1cm4gb1swXSpuLW9bMV0qZStvWzJdKnR9LEJ0PShvLG4pPT57Y29uc3QgZT1QZShvKTtpZihNYXRoLmFicyhlKTw9bilyZXR1cm4gbnVsbDtjb25zdCB0PTEvZTtyZXR1cm5bKG9bNF0qb1s4XS1vWzVdKm9bN10pKnQsKG9bMl0qb1s3XS1vWzFdKm9bOF0pKnQsKG9bMV0qb1s1XS1vWzJdKm9bNF0pKnQsKG9bNV0qb1s2XS1vWzNdKm9bOF0pKnQsKG9bMF0qb1s4XS1vWzJdKm9bNl0pKnQsKG9bMl0qb1szXS1vWzBdKm9bNV0pKnQsKG9bM10qb1s3XS1vWzRdKm9bNl0pKnQsKG9bMV0qb1s2XS1vWzBdKm9bN10pKnQsKG9bMF0qb1s0XS1vWzFdKm9bM10pKnRdfSxvdD0obyxuKT0+e2NvbnN0IGU9bls2XSpvWzBdK25bN10qb1sxXStuWzhdLHQ9W107cmV0dXJuIHRbMF09KG5bMF0qb1swXStuWzFdKm9bMV0rblsyXSkvZSx0WzFdPShuWzNdKm9bMF0rbls0XSpvWzFdK25bNV0pL2UsdH0sRGU9KG8sbixlLHQpPT57Y29uc3Qgcz1ydChuLG8pLHI9cnQoZSxvKSxpPXJ0KHQsbyksaD1ydChuLGUpLGw9cnQodCxlKSx1PW10KHMsciksZj1tdChyLGkpLGc9bXQocyxpKSxhPW10KGgsbCk7cmV0dXJuIE1hdGgubWluKE1hdGgubWluKE1hdGgubWluKHUsZiksZyksYSl9LEJlPShvLG4sZSx0KT0+e2NvbnN0IHM9SihvLG4sZSk8PTA7cmV0dXJuIShKKG4sZSx0KTw9MCE9PXN8fEooZSx0LG8pPD0wIT09c3x8Sih0LG8sbik8PTAhPT1zKX0scnQ9KG8sbik9PltvWzBdLW5bMF0sb1sxXS1uWzFdXSxtdD0obyxuKT0+e2NvbnN0IGU9b1swXSpuWzFdLW9bMV0qblswXTtyZXR1cm4gTWF0aC5hYnMoZSkqLjV9LFZ0PShvLG4pPT57Y29uc3R7bm9ybVBvaW50czplLHBhcmFtOnR9PVh0KG8pLHtub3JtUG9pbnRzOnMscGFyYW06cn09WHQobiksaT1zLmxlbmd0aCxoPVtdLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7Y29uc3QgZj1bZVt1XVswXSxlW3VdWzFdLDEsMCwwLDAsLShlW3VdWzBdKnNbdV1bMF0pLC0oZVt1XVsxXSpzW3VdWzBdKV0sZz1bMCwwLDAsZVt1XVswXSxlW3VdWzFdLDEsLShlW3VdWzBdKnNbdV1bMV0pLC0oZVt1XVsxXSpzW3VdWzFdKV07aC5wdXNoKGYpLGgucHVzaChnKSxsLnB1c2goW3NbdV1bMF1dKSxsLnB1c2goW3NbdV1bMV1dKX10cnl7Y29uc3QgdT1uZXcgYihoKSxmPW5ldyBiKGwpLGc9dS50cmFuc3Bvc2UoKSxhPWcubW11bCh1KSxqPWcubW11bChmKSx5PU10KGEpLm1tdWwoaikudG8xREFycmF5KCk7cmV0dXJuIFZlKHksdCxyKX1jYXRjaHtyZXR1cm4gbnVsbH19LFh0PW89PntsZXQgbj0wLGU9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyluKz1vW2xdWzBdLGUrPW9bbF1bMV07bGV0IHQ9bi9vLmxlbmd0aCxzPWUvby5sZW5ndGgscj0wO2ZvcihsZXQgbD0wO2w8by5sZW5ndGg7bCsrKXtjb25zdCB1PW9bbF1bMF0tdCxmPW9bbF1bMV0tcztyKz1NYXRoLnNxcnQodSp1K2YqZil9bGV0IGk9TWF0aC5zcXJ0KDIpKm8ubGVuZ3RoL3I7Y29uc3QgaD1bXTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyloLnB1c2goWyhvW2xdWzBdLXQpKmksKG9bbF1bMV0tcykqaV0pO3JldHVybntub3JtUG9pbnRzOmgscGFyYW06e21lYW5YOnQsbWVhblk6cyxzOml9fX0sVmU9KG8sbixlKT0+e2NvbnN0IHQ9ZS5zKmUubWVhblgscz1lLnMqZS5tZWFuWSxyPVtvWzBdK3Qqb1s2XSxvWzFdK3Qqb1s3XSwob1swXSt0Km9bNl0pKi1uLm1lYW5YKyhvWzFdK3Qqb1s3XSkqLW4ubWVhblkrKG9bMl0rdCkvbi5zLG9bM10rcypvWzZdLG9bNF0rcypvWzddLChvWzNdK3Mqb1s2XSkqLW4ubWVhblgrKG9bNF0rcypvWzddKSotbi5tZWFuWSsob1s1XStzKS9uLnMsZS5zKm9bNl0sZS5zKm9bN10sZS5zKm9bNl0qLW4ubWVhblgrZS5zKm9bN10qLW4ubWVhblkrZS5zL24uc107Zm9yKGxldCBpPTA7aTw5O2krKylyW2ldPXJbaV0vcls4XTtyZXR1cm4gcn0sWGU9LjAxLFVlPTEwLCRlPTIwLExlPTEwLFV0PW89Pntjb25zdHtzcmNQb2ludHM6bixkc3RQb2ludHM6ZSxrZXlmcmFtZTp0LHF1aWNrTW9kZTpzfT1vLHI9W1swLDBdLFt0LndpZHRoLDBdLFt0LndpZHRoLHQuaGVpZ2h0XSxbMCx0LmhlaWdodF1dLGk9NDtpZihuLmxlbmd0aDxpKXJldHVybiBudWxsO2NvbnN0IGg9WGUsbD0xLyhoKmgpLHU9TWF0aC5taW4oVWUsbi5sZW5ndGgpLGY9VGUoKSxnPVtdO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKWdbRV09RTtmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTpnLmxlbmd0aH0pO2NvbnN0IGE9cz9MZTokZSxqPWEqMjtsZXQgdz0wO2NvbnN0IHk9W107Zm9yKDt3PGomJnkubGVuZ3RoPGE7KXtpZih3Kz0xLGYuYXJyYXlTaHVmZmxlKHthcnI6ZyxzYW1wbGVTaXplOml9KSwhemUobltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSxlW2dbMF1dLGVbZ1sxXV0sZVtnWzJdXSxlW2dbM11dKSljb250aW51ZTtjb25zdCBFPVZ0KFtuW2dbMF1dLG5bZ1sxXV0sbltnWzJdXSxuW2dbM11dXSxbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0pO0UhPT1udWxsJiZIZSh7SDpFLHRlc3RQb2ludHM6cn0pJiZ5LnB1c2goRSl9aWYoeS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2NvbnN0IG09W107Zm9yKGxldCBFPTA7RTx5Lmxlbmd0aDtFKyspbS5wdXNoKHtIOnlbRV0sY29zdDowfSk7bGV0IE09dTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoJiZtLmxlbmd0aD4yO0UrPU0pe009TWF0aC5taW4odSxuLmxlbmd0aC1FKTtsZXQgaz1FK007Zm9yKGxldCBSPTA7UjxtLmxlbmd0aDtSKyspZm9yKGxldCBxPUU7cTxrO3ErKyl7Y29uc3QgST1DZSh7SDptW1JdLkgsc3JjUG9pbnQ6bltxXSxkc3RQb2ludDplW3FdLG9uZU92ZXJTY2FsZTI6bH0pO21bUl0uY29zdCs9SX1tLnNvcnQoKFIscSk9PlIuY29zdC1xLmNvc3QpLG0uc3BsaWNlKC1NYXRoLmZsb29yKChtLmxlbmd0aCsxKS8yKSl9bGV0IFQ9bnVsbDtmb3IobGV0IEU9MDtFPG0ubGVuZ3RoO0UrKyl7Y29uc3Qgaz1ZZSh7aW5IOm1bRV0uSH0pO2lmKE9lKHtIOmssdGVzdFBvaW50czpyLGtleWZyYW1lOnR9KSl7VD1rO2JyZWFrfX1yZXR1cm4gVH0sT2U9KHtIOm8sdGVzdFBvaW50czpuLGtleWZyYW1lOmV9KT0+e2NvbnN0IHQ9QnQobywxZS01KTtpZih0PT09bnVsbClyZXR1cm4hMTtjb25zdCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXMucHVzaChvdChuW2ldLHQpKTtyZXR1cm4hKERlKHNbMF0sc1sxXSxzWzJdLHNbM10pPGUud2lkdGgqZS5oZWlnaHQqMWUtNHx8IUJlKHNbMF0sc1sxXSxzWzJdLHNbM10pKX0sWWU9KHtpbkg6b30pPT57Y29uc3Qgbj0xL29bOF0sZT1bXTtmb3IobGV0IHQ9MDt0PDg7dCsrKWVbdF09b1t0XSpuO3JldHVybiBlWzhdPTEsZX0sQ2U9KHtIOm8sc3JjUG9pbnQ6bixkc3RQb2ludDplLG9uZU92ZXJTY2FsZTI6dH0pPT57Y29uc3Qgcz1vdChuLG8pLHI9W3NbMF0tZVswXSxzWzFdLWVbMV1dO3JldHVybiBNYXRoLmxvZygxKyhyWzBdKnJbMF0rclsxXSpyWzFdKSp0KX0sSGU9KHtIOm8sdGVzdFBvaW50czpufSk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWVbdF09b3Qoblt0XSxvKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3Qgcz10LHI9KHQrMSklbi5sZW5ndGgsaT0odCsyKSVuLmxlbmd0aDtpZighRmUobltzXSxuW3JdLG5baV0sZVtzXSxlW3JdLGVbaV0pKXJldHVybiExfXJldHVybiEwfSwkdD0zLEx0PTYsS2U9OCxPdD0uNyxKZT0oe2tleWZyYW1lOm8scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOmUscXVlcnloZWlnaHQ6dCxkZWJ1Z01vZGU6c30pPT57bGV0IHI9e307Y29uc3QgaT1bXTtmb3IobGV0IG09MDttPG4ubGVuZ3RoO20rKyl7Y29uc3QgTT1uW21dLFQ9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7aWYoVC5sZW5ndGg9PT0wKWNvbnRpbnVlO2NvbnN0IEU9TS5tYXhpbWE/by5tYXhpbWFQb2ludHNDbHVzdGVyLnJvb3ROb2RlOm8ubWluaW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZSxrPVtdLFI9bmV3IFd0KFtdLChCLGMpPT5CLmQtYy5kKTtFdCh7bm9kZTpFLGtleXBvaW50czpULHF1ZXJ5cG9pbnQ6TSxxdWV1ZTpSLGtleXBvaW50SW5kZXhlczprLG51bVBvcDowfSk7bGV0IHE9LTEsST1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgQj0wO0I8ay5sZW5ndGg7QisrKXtjb25zdCBjPVRba1tCXV0scD15dCh7djE6Yy5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7cDxJPyh6PUksST1wLHE9a1tCXSk6cDx6JiYoej1wKX1xIT09LTEmJih6PT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqSS96PE90KSYmaS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6VFtxXX0pfWlmKHMmJihyLm1hdGNoZXM9aSksaS5sZW5ndGg8THQpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgaD12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczppfSk7cyYmKHIuaG91Z2hNYXRjaGVzPWgpO2NvbnN0IGw9VXQoe3NyY1BvaW50czpoLm1hcChtPT5bbS5rZXlwb2ludC54LG0ua2V5cG9pbnQueV0pLGRzdFBvaW50czpoLm1hcChtPT5bbS5xdWVyeXBvaW50LngsbS5xdWVyeXBvaW50LnldKSxrZXlmcmFtZTpvfSk7aWYobD09PW51bGwpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgdT1ZdCh7SDpsLG1hdGNoZXM6aCx0aHJlc2hvbGQ6JHR9KTtpZihzJiYoci5pbmxpZXJNYXRjaGVzPXUpLHUubGVuZ3RoPEx0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGY9QnQobCwxZS01KSxnPTEwKjEwLGE9W107Zm9yKGxldCBtPTA7bTxuLmxlbmd0aDttKyspe2NvbnN0IE09blttXSxUPW90KFtNLngsTS55XSxmKTtsZXQgRT0tMSxrPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Y29uc3QgcT1NLm1heGltYT9vLm1heGltYVBvaW50czpvLm1pbmltYVBvaW50cztmb3IobGV0IEk9MDtJPHEubGVuZ3RoO0krKyl7Y29uc3Qgej1xW0ldO2lmKCh6LngtVFswXSkqKHoueC1UWzBdKSsoei55LVRbMV0pKih6LnktVFsxXSk+Zyljb250aW51ZTtjb25zdCBjPXl0KHt2MTp6LmRlc2NyaXB0b3JzLHYyOk0uZGVzY3JpcHRvcnN9KTtjPGs/KFI9ayxrPWMsRT1JKTpjPFImJihSPWMpfUUhPT0tMSYmKFI9PT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8MSprL1I8T3QpJiZhLnB1c2goe3F1ZXJ5cG9pbnQ6TSxrZXlwb2ludDpxW0VdfSl9cyYmKHIubWF0Y2hlczI9YSk7Y29uc3Qgaj12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczphfSk7cyYmKHIuaG91Z2hNYXRjaGVzMj1qKTtjb25zdCB3PVV0KHtzcmNQb2ludHM6ai5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6ai5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKHc9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHk9WXQoe0g6dyxtYXRjaGVzOmosdGhyZXNob2xkOiR0fSk7cmV0dXJuIHMmJihyLmlubGllck1hdGNoZXMyPXkpLHtIOncsbWF0Y2hlczp5LGRlYnVnRXh0cmE6cn19LEV0PSh7bm9kZTpvLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSk9PntpZihvLmxlYWYpe2ZvcihsZXQgbD0wO2w8by5wb2ludEluZGV4ZXMubGVuZ3RoO2wrKylzLnB1c2goby5wb2ludEluZGV4ZXNbbF0pO3JldHVybn1jb25zdCBpPVtdO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKXtjb25zdCBmPW8uY2hpbGRyZW5bbF0uY2VudGVyUG9pbnRJbmRleCxnPXl0KHt2MTpuW2ZdLmRlc2NyaXB0b3JzLHYyOmUuZGVzY3JpcHRvcnN9KTtpLnB1c2goZyl9bGV0IGg9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaD1NYXRoLm1pbihoLGlbbF0pO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWlbbF0hPT1oJiZ0LnB1c2goe25vZGU6by5jaGlsZHJlbltsXSxkOmlbbF19KTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdPT09aCYmRXQoe25vZGU6by5jaGlsZHJlbltsXSxrZXlwb2ludHM6bixxdWVyeXBvaW50OmUscXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pO2lmKHI8S2UmJnQubGVuZ3RoPjApe2NvbnN0e25vZGU6bCxkOnV9PXQucG9wKCk7cis9MSxFdCh7bm9kZTpsLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSl9fSxZdD1vPT57Y29uc3R7SDpuLG1hdGNoZXM6ZSx0aHJlc2hvbGQ6dH09byxzPXQqdCxyPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCBoPWVbaV0ucXVlcnlwb2ludCxsPWVbaV0ua2V5cG9pbnQsdT1vdChbbC54LGwueV0sbik7KHVbMF0taC54KSoodVswXS1oLngpKyh1WzFdLWgueSkqKHVbMV0taC55KTw9cyYmci5wdXNoKGVbaV0pfXJldHVybiByfTtjbGFzcyBHZXtjb25zdHJ1Y3RvcihuLGUsdD0hMSl7dGhpcy5xdWVyeVdpZHRoPW4sdGhpcy5xdWVyeUhlaWdodD1lLHRoaXMuZGVidWdNb2RlPXR9bWF0Y2hEZXRlY3Rpb24obixlKXtsZXQgdD17ZnJhbWVzOltdfSxzPW51bGw7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0e0g6dSxtYXRjaGVzOmYsZGVidWdFeHRyYTpnfT1KZSh7a2V5ZnJhbWU6bltsXSxxdWVyeXBvaW50czplLHF1ZXJ5d2lkdGg6dGhpcy5xdWVyeVdpZHRoLHF1ZXJ5aGVpZ2h0OnRoaXMucXVlcnlIZWlnaHQsZGVidWdNb2RlOnRoaXMuZGVidWdNb2RlfSk7dC5mcmFtZXMucHVzaChnKSx1JiYocz09PW51bGx8fHMubWF0Y2hlcy5sZW5ndGg8Zi5sZW5ndGgpJiYocz17a2V5ZnJhbWVJbmRleDpsLEg6dSxtYXRjaGVzOmZ9KX1pZihzPT09bnVsbClyZXR1cm57a2V5ZnJhbWVJbmRleDotMSxkZWJ1Z0V4dHJhOnR9O2NvbnN0IHI9W10saT1bXSxoPW5bcy5rZXlmcmFtZUluZGV4XTtmb3IobGV0IGw9MDtsPHMubWF0Y2hlcy5sZW5ndGg7bCsrKXtjb25zdCB1PXMubWF0Y2hlc1tsXS5xdWVyeXBvaW50LGY9cy5tYXRjaGVzW2xdLmtleXBvaW50O3IucHVzaCh7eDp1LngseTp1Lnl9KSxpLnB1c2goe3g6KGYueCsuNSkvaC5zY2FsZSx5OihmLnkrLjUpL2guc2NhbGUsejowfSl9cmV0dXJue3NjcmVlbkNvb3JkczpyLHdvcmxkQ29vcmRzOmksa2V5ZnJhbWVJbmRleDpzLmtleWZyYW1lSW5kZXgsZGVidWdFeHRyYTp0fX19Y29uc3QgV2U9KHtzY3JlZW5Db29yZHM6byx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06ZX0pPT57Y29uc3QgdD1WdChuLm1hcChtPT5bbS54LG0ueV0pLG8ubWFwKG09PlttLngsbS55XSkpLHM9bmV3IGIoW1t0WzBdLHRbMV0sdFsyXV0sW3RbM10sdFs0XSx0WzVdXSxbdFs2XSx0WzddLHRbOF1dXSkscj1uZXcgYihlKSxsPU10KHIpLm1tdWwocykudG8xREFycmF5KCksdT1NYXRoLnNxcnQobFswXSpsWzBdK2xbM10qbFszXStsWzZdKmxbNl0pLGY9TWF0aC5zcXJ0KGxbMV0qbFsxXStsWzRdKmxbNF0rbFs3XSpsWzddKSxnPSh1K2YpLzIsYT1bXTthWzBdPWxbMF0vdSxhWzNdPWxbM10vdSxhWzZdPWxbNl0vdSxhWzFdPWxbMV0vZixhWzRdPWxbNF0vZixhWzddPWxbN10vZixhWzJdPWFbM10qYVs3XS1hWzZdKmFbNF0sYVs1XT1hWzZdKmFbMV0tYVswXSphWzddLGFbOF09YVswXSphWzRdLWFbMV0qYVszXTtjb25zdCBqPU1hdGguc3FydChhWzJdKmFbMl0rYVs1XSphWzVdK2FbOF0qYVs4XSk7YVsyXS89aixhWzVdLz1qLGFbOF0vPWo7Y29uc3Qgdz1bXTtyZXR1cm4gd1swXT1sWzJdL2csd1sxXT1sWzVdL2csd1syXT1sWzhdL2csW1thWzBdLGFbMV0sYVsyXSx3WzBdXSxbYVszXSxhWzRdLGFbNV0sd1sxXV0sW2FbNl0sYVs3XSxhWzhdLHdbMl1dXX0sUWU9KG8sbik9Pltbb1swXVswXSpuWzBdWzBdK29bMF1bMl0qblsyXVswXSxvWzBdWzBdKm5bMF1bMV0rb1swXVsyXSpuWzJdWzFdLG9bMF1bMF0qblswXVsyXStvWzBdWzJdKm5bMl1bMl0sb1swXVswXSpuWzBdWzNdK29bMF1bMl0qblsyXVszXV0sW29bMV1bMV0qblsxXVswXStvWzFdWzJdKm5bMl1bMF0sb1sxXVsxXSpuWzFdWzFdK29bMV1bMl0qblsyXVsxXSxvWzFdWzFdKm5bMV1bMl0rb1sxXVsyXSpuWzJdWzJdLG9bMV1bMV0qblsxXVszXStvWzFdWzJdKm5bMl1bM11dLFtuWzJdWzBdLG5bMl1bMV0sblsyXVsyXSxuWzJdWzNdXV0sQ3Q9KG8sbixlLHQpPT57Y29uc3Qgcz1vWzBdWzBdKm4rb1swXVsxXSplK29bMF1bM10scj1vWzFdWzBdKm4rb1sxXVsxXSplK29bMV1bM10saT1vWzJdWzBdKm4rb1syXVsxXSplK29bMl1bM107cmV0dXJue3g6cyx5OnIsejppfX0sWmU9KG8sbixlLHQpPT57Y29uc3R7eDpzLHk6cix6Oml9PUN0KG8sbixlKTtyZXR1cm57eDpzL2kseTpyL2l9fSx4ZT01LEFlPTQsSHQ9MTAsdG49LjEsZW49Ljk5O2xldCBIPVtbXSxbXSxbXV0sQT1bW10sW11dLE89W1tdLFtdLFtdXTtjb25zdCBubj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dH0pPT57bGV0IHM9MCxyPTA7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDtnKyspcys9ZVtnXS54LHIrPWVbZ10ueTtzLz1lLmxlbmd0aCxyLz1lLmxlbmd0aDtjb25zdCBpPVtdO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7ZysrKWkucHVzaCh7eDplW2ddLngtcyx5OmVbZ10ueS1yLHo6ZVtnXS56fSk7Y29uc3QgaD1bW10sW10sW11dO2ZvcihsZXQgZz0wO2c8MztnKyspZm9yKGxldCBhPTA7YTwzO2ErKyloW2ddW2FdPW9bZ11bYV07aFswXVszXT1vWzBdWzBdKnMrb1swXVsxXSpyK29bMF1bM10saFsxXVszXT1vWzFdWzBdKnMrb1sxXVsxXSpyK29bMV1bM10saFsyXVszXT1vWzJdWzBdKnMrb1syXVsxXSpyK29bMl1bM107Y29uc3QgbD1bMSwuOCwuNiwuNCwwXTtsZXQgdT1oLGY9bnVsbDtmb3IobGV0IGc9MDtnPGwubGVuZ3RoO2crKyl7Y29uc3QgYT1zbih7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTp1LHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkczppLHNjcmVlbkNvb3Jkczp0LGlubGllclByb2I6bFtnXX0pO2lmKHU9YS5tb2RlbFZpZXdUcmFuc2Zvcm0sYS5lcnI8eGUpe2Y9dTticmVha319cmV0dXJuIGY9PT1udWxsP251bGw6KGZbMF1bM109ZlswXVszXS1mWzBdWzBdKnMtZlswXVsxXSpyLGZbMV1bM109ZlsxXVszXS1mWzFdWzBdKnMtZlsxXVsxXSpyLGZbMl1bM109ZlsyXVszXS1mWzJdWzBdKnMtZlsyXVsxXSpyLGYpfSxzbj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOnN9KT0+e2NvbnN0IHI9czwxO2xldCBpPW8saD0wLGw9MCx1PW5ldyBBcnJheShlLmxlbmd0aCksZj1uZXcgQXJyYXkoZS5sZW5ndGgpLGc9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBqPTA7ajw9SHQ7aisrKXtjb25zdCB3PVFlKG4saSk7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aDtFKyspe2NvbnN0IGs9WmUodyxlW0VdLngsZVtFXS55LGVbRV0ueiksUj10W0VdLngtay54LHE9dFtFXS55LWsueTtnW0VdPVIsYVtFXT1xLHVbRV09UipSK3EqcX1sZXQgeTtpZihsPTAscil7Y29uc3QgRT1NYXRoLm1heCgzLE1hdGguZmxvb3IoZS5sZW5ndGgqcyktMSk7Zm9yKGxldCBrPTA7azxlLmxlbmd0aDtrKyspZltrXT11W2tdO2Yuc29ydCgoayxSKT0+ay1SKSx5PU1hdGgubWF4KGZbRV0qQWUsMTYpO2ZvcihsZXQgaz0wO2s8ZS5sZW5ndGg7aysrKWZba10+eT9sKz15LzY6bCs9eS82KigxLSgxLWZba10veSkqKDEtZltrXS95KSooMS1mW2tdL3kpKX1lbHNlIGZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKWwrPXVbRV07aWYobC89ZS5sZW5ndGgsbDx0bnx8aj4wJiZsL2g+ZW58fGo9PT1IdClicmVhaztoPWw7Y29uc3QgbT1bXSxNPVtdO2ZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKXtpZihyJiZ1W0VdPnkpY29udGludWU7Y29uc3Qgaz1sbih7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTp3LG1vZGVsVmlld1RyYW5zZm9ybTppLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOmVbRV19KTtpZihyKXtjb25zdCBSPSgxLXVbRV0veSkqKDEtdVtFXS95KTtmb3IobGV0IHE9MDtxPDI7cSsrKWZvcihsZXQgST0wO0k8NjtJKyspa1txXVtJXSo9UjttLnB1c2goW2dbRV0qUl0pLG0ucHVzaChbYVtFXSpSXSl9ZWxzZSBtLnB1c2goW2dbRV1dKSxtLnB1c2goW2FbRV1dKTtmb3IobGV0IFI9MDtSPGsubGVuZ3RoO1IrKylNLnB1c2goa1tSXSl9Y29uc3QgVD1ybih7ZFU6bSxKX1VfUzpNfSk7aWYoVD09PW51bGwpYnJlYWs7aT1vbih7bW9kZWxWaWV3VHJhbnNmb3JtOmksZFM6VH0pfXJldHVybnttb2RlbFZpZXdUcmFuc2Zvcm06aSxlcnI6bH19LG9uPSh7bW9kZWxWaWV3VHJhbnNmb3JtOm8sZFM6bn0pPT57bGV0IGU9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl0sdCxzLHI7ZTwxZS02Pyh0PTEscz0wLHI9MCxlPTApOihlPU1hdGguc3FydChlKSx0PW5bMF0vZSxzPW5bMV0vZSxyPW5bMl0vZSk7Y29uc3QgaT1NYXRoLmNvcyhlKSxoPU1hdGguc2luKGUpLGw9MS1pO0hbMF1bMF09dCp0KmwraSxIWzBdWzFdPXQqcypsLXIqaCxIWzBdWzJdPXQqcipsK3MqaCxIWzBdWzNdPW5bM10sSFsxXVswXT1zKnQqbCtyKmgsSFsxXVsxXT1zKnMqbCtpLEhbMV1bMl09cypyKmwtdCpoLEhbMV1bM109bls0XSxIWzJdWzBdPXIqdCpsLXMqaCxIWzJdWzFdPXIqcypsK3QqaCxIWzJdWzJdPXIqcipsK2ksSFsyXVszXT1uWzVdO2NvbnN0IHU9W1tdLFtdLFtdXTtmb3IobGV0IGY9MDtmPDM7ZisrKXtmb3IobGV0IGc9MDtnPDQ7ZysrKXVbZl1bZ109b1tmXVswXSpIWzBdW2ddK29bZl1bMV0qSFsxXVtnXStvW2ZdWzJdKkhbMl1bZ107dVtmXVszXSs9b1tmXVszXX1yZXR1cm4gdX0scm49KHtkVTpvLEpfVV9TOm59KT0+e2NvbnN0IGU9bmV3IGIobiksdD1uZXcgYihvKSxzPWUudHJhbnNwb3NlKCkscj1zLm1tdWwoZSksaT1zLm1tdWwodCk7bGV0IGg7dHJ5e2g9TXQocil9Y2F0Y2h7cmV0dXJuIG51bGx9cmV0dXJuIGgubW11bChpKS50bzFEQXJyYXkoKX0sbG49KHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtOm8sbW9kZWxWaWV3VHJhbnNmb3JtOm4scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmQ6dH0pPT57Y29uc3Qgcz1uLHt4OnIseTppLHo6aH09dCxsPUN0KG8scixpKSx1PWwueipsLno7QVswXVswXT1lWzBdWzBdKmwuei91LEFbMF1bMV09ZVswXVsxXSpsLnovdSxBWzBdWzJdPShlWzBdWzJdKmwuei1lWzJdWzJdKmwueCkvdSxBWzFdWzBdPWVbMV1bMF0qbC56L3UsQVsxXVsxXT1lWzFdWzFdKmwuei91LEFbMV1bMl09KGVbMV1bMl0qbC56LWVbMl1bMl0qbC55KS91LE9bMF1bMF09c1swXVsyXSppLE9bMF1bMV09LXNbMF1bMl0qcixPWzBdWzJdPXNbMF1bMV0qci1zWzBdWzBdKmksT1swXVszXT1zWzBdWzBdLE9bMF1bNF09c1swXVsxXSxPWzBdWzVdPXNbMF1bMl0sT1sxXVswXT1zWzFdWzJdKmksT1sxXVsxXT0tc1sxXVsyXSpyLE9bMV1bMl09c1sxXVsxXSpyLXNbMV1bMF0qaSxPWzFdWzNdPXNbMV1bMF0sT1sxXVs0XT1zWzFdWzFdLE9bMV1bNV09c1sxXVsyXSxPWzJdWzBdPXNbMl1bMl0qaSxPWzJdWzFdPS1zWzJdWzJdKnIsT1syXVsyXT1zWzJdWzFdKnItc1syXVswXSppLE9bMl1bM109c1syXVswXSxPWzJdWzRdPXNbMl1bMV0sT1syXVs1XT1zWzJdWzJdO2NvbnN0IGY9W1tdLFtdXTtmb3IobGV0IGc9MDtnPDI7ZysrKWZvcihsZXQgYT0wO2E8NjthKyspe2ZbZ11bYV09MDtmb3IobGV0IGo9MDtqPDM7aisrKWZbZ11bYV0rPUFbZ11bal0qT1tqXVthXX1yZXR1cm4gZn07Y2xhc3MgaG57Y29uc3RydWN0b3Iobil7dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPW59ZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmV9KXtyZXR1cm4gV2Uoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmUscHJvamVjdGlvblRyYW5zZm9ybTp0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KX1yZWZpbmVFc3RpbWF0ZSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTpuLHdvcmxkQ29vcmRzOmUsc2NyZWVuQ29vcmRzOnR9KXtyZXR1cm4gbm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06bix3b3JsZENvb3JkczplLHNjcmVlbkNvb3Jkczp0LHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9fWxldCBLdD1udWxsLEp0PSExLEd0PW51bGwsU3Q9bnVsbDtvbm1lc3NhZ2U9bz0+e2NvbnN0e2RhdGE6bn09bztzd2l0Y2gobi50eXBlKXtjYXNlInNldHVwIjpuLnByb2plY3Rpb25UcmFuc2Zvcm0sS3Q9bi5tYXRjaGluZ0RhdGFMaXN0LEp0PW4uZGVidWdNb2RlLEd0PW5ldyBHZShuLmlucHV0V2lkdGgsbi5pbnB1dEhlaWdodCxKdCksU3Q9bmV3IGhuKG4ucHJvamVjdGlvblRyYW5zZm9ybSk7YnJlYWs7Y2FzZSJtYXRjaCI6Y29uc3QgZT1uLnRhcmdldEluZGV4ZXM7bGV0IHQ9LTEscz1udWxsLHI9bnVsbDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3QgZz1lW2ZdLHtrZXlmcmFtZUluZGV4OmEsc2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6dyxkZWJ1Z0V4dHJhOnl9PUd0Lm1hdGNoRGV0ZWN0aW9uKEt0W2ddLG4uZmVhdHVyZVBvaW50cyk7aWYocj15LGEhPT0tMSl7Y29uc3QgbT1TdC5lc3RpbWF0ZSh7c2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6d30pO20mJih0PWcscz1tKTticmVha319cG9zdE1lc3NhZ2Uoe3R5cGU6Im1hdGNoRG9uZSIsdGFyZ2V0SW5kZXg6dCxtb2RlbFZpZXdUcmFuc2Zvcm06cyxkZWJ1Z0V4dHJhOnJ9KTticmVhaztjYXNlInRyYWNrVXBkYXRlIjpjb25zdHttb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfT1uLHU9U3QucmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfSk7cG9zdE1lc3NhZ2Uoe3R5cGU6InRyYWNrVXBkYXRlRG9uZSIsbW9kZWxWaWV3VHJhbnNmb3JtOnV9KTticmVhaztjYXNlImRpc3Bvc2UiOmNsb3NlKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0eXBlICcke24udHlwZX0nYCl9fX0pKCk7Cg==",fj=typeof window<"u"&&window.Blob&&new Blob([atob(Jse)],{type:"text/javascript;charset=utf-8"});function pit(){let n;try{if(n=fj&&(window.URL||window.webkitURL).createObjectURL(fj),!n)throw"";return new Worker(n)}catch{return new Worker("data:application/javascript;base64,"+Jse)}finally{n&&(window.URL||window.webkitURL).revokeObjectURL(n)}}const fit=(n,e)=>[[n[0][0]*e[0][0]+n[0][2]*e[2][0],n[0][0]*e[0][1]+n[0][2]*e[2][1],n[0][0]*e[0][2]+n[0][2]*e[2][2],n[0][0]*e[0][3]+n[0][2]*e[2][3]],[n[1][1]*e[1][0]+n[1][2]*e[2][0],n[1][1]*e[1][1]+n[1][2]*e[2][1],n[1][1]*e[1][2]+n[1][2]*e[2][2],n[1][1]*e[1][3]+n[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],mit=(n,e,t,i)=>{const r=n[0][0]*e+n[0][1]*t+n[0][3],s=n[1][0]*e+n[1][1]*t+n[1][3],o=n[2][0]*e+n[2][1]*t+n[2][3];return{x:r,y:s,z:o}},git=(n,e,t,i)=>{const{x:r,y:s,z:o}=mit(n,e,t);return{x:r/o,y:s/o}},yit=6,bit=1,xit=10,vit=1,wit=.8,Sit=1,lu=1e3;class Tit{constructor(e,t,i,r,s,o=!1){this.markerDimensions=e,this.trackingDataList=t,this.projectionTransform=i,this.debugMode=o,this.trackingKeyframeList=[];for(let l=0;l<t.length;l++)this.trackingKeyframeList.push(t[l][Sit]);let a=0;for(let l=0;l<this.trackingKeyframeList.length;l++)a=Math.max(a,this.trackingKeyframeList[l].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let l=0;l<this.trackingKeyframeList.length;l++){const{featurePoints:u,imagePixels:c,imageProperties:h}=this._prebuild(this.trackingKeyframeList[l],a);this.featurePointsListT[l]=u,this.imagePixelsListT[l]=c,this.imagePropertiesListT[l]=h}this.kernelCaches={}}dummyRun(e){let t=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let i=0;i<this.featurePointsListT.length;i++)this.track(e,t,i)}track(e,t,i){let r={};const s=fit(this.projectionTransform,t),o=this._buildAdjustedModelViewTransform(s);this.markerDimensions[i][0],this.markerDimensions[i][1],this.trackingKeyframeList[i].width,this.trackingKeyframeList[i].height;const a=this.featurePointsListT[i],l=this.imagePixelsListT[i],u=this.imagePropertiesListT[i],c=this._computeProjection(o,e,i),{matchingPointsT:h,simT:d}=this._computeMatching(a,l,u,c),p=h.arraySync(),f=d.arraySync(),g=this.trackingKeyframeList[i],y=[],m=[],v=[];for(let w=0;w<p.length;w++)if(f[w]>wit&&w<g.points.length){v.push(w);const S=git(s,p[w][0],p[w][1]);m.push(S),y.push({x:g.points[w].x/g.scale,y:g.points[w].y/g.scale,z:0})}return this.debugMode&&(r={projectedImage:c.arraySync(),matchingPoints:h.arraySync(),goodTrack:v,trackedPoints:m}),o.dispose(),c.dispose(),h.dispose(),d.dispose(),{worldCoords:y,screenCoords:m,debugExtra:r}}_computeMatching(e,t,i,r){const s=yit,o=s*2+1,a=xit*bit,l=vit,u=a*2+1,c=r.shape[0],h=r.shape[1],d=e.shape[0];if(!this.kernelCaches.computeMatching){const p={variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[d,u*u],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    int featureIndex = coords[0];
	    int searchOffsetIndex = coords[1];

	    int markerWidth = int(getMarkerProperties(0));
	    int markerHeight = int(getMarkerProperties(1));
	    float markerScale = getMarkerProperties(2);

	    int searchOffsetX = imod(searchOffsetIndex, ${u}) * ${l};
	    int searchOffsetY = searchOffsetIndex / ${u} * ${l};

	    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);
	    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);

	    int sx = sCenterX + searchOffsetX - ${a};
	    int sy = sCenterY + searchOffsetY - ${a};

	    if (sx < ${s} || sx >= (${h} - ${s}) || sy < ${s} || sy >= (${c} - ${s})) {
	      setOutput(-2.);
	    } 
	    else {
	      float sumPoint = 0.;
	      float sumPointSquare = 0.;
	      float sumTemplate = 0.;
	      float sumTemplateSquare = 0.;
	      float sumPointTemplate = 0.;

	      for (int templateOffsetY = 0; templateOffsetY < ${o}; templateOffsetY++) {
		for (int templateOffsetX = 0; templateOffsetX < ${o}; templateOffsetX++) {
		  int fx2 = sCenterX + templateOffsetX - ${s};
		  int fy2 = sCenterY + templateOffsetY - ${s};

		  int sx2 = sx + templateOffsetX - ${s};
		  int sy2 = sy + templateOffsetY - ${s};

		  int markerPixelIndex = fy2 * markerWidth + fx2;
		  float markerPixel = getMarkerPixels(markerPixelIndex);
		  float targetPixel = getTargetPixels(sy2, sx2);

		  sumTemplate += markerPixel;
		  sumTemplateSquare += markerPixel * markerPixel;
		  sumPoint += targetPixel;
		  sumPointSquare += targetPixel * targetPixel;
		  sumPointTemplate += targetPixel * markerPixel;
		}
	      }

	      // Normalized cross-correlation
	      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)
	      float count = float(${o} * ${o});
	      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);
	      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);

	      if (pointVariance < 0.0000001) {
		setOutput(-3.);
	      } else if (templateVariance < 0.0000001) {
		//setOutput(sumTemplate);
		setOutput(-4.);
	      } else {
		sumPointTemplate -= sumPoint / count * sumTemplate;
		float sim = sumPointTemplate / pointVariance / templateVariance;  
		setOutput(sim);
	      }
	    }
	  }
	`},f={variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[d,2],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    float markerScale = getMarkerProperties(2);

	    int featureIndex = coords[0];

	    int maxIndex = int(getMaxIndex(featureIndex));
	    int searchLocationIndex = maxIndex / ${u*u};
	    int searchOffsetIndex = imod(maxIndex, ${u*u});

	    if (coords[1] == 0) {
	      int searchOffsetX = imod(searchOffsetIndex, ${u}) * ${l};
	      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${a}) / markerScale);
	    }
	    else if (coords[1] == 1) {
	      int searchOffsetY = searchOffsetIndex / ${u} * ${l};
	      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${a}) / markerScale);
	    }
	  }
	`},g={variableNames:["sims","maxIndex"],outputShape:[d],userCode:`
	  void main() {
	    int featureIndex = getOutputCoords();
	    int maxIndex = int(getMaxIndex(featureIndex));
	    setOutput(getSims(featureIndex, maxIndex));
	  }
	`};this.kernelCaches.computeMatching=[p,f,g]}return me(()=>{const p=this.kernelCaches.computeMatching,f=this._compileAndRun(p[0],[e,t,i,r]),g=f.argMax(1),y=this._compileAndRun(p[1],[e,i,g]),m=this._compileAndRun(p[2],[f,g]);return{matchingPointsT:y,simT:m}})}_computeProjection(e,t,i){const r=this.trackingKeyframeList[i].width,s=this.trackingKeyframeList[i].height,o=this.trackingKeyframeList[i].scale,a=r+"-"+s+"-"+o;if(this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),!this.kernelCaches.computeProjection[a]){const l={variableNames:["M","pixel"],outputShape:[s,r],userCode:`
	  void main() {
	      ivec2 coords = getOutputCoords();

	      float m00 = getM(0, 0) * ${lu}.;
	      float m01 = getM(0, 1) * ${lu}.;
	      float m03 = getM(0, 3) * ${lu}.;
	      float m10 = getM(1, 0) * ${lu}.;
	      float m11 = getM(1, 1) * ${lu}.;
	      float m13 = getM(1, 3) * ${lu}.;
	      float m20 = getM(2, 0) * ${lu}.;
	      float m21 = getM(2, 1) * ${lu}.;
	      float m23 = getM(2, 3) * ${lu}.;

	      float y = float(coords[0]) / float(${o});
	      float x = float(coords[1]) / float(${o});
	      float uz = (x * m20) + (y * m21) + m23;
	      float oneOverUz = 1. / uz;

	      float ux = (x * m00) + (y * m01) + m03;
	      float uy = (x * m10) + (y * m11) + m13;

	      ux = floor(ux * oneOverUz + 0.5);
	      uy = floor(uy * oneOverUz + 0.5);
	      setOutput(getPixel(int(uy), int(ux)));
	    }
	`};this.kernelCaches.computeProjection[a]=l}return me(()=>{const l=this.kernelCaches.computeProjection[a];return this._compileAndRun(l,[e,t])})}_buildAdjustedModelViewTransform(e){return me(()=>{let t=[];for(let i=0;i<e.length;i++){t.push([]);for(let r=0;r<e[i].length;r++)t[i].push(e[i][r]/lu)}return hi(t,[3,4])})}_prebuild(e,t){return me(()=>{const i=e.scale,r=[];for(let a=0;a<t;a++)a<e.points.length?r.push([e.points[a].x/i,e.points[a].y/i]):r.push([-1,-1]);const s=hi(e.data,[e.width*e.height]),o=hi([e.width,e.height,e.scale],[3]);return{featurePoints:hi(r,[r.length,2],"float32"),imagePixels:s,imageProperties:o}})}_compileAndRun(e,t){const i=vc().compileAndRun(e,t);return Wn().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}}const h_=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],Hf=[];for(let n=0;n<h_.length;n++){const e=h_[n].sigma;for(let t=0;t<h_[n].points.length;t++){const i=h_[n].points[t];Hf.push([e,i[0],i[1]])}}const tP={};function Cit(n){const e=n.shape[1],t=n.shape[0],i="w"+e+"h"+t;if(!tP.hasOwnProperty(i)){const r={variableNames:["p"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0], coords[1]-2);
          sum += getP(coords[0], coords[1]-1) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0], coords[1]+1) * 4.;
          sum += getP(coords[0], coords[1]+2);
          setOutput(sum);
        }
      `},s={variableNames:["p"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0]-2, coords[1]);
          sum += getP(coords[0]-1, coords[1]) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0]+1, coords[1]) * 4.;
          sum += getP(coords[0]+2, coords[1]);
          sum /= 256.;
          setOutput(sum);
        }
      `};tP[i]=[r,s]}return tP[i]}const _it=n=>{const e=n.inputs.image,t=n.backend,[i,r]=Cit(e),s=t.runWebGLProgram(i,[e],e.dtype),o=t.runWebGLProgram(r,[s],e.dtype);return t.disposeIntermediateTensorInfo(s),o},Mit={kernelName:"BinomialFilter",backendName:"webgl",kernelFunc:_it},d_=7,mj=3,Ait=mj*mj,nP=4,Eit=(nP+1)*(nP+1)/nP,iP={};function Iit(n){const e=n.shape[1],t=n.shape[0],i="w"+e+"h"+t;if(!iP.hasOwnProperty(i)){const r={variableNames:["image0","image1","image2"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();
    
          int y = coords[0];
          int x = coords[1];
    
          float value = getImage1(y, x);
    
          // Step 1: find local maxima/minima
          if (value * value < ${Ait}.) {
            setOutput(0.);
            return;
          }
          if (y < ${d_} || y > ${t-1-d_}) {
            setOutput(0.);
            return;
          }
          if (x < ${d_} || x > ${e-1-d_}) {
            setOutput(0.);
            return;
          }
    
          bool isMax = true;
          bool isMin = true;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              float value0 = getImage0(y+dy, x+dx);
              float value1 = getImage1(y+dy, x+dx);
              float value2 = getImage2(y+dy, x+dx);
    
        if (value < value0 || value < value1 || value < value2) {
          isMax = false;
        }
        if (value > value0 || value > value1 || value > value2) {
          isMin = false;
        }
            }
          }
    
          if (!isMax && !isMin) {
            setOutput(0.);
            return;
          }
    
          // compute edge score and reject based on threshold
          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);
          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);
          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));
    
          float det = (dxx * dyy) - (dxy * dxy);
    
          if (abs(det) < 0.0001) { // determinant undefined. no solution
            setOutput(0.);
            return;
          }
    
          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;
    
          if (abs(edgeScore) >= ${Eit} ) {
            setOutput(0.);
            return;
          }
          setOutput(getImage1(y,x));
        }
      `};iP[i]=r}return iP[i]}const kit=n=>{let{image0:e,image1:t,image2:i}=n.inputs;const r=n.backend,s=Iit(t);return e=Wn().runKernel("DownsampleBilinear",{image:e}),i=Wn().runKernel("UpsampleBilinear",{image:i,targetImage:t}),r.runWebGLProgram(s,[e,t,i],t.dtype)},Rit={kernelName:"BuildExtremas",backendName:"webgl",kernelFunc:kit},Tx=36,rP={};function Nit(n){const e=n.shape[0];if(!rP.hasOwnProperty(e)){const t={variableNames:["histogram"],outputShape:[n.shape[0]],userCode:`
            void main() {
                int featureIndex = getOutputCoords();

                int maxIndex = 0;
                for (int i = 1; i < ${Tx}; i++) {
                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {
                        maxIndex = i;
                    }
                }

                int prev = imod(maxIndex - 1 + ${Tx}, ${Tx});
                int next = imod(maxIndex + 1, ${Tx});

                /**
                 * Fit a quatratic to 3 points. The system of equations is:
                 *
                 * y0 = A*x0^2 + B*x0 + C
                 * y1 = A*x1^2 + B*x1 + C
                 * y2 = A*x2^2 + B*x2 + C
                 *
                 * This system of equations is solved for A,B,C.
                 */
                float p10 = float(maxIndex - 1);
                float p11 = getHistogram(featureIndex, prev); 
                float p20 = float(maxIndex);
                float p21 = getHistogram(featureIndex, maxIndex); 
                float p30 = float(maxIndex + 1);
                float p31 = getHistogram(featureIndex, next); 

                float d1 = (p30-p20)*(p30-p10);
                float d2 = (p10-p20)*(p30-p10);
                float d3 = p10-p20;

                // If any of the denominators are zero then, just use maxIndex.
                    float fbin = float(maxIndex);
                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {
                float a = p10*p10;
                float b = p20*p20;

                // Solve for the coefficients A,B,C
                float A = ((p31-p21)/d1)-((p11-p21)/d2);
                float B = ((p11-p21)+(A*(b-a)))/d3;
                float C = p11-(A*a)-(B*p10);
                fbin = -B / (2. * A);
                }

                float an = 2.0 *${Math.PI} * (fbin + 0.5) / ${Tx}. - ${Math.PI};
                setOutput(an);
            }
            `};rP[e]=t}return rP[e]}const Lit=n=>{const{histograms:e}=n.inputs,t=n.backend,i=Nit(e);return t.runWebGLProgram(i,[e],e.dtype)},Pit={kernelName:"ComputeExtremaAngles",backendName:"webgl",kernelFunc:Lit},gj=7,sP={};function Dit(n,e){const t=`${n}|${e.shape[0]}`;if(!sP.hasOwnProperty(t)){const i=[];for(let o=1;o<n;o++)i.push("image"+o);let r="float getPixel(int octave, int y, int x) {";for(let o=1;o<n;o++)r+=`
  if (octave == ${o}) {
	return getImage${o}(y, x);
  }
`;r+="}";const s={variableNames:[...i,"extrema","angles","freakPoints"],outputShape:[e.shape[0],Hf.length],userCode:`
  ${r}
  void main() {
	ivec2 coords = getOutputCoords();
	int featureIndex = coords[0];
	int freakIndex = coords[1];

	float freakSigma = getFreakPoints(freakIndex, 0);
	float freakX = getFreakPoints(freakIndex, 1);
	float freakY = getFreakPoints(freakIndex, 2);

	int octave = int(getExtrema(featureIndex, 1));
	float inputY = getExtrema(featureIndex, 2);
	float inputX = getExtrema(featureIndex, 3);
	float inputAngle = getAngles(featureIndex);
	float cos = ${gj}. * cos(inputAngle);
	float sin = ${gj}. * sin(inputAngle);

	float yp = inputY + freakX * sin + freakY * cos;
	float xp = inputX + freakX * cos + freakY * -sin;

	int x0 = int(floor(xp));
	int x1 = x0 + 1;
	int y0 = int(floor(yp));
	int y1 = y0 + 1;

	float f1 = getPixel(octave, y0, x0);
	float f2 = getPixel(octave, y0, x1);
	float f3 = getPixel(octave, y1, x0);
	float f4 = getPixel(octave, y1, x1);

	float x1f = float(x1);
	float y1f = float(y1);
	float x0f = float(x0);
	float y0f = float(y0);

	// ratio for interpolation between four neighbouring points
	float value = (x1f - xp) * (y1f - yp) * f1
		+ (xp - x0f) * (y1f - yp) * f2
		+ (x1f - xp) * (yp - y0f) * f3
		+ (xp - x0f) * (yp - y0f) * f4;

	setOutput(value);
  }
`};sP[t]=s}return sP[t]}const Fit=n=>{const{gaussianImagesT:e,prunedExtremas:t,prunedExtremasAngles:i,freakPointsT:r,pyramidImagesLength:s}=n.inputs,o=n.backend,a=Dit(s,t);return o.runWebGLProgram(a,[...e,t,i,r],"float32")},Oit={kernelName:"ComputeExtremaFreak",backendName:"webgl",kernelFunc:Fit},Qse=(Hf.length-1)*Hf.length/2,Bit=Math.ceil(Qse/8),oP={};function zit(n){const e=`${n.shape[0]}`;if(!oP.hasOwnProperty(e)){const t={variableNames:["freak","p"],outputShape:[n.shape[0],Bit],userCode:`
  void main() {
    ivec2 coords = getOutputCoords();
    int featureIndex = coords[0];
    int descIndex = coords[1] * 8;

    int sum = 0;
    for (int i = 0; i < 8; i++) {
      if (descIndex + i >= ${Qse}) {
        continue;
      }

      int p1 = int(getP(descIndex + i, 0));
      int p2 = int(getP(descIndex + i, 1));

      float v1 = getFreak(featureIndex, p1);
      float v2 = getFreak(featureIndex, p2);

      if (v1 < v2 + 0.01) {
        sum += int(pow(2.0, float(7 - i)));
      }
    }
    setOutput(float(sum));
  }
`};oP[e]=t}return oP[e]}const Git=n=>{const{extremaFreaks:e,positionT:t}=n.inputs,{backend:i}=n,r=zit(e);return i.runWebGLProgram(r,[e,t],"int32")},Vit={kernelName:"ComputeFreakDescriptors",backendName:"webgl",kernelFunc:Git},aP={};function Uit(n,e){const t=`${n}|${e}`;if(!aP.hasOwnProperty(t)){const i=[];let r="float getPixel(int octave, int y, int x) {";for(let s=1;s<n;s++)i.push("image"+s),r+=`
				if (octave == ${s}) {
					return getImage${s}(y, x);
				}
			`;r+="}",aP[t]={variableNames:[...i,"extrema"],outputShape:[e,3,3],userCode:`
			${r}
		
			void main() {
				ivec3 coords = getOutputCoords();
				int featureIndex = coords[0];
				float score = getExtrema(featureIndex, 0);
				if (score == 0.0) {
					return;
				}
		
				int dy = coords[1]-1;
				int dx = coords[2]-1;
				int octave = int(getExtrema(featureIndex, 1));
				int y = int(getExtrema(featureIndex, 2));
				int x = int(getExtrema(featureIndex, 3));
				setOutput(getPixel(octave, y+dy, x+dx));
			}
			`}}return aP[t]}const $it=n=>{const{prunedExtremasList:e,dogPyramidImagesT:t}=n.inputs,i=n.backend,r=Uit(t.length,e.length),s=hi(e,[e.length,e[0].length],"int32");return i.runWebGLProgram(r,[...t.slice(1),s],t[0].dtype)},Wit={kernelName:"ComputeLocalization",backendName:"webgl",kernelFunc:$it},Hit=.159154943091895,yg=36,lP={};function Xit(n,e,t){const i=`${t}|${n.shape[0]}|${e.shape[0]}`;if(!lP.hasOwnProperty(i)){const r=[];for(let l=1;l<t;l++)r.push("image"+l);let s="float getPixel(int octave, int y, int x) {";for(let l=1;l<t;l++)s+=`
            if (octave == ${l}) {
                return getImage${l}(y, x);
            }
            `;s+="}";const o={variableNames:[...r,"extrema","radial"],outputShape:[n.shape[0],e.shape[0],2],userCode:`
                ${s}

                void main() {
                    ivec3 coords = getOutputCoords();
                    int featureIndex = coords[0];
                    int radialIndex = coords[1];
                    int propertyIndex = coords[2];

                    int radialY = int(getRadial(radialIndex, 0));
                    int radialX = int(getRadial(radialIndex, 1));
                    float radialW = getRadial(radialIndex, 2);

                    int octave = int(getExtrema(featureIndex, 1));
                    int y = int(getExtrema(featureIndex, 2));
                    int x = int(getExtrema(featureIndex, 3));

                    int xp = x + radialX;
                    int yp = y + radialY;

                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);
                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);

                    if (propertyIndex == 0) {
                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0
                    
                    float angle = atan(dy, dx) + ${Math.PI};
                    float fbin = angle * ${yg}. * ${Hit};
                    setOutput(fbin);
                    return;
                    }

                    if (propertyIndex == 1) {
                        float mag = sqrt(dx * dx + dy * dy);
                        float magnitude = radialW * mag;
                        setOutput(magnitude);
                        return;
                    }
                }

                `},a={variableNames:["fbinMag"],outputShape:[n.shape[0],yg],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int featureIndex = coords[0];
                int binIndex = coords[1];

                float sum = 0.;
                for (int i = 0; i < ${e.shape[0]}; i++) {
                    float fbin = getFbinMag(featureIndex, i, 0);
                    int bin = int(floor(fbin - 0.5));
                    int b1 = imod(bin + ${yg}, ${yg});
                    int b2 = imod(bin + 1 + ${yg}, ${yg});

                    if (b1 == binIndex || b2 == binIndex) {
                        float magnitude = getFbinMag(featureIndex, i, 1);
                        float w2 = fbin - float(bin) - 0.5;
                        float w1 = w2 * -1. + 1.;

                        if (b1 == binIndex) {
                            sum += w1 * magnitude;
                        }
                        if (b2 == binIndex) {
                            sum += w2 * magnitude;
                        }
                    }
                }
                setOutput(sum);
            }
            `};lP[i]=[o,a]}return lP[i]}const Kit=n=>{const{gaussianImagesT:e,prunedExtremasT:t,radialPropertiesT:i,pyramidImagesLength:r}=n.inputs,s=n.backend,[o,a]=Xit(t,i,r),l=s.runWebGLProgram(o,[...e,t,i],i.dtype),u=s.runWebGLProgram(a,[l],i.dtype);return s.disposeIntermediateTensorInfo(l),u},Zit={kernelName:"ComputeOrientationHistograms",backendName:"webgl",kernelFunc:Kit},uP={};function jit(n){const e=n.shape[1],t=n.shape[0],i="w"+e+"h"+t;if(!uP.hasOwnProperty(i)){const r={variableNames:["p"],outputShape:[Math.floor(t/2),Math.floor(e/2)],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int y = coords[0] * 2;
                int x = coords[1] * 2;
        
                float sum = getP(y, x) * 0.25;
                sum += getP(y+1,x) * 0.25; 
                sum += getP(y, x+1) * 0.25; 
                sum += getP(y+1,x+1) * 0.25;
                setOutput(sum);
            }
            `};uP[i]=r}return uP[i]}const Yit=n=>{const e=n.inputs.image,t=n.backend,i=jit(e);return t.runWebGLProgram(i,[e],e.dtype)},Jit={kernelName:"DownsampleBilinear",backendName:"webgl",kernelFunc:Yit},Qit=n=>{const{extremasResultT:e}=n.inputs,t=n.backend,i=e.shape[0],r=e.shape[1],s={variableNames:["extrema"],outputShape:[Math.floor(i/2),Math.floor(r/2)],userCode:`
		  void main() {
			ivec2 coords = getOutputCoords();
			int y = coords[0] * 2;
			int x = coords[1] * 2;
  
			float location = 0.0;
			float values = getExtrema(y, x);
  
			if (getExtrema(y+1, x) != 0.0) {
			  location = 1.0;
		  values = getExtrema(y+1, x);
			}
			else if (getExtrema(y, x+1) != 0.0) {
			  location = 2.0;
		  values = getExtrema(y, x+1);
			}
			else if (getExtrema(y+1, x+1) != 0.0) {
			  location = 3.0;
		  values = getExtrema(y+1, x+1);
			}
  
			if (values < 0.0) {
			  setOutput(location * -1000.0 + values);
			} else {
			  setOutput(location * 1000.0 + values);
			}
		  }
		`};return t.runWebGLProgram(s,[e],e.dtype)},qit={kernelName:"ExtremaReduction",backendName:"webgl",kernelFunc:Qit},p_=36,ert=5,cP={};function trt(n){const e=`h${n.shape[0]}`;if(!cP.hasOwnProperty(e)){const t={variableNames:["histogram"],outputShape:[n.shape[0],p_],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();

                int featureIndex = coords[0];
                int binIndex = coords[1];

                int prevBin = imod(binIndex - 1 + ${p_}, ${p_});
                int nextBin = imod(binIndex + 1, ${p_});
                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);

                setOutput(result);
            }
            `};cP[e]=t}return cP[e]}const nrt=n=>{let{histograms:e}=n.inputs;const t=n.backend,i=trt(e);for(let r=0;r<ert;r++){const s=e;e=t.runWebGLProgram(i,[e],e.dtype),r>0&&t.disposeIntermediateTensorInfo(s)}return e},irt={kernelName:"SmoothHistograms",backendName:"webgl",kernelFunc:nrt},hP={};function rrt(n,e){const t=e.shape[1],i=e.shape[0],r="w"+t+"h"+i;if(!hP.hasOwnProperty(r)){const s={variableNames:["p"],outputShape:[i,t],userCode:`
              void main() {
                ivec2 coords = getOutputCoords();
                int j = coords[0];
                int i = coords[1];
        
                float sj = 0.5 * float(j) - 0.25; 
                float si = 0.5 * float(i) - 0.25;
        
                float sj0 = floor(sj);
                float sj1 = ceil(sj);
                float si0 = floor(si);
                float si1 = ceil(si);
        
                int sj0I = int(sj0);
                int sj1I = int(sj1);
                int si0I = int(si0);
                int si1I = int(si1);
        
                float sum = 0.0;
                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
                setOutput(sum);
              }
            `};hP[r]=s}return hP[r]}const srt=n=>{const{image:e,targetImage:t}=n.inputs,i=n.backend,r=rrt(e,t);return i.runWebGLProgram(r,[e],e.dtype)},ort={kernelName:"UpsampleBilinear",backendName:"webgl",kernelFunc:srt};so(Mit);so(Rit);so(Pit);so(Oit);so(Vit);so(Wit);so(Zit);so(Jit);so(qit);so(irt);so(ort);const yj=8,art=5,Cx=10,lrt=5,dP=3,urt=1.5;(Hf.length-1)*Hf.length/2;class qse{constructor(e,t,i=!1){this.debugMode=i,this.width=e,this.height=t;let r=0;for(;e>=yj&&t>=yj&&(e/=2,t/=2,r++,r!==art););this.numOctaves=r,this.tensorCaches={},this.kernelCaches={}}detectImageData(e){const t=new Uint8ClampedArray(4*e.length);for(let r=0;r<e.length;r++)t[4*r]=e[r],t[4*r+1]=e[r],t[4*r+2]=e[r],t[4*r+3]=255;const i=new ImageData(t,this.width,this.height);return this.detect(i)}detect(e){let t=null;const i=[];for(let m=0;m<this.numOctaves;m++){let v,w;m===0?v=this._applyFilter(e):v=this._downsampleBilinear(i[m-1][i[m-1].length-1]),w=this._applyFilter(v),i.push([v,w])}const r=[];for(let m=0;m<this.numOctaves;m++){let v=this._differenceImageBinomial(i[m][0],i[m][1]);r.push(v)}const s=[];for(let m=1;m<this.numOctaves-1;m++){const v=this._buildExtremas(r[m-1],r[m],r[m+1]);s.push(v)}const o=this._applyPrune(s),a=this._computeLocalization(o,r),l=this._computeOrientationHistograms(a,i),u=this._smoothHistograms(l),c=this._computeExtremaAngles(u),h=this._computeExtremaFreak(i,a,c),d=this._computeFreakDescriptors(h),p=a.arraySync(),f=c.arraySync(),g=d.arraySync();this.debugMode&&(t={pyramidImages:i.map(m=>m.map(v=>v.arraySync())),dogPyramidImages:r.map(m=>m?m.arraySync():null),extremasResults:s.map(m=>m.arraySync()),extremaAngles:c.arraySync(),prunedExtremas:o,localizedExtremas:a.arraySync()}),i.forEach(m=>m.forEach(v=>v.dispose())),r.forEach(m=>m&&m.dispose()),s.forEach(m=>m.dispose()),a.dispose(),l.dispose(),u.dispose(),c.dispose(),h.dispose(),d.dispose();const y=[];for(let m=0;m<p.length;m++){if(p[m][0]==0)continue;const v=[];for(let I=0;I<g[m].length;I+=4){const E=g[m][I],k=g[m][I+1],P=g[m][I+2],V=g[m][I+3];let U=E*16777216+k*65536+P*256+V;v.push(U)}const w=p[m][1],S=p[m][2],C=p[m][3]*Math.pow(2,w)+Math.pow(2,w-1)-.5,_=S*Math.pow(2,w)+Math.pow(2,w-1)-.5,A=Math.pow(2,w);y.push({maxima:p[m][0]>0,x:C,y:_,scale:A,angle:f[m],descriptors:v})}return{featurePoints:y,debugExtra:t}}_computeFreakDescriptors(e){if(!this.tensorCaches.computeFreakDescriptors){const i=[],r=[];for(let a=0;a<e.shape[1];a++)for(let l=a+1;l<e.shape[1];l++)i.push(a),r.push(l);const s=hi(i,[i.length]).cast("int32"),o=hi(r,[r.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:Ri(Ls([s,o],1))}}const{positionT:t}=this.tensorCaches.computeFreakDescriptors;return me(()=>Wn().runKernel("ComputeFreakDescriptors",{extremaFreaks:e,positionT:t}))}_computeExtremaFreak(e,t,i){this.tensorCaches._computeExtremaFreak||me(()=>{const o=hi(Hf);this.tensorCaches._computeExtremaFreak={freakPointsT:Ri(o)}});const{freakPointsT:r}=this.tensorCaches._computeExtremaFreak,s=[];for(let o=1;o<e.length;o++)s.push(e[o][1]);return me(()=>Wn().runKernel("ComputeExtremaFreak",{gaussianImagesT:s,prunedExtremas:t,prunedExtremasAngles:i,freakPointsT:r,pyramidImagesLength:e.length}))}_computeExtremaAngles(e){return me(()=>Wn().runKernel("ComputeExtremaAngles",{histograms:e}))}_computeOrientationHistograms(e,t){const i=[];for(let s=1;s<t.length;s++)i.push(t[s][1]);this.tensorCaches.orientationHistograms||me(()=>{const s=-1/(2*dP*dP),o=dP*urt,a=Math.ceil(o),l=[];for(let u=-a;u<=a;u++)for(let c=-a;c<=a;c++){const h=c*c+u*u;if(h<=o*o){const d=h*s;let p=(720+d*(720+d*(360+d*(120+d*(30+d*(6+d))))))*.0013888888;l.push([u,c,p])}}this.tensorCaches.orientationHistograms={radialPropertiesT:Ri(hi(l,[l.length,3]))}});const{radialPropertiesT:r}=this.tensorCaches.orientationHistograms;return me(()=>Wn().runKernel("ComputeOrientationHistograms",{gaussianImagesT:i,prunedExtremasT:e,radialPropertiesT:r,pyramidImagesLength:t.length}))}_smoothHistograms(e){return me(()=>Wn().runKernel("SmoothHistograms",{histograms:e}))}_computeLocalization(e,t){return me(()=>{const i=Wn().runKernel("ComputeLocalization",{prunedExtremasList:e,dogPyramidImagesT:t}).arraySync(),r=[];for(let o=0;o<i.length;o++){r.push([]);for(let a=0;a<i[o].length;a++)r[o].push([])}const s=[];for(let o=0;o<e.length;o++)s[o]=[e[o][0],e[o][1],e[o][2],e[o][3]];for(let o=0;o<s.length;o++){if(s[o][0]===0)continue;const a=i[o],l=.5*(a[1][2]-a[1][0]),u=.5*(a[2][1]-a[0][1]),c=a[1][2]+a[1][0]-2*a[1][1],h=a[2][1]+a[0][1]-2*a[1][1],d=.25*(a[0][0]+a[2][2]-a[0][2]-a[2][0]),p=c*h-d*d,f=(h*-l+-d*-u)/p,g=(-d*-l+c*-u)/p,y=s[o][2]+g,m=s[o][3]+f;Math.abs(p)<1e-4||(s[o][2]=y,s[o][3]=m)}return hi(s,[s.length,s[0].length],"float32")})}_applyPrune(e){const t=Cx*Cx,i=lrt,r=[],s=[];for(let a=0;a<t;a++){s.push([]),r.push([]);for(let l=0;l<i;l++)s[a].push([0,0,0,0]),r[a].push(0)}me(()=>{for(let a=0;a<e.length;a++){const l=Wn().runKernel("ExtremaReduction",{extremasResultT:e[a]}),u=a+1,c=l.arraySync(),h=l.shape[0],d=l.shape[1],p=d*2/Cx,f=h*2/Cx;for(let g=0;g<h;g++)for(let y=0;y<d;y++){const m=c[g][y];if(m==0)continue;const v=m%1e3,w=Math.floor(Math.abs(m)/1e3),S=y*2+(w===2||w===3?1:0),C=g*2+(w===1||w===3?1:0),_=Math.floor(S/p),A=Math.floor(C/f)*Cx+_,I=Math.abs(v);let E=i;for(;E>=1&&I>r[A][E-1];)E-=1;if(E<i){for(let k=i-1;k>=E+1;k--)r[A][k]=r[A][k-1],s[A][k][0]=s[A][k-1][0],s[A][k][1]=s[A][k-1][1],s[A][k][2]=s[A][k-1][2],s[A][k][3]=s[A][k-1][3];r[A][E]=I,s[A][E][0]=v,s[A][E][1]=u,s[A][E][2]=C,s[A][E][3]=S}}}});const o=[];for(let a=0;a<t;a++)for(let l=0;l<i;l++)o.push(s[a][l]);return o}_buildExtremas(e,t,i){return me(()=>Wn().runKernel("BuildExtremas",{image0:e,image1:t,image2:i}))}_differenceImageBinomial(e,t){return me(()=>e.sub(t))}_applyFilter(e){return me(()=>Wn().runKernel("BinomialFilter",{image:e}))}_downsampleBilinear(e){return me(()=>Wn().runKernel("DownsampleBilinear",{image:e}))}_compileAndRun(e,t){const i=vc().compileAndRun(e,t);return Wn().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}_runWebGLProgram(e,t,i){const r=vc().runWebGLProgram(e,t,i);return Wn().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}}class crt{constructor(e,t,i=!1){this.debugMode=i,this.width=e,this.height=t;let r=Math.min(e,t)/2,s=Math.pow(2,Math.round(Math.log(r)/Math.log(2)));this.cropSize=s,this.detector=new qse(s,s,i),this.kernelCaches={},this.lastRandomIndex=4}detect(e){const t=Math.floor(this.height/2-this.cropSize/2),i=Math.floor(this.width/2-this.cropSize/2),r=this._detect(e,i,t);return this.debugMode&&(r.debugExtra.crop={startX:i,startY:t,cropSize:this.cropSize}),r}detectMoving(e){const t=this.lastRandomIndex%3,i=Math.floor(this.lastRandomIndex/3);let r=Math.floor(this.height/2-this.cropSize+i*this.cropSize/2),s=Math.floor(this.width/2-this.cropSize+t*this.cropSize/2);return s<0&&(s=0),r<0&&(r=0),s>=this.width-this.cropSize&&(s=this.width-this.cropSize-1),r>=this.height-this.cropSize&&(r=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(e,s,r)}_detect(e,t,i){const r=e.slice([i,t],[this.cropSize,this.cropSize]),{featurePoints:s,debugExtra:o}=this.detector.detect(r);return s.forEach(a=>{a.x+=t,a.y+=i}),this.debugMode&&(o.projectedImage=r.arraySync()),r.dispose(),{featurePoints:s,debugExtra:o}}}const eoe=({image:n,ratio:e})=>{const t=Math.round(n.width*e),i=Math.round(n.height*e),r=new Uint8Array(t*i);for(let s=0;s<t;s++){let o=Math.round(1*s/e),a=Math.round(1*(s+1)/e)-1;a>=n.width&&(a=n.width-1);for(let l=0;l<i;l++){let u=Math.round(1*l/e),c=Math.round(1*(l+1)/e)-1;c>=n.height&&(c=n.height-1);let h=0,d=0;for(let p=o;p<=a;p++)for(let f=u;f<=c;f++)h+=1*n.data[f*n.width+p],d+=1;r[l*t+s]=Math.floor(h/d)}}return{data:r,width:t,height:i}},hrt=100,drt=n=>{const e=hrt/Math.min(n.width,n.height),t=[];let i=e;for(;;)if(t.push(i),i*=Math.pow(2,1/3),i>=.95){i=1;break}t.push(i),t.reverse();const r=[];for(let s=0;s<t.length;s++)n.width*t[s],n.height*t[s],r.push(Object.assign(eoe({image:n,ratio:t[s]}),{scale:t[s]}));return r},prt=n=>{const e=Math.min(n.width,n.height),t=[],i=[];t.push(256/e),t.push(128/e);for(let r=0;r<t.length;r++)i.push(Object.assign(eoe({image:n,ratio:t[r]}),{scale:t[r]}));return i},frt=n=>{const{v1:e,v2:t}=n;let i=0;for(let r=0;r<e.length;r++){let s=(e[r]^t[r])>>>0;i+=mrt(s)}return i},mrt=n=>{var e=n-(n>>1&1431655765);return e=(e>>2&858993459)+(e&858993459),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},grt=1234,yrt=()=>({seed:grt,arrayShuffle(n){const{arr:e,sampleSize:t}=n;for(let i=0;i<t;i++){this.seed=(214013*this.seed+2531011)%-2147483648;let r=this.seed>>16&32767;r=r%e.length;let s=e[i];e[i]=e[r],e[r]=s}},nextInt(n){this.seed=(214013*this.seed+2531011)%-2147483648;let e=this.seed>>16&32767;return e=e%n,e}}),brt=16,xrt=128,RF=8,vrt=n=>{const{points:e,pointIndexes:t,randomizer:i}=n,r=[];for(let l=0;l<t.length;l++)r.push(l);let s=Number.MAX_SAFE_INTEGER,o=-1;const a=[];for(let l=0;l<xrt;l++){i.arrayShuffle({arr:r,sampleSize:RF});let u=0;const c=[];for(let h=0;h<t.length;h++){let d=Number.MAX_SAFE_INTEGER;for(let p=0;p<RF;p++){const f=t[r[p]],g=frt({v1:e[t[h]].descriptors,v2:e[f].descriptors});g<d&&(c[h]=r[p],d=g)}u+=d}a.push(c),u<s&&(s=u,o=l)}return a[o]},bj=({points:n})=>{const e=[];for(let i=0;i<n.length;i++)e.push(i);const t=yrt();return{rootNode:toe({points:n,pointIndexes:e,centerPointIndex:null,randomizer:t})}},toe=n=>{const{points:e,pointIndexes:t,centerPointIndex:i,randomizer:r}=n;let s=!1;(t.length<=RF||t.length<=brt)&&(s=!0);const o={};if(!s){const l=vrt({points:e,pointIndexes:t,randomizer:r});for(let u=0;u<l.length;u++)o[t[l[u]]]===void 0&&(o[t[l[u]]]=[]),o[t[l[u]]].push(t[u])}Object.keys(o).length===1&&(s=!0);const a={centerPointIndex:i};if(s){a.leaf=!0,a.pointIndexes=[];for(let l=0;l<t.length;l++)a.pointIndexes.push(t[l]);return a}return a.leaf=!1,a.children=[],Object.keys(o).forEach(l=>{a.children.push(toe({points:e,pointIndexes:o[l],centerPointIndex:l,randomizer:r}))}),a};var Dp=4294967295;function wrt(n,e,t){var i=t/4294967296,r=t;n.setUint32(e,i),n.setUint32(e+4,r)}function noe(n,e,t){var i=Math.floor(t/4294967296),r=t;n.setUint32(e,i),n.setUint32(e+4,r)}function ioe(n,e){var t=n.getInt32(e),i=n.getUint32(e+4);return t*4294967296+i}function Srt(n,e){var t=n.getUint32(e),i=n.getUint32(e+4);return t*4294967296+i}var pP,fP,mP,Mk=(typeof process>"u"||((pP=process==null?void 0:process.env)===null||pP===void 0?void 0:pP.TEXT_ENCODING)!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function xj(n){for(var e=n.length,t=0,i=0;i<e;){var r=n.charCodeAt(i++);if(r&4294967168)if(!(r&4294965248))t+=2;else{if(r>=55296&&r<=56319&&i<e){var s=n.charCodeAt(i);(s&64512)===56320&&(++i,r=((r&1023)<<10)+(s&1023)+65536)}r&4294901760?t+=4:t+=3}else{t++;continue}}return t}function Trt(n,e,t){for(var i=n.length,r=t,s=0;s<i;){var o=n.charCodeAt(s++);if(o&4294967168)if(!(o&4294965248))e[r++]=o>>6&31|192;else{if(o>=55296&&o<=56319&&s<i){var a=n.charCodeAt(s);(a&64512)===56320&&(++s,o=((o&1023)<<10)+(a&1023)+65536)}o&4294901760?(e[r++]=o>>18&7|240,e[r++]=o>>12&63|128,e[r++]=o>>6&63|128):(e[r++]=o>>12&15|224,e[r++]=o>>6&63|128)}else{e[r++]=o;continue}e[r++]=o&63|128}}var TA=Mk?new TextEncoder:void 0,Crt=Mk?typeof process<"u"&&((fP=process==null?void 0:process.env)===null||fP===void 0?void 0:fP.TEXT_ENCODING)!=="force"?200:0:Dp;function _rt(n,e,t){e.set(TA.encode(n),t)}function Mrt(n,e,t){TA.encodeInto(n,e.subarray(t))}var Art=TA!=null&&TA.encodeInto?Mrt:_rt,Ert=4096;function roe(n,e,t){for(var i=e,r=i+t,s=[],o="";i<r;){var a=n[i++];if(!(a&128))s.push(a);else if((a&224)===192){var l=n[i++]&63;s.push((a&31)<<6|l)}else if((a&240)===224){var l=n[i++]&63,u=n[i++]&63;s.push((a&31)<<12|l<<6|u)}else if((a&248)===240){var l=n[i++]&63,u=n[i++]&63,c=n[i++]&63,h=(a&7)<<18|l<<12|u<<6|c;h>65535&&(h-=65536,s.push(h>>>10&1023|55296),h=56320|h&1023),s.push(h)}else s.push(a);s.length>=Ert&&(o+=String.fromCharCode.apply(String,s),s.length=0)}return s.length>0&&(o+=String.fromCharCode.apply(String,s)),o}var Irt=Mk?new TextDecoder:null,krt=Mk?typeof process<"u"&&((mP=process==null?void 0:process.env)===null||mP===void 0?void 0:mP.TEXT_DECODER)!=="force"?200:0:Dp;function Rrt(n,e,t){var i=n.subarray(e,e+t);return Irt.decode(i)}var f_=function(){function n(e,t){this.type=e,this.data=t}return n}(),Nrt=globalThis&&globalThis.__extends||function(){var n=function(e,t){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(i,r){i.__proto__=r}||function(i,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(i[s]=r[s])},n(e,t)};return function(e,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");n(e,t);function i(){this.constructor=e}e.prototype=t===null?Object.create(t):(i.prototype=t.prototype,new i)}}(),du=function(n){Nrt(e,n);function e(t){var i=n.call(this,t)||this,r=Object.create(e.prototype);return Object.setPrototypeOf(i,r),Object.defineProperty(i,"name",{configurable:!0,enumerable:!1,value:e.name}),i}return e}(Error),Lrt=-1,Prt=4294967296-1,Drt=17179869184-1;function Frt(n){var e=n.sec,t=n.nsec;if(e>=0&&t>=0&&e<=Drt)if(t===0&&e<=Prt){var i=new Uint8Array(4),r=new DataView(i.buffer);return r.setUint32(0,e),i}else{var s=e/4294967296,o=e&4294967295,i=new Uint8Array(8),r=new DataView(i.buffer);return r.setUint32(0,t<<2|s&3),r.setUint32(4,o),i}else{var i=new Uint8Array(12),r=new DataView(i.buffer);return r.setUint32(0,t),noe(r,4,e),i}}function Ort(n){var e=n.getTime(),t=Math.floor(e/1e3),i=(e-t*1e3)*1e6,r=Math.floor(i/1e9);return{sec:t+r,nsec:i-r*1e9}}function Brt(n){if(n instanceof Date){var e=Ort(n);return Frt(e)}else return null}function zrt(n){var e=new DataView(n.buffer,n.byteOffset,n.byteLength);switch(n.byteLength){case 4:{var t=e.getUint32(0),i=0;return{sec:t,nsec:i}}case 8:{var r=e.getUint32(0),s=e.getUint32(4),t=(r&3)*4294967296+s,i=r>>>2;return{sec:t,nsec:i}}case 12:{var t=ioe(e,4),i=e.getUint32(0);return{sec:t,nsec:i}}default:throw new du("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(n.length))}}function Grt(n){var e=zrt(n);return new Date(e.sec*1e3+e.nsec/1e6)}var Vrt={type:Lrt,encode:Brt,decode:Grt},soe=function(){function n(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(Vrt)}return n.prototype.register=function(e){var t=e.type,i=e.encode,r=e.decode;if(t>=0)this.encoders[t]=i,this.decoders[t]=r;else{var s=1+t;this.builtInEncoders[s]=i,this.builtInDecoders[s]=r}},n.prototype.tryToEncode=function(e,t){for(var i=0;i<this.builtInEncoders.length;i++){var r=this.builtInEncoders[i];if(r!=null){var s=r(e,t);if(s!=null){var o=-1-i;return new f_(o,s)}}}for(var i=0;i<this.encoders.length;i++){var r=this.encoders[i];if(r!=null){var s=r(e,t);if(s!=null){var o=i;return new f_(o,s)}}}return e instanceof f_?e:null},n.prototype.decode=function(e,t,i){var r=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return r?r(e,t,i):new f_(t,e)},n.defaultCodec=new n,n}();function CA(n){return n instanceof Uint8Array?n:ArrayBuffer.isView(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n instanceof ArrayBuffer?new Uint8Array(n):Uint8Array.from(n)}function Urt(n){if(n instanceof ArrayBuffer)return new DataView(n);var e=CA(n);return new DataView(e.buffer,e.byteOffset,e.byteLength)}var $rt=100,Wrt=2048,Hrt=function(){function n(e,t,i,r,s,o,a,l){e===void 0&&(e=soe.defaultCodec),t===void 0&&(t=void 0),i===void 0&&(i=$rt),r===void 0&&(r=Wrt),s===void 0&&(s=!1),o===void 0&&(o=!1),a===void 0&&(a=!1),l===void 0&&(l=!1),this.extensionCodec=e,this.context=t,this.maxDepth=i,this.initialBufferSize=r,this.sortKeys=s,this.forceFloat32=o,this.ignoreUndefined=a,this.forceIntegerToFloat=l,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return n.prototype.reinitializeState=function(){this.pos=0},n.prototype.encodeSharedRef=function(e){return this.reinitializeState(),this.doEncode(e,1),this.bytes.subarray(0,this.pos)},n.prototype.encode=function(e){return this.reinitializeState(),this.doEncode(e,1),this.bytes.slice(0,this.pos)},n.prototype.doEncode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth ".concat(t));e==null?this.encodeNil():typeof e=="boolean"?this.encodeBoolean(e):typeof e=="number"?this.encodeNumber(e):typeof e=="string"?this.encodeString(e):this.encodeObject(e,t)},n.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(t*2)},n.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),i=new Uint8Array(t),r=new DataView(t);i.set(this.bytes),this.view=r,this.bytes=i},n.prototype.encodeNil=function(){this.writeU8(192)},n.prototype.encodeBoolean=function(e){e===!1?this.writeU8(194):this.writeU8(195)},n.prototype.encodeNumber=function(e){Number.isSafeInteger(e)&&!this.forceIntegerToFloat?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},n.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else if(e<4294967296)this.writeU8(219),this.writeU32(e);else throw new Error("Too long string: ".concat(e," bytes in UTF-8"))},n.prototype.encodeString=function(e){var t=5,i=e.length;if(i>Crt){var r=xj(e);this.ensureBufferSizeToWrite(t+r),this.writeStringHeader(r),Art(e,this.bytes,this.pos),this.pos+=r}else{var r=xj(e);this.ensureBufferSizeToWrite(t+r),this.writeStringHeader(r),Trt(e,this.bytes,this.pos),this.pos+=r}},n.prototype.encodeObject=function(e,t){var i=this.extensionCodec.tryToEncode(e,this.context);if(i!=null)this.encodeExtension(i);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else if(typeof e=="object")this.encodeMap(e,t);else throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(e)))},n.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else if(t<4294967296)this.writeU8(198),this.writeU32(t);else throw new Error("Too large binary: ".concat(t));var i=CA(e);this.writeU8a(i)},n.prototype.encodeArray=function(e,t){var i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else if(i<4294967296)this.writeU8(221),this.writeU32(i);else throw new Error("Too large array: ".concat(i));for(var r=0,s=e;r<s.length;r++){var o=s[r];this.doEncode(o,t+1)}},n.prototype.countWithoutUndefined=function(e,t){for(var i=0,r=0,s=t;r<s.length;r++){var o=s[r];e[o]!==void 0&&i++}return i},n.prototype.encodeMap=function(e,t){var i=Object.keys(e);this.sortKeys&&i.sort();var r=this.ignoreUndefined?this.countWithoutUndefined(e,i):i.length;if(r<16)this.writeU8(128+r);else if(r<65536)this.writeU8(222),this.writeU16(r);else if(r<4294967296)this.writeU8(223),this.writeU32(r);else throw new Error("Too large map object: ".concat(r));for(var s=0,o=i;s<o.length;s++){var a=o[s],l=e[a];this.ignoreUndefined&&l===void 0||(this.encodeString(a),this.doEncode(l,t+1))}},n.prototype.encodeExtension=function(e){var t=e.data.length;if(t===1)this.writeU8(212);else if(t===2)this.writeU8(213);else if(t===4)this.writeU8(214);else if(t===8)this.writeU8(215);else if(t===16)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else if(t<4294967296)this.writeU8(201),this.writeU32(t);else throw new Error("Too large extension object: ".concat(t));this.writeI8(e.type),this.writeU8a(e.data)},n.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},n.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},n.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},n.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},n.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},n.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},n.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},n.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},n.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},n.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),wrt(this.view,this.pos,e),this.pos+=8},n.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),noe(this.view,this.pos,e),this.pos+=8},n}(),Xrt={};function Krt(n,e){e===void 0&&(e=Xrt);var t=new Hrt(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat);return t.encodeSharedRef(n)}function gP(n){return"".concat(n<0?"-":"","0x").concat(Math.abs(n).toString(16).padStart(2,"0"))}var Zrt=16,jrt=16,Yrt=function(){function n(e,t){e===void 0&&(e=Zrt),t===void 0&&(t=jrt),this.maxKeyLength=e,this.maxLengthPerKey=t,this.hit=0,this.miss=0,this.caches=[];for(var i=0;i<this.maxKeyLength;i++)this.caches.push([])}return n.prototype.canBeCached=function(e){return e>0&&e<=this.maxKeyLength},n.prototype.find=function(e,t,i){var r=this.caches[i-1];e:for(var s=0,o=r;s<o.length;s++){for(var a=o[s],l=a.bytes,u=0;u<i;u++)if(l[u]!==e[t+u])continue e;return a.str}return null},n.prototype.store=function(e,t){var i=this.caches[e.length-1],r={bytes:e,str:t};i.length>=this.maxLengthPerKey?i[Math.random()*i.length|0]=r:i.push(r)},n.prototype.decode=function(e,t,i){var r=this.find(e,t,i);if(r!=null)return this.hit++,r;this.miss++;var s=roe(e,t,i),o=Uint8Array.prototype.slice.call(e,t,t+i);return this.store(o,s),s},n}(),Jrt=globalThis&&globalThis.__awaiter||function(n,e,t,i){function r(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function a(c){try{u(i.next(c))}catch(h){o(h)}}function l(c){try{u(i.throw(c))}catch(h){o(h)}}function u(c){c.done?s(c.value):r(c.value).then(a,l)}u((i=i.apply(n,e||[])).next())})},yP=globalThis&&globalThis.__generator||function(n,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},i,r,s,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(c){return l([u,c])}}function l(u){if(i)throw new TypeError("Generator is already executing.");for(;t;)try{if(i=1,r&&(s=u[0]&2?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[u[0]&2,s.value]),u[0]){case 0:case 1:s=u;break;case 4:return t.label++,{value:u[1],done:!1};case 5:t.label++,r=u[1],u=[0];continue;case 7:u=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){t=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){t.label=u[1];break}if(u[0]===6&&t.label<s[1]){t.label=s[1],s=u;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(u);break}s[2]&&t.ops.pop(),t.trys.pop();continue}u=e.call(n,t)}catch(c){u=[6,c],r=0}finally{i=s=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}},vj=globalThis&&globalThis.__asyncValues||function(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e=n[Symbol.asyncIterator],t;return e?e.call(n):(n=typeof __values=="function"?__values(n):n[Symbol.iterator](),t={},i("next"),i("throw"),i("return"),t[Symbol.asyncIterator]=function(){return this},t);function i(s){t[s]=n[s]&&function(o){return new Promise(function(a,l){o=n[s](o),r(a,l,o.done,o.value)})}}function r(s,o,a,l){Promise.resolve(l).then(function(u){s({value:u,done:a})},o)}},cy=globalThis&&globalThis.__await||function(n){return this instanceof cy?(this.v=n,this):new cy(n)},Qrt=globalThis&&globalThis.__asyncGenerator||function(n,e,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i=t.apply(n,e||[]),r,s=[];return r={},o("next"),o("throw"),o("return"),r[Symbol.asyncIterator]=function(){return this},r;function o(d){i[d]&&(r[d]=function(p){return new Promise(function(f,g){s.push([d,p,f,g])>1||a(d,p)})})}function a(d,p){try{l(i[d](p))}catch(f){h(s[0][3],f)}}function l(d){d.value instanceof cy?Promise.resolve(d.value.v).then(u,c):h(s[0][2],d)}function u(d){a("next",d)}function c(d){a("throw",d)}function h(d,p){d(p),s.shift(),s.length&&a(s[0][0],s[0][1])}},qrt=function(n){var e=typeof n;return e==="string"||e==="number"},_x=-1,w$=new DataView(new ArrayBuffer(0)),est=new Uint8Array(w$.buffer),NF=function(){try{w$.getInt8(0)}catch(n){return n.constructor}throw new Error("never reached")}(),wj=new NF("Insufficient data"),tst=new Yrt,nst=function(){function n(e,t,i,r,s,o,a,l){e===void 0&&(e=soe.defaultCodec),t===void 0&&(t=void 0),i===void 0&&(i=Dp),r===void 0&&(r=Dp),s===void 0&&(s=Dp),o===void 0&&(o=Dp),a===void 0&&(a=Dp),l===void 0&&(l=tst),this.extensionCodec=e,this.context=t,this.maxStrLength=i,this.maxBinLength=r,this.maxArrayLength=s,this.maxMapLength=o,this.maxExtLength=a,this.keyDecoder=l,this.totalPos=0,this.pos=0,this.view=w$,this.bytes=est,this.headByte=_x,this.stack=[]}return n.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=_x,this.stack.length=0},n.prototype.setBuffer=function(e){this.bytes=CA(e),this.view=Urt(this.bytes),this.pos=0},n.prototype.appendBuffer=function(e){if(this.headByte===_x&&!this.hasRemaining(1))this.setBuffer(e);else{var t=this.bytes.subarray(this.pos),i=CA(e),r=new Uint8Array(t.length+i.length);r.set(t),r.set(i,t.length),this.setBuffer(r)}},n.prototype.hasRemaining=function(e){return this.view.byteLength-this.pos>=e},n.prototype.createExtraByteError=function(e){var t=this,i=t.view,r=t.pos;return new RangeError("Extra ".concat(i.byteLength-r," of ").concat(i.byteLength," byte(s) found at buffer[").concat(e,"]"))},n.prototype.decode=function(e){this.reinitializeState(),this.setBuffer(e);var t=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return t},n.prototype.decodeMulti=function(e){return yP(this,function(t){switch(t.label){case 0:this.reinitializeState(),this.setBuffer(e),t.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return t.sent(),[3,1];case 3:return[2]}})},n.prototype.decodeAsync=function(e){var t,i,r,s;return Jrt(this,void 0,void 0,function(){var o,a,l,u,c,h,d,p;return yP(this,function(f){switch(f.label){case 0:o=!1,f.label=1;case 1:f.trys.push([1,6,7,12]),t=vj(e),f.label=2;case 2:return[4,t.next()];case 3:if(i=f.sent(),!!i.done)return[3,5];if(l=i.value,o)throw this.createExtraByteError(this.totalPos);this.appendBuffer(l);try{a=this.doDecodeSync(),o=!0}catch(g){if(!(g instanceof NF))throw g}this.totalPos+=this.pos,f.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return u=f.sent(),r={error:u},[3,12];case 7:return f.trys.push([7,,10,11]),i&&!i.done&&(s=t.return)?[4,s.call(t)]:[3,9];case 8:f.sent(),f.label=9;case 9:return[3,11];case 10:if(r)throw r.error;return[7];case 11:return[7];case 12:if(o){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,a]}throw c=this,h=c.headByte,d=c.pos,p=c.totalPos,new RangeError("Insufficient data in parsing ".concat(gP(h)," at ").concat(p," (").concat(d," in the current buffer)"))}})})},n.prototype.decodeArrayStream=function(e){return this.decodeMultiAsync(e,!0)},n.prototype.decodeStream=function(e){return this.decodeMultiAsync(e,!1)},n.prototype.decodeMultiAsync=function(e,t){return Qrt(this,arguments,function(){var i,r,s,o,a,l,u,c,h;return yP(this,function(d){switch(d.label){case 0:i=t,r=-1,d.label=1;case 1:d.trys.push([1,13,14,19]),s=vj(e),d.label=2;case 2:return[4,cy(s.next())];case 3:if(o=d.sent(),!!o.done)return[3,12];if(a=o.value,t&&r===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(a),i&&(r=this.readArraySize(),i=!1,this.complete()),d.label=4;case 4:d.trys.push([4,9,,10]),d.label=5;case 5:return[4,cy(this.doDecodeSync())];case 6:return[4,d.sent()];case 7:return d.sent(),--r===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(l=d.sent(),!(l instanceof NF))throw l;return[3,10];case 10:this.totalPos+=this.pos,d.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return u=d.sent(),c={error:u},[3,19];case 14:return d.trys.push([14,,17,18]),o&&!o.done&&(h=s.return)?[4,cy(h.call(s))]:[3,16];case 15:d.sent(),d.label=16;case 16:return[3,18];case 17:if(c)throw c.error;return[7];case 18:return[7];case 19:return[2]}})})},n.prototype.doDecodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){var i=e-128;if(i!==0){this.pushMapState(i),this.complete();continue e}else t={}}else if(e<160){var i=e-144;if(i!==0){this.pushArrayState(i),this.complete();continue e}else t=[]}else{var r=e-160;t=this.decodeUtf8String(r,0)}else if(e===192)t=null;else if(e===194)t=!1;else if(e===195)t=!0;else if(e===202)t=this.readF32();else if(e===203)t=this.readF64();else if(e===204)t=this.readU8();else if(e===205)t=this.readU16();else if(e===206)t=this.readU32();else if(e===207)t=this.readU64();else if(e===208)t=this.readI8();else if(e===209)t=this.readI16();else if(e===210)t=this.readI32();else if(e===211)t=this.readI64();else if(e===217){var r=this.lookU8();t=this.decodeUtf8String(r,1)}else if(e===218){var r=this.lookU16();t=this.decodeUtf8String(r,2)}else if(e===219){var r=this.lookU32();t=this.decodeUtf8String(r,4)}else if(e===220){var i=this.readU16();if(i!==0){this.pushArrayState(i),this.complete();continue e}else t=[]}else if(e===221){var i=this.readU32();if(i!==0){this.pushArrayState(i),this.complete();continue e}else t=[]}else if(e===222){var i=this.readU16();if(i!==0){this.pushMapState(i),this.complete();continue e}else t={}}else if(e===223){var i=this.readU32();if(i!==0){this.pushMapState(i),this.complete();continue e}else t={}}else if(e===196){var i=this.lookU8();t=this.decodeBinary(i,1)}else if(e===197){var i=this.lookU16();t=this.decodeBinary(i,2)}else if(e===198){var i=this.lookU32();t=this.decodeBinary(i,4)}else if(e===212)t=this.decodeExtension(1,0);else if(e===213)t=this.decodeExtension(2,0);else if(e===214)t=this.decodeExtension(4,0);else if(e===215)t=this.decodeExtension(8,0);else if(e===216)t=this.decodeExtension(16,0);else if(e===199){var i=this.lookU8();t=this.decodeExtension(i,1)}else if(e===200){var i=this.lookU16();t=this.decodeExtension(i,2)}else if(e===201){var i=this.lookU32();t=this.decodeExtension(i,4)}else throw new du("Unrecognized type byte: ".concat(gP(e)));this.complete();for(var s=this.stack;s.length>0;){var o=s[s.length-1];if(o.type===0)if(o.array[o.position]=t,o.position++,o.position===o.size)s.pop(),t=o.array;else continue e;else if(o.type===1){if(!qrt(t))throw new du("The type of key must be string or number but "+typeof t);if(t==="__proto__")throw new du("The key __proto__ is not allowed");o.key=t,o.type=2;continue e}else if(o.map[o.key]=t,o.readCount++,o.readCount===o.size)s.pop(),t=o.map;else{o.key=null,o.type=1;continue e}}return t}},n.prototype.readHeadByte=function(){return this.headByte===_x&&(this.headByte=this.readU8()),this.headByte},n.prototype.complete=function(){this.headByte=_x},n.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new du("Unrecognized array type byte: ".concat(gP(e)))}}},n.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new du("Max length exceeded: map length (".concat(e,") > maxMapLengthLength (").concat(this.maxMapLength,")"));this.stack.push({type:1,size:e,key:null,readCount:0,map:{}})},n.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new du("Max length exceeded: array length (".concat(e,") > maxArrayLength (").concat(this.maxArrayLength,")"));this.stack.push({type:0,size:e,array:new Array(e),position:0})},n.prototype.decodeUtf8String=function(e,t){var i;if(e>this.maxStrLength)throw new du("Max length exceeded: UTF-8 byte length (".concat(e,") > maxStrLength (").concat(this.maxStrLength,")"));if(this.bytes.byteLength<this.pos+t+e)throw wj;var r=this.pos+t,s;return this.stateIsMapKey()&&!((i=this.keyDecoder)===null||i===void 0)&&i.canBeCached(e)?s=this.keyDecoder.decode(this.bytes,r,e):e>krt?s=Rrt(this.bytes,r,e):s=roe(this.bytes,r,e),this.pos+=t+e,s},n.prototype.stateIsMapKey=function(){if(this.stack.length>0){var e=this.stack[this.stack.length-1];return e.type===1}return!1},n.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new du("Max length exceeded: bin length (".concat(e,") > maxBinLength (").concat(this.maxBinLength,")"));if(!this.hasRemaining(e+t))throw wj;var i=this.pos+t,r=this.bytes.subarray(i,i+e);return this.pos+=t+e,r},n.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new du("Max length exceeded: ext length (".concat(e,") > maxExtLength (").concat(this.maxExtLength,")"));var i=this.view.getInt8(this.pos+t),r=this.decodeBinary(e,t+1);return this.extensionCodec.decode(r,i,this.context)},n.prototype.lookU8=function(){return this.view.getUint8(this.pos)},n.prototype.lookU16=function(){return this.view.getUint16(this.pos)},n.prototype.lookU32=function(){return this.view.getUint32(this.pos)},n.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},n.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},n.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},n.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},n.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},n.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},n.prototype.readU64=function(){var e=Srt(this.view,this.pos);return this.pos+=8,e},n.prototype.readI64=function(){var e=ioe(this.view,this.pos);return this.pos+=8,e},n.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},n.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},n}(),ist={};function rst(n,e){e===void 0&&(e=ist);var t=new nst(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength);return t.decode(n)}const Sj=2;class sst{constructor(){this.data=null}compileImageTargets(e,t){return new Promise(async(i,r)=>{const s=[];for(let u=0;u<e.length;u++){const c=e[u],h=this.createProcessCanvas(c).getContext("2d");h.drawImage(c,0,0,c.width,c.height);const d=h.getImageData(0,0,c.width,c.height),p=new Uint8Array(c.width*c.height);for(let g=0;g<p.length;g++){const y=g*4;p[g]=Math.floor((d.data[y]+d.data[y+1]+d.data[y+2])/3)}const f={data:p,height:c.height,width:c.width};s.push(f)}const o=50/s.length;let a=0;this.data=[];for(let u=0;u<s.length;u++){const c=s[u],h=drt(c),d=o/h.length,p=await ost(h,()=>{a+=d,t(a)});this.data.push({targetImage:c,imageList:h,matchingData:p})}for(let u=0;u<s.length;u++){const c=prt(s[u]);this.data[u].trackingImageList=c}const l=await this.compileTrack({progressCallback:t,targetImages:s,basePercent:50});for(let u=0;u<s.length;u++)this.data[u].trackingData=l[u];i(this.data)})}exportData(){const e=[];for(let t=0;t<this.data.length;t++)e.push({targetImage:{width:this.data[t].targetImage.width,height:this.data[t].targetImage.height},trackingData:this.data[t].trackingData,matchingData:this.data[t].matchingData});return Krt({v:Sj,dataList:e})}importData(e){const t=rst(new Uint8Array(e));if(!t.v||t.v!==Sj)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:i}=t;this.data=[];for(let r=0;r<i.length;r++)this.data.push({targetImage:i[r].targetImage,trackingData:i[r].trackingData,matchingData:i[r].matchingData});return this.data}createProcessCanvas(e){console.warn("missing createProcessCanvas implementation")}compileTrack({progressCallback:e,targetImages:t,basePercent:i}){console.warn("missing compileTrack implementation")}}const ost=async(n,e)=>{const t=[];for(let i=0;i<n.length;i++){const r=n[i],s=new qse(r.width,r.height);await vS(),me(()=>{const o=hi(r.data,[r.data.length],"float32").reshape([r.height,r.width]),{featurePoints:a}=s.detect(o),l=a.filter(d=>d.maxima),u=a.filter(d=>!d.maxima),c=bj({points:l}),h=bj({points:u});t.push({maximaPoints:l,minimaPoints:u,maximaPointsCluster:c,minimaPointsCluster:h,width:r.width,height:r.height,scale:r.scale}),e(i)})}return t},ooe="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK",Tj=typeof window<"u"&&window.Blob&&new Blob([atob(ooe)],{type:"text/javascript;charset=utf-8"});function ast(){let n;try{if(n=Tj&&(window.URL||window.webkitURL).createObjectURL(Tj),!n)throw"";return new Worker(n)}catch{return new Worker("data:application/javascript;base64,"+ooe)}finally{n&&(window.URL||window.webkitURL).revokeObjectURL(n)}}class lst extends sst{createProcessCanvas(e){const t=document.createElement("canvas");return t.width=e.width,t.height=e.height,t}compileTrack({progressCallback:e,targetImages:t,basePercent:i}){return new Promise((r,s)=>{const o=new ast;o.onmessage=a=>{a.data.type==="progress"?e(i+a.data.percent*i/100):a.data.type==="compileDone"&&r(a.data.list)},o.postMessage({type:"compile",targetImages:t})})}}class ust{constructor(e,t){this.width=e,this.height=t,this.texShape=[t,e];const i=document.createElement("canvas").getContext("2d");i.canvas.width=e,i.canvas.height=t,this.context=i,this.program=this.buildProgram(e,t);const r=vc();this.tempPixelHandle=r.makeTensorInfo(this.texShape,"float32"),r.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput(e){return me(()=>{let t=aV(e);return t=t.mean(2),t})}loadInput(e){const t=this.context;if(t.clearRect(0,0,this.context.canvas.width,this.context.canvas.height),e.width===this.height&&e.height===this.width){let r=this.context.canvas.width/2,s=this.context.canvas.height/2,o=90;t.save(),t.translate(r,s),t.rotate(o*Math.PI/180),t.drawImage(e,-e.width/2,-e.height/2),t.restore()}else this.context.drawImage(e,0,0,e.width,e.height);const i=vc();return i.gpgpu.uploadPixelDataToTexture(i.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(e,t){const i=ve().getNumber("WEBGL_VERSION")===2?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`
	void main() {
	  ivec2 coords = getOutputCoords();
	  int texR = coords[0];
	  int texC = coords[1];
	  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${e}.0, ${t}.0);

	  vec4 values = ${i}(A, uv);
	  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);
	}
      `}}_compileAndRun(e,t){const i=vc().compileAndRun(e,t);return Wn().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}_runWebGLProgram(e,t,i){const r=vc().runWebGLProgram(e,t,i);return Wn().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}}const bP={memory:h1,nextFrame:vS},cst=.001,hst=1e3,dst=5,pst=5;class fst{constructor({inputWidth:e,inputHeight:t,onUpdate:i=null,debugMode:r=!1,maxTrack:s=1,warmupTolerance:o=null,missTolerance:a=null,filterMinCF:l=null,filterBeta:u=null}){this.inputWidth=e,this.inputHeight=t,this.maxTrack=s,this.filterMinCF=l===null?cst:l,this.filterBeta=u===null?hst:u,this.warmupTolerance=o===null?dst:o,this.missTolerance=a===null?pst:a,this.cropDetector=new crt(this.inputWidth,this.inputHeight,r),this.inputLoader=new ust(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=i,this.debugMode=r,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const c=10,h=1e5,d=45*Math.PI/180,p=this.inputHeight/2/Math.tan(d/2);this.projectionTransform=[[p,0,this.inputWidth/2],[0,p,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:c,far:h}),this.worker=new pit,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=f=>{f.data.type==="matchDone"&&this.workerMatchDone!==null&&this.workerMatchDone(f.data),f.data.type==="trackUpdateDone"&&this.workerTrackDone!==null&&this.workerTrackDone(f.data)}}showTFStats(){console.log(bP.memory().numTensors),console.table(bP.memory())}addImageTargets(e){return new Promise(async(t,i)=>{const r=await(await fetch(e)).arrayBuffer(),s=this.addImageTargetsFromBuffer(r);t(s)})}addImageTargetsFromBuffer(e){const t=new lst().importData(e),i=[],r=[],s=[];for(let o=0;o<t.length;o++)r.push(t[o].matchingData),i.push(t[o].trackingData),s.push([t[o].targetImage.width,t[o].targetImage.height]);return this.tracker=new Tit(s,i,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:r}),this.markerDimensions=s,{dimensions:s,matchingDataList:r,trackingDataList:i}}dispose(){this.stopProcessVideo(),this.worker.postMessage({type:"dispose"})}dummyRun(e){const t=this.inputLoader.loadInput(e);this.cropDetector.detect(t),this.tracker.dummyRun(t),t.dispose()}getProjectionMatrix(){return this.projectionMatrix}getRotatedZ90Matrix(e){return[-e[1],e[0],e[2],e[3],-e[5],e[4],e[6],e[7],-e[9],e[8],e[10],e[11],-e[13],e[12],e[14],e[15]]}getWorldMatrix(e,t){return this._glModelViewMatrix(e,t)}async _detectAndMatch(e,t){const{featurePoints:i}=this.cropDetector.detectMoving(e),{targetIndex:r,modelViewTransform:s}=await this._workerMatch(i,t);return{targetIndex:r,modelViewTransform:s}}async _trackAndUpdate(e,t,i){const{worldCoords:r,screenCoords:s}=this.tracker.track(e,t,i);return r.length<4?null:await this._workerTrackUpdate(t,{worldCoords:r,screenCoords:s})}processVideo(e){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let t=0;t<this.markerDimensions.length;t++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new $Pe({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const t=this.inputLoader.loadInput(e);if(this.trackingStates.reduce((i,r)=>i+(r.isTracking?1:0),0)<this.maxTrack){const i=[];for(let o=0;o<this.trackingStates.length;o++)this.trackingStates[o].isTracking!==!0&&(this.interestedTargetIndex!==-1&&this.interestedTargetIndex!==o||i.push(o));const{targetIndex:r,modelViewTransform:s}=await this._detectAndMatch(t,i);r!==-1&&(this.trackingStates[r].isTracking=!0,this.trackingStates[r].currentModelViewTransform=s)}for(let i=0;i<this.trackingStates.length;i++){const r=this.trackingStates[i];if(r.isTracking){let s=await this._trackAndUpdate(t,r.currentModelViewTransform,i);s===null?r.isTracking=!1:r.currentModelViewTransform=s}if(r.showing||r.isTracking&&(r.trackMiss=0,r.trackCount+=1,r.trackCount>this.warmupTolerance&&(r.showing=!0,r.trackingMatrix=null,r.filter.reset())),r.showing&&(r.isTracking?r.trackMiss=0:(r.trackCount=0,r.trackMiss+=1,r.trackMiss>this.missTolerance&&(r.showing=!1,r.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:i,worldMatrix:null})))),r.showing){const s=this._glModelViewMatrix(r.currentModelViewTransform,i);r.trackingMatrix=r.filter.filter(Date.now(),s);let o=[];for(let a=0;a<r.trackingMatrix.length;a++)o[a]=r.trackingMatrix[a];e.width===this.inputHeight&&e.height===this.inputWidth&&(o=this.getRotatedZ90Matrix(o)),this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:i,worldMatrix:o})}}t.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await bP.nextFrame()}})()}}stopProcessVideo(){this.processingVideo=!1}async detect(e){const t=this.inputLoader.loadInput(e),{featurePoints:i,debugExtra:r}=await this.cropDetector.detect(t);return t.dispose(),{featurePoints:i,debugExtra:r}}async match(e,t){const{modelViewTransform:i,debugExtra:r}=await this._workerMatch(e,[t]);return{modelViewTransform:i,debugExtra:r}}async track(e,t,i){const r=this.inputLoader.loadInput(e),s=this.tracker.track(r,t,i);return r.dispose(),s}async trackUpdate(e,t){return t.worldCoords.length<4?null:await this._workerTrackUpdate(e,t)}_workerMatch(e,t){return new Promise(async(i,r)=>{this.workerMatchDone=s=>{i({targetIndex:s.targetIndex,modelViewTransform:s.modelViewTransform,debugExtra:s.debugExtra})},this.worker.postMessage({type:"match",featurePoints:e,targetIndexes:t})})}_workerTrackUpdate(e,t){return new Promise(async(i,r)=>{this.workerTrackDone=a=>{i(a.modelViewTransform)};const{worldCoords:s,screenCoords:o}=t;this.worker.postMessage({type:"trackUpdate",modelViewTransform:e,worldCoords:s,screenCoords:o})})}_glModelViewMatrix(e,t){const i=this.markerDimensions[t][1];return[e[0][0],-e[1][0],-e[2][0],0,-e[0][1],e[1][1],e[2][1],0,-e[0][2],e[1][2],e[2][2],0,e[0][1]*i+e[0][3],-(e[1][1]*i+e[1][3]),-(e[2][1]*i+e[2][3]),1]}_glProjectionMatrix({projectionTransform:e,width:t,height:i,near:r,far:s}){const o=[[2*e[0][0]/t,0,-(2*e[0][2]/t-1),0],[0,2*e[1][1]/i,-(2*e[1][2]/i-1),0],[0,0,-(s+r)/(s-r),-2*s*r/(s-r)],[0,0,-1,0]],a=[];for(let l=0;l<4;l++)for(let u=0;u<4;u++)a.push(o[u][l]);return a}}const Cj=new Y,mst=new Li,_j=new Y,uu=new Ft,gst=new Ft;class yst{constructor(e={}){const t=this;let i,r,s,o;const a={camera:{style:""},objects:new WeakMap},l=e.element!==void 0?e.element:document.createElement("div");l.style.overflow="hidden",this.domElement=l;const u=document.createElement("div");u.style.transformOrigin="0 0",u.style.pointerEvents="none",l.appendChild(u);const c=document.createElement("div");c.style.transformStyle="preserve-3d",u.appendChild(c),this.getSize=function(){return{width:i,height:r}},this.render=function(g,y){const m=y.projectionMatrix.elements[5]*o;y.view&&y.view.enabled?(u.style.transform=`translate( ${-y.view.offsetX*(i/y.view.width)}px, ${-y.view.offsetY*(r/y.view.height)}px )`,u.style.transform+=`scale( ${y.view.fullWidth/y.view.width}, ${y.view.fullHeight/y.view.height} )`):u.style.transform="",g.matrixWorldAutoUpdate===!0&&g.updateMatrixWorld(),y.parent===null&&y.matrixWorldAutoUpdate===!0&&y.updateMatrixWorld();let v,w;y.isOrthographicCamera&&(v=-(y.right+y.left)/2,w=(y.top+y.bottom)/2);const S=y.view&&y.view.enabled?y.view.height/y.view.fullHeight:1,C=y.isOrthographicCamera?`scale( ${S} )scale(`+m+")translate("+h(v)+"px,"+h(w)+"px)"+d(y.matrixWorldInverse):`scale( ${S} )translateZ(`+m+"px)"+d(y.matrixWorldInverse),A=(y.isPerspectiveCamera?"perspective("+m+"px) ":"")+C+"translate("+s+"px,"+o+"px)";a.camera.style!==A&&(c.style.transform=A,a.camera.style=A),f(g,g,y)},this.setSize=function(g,y){i=g,r=y,s=i/2,o=r/2,l.style.width=g+"px",l.style.height=y+"px",u.style.width=g+"px",u.style.height=y+"px",c.style.width=g+"px",c.style.height=y+"px"};function h(g){return Math.abs(g)<1e-10?0:g}function d(g){const y=g.elements;return"matrix3d("+h(y[0])+","+h(-y[1])+","+h(y[2])+","+h(y[3])+","+h(y[4])+","+h(-y[5])+","+h(y[6])+","+h(y[7])+","+h(y[8])+","+h(-y[9])+","+h(y[10])+","+h(y[11])+","+h(y[12])+","+h(-y[13])+","+h(y[14])+","+h(y[15])+")"}function p(g){const y=g.elements;return"translate(-50%,-50%)"+("matrix3d("+h(y[0])+","+h(y[1])+","+h(y[2])+","+h(y[3])+","+h(-y[4])+","+h(-y[5])+","+h(-y[6])+","+h(-y[7])+","+h(y[8])+","+h(y[9])+","+h(y[10])+","+h(y[11])+","+h(y[12])+","+h(y[13])+","+h(y[14])+","+h(y[15])+")")}function f(g,y,m,v){if(g.isCSS3DObject){const w=g.visible===!0&&g.layers.test(m.layers)===!0;if(g.element.style.display=w===!0?"":"none",w===!0){g.onBeforeRender(t,y,m);let S;g.isCSS3DSprite?(uu.copy(m.matrixWorldInverse),uu.transpose(),g.rotation2D!==0&&uu.multiply(gst.makeRotationZ(g.rotation2D)),g.matrixWorld.decompose(Cj,mst,_j),uu.setPosition(Cj),uu.scale(_j),uu.elements[3]=0,uu.elements[7]=0,uu.elements[11]=0,uu.elements[15]=1,S=p(uu)):S=p(g.matrixWorld);const C=g.element,_=a.objects.get(g);if(_===void 0||_.style!==S){C.style.transform=S;const A={style:S};a.objects.set(g,A)}C.parentNode!==c&&c.appendChild(C),g.onAfterRender(t,y,m)}}for(let w=0,S=g.children.length;w<S;w++)f(g.children[w],y,m)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bst(n){B(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),B(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,s)=>W(r,`tensors${s}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!bn(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const i=e;return ne.runKernel(tw,i)}const aoe=ie({addN_:bst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xst(n,e,t,i,r,s){const o=W(n,"forgetBias","basicLSTMCell"),a=W(e,"lstmKernel","basicLSTMCell"),l=W(t,"lstmBias","basicLSTMCell"),u=W(i,"data","basicLSTMCell"),c=W(r,"c","basicLSTMCell"),h=W(s,"h","basicLSTMCell"),d=Hi([u,h],1),p=ln(d,a),f=He(p,l),g=f.shape[0],y=f.shape[1]/4,m=[g,y],v=vn(f,[0,0],m),w=vn(f,[0,y],m),S=vn(f,[0,y*2],m),C=vn(f,[0,y*3],m),_=He(ae(Dl(v),Of(w)),ae(c,Dl(He(o,S)))),A=ae(Of(_),Dl(C));return[_,A]}const loe=ie({basicLSTMCell_:xst});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vst(n,e){const t=W(n,"s0","broadcastArgs","int32"),i=W(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(i.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${i.rank}`);const r={s0:t,s1:i};return ne.runKernel(c2,r)}const uoe=ie({broadcastArgs_:vst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wst(n){const e={x:W(n,"x","diag")};return ne.runKernel(w2,e)}const coe=ie({diag_:wst});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sst(n,...e){const t=e.map((r,s)=>W(r,`tensors${s}`,"einsum")),i={equation:n};return ne.runKernel(S2,t,i)}const hoe=ie({einsum_:Sst});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function doe(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const i={start:n,stop:e,num:t};return ne.runKernel(k2,{},i)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_=2147483648;function Tst(n,e,t="left"){const i=W(n,"sortedSequence","searchSorted"),r=W(e,"values","searchSorted"),s=i.shape[i.shape.length-1],o=r.shape[r.shape.length-1],a=ue(i,[-1,s]),l=ue(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ke(l.shape)>=m_)throw new Error(`values tensor size must less than ${m_}`);if(a.shape[1]>=m_)throw new Error(`trailing dim_size must less than ${m_} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return ne.runKernel(K2,u,c)}const Ak=ie({searchSorted_:Tst});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poe(n,e){return Ak(n,e,"left")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cst(n,e,t,i,r=!1){const s={x:W(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:i,includeBatchInIndex:r},a=ne.runKernel(P2,s,o);return{result:a[0],indexes:a[1]}}const foe=ie({maxPoolWithArgmax_:Cst});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moe(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let i=W(n,"x","meshgrid",n instanceof An?n.dtype:"float32");if(e===void 0)return[i];let r=W(e,"y","meshgrid",e instanceof An?e.dtype:"float32");const s=ke(i.shape),o=ke(r.shape);return t==="xy"?(i=ue(i,[1,-1]),r=ue(r,[-1,1]),[ln(_o([o,1],i.dtype),i),ln(r,_o([1,s],r.dtype))]):(i=ue(i,[-1,1]),r=ue(r,[1,-1]),[ln(i,_o([1,o],i.dtype)),ln(_o([s,1],r.dtype),r)])}function _st(n,e,t,i){const r=W(e,"data","multiRNNCell"),s=c1(t,"c","multiRNNCell"),o=c1(i,"h","multiRNNCell");let a=r;const l=[];for(let h=0;h<n.length;h++){const d=n[h](a,s[h],o[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const goe=ie({multiRNNCell_:_st});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mst(n,e,t,i=!1){const r=W(n,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const a={logits:o===1?ue(r,[1,-1]):r},l={numSamples:e,seed:t,normalized:i},u=ne.runKernel(D2,a,l);return o===1?ue(u,[u.size]):u}const yoe=ie({multinomial_:Mst});function Ast(n,e){const t=W(n,"v1","outerProduct"),i=W(e,"v2","outerProduct");B(t.rank===1&&i.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${i.rank}.`);const r=ue(t,[-1,1]),s=ue(i,[1,-1]);return ln(r,s)}const boe=ie({outerProduct_:Ast});function Est(n,e,t=0){return B(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),eh(n,[e],t)}const xoe=ie({pad1d_:Est});function Ist(n,e,t=0){return B(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eh(n,e,t)}const voe=ie({pad2d_:Ist});function kst(n,e,t=0){return B(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eh(n,e,t)}const woe=ie({pad3d_:kst});function Rst(n,e,t=0){return B(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),eh(n,e,t)}const Soe=ie({pad4d_:Rst});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nst(n,e,t,i){const r=n.map((c,h)=>W(c,`tensors${h}`,"raggedGather","int32")),s=W(e,"paramsDenseValues","raggedGather"),o=W(t,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:s,indices:o},l={outputRaggedRank:i},u=ne.runKernel(z2,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const Toe=ie({raggedGather_:Nst});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lst(n,e,t){const i=W(n,"starts","raggedRange"),r=W(e,"limits","raggedRange",i.dtype),s=W(t,"deltas","raggedRange",i.dtype),o={starts:i,limits:r,deltas:s},a=ne.runKernel(G2,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const Coe=ie({raggedRange_:Lst});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pst(n,e,t,i,r){const s=W(n,"shape","raggedTensorToTensor","int32"),o=W(e,"values","raggedTensorToTensor"),a=W(t,"defaultValue","raggedTensorToTensor",o.dtype),l=i.map((h,d)=>W(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:s,values:o,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:r};return ne.runKernel(V2,u,c)}const _oe=ie({raggedTensorToTensor_:Pst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dst(n,e,t){Do(n);const i=ke(n);let r=null;if(t==null||t==="float32")r=new Float32Array(i);else if(t==="int32")r=new Int32Array(i);else if(t==="bool")r=new Uint8Array(i);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<i;s++)r[s]=e();return ne.makeTensor(r,n,t)}const Moe=ie({rand_:Dst});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fst=.001,Aoe=.1;function Ost(n,e,t){return t==null&&(t=S$()),LF(n,e,(i,r)=>T$(i,r,t))}function S$(){return ne.backend.floatPrecision()===32?Fst:Aoe}function LF(n,e,t){let i=!0;if((Tr(n)||Tr(e))&&(i=!1),Tr(n)&&Tr(e)&&(i=!0),i){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=zu(n),a=zu(e);if(!bn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const r=Tr(n)?n:Bu(n),s=Tr(e)?e:Bu(e);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let o=0;o<s.length;++o){const a=r[o],l=s[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function Bst(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function zst(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return vu(n)||vu(n[0])||vu(e)||vu(e[0])?LF(n,t,(i,r)=>i==r):LF(n,e,(i,r)=>T$(i,r,0))}function Gst(n,e,t){if(t==null&&(t=S$()),!T$(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function T$(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function Vst(n,e,t){for(let i=0;i<n.length;i++)if(n[i]<e||n[i]>t)throw new Error(`Value out of range:${n[i]} low: ${e}, high: ${t}`)}function Ust(n,e){const t=new Float32Array(n),i=new Float32Array(e);if(t.length!==i.length)throw new Error(`Expected ArrayBuffer to be of length ${i.length}, but it was ${t.length}`);for(let r=0;r<i.length;r++)if(t[r]!==i[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${i[r]} but got ${t[r]} instead`)}function Eoe(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?Eoe(t):n[e]=ku(t)}return n}function $st(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",i=>t(e)),e.load()})}async function Wst(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const Hst=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Aoe,createVideoElement:$st,encodeStrings:Eoe,expectArrayBuffersEqual:Ust,expectArraysClose:Ost,expectArraysEqual:zst,expectNumbersClose:Gst,expectPromiseToFail:Bst,expectValuesInRange:Vst,play:Wst,testEpsilon:S$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xst(n,e,t=1,i="float32",r){if(Do(n),t==null&&(t=1),i==null&&(i="float32"),i!=="float32"&&i!=="int32")throw new Error(`Unsupported data type ${i}`);const s=new hBe(e,t,i,r),o=nn(n,i);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const Ioe=ie({randomGamma_:Xst});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kst(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return TI(n,0,1,e,t)}const koe=ie({randomStandardNormal_:Kst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zst(n){const e=W(n,"x","reverse");return B(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),da(e,0)}const Roe=ie({reverse1d_:Zst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jst(n,e){const t=W(n,"x","reverse");return B(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),da(t,e)}const Noe=ie({reverse2d_:jst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yst(n,e){const t=W(n,"x","reverse");return B(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),da(t,e)}const Loe=ie({reverse3d_:Yst});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jst(n,e){const t=W(n,"x","reverse");return B(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),da(t,e)}const Poe=ie({reverse4d_:Jst});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Qst(n,e){const t=W(n,"x","setdiff1d"),i=W(e,"y","setdiff1d");B(t.dtype===i.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${i.dtype}).`),B(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),B(i.rank===1,()=>`y should be 1D tensor, but got y (${i.shape}).`);const r=await t.data(),s=await i.data(),o=new Set(s);let a=0;for(let c=0;c<r.length;c++)o.has(r[c])||a++;const l=new mr([a],t.dtype),u=new mr([a],"int32");for(let c=0,h=0;c<r.length;c++)o.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const Doe=Qst;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(n,e,t){if(fm(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const i=zu(n,t);if(i.length!==4&&i.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Bd(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ooe(n,e,t){if(fm(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const i=zu(n,t);if(i.length!==5&&i.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Bd(n,e,i,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Boe(n,e,t){if(fm(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const i=zu(n,t);if(i.length!==6&&i.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(i.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||i,Bd(n,e,i,t)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(n,e){return Ak(n,e,"right")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function qst(n){const e=W(n,"condition","whereAsync","bool"),t=await e.data(),i=FI(e.shape,t);return n!==e&&e.dispose(),i}const C$=qst;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function eot(n,e,t){const i=W(n,"tensor","boolMask"),r=W(e,"mask","boolMask","bool"),s=t??0,o=r.rank,a=i.shape;B(o>0,()=>"mask cannot be scalar"),qr(a.slice(s,s+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=s;g<s+o;g++)l*=a[g];const u=a.slice(0,s).concat([l],a.slice(s+o)),c=ue(i,u),h=ue(r,[-1]),d=await C$(h),p=Ud(d,[1]),f=ob(c,p,s);return n!==i&&i.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}const Goe=eot;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tot(n,e,t,i,r=!0){const s=W(n,"v","movingAverage"),o=W(e,"x","movingAverage"),a=W(t,"decay","movingAverage");pte(s,o),B(bn(s.shape,o.shape),()=>"Shape mismatch in v and x");const l=Nt(1),u=xt(l,a);let c=ae(xt(o,s),u);if(r){B(i!=null,()=>"When using zeroDebias: true, step is required.");const h=W(i,"step","movingAverage");c=At(c,xt(l,$c(a,h)))}return He(s,c)}const Voe=ie({movingAverage_:tot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function not(n,e,t){Do(t);const i=W(n,"indices","scatterND","int32"),r=W(e,"updates","scatterND");KG(r,i,t);const s={indices:i,updates:r},o={shape:t};return ne.runKernel(X2,s,o)}const Uoe=ie({scatterND_:not});function iot(n,e,t,i){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==i.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rot(n,e,t,i=0){Do(t);const r=W(n,"sparseIndices","sparseToDense","int32"),s=W(e,"sparseValues","sparseToDense","string_or_numeric"),o=W(i,"defaultValue","sparseToDense",s.dtype);iot(r,s,t,o);const a={sparseIndices:r,sparseValues:s,defaultValue:o},l={outputShape:t};return ne.runKernel(Q2,a,l)}const $oe=ie({sparseToDense_:rot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sot(n,e){const t=W(e,"indices","gatherND","int32"),i={params:W(n,"x","gatherND","string_or_numeric"),indices:t};return ne.runKernel(A2,i)}const Woe=ie({gatherND_:sot});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function oot(n,e,t=1){const i=W(n,"predictions","inTopK"),r=W(e,"targets","inTopK");B(i.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${i.rank}`),B(i.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${i.rank} and targets rank ${r.rank}`),qr(i.shape.slice(0,i.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=i.shape[i.shape.length-1];B(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);const o=await i.data(),a=await r.data(),[l,u]=[o.length/s,s],c=br("bool",l);for(let h=0;h<l;h++){const d=h*u,p=o.subarray(d,d+u),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,y)=>y.value-g.value),c[h]=0;for(let g=0;g<t;g++)if(f[g].index===a[h]){c[h]=1;break}}return n!==i&&i.dispose(),e!==r&&r.dispose(),hi(c,r.shape,"bool")}const Hoe=oot;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aot({x:n,filter:e,strides:t,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(VI(ne.state.gradientDepth,l)===!1){let C=nb(n,e,t,i,r,s,o);return a!=null&&(C=He(C,a)),GI(C,l,u,c)}const h=W(n,"x","depthwiseConv2d","float32"),d=W(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=ue(h,[1,h.shape[0],h.shape[1],h.shape[2]])),B(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),B(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),B(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),B(es(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Ds("fused depthwiseConv2d",i,o);const g=Ir(p.shape,d.shape,t,s,i,o,!0);let y;a!=null&&(y=W(a,"bias","fused conv2d"),[y]=Si(y,h),Yt(g.outShape,y.shape));let m;u!=null&&(m=W(u,"prelu weights","fused depthwiseConv2d"));const v=(C,_)=>{B(vd(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[A,I,E,k]=_,P=BI(C,E,l),V=Gte(I.shape,P,A,t,i,s,o),U=zte(I,P,A.shape,t,i,s,o);if(k!=null){const F=zI(y,P);return[V,U,F]}return[V,U]},w={x:p,filter:d,bias:y,preluActivationWeights:m},S={strides:t,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Gu((C,_,A)=>{let I=ne.runKernel(a1,w,S);return A([_,C,I]),f&&(I=ue(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:v}})(p,d):Gu((C,_,A,I)=>{let E=ne.runKernel(a1,w,S);return I([_,C,E,A]),f&&(E=ue(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:v}})(p,d,y)}const lot=ie({fusedDepthwiseConv2d_:aot});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xoe=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Bte,depthwiseConv2d:lot,matMul:hF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uot="model",cot=".json",hot=".weights.bin";function Mj(n){return new Promise(e=>setTimeout(e)).then(n)}class Xf{constructor(e){if(!ve().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Xf.URL_SCHEME)&&(e=e.slice(Xf.URL_SCHEME.length)),(e==null||e.length===0)&&(e=uot),this.modelJsonFileName=e+cot,this.weightDataFileName=e+hot}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=yte(e,i),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await Mj(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await Mj(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:nS(e)}}}}Xf.URL_SCHEME="downloads://";class dot{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const i=new FileReader;i.onload=r=>{const s=JSON.parse(r.target.result),o=s.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const a=Xz(s,l=>this.loadWeights(l));e(a)},i.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),i.readAsText(this.jsonFile)})}loadWeights(e){const t=[],i=[];for(const o of e)t.push(...o.weights),i.push(...o.paths);const r=this.checkManifestAndWeightFiles(e),s=i.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(s).then(o=>[t,cI(o)])}loadWeightsFile(e,t){return new Promise((i,r)=>{const s=new FileReader;s.onload=o=>{const a=o.target.result;i(a)},s.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],i=this.weightsFiles.map(s=>qK(s.name)),r={};for(const s of e)s.paths.forEach(o=>{const a=qK(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),i.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[i.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const pot=n=>ve().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xf.URL_SCHEME)?fot(n.slice(Xf.URL_SCHEME.length)):null;yi.registerSaveRouter(pot);function fot(n="model"){return new Xf(n)}function mot(n){return new dot(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xP{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Koe{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class got{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function yot(n,e,t,i){const r=arguments;return new got(_A(...r))}function _A(n,e,t,i){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new xP(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xP({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xP({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:i}))}function bot(n){return new Koe(n)}function xot(n){return new Koe(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:mot,browserHTTPRequest:ene,concatenateArrayBuffers:cI,copyModel:h3e,decodeWeights:$z,encodeWeights:oF,fromMemory:yot,fromMemorySync:_A,getLoadHandlers:xte,getModelArtifactsForJSON:Xz,getModelArtifactsForJSONSync:Hz,getModelArtifactsInfoForJSON:nS,getSaveHandlers:bte,getWeightSpecs:Kz,http:oV,isHTTPScheme:dF,listModels:u3e,loadWeights:Jte,moveModel:d3e,registerLoadRouter:JDe,registerSaveRouter:YDe,removeModel:c3e,weightsLoaderFactory:Qte,withSaveHandler:bot,withSaveHandlerSync:xot},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vot(n,e,t){const i=W(n,"labels","confusionMatrix"),r=W(e,"predictions","confusionMatrix");B(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),B(i.rank===1,()=>`Expected the rank of labels to be 1, but got ${i.rank}`),B(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),B(i.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${i.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),B(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const s=Dy(ot(i,"int32"),t),o=Dy(ot(r,"int32"),t),a=gn(s),l=ln(a,o);return ot(l,"int32")}const wot=ie({confusionMatrix_:vot});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sot=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:wot},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const Zoe="4.2.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tot=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:UI,nonMaxSuppressionV4Impl:$I,nonMaxSuppressionV5Impl:WI,whereImpl:FI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cot(n){return new WV(n)}function _ot(n){return new HV(n)}function Mot(){return new XV}function Aot(n){return new KV(n)}const Eot=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Cot,minMaxNorm:Aot,nonNeg:Mot,unitNorm:_ot},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Iot(){return new DV}function kot(){return new qI}function Rot(n){return new FV(n)}function Not(n){return new OV(n)}function Lot(n){return new BV(n)}function Pot(n){return new zV(n)}function Dot(n){return new GV(n)}function Fot(n){return new to(n)}function Oot(n){return new ek(n)}function Bot(n){return new tk(n)}function zot(n){return new nk(n)}function Got(n){return new ik(n)}function Vot(n){return new rk(n)}function Uot(n){return new sk(n)}function $ot(n){return new VV(n)}const Wot=Object.freeze(Object.defineProperty({__proto__:null,constant:Rot,glorotNormal:Bot,glorotUniform:Oot,heNormal:zot,heUniform:Got,identity:Dot,leCunNormal:Vot,leCunUniform:Uot,ones:kot,orthogonal:$ot,randomNormal:Lot,randomUniform:Not,truncatedNormal:Pot,varianceScaling:Fot,zeros:Iot},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hot(n){return new Ic(n)}function Xot(n){return new ck(n)}function joe(n){return tie(n)}function Kot(n,e){ZV.registerCallbackConstructor(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zot(n){return new db(n)}function jot(n){return new rU(n)}function Yot(n){return new tU(n)}function Jot(n){return new nU(n)}function Qot(n){return new iU(n)}function qot(n){return new oU(n)}function eat(n){return new sU(n)}function tat(n){return new kS(n)}function nat(n){return new mb(n)}function iat(n){return new lU(n)}function rat(n){return new gb(n)}function sat(n){return new uU(n)}function oat(n){return new cU(n)}function aat(n){return new hU(n)}function lat(n){return new dU(n)}function uat(n){return new pU(n)}function cat(n){return new wU(n)}function hat(n){return new xU(n)}function dat(n){return new gk(n)}function pat(n){return new bU(n)}function fat(n){return new vU(n)}function mat(n){return new SU(n)}function gat(n){return new TU(n)}function yat(n){return new CU(n)}function bat(n){return new MU(n)}function xat(n){return new AU(n)}function vat(n){return new IU(n)}function wat(n){return new NU(n)}function Sat(n){return new kU(n)}function Tat(n){return new RU(n)}function Cat(n){return new EU(n)}function _at(n){return new LU(n)}function Mat(n){return new OU(n)}function Aat(n){return new BU(n)}function Eat(n){return new zU(n)}function M$(n){return new VU(n)}function Iat(n){return M$(n)}function kat(n){return M$(n)}function A$(n){return new $U(n)}function Rat(n){return A$(n)}function Nat(n){return A$(n)}function E$(n){return new HU(n)}function Lat(n){return E$(n)}function Pat(n){return E$(n)}function Dat(n){return new XU(n)}function Fat(n){return new ZU(n)}function Yoe(n){return new KU(n)}function Joe(n){return new jU(n)}function Qoe(n){return new GU(n)}function qoe(n){return new UU(n)}function Oat(n){return new WU(n)}function Bat(n){return new mU(n)}function zat(n){return new pk(n)}function Gat(n){return new gU(n)}function Vat(n){return new NS(n)}function Uat(n){return new fU(n)}function $at(n){return new dk(n)}function Wat(n){return new yU(n)}function Hat(n){return new mk(n)}function Xat(n){return new Jl(n)}function Kat(n){return new fk(n)}function Zat(n){return new JU(n)}function jat(n){return new YU(n)}const Yat=Yoe,Jat=Joe,Qat=Qoe,qat=qoe;function elt(n){return new PU(n)}function tlt(n){return new DU(n)}function nlt(n){return new FU(n)}function ilt(n){return new _U(n)}function rlt(n){return new QU(n)}function slt(n){return new qU(n)}function olt(n){return new t$(n)}function alt(n){return new e$(n)}const llt=Object.freeze(Object.defineProperty({__proto__:null,Layer:pn,RNN:Jl,RNNCell:RS,activation:cat,add:xat,alphaDropout:nlt,average:vat,averagePooling1d:M$,averagePooling2d:A$,averagePooling3d:E$,avgPool1d:Iat,avgPool2d:Rat,avgPool3d:Lat,avgPooling1d:kat,avgPooling2d:Nat,avgPooling3d:Pat,batchNormalization:Mat,bidirectional:Zat,categoryEncoding:alt,centerCrop:slt,concatenate:wat,conv1d:tat,conv2d:nat,conv2dTranspose:iat,conv3d:rat,conv3dTranspose:sat,convLstm2d:Wat,convLstm2dCell:Hat,cropping2D:aat,dense:hat,depthwiseConv2d:uat,dot:_at,dropout:dat,elu:jot,embedding:bat,flatten:fat,gaussianDropout:tlt,gaussianNoise:elt,globalAveragePooling1d:Dat,globalAveragePooling2d:Fat,globalMaxPool1d:Yat,globalMaxPool2d:Jat,globalMaxPooling1d:Yoe,globalMaxPooling2d:Joe,gru:Bat,gruCell:zat,input:joe,inputLayer:Zot,layerNormalization:Aat,leakyReLU:Jot,lstm:Gat,lstmCell:Vat,masking:ilt,maxPool1d:Qat,maxPool2d:qat,maxPooling1d:Qoe,maxPooling2d:qoe,maxPooling3d:Oat,maximum:Sat,minimum:Tat,multiply:Cat,permute:yat,prelu:Qot,reLU:Yot,repeatVector:mat,rescaling:rlt,reshape:gat,resizing:olt,rnn:Xat,separableConv2d:oat,simpleRNN:Uat,simpleRNNCell:$at,softmax:qot,spatialDropout1d:pat,stackedRNNCells:Kat,thresholdedReLU:eat,timeDistributed:jat,upSampling2d:lat,zeroPadding2d:Eat},Symbol.toStringTag,{value:"Module"}));function ult(n,e){return YV(n,e)}function clt(n,e){return cie(n,e)}function hlt(n,e){return hie(n,e)}function dlt(n,e){return JV(n,e)}function plt(n,e){return QV(n,e)}function flt(n,e){return uie(n,e)}function mlt(n,e){return K$e(n,e)}function glt(n,e){return jV(n,e)}function ylt(n,e){return ak(n,e)}function blt(n,e){return pb(n,e)}function xlt(n,e){return pb(n,e)}function vlt(n,e){return pb(n,e)}function wlt(n,e){return _m(n,e)}function Slt(n,e){return _m(n,e)}function Tlt(n,e){return _m(n,e)}const Clt=Object.freeze(Object.defineProperty({__proto__:null,MAPE:xlt,MSE:Slt,binaryAccuracy:ult,binaryCrossentropy:clt,categoricalAccuracy:dlt,categoricalCrossentropy:plt,cosineProximity:glt,mape:vlt,meanAbsoluteError:ylt,meanAbsolutePercentageError:blt,meanSquaredError:wlt,mse:Tlt,precision:flt,recall:mlt,sparseCategoricalAccuracy:hlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const _lt=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:SWe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mlt(n){return new IS(n)}function Alt(n){return MWe(n)}function Elt(n){return AWe(n)}const Ilt=Object.freeze(Object.defineProperty({__proto__:null,l1:Alt,l1l2:Mlt,l2:Elt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eae extends Gy{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Ic))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function g_(n,e){return n<e}function Aj(n,e){return n>e}class tae extends eae{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new tn("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=g_:this.mode==="max"?this.monitorFunc=Aj:this.monitor.indexOf("acc")!==-1?this.monitorFunc=Aj:this.monitorFunc=g_,this.monitorFunc===g_&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===g_?1/0:-1/0}async onEpochEnd(e,t){await Mh(t);const i=this.getMonitorValue(t);i!=null&&(this.monitorFunc(i-this.minDelta,this.best)?(this.best=i,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function klt(n){return new tae(n)}const Rlt={earlyStopping:klt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I$={};function Nlt(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};I$[n]=t}function nae(n){return I$[n]}function Llt(n){delete I$[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(n,e,t,i,r){const s=e.inputParams[n];if(s&&s.inputIndexStart!==void 0){const a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Es(e.inputNames[s.inputIndexStart],t,i,r);if(s.type==="tensors")return e.inputNames.slice(a,l).map(h=>Es(h,t,i,r));const u=Es(e.inputNames.slice(a)[0],t,i,r),c=u.dataSync();return s.type==="number"?c[0]:aa(u.shape,c)}const o=e.attrParams[n];return o&&o.value}function Es(n,e,t,i){const[r,s]=mo(n);if(i!=null){const a=i.getHashTableHandleByName(r);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[MA(r,a)]);return o!==void 0?e[MA(r,o)][s]:void 0}function Plt(n,e,t){return e[MA(n,t.currentContextId)]}function hc(n,e){const[t,i,r]=mo(n);return[MA(t,e&&e.currentContextId),i,r]}function MA(n,e){return e?`${n}-${e}`:n}function mo(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],i=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[t,r,i]}function j_(n,e,t){let i=N("pad",n,e,t);if(i==="explicit"){i=N("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=i[s*2],r[s][1]=i[s*2+1];return r}return i}function dc(n){return n.kept?n:Ru(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dlt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Flt=Object.freeze(Object.defineProperty({__proto__:null,json:Dlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Olt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Blt=Object.freeze(Object.defineProperty({__proto__:null,json:Olt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zlt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Glt=Object.freeze(Object.defineProperty({__proto__:null,json:zlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vlt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Ult=Object.freeze(Object.defineProperty({__proto__:null,json:Vlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $lt=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Wlt=Object.freeze(Object.defineProperty({__proto__:null,json:$lt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hlt=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Xlt=Object.freeze(Object.defineProperty({__proto__:null,json:Hlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Klt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Zlt=Object.freeze(Object.defineProperty({__proto__:null,json:Klt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jlt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ylt=Object.freeze(Object.defineProperty({__proto__:null,json:jlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jlt=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Qlt=Object.freeze(Object.defineProperty({__proto__:null,json:Jlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qlt=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],eut=Object.freeze(Object.defineProperty({__proto__:null,json:qlt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tut=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],nut=Object.freeze(Object.defineProperty({__proto__:null,json:tut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iut=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],rut=Object.freeze(Object.defineProperty({__proto__:null,json:iut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sut=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],out=Object.freeze(Object.defineProperty({__proto__:null,json:sut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aut=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],lut=Object.freeze(Object.defineProperty({__proto__:null,json:aut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uut=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],cut=Object.freeze(Object.defineProperty({__proto__:null,json:uut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hut=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],dut=Object.freeze(Object.defineProperty({__proto__:null,json:hut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const put=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],fut=Object.freeze(Object.defineProperty({__proto__:null,json:put},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mut=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],gut=Object.freeze(Object.defineProperty({__proto__:null,json:mut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yut=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],but=Object.freeze(Object.defineProperty({__proto__:null,json:yut},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ej{constructor(){const e=[Flt,Blt,Glt,Ult,Wlt,Xlt,Zlt,Ylt,Qlt,eut,nut,rut,out,lut,cut,dut,fut,gut,but],t=[].concat(...e.map(i=>i.json));this.opMappers=t.reduce((i,r)=>(i[r.tfOpName]=r,i),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,t={}){const i=e.node,r=[],s=[],o=[],a=i.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?r.push(g[y.name]):y.op==="Const"?s.push(g[y.name]):(y.input==null||y.input.length===0)&&o.push(g[y.name]),g),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(g=>{const y=a[g];y.inputNames.forEach((m,v)=>{const[w,,S]=hc(m),C=a[w];if(C.outputs!=null){const _=C.outputs.indexOf(S);if(_!==-1){const A=`${w}:${_}`;y.inputNames[v]=A}}y.inputs.push(C),C.children.push(y)})}),Object.keys(h).length===0?d.forEach(g=>{const y=a[g];y.children.length===0&&u.push(y)}):Object.keys(h).forEach(g=>{const[y]=hc(g),m=a[y];m!=null&&(m.signatureKey=h[g],u.push(m))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[y]=hc(g),m=a[y];m&&(m.signatureKey=c[g],l.push(m))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:a,inputs:l,outputs:u,weights:s,placeholders:r,signature:t,functions:p};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,i)=>(t[e[i].name]=i,t),{})}mapNode(e){const t=nae(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const i={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(i.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(i.attrParams=t.attrs.reduce((r,s)=>{const o=s.type;let a;switch(s.type){case"string":a=PF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=PF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=VF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=VF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=FF(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=FF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=GF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=GF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=DF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=DF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=$F(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=$F(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=zF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=zF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=UF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=UF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=OF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=OF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=BF(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=BF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=Ij(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Ij(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:a,type:o},r},{})),i}mapFunction(e){const t=e.nodeDef,i=[],r=[];let s={};t!=null&&(s=t.reduce((c,h)=>(c[h.name]=this.mapNode(h),h.op==="Const"&&r.push(c[h.name]),c),{}));const o=[],a=[];e.signature.inputArg.forEach(c=>{const[h]=hc(c.name),d={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:k$(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,o.push(d),s[h]=d}),Object.keys(s).forEach(c=>{const h=s[c];h.inputNames.forEach((d,p)=>{const[f,,g]=hc(d),y=s[f];if(y.outputs!=null){const m=y.outputs.indexOf(g);if(m!==-1){const v=`${f}:${m}`;h.inputNames[p]=v}}h.inputs.push(y),y.children.push(h)})});const l=e.ret;e.signature.outputArg.forEach(c=>{const[h,d]=hc(l[c.name]),p=s[h];p!=null&&(p.defaultOutput=d,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:r,placeholders:i,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,i)=>(t[i.name]=this.mapArgToTensorInfo(i),t),{}),outputs:e.signature.outputArg.reduce((t,i)=>(t[i.name]=this.mapArgToTensorInfo(i,e.ret),t),{})}}mapArgToTensorInfo(e,t){let i=e.name;return t!=null&&(i=t[i]),{name:i,dtype:e.type}}}function xut(n){const e=ve().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function iae(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):xut(n);return e?t:t.toLowerCase()}function PF(n,e,t,i=!1){const r=n[e];return r!=null?iae(r.s,i):t}function DF(n,e,t){const i=n[e];return i?i.b:t}function FF(n,e,t){const i=n[e]||{},r=i.i!=null?i.i:i.f!=null?i.f:t;return typeof r=="number"?r:parseInt(r,10)}function k$(n){switch(typeof n=="string"&&(n=Fa[n]),n){case Fa.DT_FLOAT:case Fa.DT_HALF:return"float32";case Fa.DT_INT32:case Fa.DT_INT64:case Fa.DT_INT8:case Fa.DT_UINT8:return"int32";case Fa.DT_BOOL:return"bool";case Fa.DT_DOUBLE:return"float32";case Fa.DT_STRING:return"string";default:return null}}function Ij(n,e,t){const i=n[e];return i&&i.func?i.func.name:t}function OF(n,e,t){const i=n[e];return i&&i.type?k$(i.type):t}function BF(n,e,t){const i=n[e];return i&&i.list&&i.list.type?i.list.type.map(r=>k$(r)):t}function rae(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function zF(n,e,t){const i=n[e];return i&&i.shape?rae(i.shape):t}function GF(n,e,t){const i=n[e];return i?((i.list.f&&i.list.f.length?i.list.f:i.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function VF(n,e,t,i=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(s=>iae(s,i)):t}function UF(n,e,t){const i=n[e];return i&&i.list&&i.list.shape?i.list.shape.map(r=>rae(r)):t}function $F(n,e,t){const i=n[e];return i&&i.list&&i.list.b?i.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vut{constructor(e,t,i){this.node=e,this.tensorMap=t,this.context=i,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return Es(e,this.tensorMap,this.context)}getAttr(e,t){const i=this.node.rawAttrs[e];if(i.tensor!=null)return Es(e,this.tensorMap,this.context);if(i.i!=null||i.f!=null)return FF(this.node.rawAttrs,e,t);if(i.s!=null)return PF(this.node.rawAttrs,e,t);if(i.b!=null)return DF(this.node.rawAttrs,e,t);if(i.shape!=null)return zF(this.node.rawAttrs,e,t);if(i.type!=null)return OF(this.node.rawAttrs,e,t);if(i.list!=null){if(i.list.i!=null||i.list.f!=null)return GF(this.node.rawAttrs,e,t);if(i.list.s!=null)return VF(this.node.rawAttrs,e,t);if(i.list.shape!=null)return UF(this.node.rawAttrs,e,t);if(i.list.b!=null)return $F(this.node.rawAttrs,e,t);if(i.list.type!=null)return BF(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const is=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Uz,abs:qi,acos:Yz,acosh:Jz,add:He,addN:aoe,all:dI,any:d1,argMax:Df,argMin:Qz,asin:qz,asinh:eG,atan:tG,atan2:nG,atanh:iG,avgPool:rS,avgPool3d:sG,basicLSTMCell:loe,batchNorm:tb,batchNorm2d:oG,batchNorm3d:aG,batchNorm4d:lG,batchToSpaceND:sS,bincount:uG,booleanMaskAsync:Goe,broadcastArgs:uoe,broadcastTo:uf,buffer:nn,cast:ot,ceil:cG,clipByValue:eo,clone:Ru,complex:Vc,concat:Hi,concat1d:hG,concat2d:dG,concat3d:pG,concat4d:fG,conv1d:pI,conv2d:Uc,conv2dTranspose:fI,conv3d:gG,conv3dTranspose:yG,cos:oS,cosh:mI,cosineWindow:OI,cumprod:m1,cumsum:gI,denseBincount:iA,depthToSpace:bG,depthwiseConv2d:nb,diag:coe,dilation2d:xG,div:At,divNoNan:vG,dot:wG,dropout:ZG,einsum:hoe,elu:ib,enclosingPowerOfTwo:jG,equal:ko,erf:SG,euclideanNorm:CG,exp:Ro,expandDims:as,expm1:_G,eye:yI,fft:bS,fill:bm,floor:sb,floorDiv:hI,fused:Xoe,gather:ob,gatherND:Woe,greater:Fs,greaterEqual:qc,ifft:By,imag:aS,image:wu,inTopKAsync:Hoe,irfft:NI,isFinite:MG,isInf:AG,isNaN:EG,leakyRelu:lS,less:bI,lessEqual:Vd,linalg:QG,linspace:doe,localResponseNormalization:IG,log:No,log1p:uS,logSigmoid:kG,logSoftmax:vI,logSumExp:wI,logicalAnd:tl,logicalNot:cS,logicalOr:SI,logicalXor:RG,losses:Kte,lowerBound:poe,matMul:ln,max:la,maxPool:hS,maxPool3d:NG,maxPoolWithArgmax:foe,maximum:Hu,mean:vi,meshgrid:moe,min:Py,minimum:ab,mirrorPad:LG,mod:PG,moments:dS,movingAverage:Voe,mul:ae,multiRNNCell:goe,multinomial:yoe,neg:si,norm:rb,notEqual:zf,oneHot:Dy,ones:_o,onesLike:Lo,op:ie,outerProduct:boe,pad:eh,pad1d:xoe,pad2d:voe,pad3d:woe,pad4d:Soe,pool:DG,pow:$c,prelu:fS,print:Zz,prod:FG,raggedGather:Toe,raggedRange:Coe,raggedTensorToTensor:_oe,rand:Moe,randomGamma:Ioe,randomNormal:TI,randomStandardNormal:koe,randomUniform:ub,range:Gf,real:Fy,reciprocal:BG,relu:jl,relu6:CI,reshape:ue,reverse:da,reverse1d:Roe,reverse2d:Noe,reverse3d:Loe,reverse4d:Poe,rfft:xS,round:_I,rsqrt:MI,scalar:Nt,scatterND:Uoe,searchSorted:Ak,selu:AI,separableConv2d:EI,setdiff1dAsync:Doe,sigmoid:Dl,sign:zG,signal:Xte,sin:II,sinh:kI,slice:vn,slice1d:mS,slice2d:RI,slice3d:gS,slice4d:Oy,softmax:yS,softplus:xm,spaceToBatchND:pS,sparse:Zte,sparseToDense:$oe,spectral:Hte,split:Js,sqrt:Yr,square:Vn,squaredDifference:LI,squeeze:Ud,stack:Ls,step:wm,stridedSlice:GG,string:jte,sub:xt,sum:wt,tan:VG,tanh:Of,tensor:hi,tensor1d:ls,tensor2d:od,tensor3d:UG,tensor4d:Foe,tensor5d:Ooe,tensor6d:Boe,tile:Qo,topk:$G,transpose:gn,truncatedNormal:PI,unique:WG,unsortedSegmentSum:DI,unstack:pa,upperBound:zoe,variable:HG,where:ds,whereAsync:C$,zeros:tr,zerosLike:wn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wut=(n,e,t,i=is)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[i.add(N("a",n,e,t),N("b",n,e,t))];case"AddN":return[i.addN(N("tensors",n,e,t))];case"FloorMod":case"Mod":return[i.mod(N("a",n,e,t),N("b",n,e,t))];case"Mul":return[i.mul(N("a",n,e,t),N("b",n,e,t))];case"RealDiv":case"Div":return[i.div(N("a",n,e,t),N("b",n,e,t))];case"DivNoNan":return[i.divNoNan(N("a",n,e,t),N("b",n,e,t))];case"FloorDiv":return[i.floorDiv(N("a",n,e,t),N("b",n,e,t))];case"Sub":return[i.sub(N("a",n,e,t),N("b",n,e,t))];case"Minimum":return[i.minimum(N("a",n,e,t),N("b",n,e,t))];case"Maximum":return[i.maximum(N("a",n,e,t),N("b",n,e,t))];case"Pow":return[i.pow(N("a",n,e,t),N("b",n,e,t))];case"SquaredDifference":return[i.squaredDifference(N("a",n,e,t),N("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sut=(n,e,t,i=is)=>{switch(n.op){case"Abs":case"ComplexAbs":return[i.abs(N("x",n,e,t))];case"Acos":return[i.acos(N("x",n,e,t))];case"Acosh":return[i.acosh(N("x",n,e,t))];case"Asin":return[i.asin(N("x",n,e,t))];case"Asinh":return[i.asinh(N("x",n,e,t))];case"Atan":return[i.atan(N("x",n,e,t))];case"Atan2":return[i.atan2(N("x",n,e,t),N("y",n,e,t))];case"Atanh":return[i.atanh(N("x",n,e,t))];case"Ceil":return[i.ceil(N("x",n,e,t))];case"Complex":return[i.complex(N("real",n,e,t),N("imag",n,e,t))];case"Cos":return[i.cos(N("x",n,e,t))];case"Cosh":return[i.cosh(N("x",n,e,t))];case"Elu":return[i.elu(N("x",n,e,t))];case"Erf":return[i.erf(N("x",n,e,t))];case"Exp":return[i.exp(N("x",n,e,t))];case"Expm1":return[i.expm1(N("x",n,e,t))];case"Floor":return[i.floor(N("x",n,e,t))];case"Log":return[i.log(N("x",n,e,t))];case"Log1p":return[i.log1p(N("x",n,e,t))];case"Imag":return[i.imag(N("x",n,e,t))];case"Neg":return[i.neg(N("x",n,e,t))];case"Reciprocal":return[i.reciprocal(N("x",n,e,t))];case"Real":return[i.real(N("x",n,e,t))];case"Relu":return[i.relu(N("x",n,e,t))];case"Round":return[i.round(N("x",n,e,t))];case"Selu":return[i.selu(N("x",n,e,t))];case"Sigmoid":return[i.sigmoid(N("x",n,e,t))];case"Sin":return[i.sin(N("x",n,e,t))];case"Sign":return[i.sign(N("x",n,e,t))];case"Sinh":return[i.sinh(N("x",n,e,t))];case"Softplus":return[i.softplus(N("x",n,e,t))];case"Sqrt":return[i.sqrt(N("x",n,e,t))];case"Square":return[i.square(N("x",n,e,t))];case"Tanh":return[i.tanh(N("x",n,e,t))];case"Tan":return[i.tan(N("x",n,e,t))];case"ClipByValue":return[i.clipByValue(N("x",n,e,t),N("clipValueMin",n,e,t),N("clipValueMax",n,e,t))];case"Relu6":return[i.relu6(N("x",n,e,t))];case"Rsqrt":return[i.rsqrt(Es(n.inputNames[0],e,t))];case"Prod":return[i.prod(N("x",n,e,t),N("axes",n,e,t))];case"LeakyRelu":return[i.leakyRelu(N("x",n,e,t),N("alpha",n,e,t))];case"Prelu":return[i.prelu(N("x",n,e,t),N("alpha",n,e,t))];case"IsNan":return[i.isNaN(Es(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ga(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){B(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let i=0;i<n.length;i++){const r=n[i],s=e[i];B(r<0||s<0||r===s,()=>t+` Shapes ${n} and ${e} must match`)}}}function kj(n){return!(typeof n=="number"||n.some(e=>e<0))}function Mx(n,e,t){let i=WF(n,t);const r=!kj(i);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${i}`);if(r&&e.forEach(s=>{i=WF(s.shape,i)}),!kj(i))throw new Error(`Non-fully-defined elementShape: ${i}`);return i}function WF(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let i=0;i<n.length;++i){const r=n[i],s=e[i];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[i]=r>=0?r:s}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tut{constructor(e,t,i,r,s,o,a){this.name=e,this.dtype=t,this.maxSize=i,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Nt(0),Ri(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const i=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ga(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),i.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(i.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);i.tensor=t,Ri(t),i.written=!0,this.tensors[e]=i}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((i,r)=>this.write(i,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return hi([],[0].concat(this.elementShape));const i=this.readMany(e);return Ga(this.elementShape,i[0].shape,"TensorArray shape mismatch: "),Ls(i,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return hi([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const i=this.readMany(t);return Ga(this.elementShape,i[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${i[0].shape})`),Hi(i,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const i=Math.max(...e);if(!this.dynamicSize&&i>=this.maxSize)throw new Error(`Max index must be < array size (${i}  vs. ${this.maxSize})`);this.writeMany(e,pa(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let i=0;const r=e.map(l=>(i+=l,i));if(i!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${i}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=i===0?0:t.size/i,o=[];me(()=>{t=ue(t,[1,i,s]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:r[l-1],0],c=[1,e[l],s];o[l]=ue(vn(t,u,c),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kf{constructor(e,t,i,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=i,e!=null&&e.forEach(s=>{if(i!==s.dtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${s.dtype}`);Ga(t,s.shape,"TensorList shape mismatch: "),Ri(s)}),this.idTensor=Nt(0),this.maxNumElements=r,Ri(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Kf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,i=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(i!==-1&&this.tensors.length!==i)throw new Error(`Operation expected a list with ${i} elements but got a list with ${this.tensors.length} elements.`);Ga(e,this.elementShape,"TensorList shape mismatch: ");const r=Mx(this.elementShape,this.tensors,e);return me(()=>{const s=this.tensors.map(o=>ue(o,r));return Ls(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const i=Mx(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Ga(r.shape,e,"TensorList shape mismatch: "),ue(r,i)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ga(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ri(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Kf([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let i=0;i<Math.min(this.tensors.length,e);++i)t.tensors[i]=this.tensors[i];return t}getItem(e,t,i){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ga(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Mx(this.elementShape,this.tensors,t);return ue(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ga(this.elementShape,t.shape,"TensorList shape mismatch: "),Ri(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,i){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ga(this.elementShape,i,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Mx(this.elementShape,this.tensors,i);return e.length===0?hi([],[0].concat(r)):me(()=>{const s=e.map(o=>ue(this.tensors[o],r));return Ls(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ga(this.elementShape,t,"TensorList shape mismatch: ");const i=Mx(this.elementShape,this.tensors,t);return this.size()===0?hi([],[0].concat(i)):me(()=>{const r=this.tensors.map(s=>ue(s,i));return Hi(r,0)})}}function Cut(n,e,t){const i=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Ga(r,e,"TensorList shape mismatch: ");const s=pa(n);return new Kf(s,e,i)}function _ut(n,e,t,i){return new Kf([],n,e,i)}function Mut(n,e,t,i){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(i!=null&&i!==-1&&r>=i)throw new Error(`Max index must be < array size (${r}  vs. ${i})`);const s=new Kf([],t,n.dtype,i),o=pa(n,0);return e.forEach((a,l)=>{s.setItem(a,o[l])}),s}function Aut(n,e,t){let i=0;const r=e.map(c=>(i+=c,i));if(i!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${i}, and tensor's shape is: ${n.shape}`);const s=n.shape.slice(1),o=WF(s,t),a=i===0?0:n.size/i,l=me(()=>{const c=[];n=ue(n,[1,i,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:r[h-1],0],p=[1,e[h],a];c[h]=ue(vn(n,d,p),o)}return n.dispose(),c}),u=new Kf([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eut=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const i=N("thenBranch",n,e,t),r=N("elseBranch",n,e,t),s=N("cond",n,e,t),o=N("args",n,e,t);return(await s.data())[0]?t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const i=N("body",n,e,t),r=N("cond",n,e,t),s=N("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){const c=u;u=await t.functionMap[i].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const i=N("pred",n,e,t);return[dc(i)]}case"Switch":{const i=N("pred",n,e,t);let r=N("data",n,e,t);return r.kept||(r=dc(r)),(await i.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const i=n.inputNames.find(r=>Es(r,e,t)!==void 0);if(i){const r=Es(i,e,t);return[dc(r)]}return}case"Enter":{const i=N("frameName",n,e,t),r=N("tensor",n,e,t);return t.enterFrame(i),[dc(r)]}case"Exit":{const i=N("tensor",n,e,t);return t.exitFrame(),[dc(i)]}case"NextIteration":{const i=N("tensor",n,e,t);return t.nextIteration(),[dc(i)]}case"TensorArrayV3":{const i=N("size",n,e,t),r=N("dtype",n,e,t),s=N("elementShape",n,e,t),o=N("dynamicSize",n,e,t),a=N("clearAfterRead",n,e,t),l=N("identicalElementShapes",n,e,t),u=N("name",n,e,t),c=new Tut(u,r,i,s,l,o,a);return t.addTensorArray(c),[c.idTensor,Nt(1)]}case"TensorArrayWriteV3":{const i=N("tensorArrayId",n,e,t),r=N("index",n,e,t),s=N("tensor",n,e,t),o=t.getTensorArray(i.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const i=N("tensorArrayId",n,e,t),r=N("index",n,e,t);return[t.getTensorArray(i.id).read(r)]}case"TensorArrayGatherV3":{const i=N("tensorArrayId",n,e,t),r=N("indices",n,e,t),s=N("dtype",n,e,t);return[t.getTensorArray(i.id).gather(r,s)]}case"TensorArrayScatterV3":{const i=N("tensorArrayId",n,e,t),r=N("indices",n,e,t),s=N("tensor",n,e,t),o=t.getTensorArray(i.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const i=N("tensorArrayId",n,e,t),r=t.getTensorArray(i.id),s=N("dtype",n,e,t);return[r.concat(s)]}case"TensorArraySplitV3":{const i=N("tensorArrayId",n,e,t),r=N("tensor",n,e,t),s=N("lengths",n,e,t),o=t.getTensorArray(i.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const i=N("tensorArrayId",n,e,t),r=t.getTensorArray(i.id);return[Nt(r.size(),"int32")]}case"TensorArrayCloseV3":{const i=N("tensorArrayId",n,e,t),r=t.getTensorArray(i.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const i=N("tensorListId",n,e,t),r=N("index",n,e,t),s=N("tensor",n,e,t),o=t.getTensorList(i.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const i=N("tensorListId",n,e,t),r=N("index",n,e,t),s=N("elementShape",n,e,t),o=N("elementDType",n,e,t);return[t.getTensorList(i.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const i=N("indices",n,e,t),r=N("tensor",n,e,t),s=N("elementShape",n,e,t),o=N("numElements",n,e,t),a=Mut(r,i,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=N("elementShape",n,e,t),r=N("elementDType",n,e,t);let s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=N(s,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=_ut(i,r,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const i=N("tensorListId",n,e,t),r=N("indices",n,e,t),s=N("elementShape",n,e,t),o=N("elementDType",n,e,t);return[t.getTensorList(i.id).gather(r,o,s)]}case"TensorListStack":{const i=N("tensorListId",n,e,t),r=N("elementShape",n,e,t),s=N("elementDType",n,e,t),o=N("numElements",n,e,t);return[t.getTensorList(i.id).stack(r,s,o)]}case"TensorListFromTensor":{const i=N("tensor",n,e,t),r=N("elementShape",n,e,t),s=N("elementDType",n,e,t),o=Cut(i,r,s);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=N("tensorListId",n,e,t),r=t.getTensorList(i.id),s=N("dtype",n,e,t),o=N("elementShape",n,e,t);return[r.concat(s,o)]}case"TensorListPushBack":{const i=N("tensorListId",n,e,t),r=N("tensor",n,e,t),s=t.getTensorList(i.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const i=N("tensorListId",n,e,t),r=N("elementShape",n,e,t),s=N("elementDType",n,e,t);return[t.getTensorList(i.id).popBack(r,s)]}case"TensorListSplit":{const i=N("tensor",n,e,t),r=N("elementShape",n,e,t),s=N("lengths",n,e,t),o=Aut(i,s,r);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const i=N("tensorListId",n,e,t),r=t.getTensorList(i.id);return[Nt(r.size(),"int32")]}case"TensorListResize":{const i=N("tensorListId",n,e,t),r=N("size",n,e,t),s=t.getTensorList(i.id).resize(r);return t.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rj(n,e,t){const[i,r]=N("fusedOps",n,e,t),s=i==="biasadd",o=!s,a=r==="prelu",l=i==="fusedbatchnorm",u=N("numArgs",n,e,t);if(s){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=N("strides",n,e,t),h=j_(n,e,t),d=N("dataFormat",n,e,t).toUpperCase(),p=N("dilations",n,e,t);let[f,g]=N("args",n,e,t);o&&(g=f,f=void 0);const y=N("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:g,activationFunc:r,leakyreluAlpha:y}}const Iut=(n,e,t,i=is)=>{switch(n.op){case"Conv1D":{const r=N("stride",n,e,t),s=N("pad",n,e,t),o=N("dataFormat",n,e,t).toUpperCase(),a=N("dilation",n,e,t);return[i.conv1d(N("x",n,e,t),N("filter",n,e,t),r,s,o,a)]}case"Conv2D":{const r=N("strides",n,e,t),s=j_(n,e,t),o=N("dataFormat",n,e,t).toUpperCase(),a=N("dilations",n,e,t);return[i.conv2d(N("x",n,e,t),N("filter",n,e,t),[r[1],r[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Rj(n,e,t);return[i.fused.conv2d({x:N("x",n,e,t),filter:N("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Rj(n,e,t);return[i.fused.depthwiseConv2d({x:N("x",n,e,t),filter:N("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=N("outputShape",n,e,t),s=N("strides",n,e,t),o=j_(n,e,t);return[i.conv2dTranspose(N("x",n,e,t),N("filter",n,e,t),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=N("strides",n,e,t),s=j_(n,e,t),o=N("dilations",n,e,t),a=N("dataFormat",n,e,t).toUpperCase();return[i.depthwiseConv2d(N("input",n,e,t),N("filter",n,e,t),[r[1],r[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("dataFormat",n,e,t).toUpperCase(),a=N("dilations",n,e,t);return[i.conv3d(N("x",n,e,t),N("filter",n,e,t),[r[1],r[2],r[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("kernelSize",n,e,t);return[i.avgPool(N("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("kernelSize",n,e,t);return[i.maxPool(N("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("kernelSize",n,e,t),a=N("includeBatchInIndex",n,e,t),{result:l,indexes:u}=i.maxPoolWithArgmax(N("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s,a);return[l,u]}case"AvgPool3D":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("kernelSize",n,e,t);return[i.avgPool3d(N("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("kernelSize",n,e,t);return[i.maxPool3d(N("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=N("strides",n,e,t),s=N("pad",n,e,t),o=N("dilations",n,e,t),a=r[1],l=r[2],u=o[1],c=o[2];return[i.dilation2d(N("x",n,e,t),N("filter",n,e,t),[a,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kut=(n,e,t,i=is)=>{switch(n.op){case"Fill":{const r=N("shape",n,e,t),s=N("dtype",n,e,t),o=N("value",n,e,t);return[i.fill(r,o,s)]}case"LinSpace":{const r=N("start",n,e,t),s=N("stop",n,e,t),o=N("num",n,e,t);return[i.linspace(r,s,o)]}case"Multinomial":{const r=N("logits",n,e,t),s=N("numSamples",n,e,t),o=N("seed",n,e,t);return[i.multinomial(r,s,o)]}case"OneHot":{const r=N("indices",n,e,t),s=N("depth",n,e,t),o=N("onValue",n,e,t),a=N("offValue",n,e,t),l=N("dtype",n,e,t);return[i.oneHot(r,s,o,a,l)]}case"Ones":return[i.ones(N("shape",n,e,t),N("dtype",n,e,t))];case"OnesLike":return[i.onesLike(N("x",n,e,t))];case"RandomStandardNormal":return[i.randomStandardNormal(N("shape",n,e,t),N("dtype",n,e,t),N("seed",n,e,t))];case"RandomUniform":return[i.randomUniform(N("shape",n,e,t),N("minval",n,e,t),N("maxval",n,e,t),N("dtype",n,e,t))];case"Range":{const r=N("start",n,e,t),s=N("stop",n,e,t),o=N("step",n,e,t);return[i.range(r,s,o,N("dtype",n,e,t))]}case"TruncatedNormal":{const r=N("shape",n,e,t),s=N("mean",n,e,t),o=N("stdDev",n,e,t),a=N("seed",n,e,t);return[i.truncatedNormal(r,s,o,N("dtype",n,e,t),a)]}case"Zeros":return[i.zeros(N("shape",n,e,t),N("dtype",n,e,t))];case"ZerosLike":return[i.zerosLike(N("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(n,e,t){const i=N("boxes",n,e,t),r=N("scores",n,e,t),s=N("maxOutputSize",n,e,t),o=N("iouThreshold",n,e,t),a=N("scoreThreshold",n,e,t),l=N("softNmsSigma",n,e,t);return{boxes:i,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const Rut=async(n,e,t,i,r=is)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=vP(n,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(s,o,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=vP(n,e,t),c=N("padToMaxOutputSize",n,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(s,o,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=vP(n,e,t);return[await r.image.nonMaxSuppressionAsync(s,o,a,l,u)]}case"Where":{const s=r.cast(N("condition",n,e,t),"bool"),o=[await r.whereAsync(s)];return s.dispose(),o}case"ListDiff":return r.setdiff1dAsync(N("x",n,e,t),N("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nut=(n,e,t,i=is)=>{switch(n.op){case"LowerBound":{const r=N("sortedSequence",n,e,t),s=N("values",n,e,t);return[i.lowerBound(r,s)]}case"TopKV2":{const r=N("x",n,e,t),s=N("k",n,e,t),o=N("sorted",n,e,t),a=i.topk(r,s,o);return[a.values,a.indices]}case"UpperBound":{const r=N("sortedSequence",n,e,t),s=N("values",n,e,t);return[i.upperBound(r,s)]}case"Unique":{const r=N("x",n,e,t),s=i.unique(r);return[s.values,s.indices]}case"UniqueV2":{const r=N("x",n,e,t),s=N("axis",n,e,t),o=i.unique(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lut=(n,e,t,i=is)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=N("default",n,e,t);return[Es(n.name,e,t)||r];case"Placeholder":return[Es(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=N("x",n,e,t);return[dc(c)]}case"IdentityN":return N("x",n,e,t).map(c=>dc(c));case"Snapshot":const s=N("x",n,e,t);return[dc(s)];case"Shape":return[i.tensor1d(N("x",n,e,t).shape,"int32")];case"ShapeN":return N("x",n,e,t).map(c=>i.tensor1d(c.shape));case"Size":return[i.scalar(N("x",n,e,t).size,"int32")];case"Rank":return[i.scalar(N("x",n,e,t).rank,"int32")];case"NoOp":return[i.scalar(1)];case"Print":const o=N("x",n,e,t),a=N("data",n,e,t),l=N("message",n,e,t),u=N("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Put{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Nt(0),this.tensorMap=new Map,Ri(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Nt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const i=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),me(()=>{const r=pa(t),s=i.length,o=r.length;B(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){const l=i[a],u=r[a];Ri(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const i=await e.data();return me(()=>{const r=[];for(let s=0;s<i.length;s++){const o=i[s],a=this.findWithDefault(o,t);r.push(a)}return Ls(r)})}findWithDefault(e,t){return this.tensorMap.get(e)??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dut=async(n,e,t,i)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=i.getHashTableHandleByName(n.name);if(r!=null)return[r];{const s=N("keyDType",n,e,t),o=N("valueDType",n,e,t),a=new Put(s,o);return i.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=N("tableHandle",n,e,t,i),s=N("keys",n,e,t),o=N("values",n,e,t);return[await i.getHashTableById(r.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=N("tableHandle",n,e,t,i),s=N("keys",n,e,t),o=N("defaultValue",n,e,t);return[await i.getHashTableById(r.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=N("tableHandle",n,e,t,i);return[i.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fut=(n,e,t,i=is)=>{switch(n.op){case"ResizeBilinear":{const r=N("images",n,e,t),s=N("size",n,e,t),o=N("alignCorners",n,e,t),a=N("halfPixelCenters",n,e,t);return[i.image.resizeBilinear(r,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const r=N("images",n,e,t),s=N("size",n,e,t),o=N("alignCorners",n,e,t),a=N("halfPixelCenters",n,e,t);return[i.image.resizeNearestNeighbor(r,[s[0],s[1]],o,a)]}case"CropAndResize":{const r=N("image",n,e,t),s=N("boxes",n,e,t),o=N("boxInd",n,e,t),a=N("cropSize",n,e,t),l=N("method",n,e,t),u=N("extrapolationValue",n,e,t);return[i.image.cropAndResize(r,s,o,a,l,u)]}case"ImageProjectiveTransformV3":{const r=N("images",n,e,t),s=N("transforms",n,e,t),o=N("outputShape",n,e,t),a=N("fillValue",n,e,t),l=N("interpolation",n,e,t),u=N("fillMode",n,e,t);return[i.image.transform(r,s,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Out=(n,e,t,i=is)=>{switch(n.op){case"Equal":return[i.equal(N("a",n,e,t),N("b",n,e,t))];case"NotEqual":return[i.notEqual(N("a",n,e,t),N("b",n,e,t))];case"Greater":return[i.greater(N("a",n,e,t),N("b",n,e,t))];case"GreaterEqual":return[i.greaterEqual(N("a",n,e,t),N("b",n,e,t))];case"Less":return[i.less(N("a",n,e,t),N("b",n,e,t))];case"LessEqual":return[i.lessEqual(N("a",n,e,t),N("b",n,e,t))];case"LogicalAnd":return[i.logicalAnd(N("a",n,e,t),N("b",n,e,t))];case"LogicalNot":return[i.logicalNot(N("a",n,e,t))];case"LogicalOr":return[i.logicalOr(N("a",n,e,t),N("b",n,e,t))];case"Select":case"SelectV2":return[i.where(N("condition",n,e,t),N("a",n,e,t),N("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const But=(n,e,t,i=is)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[i.matMul(N("a",n,e,t),N("b",n,e,t),N("transposeA",n,e,t),N("transposeB",n,e,t))];case"Einsum":return[i.einsum(N("equation",n,e,t),...N("tensors",n,e,t))];case"Transpose":return[i.transpose(N("x",n,e,t),N("perm",n,e,t))];case"_FusedMatMul":const[r,s]=N("fusedOps",n,e,t),o=r==="biasadd",a=s==="prelu",l=N("numArgs",n,e,t),u=N("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=N("args",n,e,t);return[i.fused.matMul({a:N("a",n,e,t),b:N("b",n,e,t),transposeA:N("transposeA",n,e,t),transposeB:N("transposeB",n,e,t),bias:c,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zut=(n,e,t,i=is)=>{switch(n.op){case"EuclideanNorm":return[i.euclideanNorm(N("x",n,e,t),N("axis",n,e,t),N("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[i.batchNorm(N("x",n,e,t),N("mean",n,e,t),N("variance",n,e,t),N("offset",n,e,t),N("scale",n,e,t),N("epsilon",n,e,t))];case"FusedBatchNormV3":return[i.batchNorm(N("x",n,e,t),N("mean",n,e,t),N("variance",n,e,t),N("offset",n,e,t),N("scale",n,e,t),N("epsilon",n,e,t))];case"LRN":return[i.localResponseNormalization(N("x",n,e,t),N("radius",n,e,t),N("bias",n,e,t),N("alpha",n,e,t),N("beta",n,e,t))];case"Softmax":return[i.softmax(N("x",n,e,t))];case"LogSoftmax":return[i.logSoftmax(N("x",n,e,t))];case"SparseToDense":return[i.sparseToDense(N("sparseIndices",n,e,t),N("outputShape",n,e,t),N("sparseValues",n,e,t),N("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gut=(n,e,t,i=is)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:s}=i.raggedGather(N("paramsNestedSplits",n,e,t),N("paramsDenseValues",n,e,t),N("indices",n,e,t),N("outputRaggedRank",n,e,t));return r.concat(s)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:s}=i.raggedRange(N("starts",n,e,t),N("limits",n,e,t),N("splits",n,e,t));return[r,s]}case"RaggedTensorToTensor":return[i.raggedTensorToTensor(N("shape",n,e,t),N("values",n,e,t),N("defaultValue",n,e,t),N("rowPartitionTensors",n,e,t),N("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vut=(n,e,t,i=is)=>{switch(n.op){case"Max":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.max(N("x",n,e,t),a,l)]}case"Mean":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.mean(N("x",n,e,t),a,l)]}case"Min":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.min(N("x",n,e,t),a,l)]}case"Sum":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.sum(N("x",n,e,t),a,l)]}case"All":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.all(N("x",n,e,t),a,l)]}case"Any":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.any(N("x",n,e,t),a,l)]}case"ArgMax":{const a=N("axis",n,e,t);return[i.argMax(N("x",n,e,t),a)]}case"ArgMin":{const a=N("axis",n,e,t);return[i.argMin(N("x",n,e,t),a)]}case"Prod":{const a=N("axis",n,e,t),l=N("keepDims",n,e,t);return[i.prod(N("x",n,e,t),a,l)]}case"Cumprod":{const a=N("axis",n,e,t),l=N("exclusive",n,e,t),u=N("reverse",n,e,t);return[i.cumprod(N("x",n,e,t),a,l,u)]}case"Cumsum":{const a=N("axis",n,e,t),l=N("exclusive",n,e,t),u=N("reverse",n,e,t);return[i.cumsum(N("x",n,e,t),a,l,u)]}case"Bincount":const r=N("x",n,e,t),s=N("weights",n,e,t),o=N("size",n,e,t);return[i.bincount(r,s,o)];case"DenseBincount":{const a=N("x",n,e,t),l=N("weights",n,e,t),u=N("size",n,e,t),c=N("binaryOutput",n,e,t);return[i.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uut=(n,e,t,i=is)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=N("n",n,e,t),s=N("axis",n,e,t);let o=N("tensors",n,e,t);return o=o.slice(0,r),[i.concat(o,s)]}case"Gather":{const r=N("x",n,e,t),s=N("indices",n,e,t);return[i.gather(r,i.cast(s,"int32"),0)]}case"GatherV2":{const r=N("axis",n,e,t),s=N("batchDims",n,e,t),o=N("x",n,e,t),a=N("indices",n,e,t);return[i.gather(o,i.cast(a,"int32"),r,s)]}case"Reverse":{const r=N("dims",n,e,t),s=[];for(let a=0;a<r.length;a++)r[a]&&s.push(a);const o=N("x",n,e,t);return[i.reverse(o,s)]}case"ReverseV2":{const r=N("axis",n,e,t),s=N("x",n,e,t);return[i.reverse(s,r)]}case"Slice":{const r=N("begin",n,e,t),s=N("size",n,e,t);return[i.slice(N("x",n,e,t),r,s)]}case"StridedSlice":{const r=N("begin",n,e,t),s=N("end",n,e,t),o=N("strides",n,e,t),a=N("beginMask",n,e,t),l=N("endMask",n,e,t),u=N("ellipsisMask",n,e,t),c=N("newAxisMask",n,e,t),h=N("shrinkAxisMask",n,e,t),d=N("x",n,e,t);return[i.stridedSlice(d,r,s,o,a,l,u,c,h)]}case"Pack":return me(()=>{const r=N("axis",n,e,t),s=N("tensors",n,e,t),o=s[0].shape,a=i.squeeze(s[0]).shape,l=s.map(u=>{const c=bn(u.shape,o);if(!c&&!bn(i.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:i.reshape(u,o)});return[i.stack(l,r)]});case"Unpack":{const r=N("axis",n,e,t),s=N("tensor",n,e,t);return i.unstack(s,r)}case"Tile":{const r=N("reps",n,e,t);return[i.tile(N("x",n,e,t),r)]}case"Split":case"SplitV":{const r=N("axis",n,e,t),s=N("numOrSizeSplits",n,e,t),o=N("x",n,e,t);return i.split(o,s,r)}case"ScatterNd":{const r=N("indices",n,e,t),s=N("values",n,e,t),o=N("shape",n,e,t);return[i.scatterND(r,s,o)]}case"GatherNd":{const r=N("x",n,e,t),s=N("indices",n,e,t);return[i.gatherND(r,s)]}case"SparseToDense":{const r=N("sparseIndices",n,e,t),s=N("outputShape",n,e,t),o=N("sparseValues",n,e,t),a=N("defaultValue",n,e,t);return[i.sparseToDense(r,o,s,o.dtype===a.dtype?a:i.cast(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ut=(n,e,t,i=is)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=i.sparse.sparseFillEmptyRows(N("indices",n,e,t),N("values",n,e,t),N("denseShape",n,e,t),N("defaultValue",n,e,t));return[r,s,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=i.sparse.sparseReshape(N("inputIndices",n,e,t),N("inputShape",n,e,t),N("newShape",n,e,t));return[r,s]}case"SparseSegmentMean":return[i.sparse.sparseSegmentMean(N("data",n,e,t),N("indices",n,e,t),N("segmentIds",n,e,t))];case"SparseSegmentSum":return[i.sparse.sparseSegmentSum(N("data",n,e,t),N("indices",n,e,t),N("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wut=(n,e,t,i=is)=>{switch(n.op){case"FFT":return[i.fft(N("x",n,e,t))];case"IFFT":return[i.ifft(N("x",n,e,t))];case"RFFT":return[i.rfft(N("x",n,e,t))];case"IRFFT":return[i.irfft(N("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hut=(n,e,t,i=is)=>{switch(n.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=i.string.stringNGrams(N("data",n,e,t),N("dataSplits",n,e,t),N("separator",n,e,t),N("nGramWidths",n,e,t),N("leftPad",n,e,t),N("rightPad",n,e,t),N("padWidth",n,e,t),N("preserveShortSequences",n,e,t));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=i.string.stringSplit(N("input",n,e,t),N("delimiter",n,e,t),N("skipEmpty",n,e,t));return[r,s,o]}case"StringToHashBucketFast":return[i.string.stringToHashBucketFast(N("input",n,e,t),N("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xut=(n,e,t,i=is)=>{switch(n.op){case"Cast":return[i.cast(N("x",n,e,t),N("dtype",n,e,t))];case"ExpandDims":{const r=N("axis",n,e,t);return[i.expandDims(N("x",n,e,t),r)]}case"Squeeze":{const r=N("axis",n,e,t);return[i.squeeze(N("x",n,e,t),r)]}case"Reshape":return[i.reshape(N("x",n,e,t),N("shape",n,e,t))];case"MirrorPad":return[i.mirrorPad(N("x",n,e,t),N("padding",n,e,t),N("mode",n,e,t))];case"PadV2":case"Pad":return[i.pad(N("x",n,e,t),N("padding",n,e,t),N("constantValue",n,e,t))];case"SpaceToBatchND":{const r=N("blockShape",n,e,t),s=N("paddings",n,e,t);return[i.spaceToBatchND(N("x",n,e,t),r,s)]}case"BatchToSpaceND":{const r=N("blockShape",n,e,t),s=N("crops",n,e,t);return[i.batchToSpaceND(N("x",n,e,t),r,s)]}case"DepthToSpace":{const r=N("blockSize",n,e,t),s=N("dataFormat",n,e,t).toUpperCase();return[i.depthToSpace(N("x",n,e,t),r,s)]}case"BroadcastTo":return[i.broadcastTo(N("x",n,e,t),N("shape",n,e,t))];case"BroadcastArgs":return[i.broadcastArgs(N("s0",n,e,t),N("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(n,e,t,i,r=me){const s=((o,a,l)=>{switch(o.category){case"arithmetic":return r(()=>wut(o,a,l));case"basic_math":return r(()=>Sut(o,a,l));case"control":return Eut(o,a,l);case"convolution":return r(()=>Iut(o,a,l));case"creation":return r(()=>kut(o,a,l));case"dynamic":return Rut(o,a,l);case"evaluation":return r(()=>Nut(o,a,l));case"image":return r(()=>Fut(o,a,l));case"graph":return r(()=>Lut(o,a,l));case"logical":return r(()=>Out(o,a,l));case"matrices":return r(()=>But(o,a,l));case"normalization":return r(()=>zut(o,a,l));case"ragged":return r(()=>Gut(o,a,l));case"reduction":return r(()=>Vut(o,a,l));case"slice_join":return r(()=>Uut(o,a,l));case"sparse":return r(()=>$ut(o,a,l));case"spectral":return r(()=>Wut(o,a,l));case"string":return r(()=>Hut(o,a,l));case"transformation":return r(()=>Xut(o,a,l));case"hash_table":return Dut(o,a,l,i);case"custom":const u=nae(o.op);if(u&&u.customExecutor)return u.customExecutor(new vut(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Bc(s)?s.then(o=>[].concat(o)):[].concat(s)}class Lj{constructor(e={},t={},i={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=i,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const i=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(i))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(n,e,t,i){const r=new Set,s=[];let o=null,a=null;const l=new Set,u=Object.keys(n).map(d=>mo(d)[0]);let c=[];i!=null&&(c=i.map(d=>mo(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((sae(d)||Jut(d)||Qut(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),t[d.name]==null&&u.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:a}}function Kut(n,e,t){const{usedNodes:i,inputs:r}=t,s=[],o=Object.keys(r).map(c=>mo(c)[0]).map(c=>n.nodes[c]),a=n.initNodes;o.forEach(c=>{i.has(c.name)&&s.push(c)}),n.weights.forEach(c=>{i.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{i.has(c.name)&&s.push(c)});const l=new Set,u=[];for(;s.length>0;){const c=s.pop();l.add(c.name),e[c.name]||u.push(c),c.children.forEach(h=>{!l.has(h.name)&&i.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&s.push(h)})}return u}const Zut=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],jut=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Yut=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function sae(n){return Zut.indexOf(n.op)>=0}function Jut(n){return jut.indexOf(n.op)>=0}function Qut(n){return Yut.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AA{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(i=>{this._functionExecutorMap[i]=new AA(e.functions[i],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(i=>e[i].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const i=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return i.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const i=Pj(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:o}=i;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const a=t.map(u=>u.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return Kut(this.graph,this.weightMap,i)}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Ri(t),t}cloneTensorList(e){return e?e.map(t=>this.cloneAndKeepTensor(t)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,i])=>[t,this.cloneTensorList(i)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const i=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=i.map(h=>this.graph.nodes[mo(h)[0]]),s=t.map(h=>mo(h)[0]);let o=s.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const a=this.getCompilationKey(r,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(e,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=ve().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const u={},c={};return me(()=>{const h=new Lj(this.weightMap,u,c,this.functionExecutorMap),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(g=>{const[y,m]=mo(g),v=[];v[m]=e[g],d[y]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(v))});const p=this.getFrozenTensorIds(d),f={};for(let g=0;g<l.length;g++){const y=l[g];if(!d[y.name]){const m=Nj(y,d,h,this._resourceManager);if(Bc(m))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(m)),this.checkTensorForDisposal(y.name,y,d,h,p,s,f)}}return this.parent==null&&h.dispose(p),t.map(g=>Es(g,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(i=>e[i]).map(i=>i.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,i,r,s,o,a){t.category==="control"||o.indexOf(e)!==-1||(i[e].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const u=Plt(l.name,i,r);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,i=!1,r={},s={}){this.disposeIntermediateTensors(),i||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ve().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new Lj(this.weightMap,r,s,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,i),l=t.map(d=>Es(d,a,o)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,i){const r=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(r,this.outputNodes,!0,t,i)}async executeWithControlFlow(e,t,i,r){const s=Object.keys(e),o=s.map(w=>this.graph.nodes[mo(w)[0]]),a=i.map(w=>mo(w)[0]);let l=a.map(w=>this.graph.nodes[w]);l.length===0&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:d}=Pj(e,l,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[S,C]=mo(w),_=[];_[C]=e[w],f[S]=_});const g={},y=this.getFrozenTensorIds(f),m={};for(;p.length>0;){const w=this.processStack(o,p,t,f,m,y,a,g,u);await Promise.all(w)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=l.filter(w=>!sae(w)&&!Es(w.name,f,t)).map(w=>w.name);if(v.length>0){let w="";throw h!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return f}processStack(e,t,i,r,s,o,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();i.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&N("isConstant",h.node,r,i)&&([d]=hc(h.node.name,i)),r[h.node.name]==null){const p=Nj(h.node,r,i,this._resourceManager);d||([d]=hc(h.node.name,i));const f=i.currentContext;Bc(p)?c.push(p.then(g=>(r[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),i.currentContext=f,this.checkTensorForDisposal(d,h.node,r,i,o,a,l),this.processChildNodes(h.node,t,i,r,s,u),g))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,i,o,a,l),this.processChildNodes(h.node,t,i,r,s,u))}else this.processChildNodes(h.node,t,i,r,s,u)}return c}processChildNodes(e,t,i,r,s,o){e.children.forEach(a=>{const[l]=hc(a.name,i);s[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!Es(u,r,i))&&(s[l]=!0,t.push({contexts:i.currentContext,node:a})):a.inputNames.every(u=>!!Es(u,r,i))&&(s[l]=!0,t.push({contexts:i.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const i=e[t],[r]=mo(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,a=o.length===i.shape.length&&i.shape.every((l,u)=>o[u]===-1||o[u]===l);B(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${i.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&B(i.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${i.dtype}`)})}mapInputs(e){var t,i;const r={};for(const s in e){const o=(i=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||i===void 0?void 0:i[s];o!=null?r[o.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter(i=>{const[r]=mo(i);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var i,r;const s=(r=(i=this._signature)===null||i===void 0?void 0:i.outputs)===null||r===void 0?void 0:r[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{const[i]=mo(t);if(!this.graph.nodes[i])throw new Error(`The output '${t}' is not found in the graph`)})}}class qut{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ect="?tfjs-format=file",tct="model.json";class R${constructor(e,t={},i=_$){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=i,t==null&&(this.loadOptions={}),this.resourceManager=new qut}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Bc(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(i=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=i,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new AA(Ej.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=Ej.Instance.transformGraph(e.modelInitializer);this.initializer=new AA(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const i=this.io.getSaveHandlers(e);if(i.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof An?[e]:e,i={};return t.forEach((r,s)=>i[this.structuredOutputKeys[s]]=r),i}return e}predict(e,t){const i=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(i)}async predictAsync(e,t){const i=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(i)}normalizeInputs(e){var t;if(!(e instanceof An)&&!Array.isArray(e)){const s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(const o in s){const a=s[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const i=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+i!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-i} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,o)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||u===void 0?void 0:u.resourceId;return c!=null?s[o]=this.resourceIdToCapturedInput[c]:s[o]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,i=Object.keys(t);for(let r=0;r<i.length;r++){const s=i[r],o=t[s];this.resourceIdToCapturedInput[o.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const i=this.executor.execute(e,t);return i.length>1?i:i[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const i=await this.executor.executeAsync(e,t);return i.length>1?i:i[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,i)=>(t[i]=[e[i]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&jt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function nct(n,e={},t=_$){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=rct(n));const i=new R$(n,e,t);return await i.load(),i}function ict(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[i,r]=n;if(!i)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in i))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in i))throw new Error("Model JSON is missing 'weightsManifest'");const s=Kz(i.weightsManifest),o=Hz(i,s,r);e=_A(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=_A(n);else throw new Error("Unknown model format");const t=new R$(e);return t.load(),t}function rct(n){return n.endsWith("/")||(n=n+"/"),`${n}${tct}${ect}`}/** @license See the LICENSE file. */const oae="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class aae extends yb{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const y_='"',Ax=Symbol("out"),Dj=Symbol("field"),b_=Symbol("quote"),wP=Symbol("quoteafterquote"),Fj=Symbol("quoteinquote");class lae extends yb{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new aae(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(B(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&B(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),i=Object.keys(t).filter(r=>t[r]>1);if(B(i.length===0,()=>"Duplicate column names found: "+i.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");const t=e.value;return this.parseRow(t,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),i={},r={};for(let s=0;s<this.fullColumnNames.length;s++){const o=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[o]:null;if(!(this.configuredColumnsOnly&&!a)){const l=t[s];let u=null;if(l==="")if(a&&a.default!==void 0)u=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${o} is empty in this line: ${e}`);u=void 0}else{const c=Number(l);if(isNaN(c))a&&a.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!a||!a.dtype)u=c;else switch(a.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}a&&a.isLabel?r[o]=u:i[o]=u}}return Object.keys(r).length===0?i:{xs:i,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const i=[];let r=0;const s=e.length;let o=Ax;for(let a=0;a<s;a++)switch(o){case Ax:switch(e.charAt(a)){case y_:r=a+1,o=b_;break;case this.delimiter:if(r=a+1,this.delimiter===" "&&this.delimWhitespace)break;i.push(""),o=Ax;break;default:o=Dj,r=a;break}break;case Dj:switch(e.charAt(a)){case this.delimiter:i.push(e.substring(r,a)),o=Ax,r=a+1;break}break;case b_:switch(e.charAt(a)){case y_:o=wP;break}break;case wP:switch(e.charAt(a)){case this.delimiter:i.push(e.substring(r,a-1)),o=Ax,r=a+1;break;case y_:o=b_;break;default:o=Fj;break}break;case Fj:switch(e.charAt(a)){case y_:o=b_;break}break}if(o===wP?i.push(e.substring(r,s-1)):i.push(e.substring(r)),t&&i.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${i}`);return i}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class N$ extends Er{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ve().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new N$(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(i){throw new Error(`Error thrown while initializing video stream: ${i.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const i=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(i.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(i.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let i=0;return new Promise(r=>{const s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++i===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,i=new Float32Array(e.length*t);return e.forEach((r,s)=>i.set(r,s*t)),i}getTensorFromAudioDataArray(e,t){const i=new Float32Array(ke(t));return i.set(e,i.length-e.length),hi(i,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class L$ extends Er{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=ls([0],"int32"),this.webcamConfig.centerCrop){const i=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-i)/2,o=(1-r)/2,a=s+i,l=r+o;this.cropBox=od([o,s,l,a],[1,4])}else this.cropBox=od([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ve().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const i=new L$(e,t);return await i.start(),i}async start(){this.webcamConfig.facingMode&&B(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=aV(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return me(()=>{const t=as(ot(e,"float32"),0);let i;i=wu.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=i.shape;return ue(i,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class uae{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class cae extends Er{split(e){return new sct(this,e)}}class sct extends cae{constructor(e,t){super(),this.upstream=e,this.impl=new oct(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class oct extends i${constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const i of t.slice(0,-1))this.outputQueue.push(i);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class act extends Er{decodeUTF8(){return new lct(this)}}class lct extends cae{constructor(e){super(),this.upstream=e,this.impl=new uct(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class uct extends i${constructor(e){if(super(),this.upstream=e,ve().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let i;return ve().get("IS_BROWSER")?i=this.decoder.decode(t,{stream:!0}):i=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(i),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class hae extends act{constructor(e,t={}){super(),this.file=e,this.options=t,B(e instanceof Uint8Array||(ve().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{const i=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,i)));else{const r=new FileReader;r.onload=o=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=o=>t(new Error("Aborted")),r.onerror=o=>t(new Error(o.type));const s=this.file.slice(this.offset,i);r.readAsArrayBuffer(s)}this.offset=i}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function cct(n,e={},t){let i,r;typeof n=="string"?i=n:(i=n.url,r=hct(n));const s=await(t||hte)(i,r);if(s.ok){const o=new Uint8Array(await s.arrayBuffer());return new hae(o,e)}else throw new Error(s.statusText)}const hct=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function dae(n){return typeof n=="string"&&n.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class pae extends uae{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(dae(this.input)&&ve().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new hae(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class fae extends uae{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return dae(this.url)?new pae(this.url,this.fileOptions).iterator():cct(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function dct(n,e={}){return new lae(new fae(n),e)}function pct(n){const e=n$(n);return fo(async()=>e)}function fct(n){return fo(async()=>{const e=await n();return n$(()=>e.next())})}async function mct(n,e){return L$.create(n,e)}async function gct(n){return N$.create(n)}/** @license See the LICENSE file. */const mae="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yct=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:lae,Dataset:yb,FileDataSource:pae,TextLineDataset:aae,URLDataSource:fae,array:cHe,csv:dct,func:pct,generator:fct,microphone:gct,version_data:mae,webcam:mct,zip:hHe},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const bct="4.2.0";/** @license See the LICENSE file. */const xct="4.2.0";/** @license See the LICENSE file. */const vct="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wct={"tfjs-core":Zoe,"tfjs-backend-cpu":bct,"tfjs-backend-webgl":xct,"tfjs-data":mae,"tfjs-layers":uk,"tfjs-converter":oae,tfjs:vct},Sct=Object.freeze(Object.defineProperty({__proto__:null,Abs:ew,Acos:o0,Acosh:a0,AdadeltaOptimizer:qG,AdagradOptimizer:eV,AdamOptimizer:tV,AdamaxOptimizer:nV,Add:gm,AddN:tw,All:s2,Any:o2,ArgMax:nw,ArgMin:iw,Asin:l0,Asinh:u0,Atan:c0,Atan2:d0,Atanh:h0,AvgPool:rw,AvgPool3D:sw,AvgPool3DGrad:l2,AvgPoolGrad:a2,BatchMatMul:ow,BatchToSpaceND:aw,Bincount:u2,BroadcastArgs:c2,BroadcastTo:qee,Callback:eae,CallbackList:iie,Cast:p0,Ceil:f0,ClipByValue:m0,Complex:h2,ComplexAbs:lw,Concat:uw,Conv2D:cw,Conv2DBackpropFilter:d2,Conv2DBackpropInput:hw,Conv3D:dw,Conv3DBackpropFilterV2:p2,Conv3DBackpropInputV2:f2,Cos:g0,Cosh:y0,CropAndResize:g2,Cumprod:m2,Cumsum:pw,CustomCallback:sie,DataStorage:Rz,DenseBincount:y2,DepthToSpace:b2,DepthwiseConv2dNative:fw,DepthwiseConv2dNativeBackpropFilter:x2,DepthwiseConv2dNativeBackpropInput:v2,Diag:w2,Dilation2D:mw,Dilation2DBackpropFilter:JM,Dilation2DBackpropInput:YM,get ENV(){return Fz},EarlyStopping:tae,Einsum:S2,Elu:x0,EluGrad:T2,Environment:Jee,Equal:gw,Erf:v0,Exp:w0,ExpandDims:yw,Expm1:S0,FFT:C2,Fill:_2,FlipLeftRight:M2,Floor:T0,FloorDiv:C0,FromPixels:QM,FusedBatchNorm:bw,FusedConv2D:o1,FusedDepthwiseConv2D:a1,GatherNd:A2,GatherV2:xw,GraphModel:R$,Greater:vw,GreaterEqual:_0,History:rie,IFFT:E2,Identity:M0,Imag:I2,InputSpec:ir,IsFinite:A0,IsInf:E0,IsNan:I0,KernelBackend:n2,LRN:Aw,LRNGrad:R2,LayerVariable:qne,LayersModel:Ic,LeakyRelu:ww,Less:Sw,LessEqual:Tw,LinSpace:k2,Log:k0,Log1p:R0,LogSoftmax:ete,LogicalAnd:Cw,LogicalNot:_w,LogicalOr:Mw,LogicalXor:uDe,LowerBound:cDe,Max:Ew,MaxPool:Iw,MaxPool3D:kw,MaxPool3DGrad:L2,MaxPoolGrad:N2,MaxPoolWithArgmax:P2,Maximum:N0,Mean:Rw,Min:Nw,Minimum:L0,MirrorPad:Lw,Mod:P0,MomentumOptimizer:iV,Multinomial:D2,Multiply:D0,Neg:Pw,NonMaxSuppressionV3:F2,NonMaxSuppressionV4:O2,NonMaxSuppressionV5:B2,NotEqual:Dw,OP_SCOPE_SUFFIX:Uz,OneHot:Ow,OnesLike:Fw,Optimizer:nh,OptimizerConstructors:hne,Pack:Bw,PadV2:zw,Pool:hDe,Pow:F0,Prelu:Gw,Prod:Vw,RMSPropOptimizer:rV,RNN:Jl,RaggedGather:z2,RaggedRange:G2,RaggedTensorToTensor:V2,Range:U2,get Rank(){return q3},Real:$2,RealDiv:b0,Reciprocal:O0,get Reduction(){return Ms},Relu:B0,Relu6:z0,Reshape:Uw,ResizeBilinear:Ww,ResizeBilinearGrad:H2,ResizeNearestNeighbor:$w,ResizeNearestNeighborGrad:W2,Reverse:Hw,RotateWithOffset:aI,Round:G0,Rsqrt:V0,SGDOptimizer:HI,ScatterNd:X2,SearchSorted:K2,Select:Xw,Selu:U0,Sequential:ck,Sigmoid:X0,Sign:H0,Sin:$0,Sinh:W0,Slice:Kw,Softmax:Jw,Softplus:K0,SpaceToBatchND:jw,SparseFillEmptyRows:Z2,SparseReshape:j2,SparseSegmentMean:Y2,SparseSegmentSum:J2,SparseToDense:Q2,SplitV:Yw,Sqrt:Z0,Square:q2,SquaredDifference:j0,Step:eb,StridedSlice:eI,StringNGrams:tI,StringSplit:nI,StringToHashBucketFast:iI,Sub:Y0,Sum:Zw,SymbolicTensor:El,Tan:J0,Tanh:Q0,Tensor:An,TensorBuffer:mr,Tile:q0,TopK:rI,Transform:sI,Transpose:lf,Unique:oI,Unpack:Qw,UnsortedSegmentSum:qw,UpperBound:dDe,Variable:u1,ZerosLike:eS,_FusedMatMul:s1,abs:qi,acos:Yz,acosh:Jz,add:He,addN:aoe,all:dI,any:d1,argMax:Df,argMin:Qz,asin:qz,asinh:eG,atan:tG,atan2:nG,atanh:iG,avgPool:rS,avgPool3d:sG,backend:vc,backend_util:Fne,basicLSTMCell:loe,batchNorm:tb,batchNorm2d:oG,batchNorm3d:aG,batchNorm4d:lG,batchToSpaceND:sS,bincount:uG,booleanMaskAsync:Goe,broadcastArgs:uoe,broadcastTo:uf,broadcast_util:FFe,browser:zGe,buffer:nn,callbacks:Rlt,cast:ot,ceil:cG,clipByValue:eo,clone:Ru,complex:Vc,concat:Hi,concat1d:hG,concat2d:dG,concat3d:pG,concat4d:fG,constraints:Eot,conv1d:pI,conv2d:Uc,conv2dTranspose:fI,conv3d:gG,conv3dTranspose:yG,copyRegisteredKernels:gDe,cos:oS,cosh:mI,cosineWindow:OI,cumprod:m1,cumsum:gI,customGrad:Gu,data:yct,denseBincount:iA,deprecationWarn:S3e,depthToSpace:bG,depthwiseConv2d:nb,deregisterOp:Llt,device_util:VDe,diag:coe,dilation2d:xG,disableDeprecationWarnings:w3e,dispose:jt,disposeVariables:T3e,div:At,divNoNan:vG,dot:wG,dropout:ZG,einsum:hoe,elu:ib,enableDebugMode:v3e,enableProdMode:x3e,enclosingPowerOfTwo:jG,engine:Wn,env:ve,equal:ko,erf:SG,euclideanNorm:CG,exp:Ro,expandDims:as,expm1:_G,eye:yI,fft:bS,fill:bm,findBackend:k3e,findBackendFactory:R3e,floor:sb,floorDiv:hI,fused:Xoe,gather:ob,gatherND:Woe,gather_util:GGe,getBackend:E3e,getGradient:Y3,getKernel:qM,getKernelsForBackend:eA,grad:yOe,grads:bOe,greater:Fs,greaterEqual:qc,ifft:By,imag:aS,image:wu,inTopKAsync:Hoe,initializers:Wot,input:joe,io:_$,irfft:NI,isFinite:MG,isInf:AG,isNaN:EG,keep:Ri,kernel_impls:Tot,layers:llt,leakyRelu:lS,less:bI,lessEqual:Vd,linalg:QG,linspace:doe,loadGraphModel:nct,loadGraphModelSync:ict,loadLayersModel:TWe,localResponseNormalization:IG,log:No,log1p:uS,logSigmoid:kG,logSoftmax:vI,logSumExp:wI,logicalAnd:tl,logicalNot:cS,logicalOr:SI,logicalXor:RG,losses:Kte,lowerBound:poe,matMul:ln,math:Sot,max:la,maxPool:hS,maxPool3d:NG,maxPoolWithArgmax:foe,maximum:Hu,mean:vi,memory:h1,meshgrid:moe,metrics:Clt,min:Py,minimum:ab,mirrorPad:LG,mod:PG,model:Hot,models:_lt,moments:dS,movingAverage:Voe,mul:ae,multiRNNCell:goe,multinomial:yoe,neg:si,nextFrame:vS,norm:rb,notEqual:zf,oneHot:Dy,ones:_o,onesLike:Lo,op:ie,outerProduct:boe,pad:eh,pad1d:xoe,pad2d:voe,pad3d:woe,pad4d:Soe,pool:DG,pow:$c,prelu:fS,print:Zz,prod:FG,profile:C3e,raggedGather:Toe,raggedRange:Coe,raggedTensorToTensor:_oe,rand:Moe,randomGamma:Ioe,randomNormal:TI,randomStandardNormal:koe,randomUniform:ub,range:Gf,ready:A3e,real:Fy,reciprocal:BG,registerBackend:jz,registerCallbackConstructor:Kot,registerGradient:tte,registerKernel:so,registerOp:Nlt,regularizers:Ilt,relu:jl,relu6:CI,removeBackend:I3e,reshape:ue,reverse:da,reverse1d:Roe,reverse2d:Noe,reverse3d:Loe,reverse4d:Poe,rfft:xS,round:_I,rsqrt:MI,scalar:Nt,scatterND:Uoe,scatter_util:jBe,searchSorted:Ak,selu:AI,separableConv2d:EI,sequential:Xot,serialization:AGe,setBackend:M3e,setPlatform:N3e,setdiff1dAsync:Doe,sigmoid:Dl,sign:zG,signal:Xte,sin:II,sinh:kI,slice:vn,slice1d:mS,slice2d:RI,slice3d:gS,slice4d:Oy,slice_util:cne,softmax:yS,softplus:xm,spaceToBatchND:pS,sparse:Zte,sparseToDense:$oe,spectral:Hte,split:Js,sqrt:Yr,square:Vn,squaredDifference:LI,squeeze:Ud,stack:Ls,step:wm,stridedSlice:GG,string:jte,sub:xt,sum:wt,sumOutType:lI,tan:VG,tanh:Of,tensor:hi,tensor1d:ls,tensor2d:od,tensor3d:UG,tensor4d:Foe,tensor5d:Ooe,tensor6d:Boe,tensor_util:FDe,test_util:Hst,tidy:me,tile:Qo,time:_3e,topk:$G,train:Ip,transpose:gn,truncatedNormal:PI,unique:WG,unregisterGradient:mDe,unregisterKernel:fDe,unsortedSegmentSum:DI,unstack:pa,upcastType:qs,upperBound:zoe,util:CDe,valueAndGrad:xOe,valueAndGrads:vOe,variable:HG,variableGrads:kte,version:wct,version_converter:oae,version_core:Zoe,version_layers:uk,where:ds,whereAsync:C$,zeros:tr,zerosLike:wn},Symbol.toStringTag,{value:"Module"})),gae=new Ft;gae.compose(new Y,new Li,new Y(.001,.001,.001));const Tct=new Ft().set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);class yae{constructor({container:e,imageTargetSrc:t,maxTrack:i,uiLoading:r="yes",uiScanning:s="yes",uiError:o="yes",filterMinCF:a=null,filterBeta:l=null,warmupTolerance:u=null,missTolerance:c=null,userDeviceId:h=null,environmentDeviceId:d=null}){this.container=e,this.imageTargetSrc=t,this.maxTrack=i,this.filterMinCF=a,this.filterBeta=l,this.warmupTolerance=u,this.missTolerance=c,this.ui=new ZPe({uiLoading:r,uiScanning:s,uiError:o}),this.userDeviceId=h,this.environmentDeviceId=d,this.shouldFaceUser=!1,this.scene=new Ey,this.cssScene=new Ey,this.renderer=new kE({antialias:!0,alpha:!0}),this.cssRenderer=new yst({antialias:!0}),this.renderer.outputEncoding=Ec,this.renderer.setPixelRatio(window.devicePixelRatio),this.camera=new ci,this.anchors=[],this.renderer.domElement.style.position="absolute",this.cssRenderer.domElement.style.position="absolute",this.container.appendChild(this.renderer.domElement),this.container.appendChild(this.cssRenderer.domElement),window.addEventListener("resize",this.resize.bind(this))}async start(){this.ui.showLoading(),await this._startVideo(),await this._startAR()}stop(){this.controller.stopProcessVideo(),this.video.srcObject.getTracks().forEach(function(e){e.stop()}),this.video.remove()}switchCamera(){this.shouldFaceUser=!this.shouldFaceUser,this.stop(),this.start()}addAnchor(e){const t=new Ks;t.visible=!1,t.matrixAutoUpdate=!1;const i={group:t,targetIndex:e,onTargetFound:null,onTargetLost:null,onTargetUpdate:null,css:!1,visible:!1};return this.anchors.push(i),this.scene.add(t),i}addCSSAnchor(e){const t=new Ks;t.visible=!1,t.matrixAutoUpdate=!1;const i={group:t,targetIndex:e,onTargetFound:null,onTargetLost:null,onTargetUpdate:null,css:!0,visible:!1};return this.anchors.push(i),this.cssScene.add(t),i}_startVideo(){return new Promise((e,t)=>{if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){this.ui.showCompatibility(),t();return}const i={audio:!1,video:{}};this.shouldFaceUser?this.userDeviceId?i.video.deviceId={exact:this.userDeviceId}:i.video.facingMode="user":this.environmentDeviceId?i.video.deviceId={exact:this.environmentDeviceId}:i.video.facingMode="environment",navigator.mediaDevices.getUserMedia(i).then(r=>{this.video.addEventListener("loadedmetadata",()=>{this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight),e()}),this.video.srcObject=r}).catch(r=>{console.log("getUserMedia error",r),t()})})}_startAR(){return new Promise(async(e,t)=>{const i=this.video;this.container,this.controller=new fst({inputWidth:i.videoWidth,inputHeight:i.videoHeight,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,warmupTolerance:this.warmupTolerance,missTolerance:this.missTolerance,maxTrack:this.maxTrack,onUpdate:s=>{if(s.type==="updateMatrix"){const{targetIndex:o,worldMatrix:a}=s;for(let l=0;l<this.anchors.length;l++)if(this.anchors[l].targetIndex===o){if(this.anchors[l].css?this.anchors[l].group.children.forEach(u=>{u.element.style.visibility=a===null?"hidden":"visible"}):this.anchors[l].group.visible=a!==null,a!==null){let u=new Ft;u.elements=[...a],u.multiply(this.postMatrixs[o]),this.anchors[l].css&&u.multiply(gae),this.anchors[l].group.matrix=u}else this.anchors[l].group.matrix=Tct;this.anchors[l].visible&&a===null&&(this.anchors[l].visible=!1,this.anchors[l].onTargetLost&&this.anchors[l].onTargetLost()),!this.anchors[l].visible&&a!==null&&(this.anchors[l].visible=!0,this.anchors[l].onTargetFound&&this.anchors[l].onTargetFound()),this.anchors[l].onTargetUpdate&&this.anchors[l].onTargetUpdate()}this.anchors.reduce((l,u)=>l||u.visible,!1)?this.ui.hideScanning():this.ui.showScanning()}}}),this.resize();const{dimensions:r}=await this.controller.addImageTargets(this.imageTargetSrc);this.postMatrixs=[];for(let s=0;s<r.length;s++){const o=new Y,a=new Li,l=new Y,[u,c]=r[s];o.x=u/2,o.y=u/2+(c-u)/2,l.x=u,l.y=u,l.z=u;const h=new Ft;h.compose(o,a,l),this.postMatrixs.push(h)}await this.controller.dummyRun(this.video),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video),e()})}resize(){const{renderer:e,cssRenderer:t,camera:i,container:r,video:s}=this;if(!s)return;this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight);let o,a;const l=s.videoWidth/s.videoHeight,u=r.clientWidth/r.clientHeight;l>u?(a=r.clientHeight,o=a*l):(o=r.clientWidth,a=o/l);const c=this.controller.getProjectionMatrix(),h=this.controller.inputWidth/this.controller.inputHeight;let d;h>u?d=this.video.width/this.controller.inputWidth:d=this.video.height/this.controller.inputHeight;let p,f;h>u?(p=r.clientHeight,p*=d):(f=r.clientWidth,p=f/this.controller.inputWidth*this.controller.inputHeight,p*=d);let g=r.clientHeight/p;const y=2*Math.atan(1/c[5]*g)*180/Math.PI,m=c[14]/(c[10]-1),v=c[14]/(c[10]+1);c[5]/c[0],i.fov=y,i.near=m,i.far=v,i.aspect=r.clientWidth/r.clientHeight,i.updateProjectionMatrix(),s.style.top=-(a-r.clientHeight)/2+"px",s.style.left=-(o-r.clientWidth)/2+"px",s.style.width=o+"px",s.style.height=a+"px";const w=e.domElement,S=t.domElement;w.style.position="absolute",w.style.left=0,w.style.top=0,w.style.width=r.clientWidth+"px",w.style.height=r.clientHeight+"px",S.style.position="absolute",S.style.left=0,S.style.top=0,S.style.width=r.clientWidth+"px",S.style.height=r.clientHeight+"px",e.setSize(r.clientWidth,r.clientHeight),t.setSize(r.clientWidth,r.clientHeight)}}window.MINDAR||(window.MINDAR={});window.MINDAR.IMAGE||(window.MINDAR.IMAGE={});window.MINDAR.IMAGE.MindARThree=yae;window.MINDAR.IMAGE.tf=Sct;const Cct="_arContainer_11w4w_1",_ct="_control_11w4w_15",Mct={arContainer:Cct,control:_ct};function Oj(n,e){if(e===KB)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===Af||e===U1){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const i=t.count-2,r=[];if(e===Af)for(let o=1;o<=i;o++)r.push(t.getX(0)),r.push(t.getX(o)),r.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2===0?(r.push(t.getX(o)),r.push(t.getX(o+1)),r.push(t.getX(o+2))):(r.push(t.getX(o+2)),r.push(t.getX(o+1)),r.push(t.getX(o)));r.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=n.clone();return s.setIndex(r),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}class Act extends fs{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Nct(t)}),this.register(function(t){return new Gct(t)}),this.register(function(t){return new Vct(t)}),this.register(function(t){return new Uct(t)}),this.register(function(t){return new Pct(t)}),this.register(function(t){return new Dct(t)}),this.register(function(t){return new Fct(t)}),this.register(function(t){return new Oct(t)}),this.register(function(t){return new Rct(t)}),this.register(function(t){return new Bct(t)}),this.register(function(t){return new Lct(t)}),this.register(function(t){return new zct(t)}),this.register(function(t){return new Ict(t)}),this.register(function(t){return new $ct(t)}),this.register(function(t){return new Wct(t)})}load(e,t,i,r){const s=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=oa.extractUrlBase(e),this.manager.itemStart(e);const a=function(u){r?r(u):console.error(u),s.manager.itemError(e),s.manager.itemEnd(e)},l=new Qs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{s.parse(u,o,function(c){t(c),s.manager.itemEnd(e)},a)}catch(c){a(c)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,r){let s;const o={},a={},l=new TextDecoder;if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===bae){try{o[Mn.KHR_BINARY_GLTF]=new Hct(e)}catch(h){r&&r(h);return}s=JSON.parse(o[Mn.KHR_BINARY_GLTF].content)}else s=JSON.parse(l.decode(e));else s=e;if(s.asset===void 0||s.asset.version[0]<2){r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const u=new rht(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](u);h.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[h.name]=h,o[h.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const h=s.extensionsUsed[c],d=s.extensionsRequired||[];switch(h){case Mn.KHR_MATERIALS_UNLIT:o[h]=new kct;break;case Mn.KHR_DRACO_MESH_COMPRESSION:o[h]=new Xct(s,this.dracoLoader);break;case Mn.KHR_TEXTURE_TRANSFORM:o[h]=new Kct;break;case Mn.KHR_MESH_QUANTIZATION:o[h]=new Zct;break;default:d.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}u.setExtensions(o),u.setPlugins(a),u.parse(i,r)}parseAsync(e,t){const i=this;return new Promise(function(r,s){i.parse(e,t,r,s)})}}function Ect(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const Mn={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Ict{constructor(e){this.parser=e,this.name=Mn.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,r=t.length;i<r;i++){const s=t[i];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let r=t.cache.get(i);if(r)return r;const s=t.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let u;const c=new lt(16777215);l.color!==void 0&&c.setRGB(l.color[0],l.color[1],l.color[2],Zr);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new e2(c),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new qE(c),u.distance=h;break;case"spot":u=new QE(c),u.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,Lh(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=t.createUniqueName(l.name||"light_"+e),r=Promise.resolve(u),t.cache.add(i,r),r}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,s=i.json.nodes[e],a=(s.extensions&&s.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return i._getNodeRef(t.cache,a,l)})}}class kct{constructor(){this.name=Mn.KHR_MATERIALS_UNLIT}getMaterialType(){return dr}extendParams(e,t,i){const r=[];e.color=new lt(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],Zr),e.opacity=o[3]}s.baseColorTexture!==void 0&&r.push(i.assignTexture(e,"map",s.baseColorTexture,bi))}return Promise.all(r)}}class Rct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}}class Nct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Ge(a,a)}return Promise.all(s)}}class Lct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}class Pct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_SHEEN}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new lt(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=r.extensions[this.name];if(o.sheenColorFactor!==void 0){const a=o.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],Zr)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,bi)),o.sheenRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class Dct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class Fct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_VOLUME}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new lt().setRGB(a[0],a[1],a[2],Zr),Promise.all(s)}}class Oct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_IOR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class Bct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_SPECULAR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new lt().setRGB(a[0],a[1],a[2],Zr),o.specularColorTexture!==void 0&&s.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,bi)),Promise.all(s)}}class zct{constructor(e){this.parser=e,this.name=Mn.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Qr}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(i.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}class Gct{constructor(e){this.parser=e,this.name=Mn.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,r=i.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const s=r.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}}class Vct{constructor(e){this.parser=e,this.name=Mn.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const u=i.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Uct{constructor(e){this.parser=e,this.name=Mn.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const u=i.options.manager.getHandler(a.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class $ct{constructor(e){this.name=Mn.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const r=i.extensions[this.name],s=this.parser.getDependency("buffer",r.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(a){const l=r.byteOffset||0,u=r.byteLength||0,c=r.count,h=r.byteStride,d=new Uint8Array(a,l,u);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(c,h,d,r.mode,r.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(c*h);return o.decodeGltfBuffer(new Uint8Array(p),c,h,d,r.mode,r.filter),p})})}else return null}}class Wct{constructor(e){this.name=Mn.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const r=t.meshes[i.mesh];for(const u of r.primitives)if(u.mode!==Ba.TRIANGLES&&u.mode!==Ba.TRIANGLE_STRIP&&u.mode!==Ba.TRIANGLE_FAN&&u.mode!==void 0)return null;const o=i.extensions[this.name].attributes,a=[],l={};for(const u in o)a.push(this.parser.getDependency("accessor",o[u]).then(c=>(l[u]=c,l[u])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(u=>{const c=u.pop(),h=c.isGroup?c.children:[c],d=u[0].count,p=[];for(const f of h){const g=new Ft,y=new Y,m=new Li,v=new Y(1,1,1),w=new PE(f.geometry,f.material,d);for(let S=0;S<d;S++)l.TRANSLATION&&y.fromBufferAttribute(l.TRANSLATION,S),l.ROTATION&&m.fromBufferAttribute(l.ROTATION,S),l.SCALE&&v.fromBufferAttribute(l.SCALE,S),w.setMatrixAt(S,g.compose(y,m,v));for(const S in l)if(S==="_COLOR_0"){const C=l[S];w.instanceColor=new Ef(C.array,C.itemSize,C.normalized)}else S!=="TRANSLATION"&&S!=="ROTATION"&&S!=="SCALE"&&f.geometry.setAttribute(S,l[S]);yn.prototype.copy.call(w,f),this.parser.assignFinalMaterial(w),p.push(w)}return c.isGroup?(c.clear(),c.add(...p),c):p[0]}))}}const bae="glTF",Ex=12,Bj={JSON:1313821514,BIN:5130562};class Hct{constructor(e){this.name=Mn.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Ex),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==bae)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-Ex,s=new DataView(e,Ex);let o=0;for(;o<r;){const a=s.getUint32(o,!0);o+=4;const l=s.getUint32(o,!0);if(o+=4,l===Bj.JSON){const u=new Uint8Array(e,Ex+o,a);this.content=i.decode(u)}else if(l===Bj.BIN){const u=Ex+o;this.body=e.slice(u,u+a)}o+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Xct{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Mn.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,r=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},u={};for(const c in o){const h=HF[c]||c.toLowerCase();a[h]=o[c]}for(const c in e.attributes){const h=HF[c]||c.toLowerCase();if(o[c]!==void 0){const d=i.accessors[e.attributes[c]],p=hy[d.componentType];u[h]=p.name,l[h]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(c){return new Promise(function(h){r.decodeDracoFile(c,function(d){for(const p in d.attributes){const f=d.attributes[p],g=l[p];g!==void 0&&(f.normalized=g)}h(d)},a,u)})})}}class Kct{constructor(){this.name=Mn.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Zct{constructor(){this.name=Mn.KHR_MESH_QUANTIZATION}}class xae extends lm{constructor(e,t,i,r){super(e,t,i,r)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r*3+r;for(let o=0;o!==r;o++)t[o]=i[s+o];return t}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,u=a*3,c=r-t,h=(i-t)/c,d=h*h,p=d*h,f=e*u,g=f-u,y=-2*p+3*d,m=p-d,v=1-y,w=m-d+h;for(let S=0;S!==a;S++){const C=o[g+S+a],_=o[g+S+l]*c,A=o[f+S+a],I=o[f+S]*c;s[S]=v*C+w*_+y*A+m*I}return s}}const jct=new Li;class Yct extends xae{interpolate_(e,t,i,r){const s=super.interpolate_(e,t,i,r);return jct.fromArray(s).normalize().toArray(s),s}}const Ba={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},hy={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},zj={9728:Ei,9729:Zn,9984:_y,9985:V1,9986:nf,9987:qa},Gj={33071:$r,33648:Tf,10497:Ul},SP={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},HF={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Th={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Jct={CUBICSPLINE:void 0,LINEAR:Fc,STEP:Mf},TP={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Qct(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new am({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Vl})),n.DefaultMaterial}function gp(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}function Lh(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function qct(n,e,t){let i=!1,r=!1,s=!1;for(let u=0,c=e.length;u<c;u++){const h=e[u];if(h.POSITION!==void 0&&(i=!0),h.NORMAL!==void 0&&(r=!0),h.COLOR_0!==void 0&&(s=!0),i&&r&&s)break}if(!i&&!r&&!s)return Promise.resolve(n);const o=[],a=[],l=[];for(let u=0,c=e.length;u<c;u++){const h=e[u];if(i){const d=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):n.attributes.position;o.push(d)}if(r){const d=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):n.attributes.normal;a.push(d)}if(s){const d=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):n.attributes.color;l.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(u){const c=u[0],h=u[1],d=u[2];return i&&(n.morphAttributes.position=c),r&&(n.morphAttributes.normal=h),s&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}function eht(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,r=t.length;i<r;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function tht(n){let e;const t=n.extensions&&n.extensions[Mn.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+CP(t.attributes):e=n.indices+":"+CP(n.attributes)+":"+n.mode,n.targets!==void 0)for(let i=0,r=n.targets.length;i<r;i++)e+=":"+CP(n.targets[i]);return e}function CP(n){let e="";const t=Object.keys(n).sort();for(let i=0,r=t.length;i<r;i++)e+=t[i]+":"+n[t[i]]+";";return e}function XF(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function nht(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const iht=new Ft;class rht{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Ect,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,r=!1,s=-1;typeof navigator<"u"&&(i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,r=navigator.userAgent.indexOf("Firefox")>-1,s=r?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||i||r&&s<98?this.textureLoader=new mz(this.options.manager):this.textureLoader=new bz(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Qs(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,r=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const a={scene:o[0][r.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:r.asset,parser:i,userData:{}};return gp(s,a,r),Lh(a,r),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let r=0,s=t.length;r<s;r++){const o=t[r].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let r=0,s=e.length;r<s;r++){const o=e[r];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const r=i.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[u,c]of o.children.entries())s(c,a.children[u])};return s(i,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let r=0;r<t.length;r++){const s=e(t[r]);s&&i.push(s)}return i}getDependency(e,t){const i=e+":"+t;let r=this.cache.get(i);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":r=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":r=this.loadCamera(t);break;default:if(r=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!r)throw new Error("Unknown type: "+e);break}this.cache.add(i,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(s,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Mn.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(s,o){i.load(oa.resolveURL(t.uri,r.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const r=t.byteLength||0,s=t.byteOffset||0;return i.slice(s,s+r)})}loadAccessor(e){const t=this,i=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0){const o=SP[r.type],a=hy[r.componentType],l=r.normalized===!0,u=new a(r.count*o);return Promise.resolve(new En(u,o,l))}const s=[];return r.bufferView!==void 0?s.push(this.getDependency("bufferView",r.bufferView)):s.push(null),r.sparse!==void 0&&(s.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=SP[r.type],u=hy[r.componentType],c=u.BYTES_PER_ELEMENT,h=c*l,d=r.byteOffset||0,p=r.bufferView!==void 0?i.bufferViews[r.bufferView].byteStride:void 0,f=r.normalized===!0;let g,y;if(p&&p!==h){const m=Math.floor(d/p),v="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+m+":"+r.count;let w=t.cache.get(v);w||(g=new u(a,m*p,r.count*p/c),w=new n0(g,p/c),t.cache.add(v,w)),y=new Oc(w,l,d%p/c,f)}else a===null?g=new u(r.count*l):g=new u(a,d,r.count*l),y=new En(g,l,f);if(r.sparse!==void 0){const m=SP.SCALAR,v=hy[r.sparse.indices.componentType],w=r.sparse.indices.byteOffset||0,S=r.sparse.values.byteOffset||0,C=new v(o[1],w,r.sparse.count*m),_=new u(o[2],S,r.sparse.count*l);a!==null&&(y=new En(y.array.slice(),y.itemSize,y.normalized));for(let A=0,I=C.length;A<I;A++){const E=C[A];if(y.setX(E,_[A*l]),l>=2&&y.setY(E,_[A*l+1]),l>=3&&y.setZ(E,_[A*l+2]),l>=4&&y.setW(E,_[A*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return y})}loadTexture(e){const t=this.json,i=this.options,s=t.textures[e].source,o=t.images[s];let a=this.textureLoader;if(o.uri){const l=i.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,t,i){const r=this,s=this.json,o=s.textures[e],a=s.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(t,i).then(function(c){c.flipY=!1,c.name=o.name||a.name||"",c.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(c.name=a.uri);const d=(s.samplers||{})[o.sampler]||{};return c.magFilter=zj[d.magFilter]||Zn,c.minFilter=zj[d.minFilter]||qa,c.wrapS=Gj[d.wrapS]||Ul,c.wrapT=Gj[d.wrapT]||Ul,r.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,t){const i=this,r=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const o=r.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",u=!1;if(o.bufferView!==void 0)l=i.getDependency("bufferView",o.bufferView).then(function(h){u=!0;const d=new Blob([h],{type:o.mimeType});return l=a.createObjectURL(d),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(h){return new Promise(function(d,p){let f=d;t.isImageBitmapLoader===!0&&(f=function(g){const y=new ni(g);y.needsUpdate=!0,d(y)}),t.load(oa.resolveURL(h,s.path),f,void 0,p)})}).then(function(h){return u===!0&&a.revokeObjectURL(l),h.userData.mimeType=o.mimeType||nht(o.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),h});return this.sourceCache[e]=c,c}assignTexture(e,t,i,r){const s=this;return this.getDependency("texture",i.index).then(function(o){if(!o)return null;if(i.texCoord!==void 0&&i.texCoord>0&&(o=o.clone(),o.channel=i.texCoord),s.extensions[Mn.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[Mn.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[Mn.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return r!==void 0&&(o.colorSpace=r),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const r=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Z1,Pi.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(a,l)),i=l}else if(e.isLine){const a="LineBasicMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new ps,Pi.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,this.cache.add(a,l)),i=l}if(r||s||o){let a="ClonedMaterial:"+i.uuid+":";r&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=i.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),r&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(i))),i=l}e.material=i}getMaterialType(){return am}loadMaterial(e){const t=this,i=this.json,r=this.extensions,s=i.materials[e];let o;const a={},l=s.extensions||{},u=[];if(l[Mn.KHR_MATERIALS_UNLIT]){const h=r[Mn.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),u.push(h.extendParams(a,s,t))}else{const h=s.pbrMetallicRoughness||{};if(a.color=new lt(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],Zr),a.opacity=d[3]}h.baseColorTexture!==void 0&&u.push(t.assignTexture(a,"map",h.baseColorTexture,bi)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),u.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=$a);const c=s.alphaMode||TP.OPAQUE;if(c===TP.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,c===TP.MASK&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==dr&&(u.push(t.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new Ge(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;a.normalScale.set(h,h)}if(s.occlusionTexture!==void 0&&o!==dr&&(u.push(t.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==dr){const h=s.emissiveFactor;a.emissive=new lt().setRGB(h[0],h[1],h[2],Zr)}return s.emissiveTexture!==void 0&&o!==dr&&u.push(t.assignTexture(a,"emissiveMap",s.emissiveTexture,bi)),Promise.all(u).then(function(){const h=new o(a);return s.name&&(h.name=s.name),Lh(h,s),t.associations.set(h,{materials:e}),s.extensions&&gp(r,h,s),h})}createUniqueName(e){const t=Cn.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,r=this.primitiveCache;function s(a){return i[Mn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return Vj(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const u=e[a],c=tht(u),h=r[c];if(h)o.push(h.promise);else{let d;u.extensions&&u.extensions[Mn.KHR_DRACO_MESH_COMPRESSION]?d=s(u):d=Vj(new rn,u,t),r[c]={primitive:u,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,r=this.extensions,s=i.meshes[e],o=s.primitives,a=[];for(let l=0,u=o.length;l<u;l++){const c=o[l].material===void 0?Qct(this.cache):this.getDependency("material",o[l].material);a.push(c)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const u=l.slice(0,l.length-1),c=l[l.length-1],h=[];for(let p=0,f=c.length;p<f;p++){const g=c[p],y=o[p];let m;const v=u[p];if(y.mode===Ba.TRIANGLES||y.mode===Ba.TRIANGLE_STRIP||y.mode===Ba.TRIANGLE_FAN||y.mode===void 0)m=s.isSkinnedMesh===!0?new LE(g,v):new pr(g,v),m.isSkinnedMesh===!0&&m.normalizeSkinWeights(),y.mode===Ba.TRIANGLE_STRIP?m.geometry=Oj(m.geometry,U1):y.mode===Ba.TRIANGLE_FAN&&(m.geometry=Oj(m.geometry,Af));else if(y.mode===Ba.LINES)m=new il(g,v);else if(y.mode===Ba.LINE_STRIP)m=new Fu(g,v);else if(y.mode===Ba.LINE_LOOP)m=new DE(g,v);else if(y.mode===Ba.POINTS)m=new FE(g,v);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(m.geometry.morphAttributes).length>0&&eht(m,s),m.name=t.createUniqueName(s.name||"mesh_"+e),Lh(m,s),y.extensions&&gp(r,m,y),t.assignFinalMaterial(m),h.push(m)}for(let p=0,f=h.length;p<f;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return s.extensions&&gp(r,h[0],s),h[0];const d=new Ks;s.extensions&&gp(r,d,s),t.associations.set(d,{meshes:e});for(let p=0,f=h.length;p<f;p++)d.add(h[p]);return d})}loadCamera(e){let t;const i=this.json.cameras[e],r=i[i.type];if(!r){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?t=new ci(Wp.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):i.type==="orthographic"&&(t=new Al(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),Lh(t,i),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],i=[];for(let r=0,s=t.joints.length;r<s;r++)i.push(this._loadNodeShallow(t.joints[r]));return t.inverseBindMatrices!==void 0?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(r){const s=r.pop(),o=r,a=[],l=[];for(let u=0,c=o.length;u<c;u++){const h=o[u];if(h){a.push(h);const d=new Ft;s!==null&&d.fromArray(s.array,u*16),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new i0(a,l)})}loadAnimation(e){const t=this.json,i=this,r=t.animations[e],s=r.name?r.name:"animation_"+e,o=[],a=[],l=[],u=[],c=[];for(let h=0,d=r.channels.length;h<d;h++){const p=r.channels[h],f=r.samplers[p.sampler],g=p.target,y=g.node,m=r.parameters!==void 0?r.parameters[f.input]:f.input,v=r.parameters!==void 0?r.parameters[f.output]:f.output;g.node!==void 0&&(o.push(this.getDependency("node",y)),a.push(this.getDependency("accessor",m)),l.push(this.getDependency("accessor",v)),u.push(f),c.push(g))}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(u),Promise.all(c)]).then(function(h){const d=h[0],p=h[1],f=h[2],g=h[3],y=h[4],m=[];for(let v=0,w=d.length;v<w;v++){const S=d[v],C=p[v],_=f[v],A=g[v],I=y[v];if(S===void 0)continue;S.updateMatrix&&S.updateMatrix();const E=i._createAnimationTracks(S,C,_,A,I);if(E)for(let k=0;k<E.length;k++)m.push(E[k])}return new kf(s,void 0,m)})}createNodeMesh(e){const t=this.json,i=this,r=t.nodes[e];return r.mesh===void 0?null:i.getDependency("mesh",r.mesh).then(function(s){const o=i._getNodeRef(i.meshCache,r.mesh,s);return r.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,u=r.weights.length;l<u;l++)a.morphTargetInfluences[l]=r.weights[l]}),o})}loadNode(e){const t=this.json,i=this,r=t.nodes[e],s=i._loadNodeShallow(e),o=[],a=r.children||[];for(let u=0,c=a.length;u<c;u++)o.push(i.getDependency("node",a[u]));const l=r.skin===void 0?Promise.resolve(null):i.getDependency("skin",r.skin);return Promise.all([s,Promise.all(o),l]).then(function(u){const c=u[0],h=u[1],d=u[2];d!==null&&c.traverse(function(p){p.isSkinnedMesh&&p.bind(d,iht)});for(let p=0,f=h.length;p<f;p++)c.add(h[p]);return c})}_loadNodeShallow(e){const t=this.json,i=this.extensions,r=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],o=s.name?r.createUniqueName(s.name):"",a=[],l=r._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(r.getDependency("camera",s.camera).then(function(u){return r._getNodeRef(r.cameraCache,s.camera,u)})),r._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){a.push(u)}),this.nodeCache[e]=Promise.all(a).then(function(u){let c;if(s.isBone===!0?c=new K1:u.length>1?c=new Ks:u.length===1?c=u[0]:c=new yn,c!==u[0])for(let h=0,d=u.length;h<d;h++)c.add(u[h]);if(s.name&&(c.userData.name=s.name,c.name=o),Lh(c,s),s.extensions&&gp(i,c,s),s.matrix!==void 0){const h=new Ft;h.fromArray(s.matrix),c.applyMatrix4(h)}else s.translation!==void 0&&c.position.fromArray(s.translation),s.rotation!==void 0&&c.quaternion.fromArray(s.rotation),s.scale!==void 0&&c.scale.fromArray(s.scale);return r.associations.has(c)||r.associations.set(c,{}),r.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],r=this,s=new Ks;i.name&&(s.name=r.createUniqueName(i.name)),Lh(s,i),i.extensions&&gp(t,s,i);const o=i.nodes||[],a=[];for(let l=0,u=o.length;l<u;l++)a.push(r.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let c=0,h=l.length;c<h;c++)s.add(l[c]);const u=c=>{const h=new Map;for(const[d,p]of r.associations)(d instanceof Pi||d instanceof ni)&&h.set(d,p);return c.traverse(d=>{const p=r.associations.get(d);p!=null&&h.set(d,p)}),h};return r.associations=u(s),s})}_createAnimationTracks(e,t,i,r,s){const o=[],a=e.name?e.name:e.uuid,l=[];Th[s.path]===Th.weights?e.traverse(function(d){d.morphTargetInfluences&&l.push(d.name?d.name:d.uuid)}):l.push(a);let u;switch(Th[s.path]){case Th.weights:u=gd;break;case Th.rotation:u=Ou;break;case Th.position:case Th.scale:u=yd;break;default:switch(i.itemSize){case 1:u=gd;break;case 2:case 3:default:u=yd;break}break}const c=r.interpolation!==void 0?Jct[r.interpolation]:Fc,h=this._getArrayFromAccessor(i);for(let d=0,p=l.length;d<p;d++){const f=new u(l[d]+"."+Th[s.path],t.array,h,c);r.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),o.push(f)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const i=XF(t.constructor),r=new Float32Array(t.length);for(let s=0,o=t.length;s<o;s++)r[s]=t[s]*i;t=r}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(i){const r=this instanceof Ou?Yct:xae;return new r(this.times,this.values,this.getValueSize()/3,i)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function sht(n,e,t){const i=e.attributes,r=new nl;if(i.POSITION!==void 0){const a=t.json.accessors[i.POSITION],l=a.min,u=a.max;if(l!==void 0&&u!==void 0){if(r.set(new Y(l[0],l[1],l[2]),new Y(u[0],u[1],u[2])),a.normalized){const c=XF(hy[a.componentType]);r.min.multiplyScalar(c),r.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const a=new Y,l=new Y;for(let u=0,c=s.length;u<c;u++){const h=s[u];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const g=XF(hy[d.componentType]);l.multiplyScalar(g)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(a)}n.boundingBox=r;const o=new ya;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,n.boundingSphere=o}function Vj(n,e,t){const i=e.attributes,r=[];function s(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in i){const a=HF[o]||o.toLowerCase();a in n.attributes||r.push(s(i[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});r.push(o)}return Fn.workingColorSpace!==Zr&&"COLOR_0"in i&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Fn.workingColorSpace}" not supported.`),Lh(n,e),sht(n,e,t),Promise.all(r).then(function(){return e.targets!==void 0?qct(n,e.targets,t):n})}const Uj=new Act,oht="https://anushkamadushanka.github.io";function aht(){const n=K.useRef(null),e=K.useRef(!1),t=K.useRef(null),i=K.useRef(null),r=K.useCallback(s=>{s.preventDefault();const{renderer:o,scene:a,camera:l}=t.current,{x:u,y:c}=s,h=new Ge;h.x=u/o.domElement.clientWidth*2-1,h.y=-(c/o.domElement.clientHeight)*2+1;const d=new _z;d.setFromCamera(h,l);const p=d.intersectObjects(a.children,!0);p.length>0&&(console.log(p[0].object),p[0].object.name.startsWith("button_linkedin")?window.open("https://www.linkedin.com/in/anushka-madushanka/","_blank"):p[0].object.name.startsWith("button_github")?window.open("https://github.com/AnushkaMadushanka/","_blank"):p[0].object.name.startsWith("button_pdf")&&window.open("https://anushkamadushanka.github.io","_blank"))},[]);return K.useEffect(()=>{if(e.current)return;e.current=!0,t.current=new yae({container:n.current,imageTargetSrc:`${oht}/targets.mind`});const s=t.current.addAnchor(0),o=new Ks;s.group.add(o),o.add(new yz(15724527,2));const a=new e0(1,.55),l=new dr({color:2040622,transparent:!0,opacity:.1}),u=new pr(a,l);o.add(u);const{renderer:c,scene:h,camera:d}=t.current,p=new Promise((g,y)=>{Uj.load("/waving.glb",function(m){m.scene.scale.set(.3,.3,.3),m.scene.position.set(-.7,-.3,0),o.add(m.scene),i.current=new Tz(m.scene),m.animations.forEach(v=>{i.current.clipAction(v).play()}),g()},function(m){console.log(`Waving model ${m.loaded/m.total*100}% loaded`)},function(m){console.log(m),y()})}),f=new Promise((g,y)=>{Uj.load("/buttons.glb",function(m){m.scene.scale.set(.075,.075,.075),m.scene.position.set(.65,-.3,0),m.scene.rotation.set(Math.PI/2,0,0),m.scene.traverse(v=>{v.isMesh&&(v.material=new dr({color:v.material.color,opacity:v.material.opacity,transparent:!0}))}),console.log(m.scene),o.add(m.scene),g()},function(m){console.log(`Buttons model ${m.loaded/m.total*100}% loaded`)},function(m){console.log(m),y()})});return Promise.all([p,f]).then(()=>{t.current.start().then(()=>{c.setAnimationLoop(()=>{i.current.update(.01),c.render(h,d)}),window.addEventListener("pointerdown",r)})}).catch(()=>{console.log("Error loading models")}),()=>{window.removeEventListener("pointerdown",r)}},[r]),se.jsx(se.Fragment,{children:se.jsx("div",{className:Mct.arContainer,ref:n})})}const lht=Jhe([{path:"/",element:se.jsxs(se.Fragment,{children:[se.jsx(qxe,{}),se.jsxs("div",{className:S7.container,children:[se.jsx(wve,{}),se.jsx(Whe,{})]})]}),children:[{path:"/",element:se.jsx(DPe,{})},{path:"/about",element:se.jsx(GPe,{})},{path:"/ar",element:se.jsx(aht,{})},{path:"*",element:se.jsx("div",{children:"404"})}]}]);function uht(){const[n,e]=K.useState(!0);return K.useEffect(()=>{const t=document.querySelector("body");xde(t);const i=setTimeout(()=>{e(!1),vde(t)},1e3);return()=>clearTimeout(i)},[]),se.jsxs(se.Fragment,{children:[se.jsx(OD,{children:n&&se.jsx(On.div,{className:S7.loading,initial:{opacity:1},exit:{opacity:0},children:se.jsx("img",{src:w7,alt:"logo"})})}),se.jsx(sde,{router:lht})]})}_P.createRoot(document.getElementById("root")).render(se.jsx(Is.StrictMode,{children:se.jsx(uht,{})}))});export default cht();
